import{_ as o,j as e,o as t,g as r,k as l,h as s,Q as p,s as n}from"./chunks/framework.a0d18f64.js";const H=JSON.parse('{"title":"15ReactDOM.render是如何串联渲染链路的？（下）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(5368) 15  ReactDOM.render 是如何串联渲染链路的？（下）.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(5368) 15  ReactDOM.render 是如何串联渲染链路的？（下）.md","lastUpdated":1696682708000}'),c={name:"posts/frontEnd/046_深入浅出搞定 React/(5368) 15  ReactDOM.render 是如何串联渲染链路的？（下）.md"},E=p(`<h1 id="_15reactdom-render是如何串联渲染链路的-下" tabindex="-1">15ReactDOM.render是如何串联渲染链路的？（下） <a class="header-anchor" href="#_15reactdom-render是如何串联渲染链路的-下" aria-label="Permalink to &quot;15ReactDOM.render是如何串联渲染链路的？（下）&quot;">​</a></h1><p>在上一讲我们从 beginWork 切入，摸索出了 Fiber 节点的创建链路与 Fiber 树的构建链路。本讲我们将以 completeWork 为线索，去寻觅 Fiber 树和 DOM 树之间的关联，将整个 render 阶段讲透。在此基础上，结合 commit 阶段工作流，你将会对 ReactDOM.render 所触发的渲染链路有一个完整、通透的理解。</p><p>本讲的实验 Demo 与前两讲保持一致，代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> React from &quot;react&quot;;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> ReactDOM from &quot;react</span><span style="color:#FDAEB7;font-style:italic;">-</span><span style="color:#E1E4E8;">dom&quot;;</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">App</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">div className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;App&quot;</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">div className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;container&quot;</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">h1</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">我是标题</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">h1</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">我是第一段话</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">我是第二段话</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">div</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">div</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> rootElement </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;root&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">ReactDOM.</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">App </span><span style="color:#F97583;">/&gt;</span><span style="color:#E1E4E8;">, rootElement);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> React from &quot;react&quot;;</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> ReactDOM from &quot;react</span><span style="color:#B31D28;font-style:italic;">-</span><span style="color:#24292E;">dom&quot;;</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">App</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">div className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;App&quot;</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">div className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;container&quot;</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">h1</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">我是标题</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">h1</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">我是第一段话</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">我是第二段话</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">div</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">div</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> rootElement </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;root&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">ReactDOM.</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">App </span><span style="color:#D73A49;">/&gt;</span><span style="color:#24292E;">, rootElement);</span></span></code></pre></div><h3 id="completework-将-fiber-节点映射为-dom-节点" tabindex="-1">completeWork------将 Fiber 节点映射为 DOM 节点 <a class="header-anchor" href="#completework-将-fiber-节点映射为-dom-节点" aria-label="Permalink to &quot;completeWork------将 Fiber 节点映射为 DOM 节点&quot;">​</a></h3><h4 id="completework-的调用时机" tabindex="-1">completeWork 的调用时机 <a class="header-anchor" href="#completework-的调用时机" aria-label="Permalink to &quot;completeWork 的调用时机&quot;">​</a></h4><p>首先，我们先在调用栈中定位一下 completeWork。Demo 所对应的调用栈中，第一个 completeWork 出现在下图红框选中的位置：</p>`,7),y=n("p",null,"从图上我们需要把握住的一个信息是，从 performUnitOfWork 到 completeWork，中间会经过一个这样的调用链路：",-1),i=p(`<p>其中 completeUnitOfWork 的工作也非常关键，但眼下我们先拿 completeWork 开刀，你可以暂时将 completeUnitOfWork 简单理解为一个用于发起 completeWork 调用的&quot;工具人&quot;。completeUnitOfWork 是在 performUnitOfWork 中被调用的，那么 performUnitOfWork 是如何把握其调用时机的呢？我们直接来看相关源码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">(unitOfWork) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 获取入参节点对应的 current 节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> current </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unitOfWork.alternate;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (xxx) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建当前节点的子节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">beginWork$1</span><span style="color:#E1E4E8;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建当前节点的子节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">beginWork$1</span><span style="color:#E1E4E8;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用 completeUnitOfWork</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">completeUnitOfWork</span><span style="color:#E1E4E8;">(unitOfWork);</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将当前节点更新为新创建出的 Fiber 节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    workInProgress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">(unitOfWork) {</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 获取入参节点对应的 current 节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> current </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unitOfWork.alternate;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (xxx) {</span></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建当前节点的子节点</span></span>
<span class="line"><span style="color:#24292E;">    next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">beginWork$1</span><span style="color:#24292E;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建当前节点的子节点</span></span>
<span class="line"><span style="color:#24292E;">    next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">beginWork$1</span><span style="color:#24292E;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (next </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用 completeUnitOfWork</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">completeUnitOfWork</span><span style="color:#24292E;">(unitOfWork);</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将当前节点更新为新创建出的 Fiber 节点</span></span>
<span class="line"><span style="color:#24292E;">    workInProgress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这段源码中你需要提取出的信息是：performUnitOfWork 每次会尝试调用 beginWork 来创建当前节点的子节点，若创建出的子节点为空（也就意味着当前节点不存在子 Fiber 节点），则说明当前节点是一个叶子节点。<strong>按照深度优先遍历的原则，当遍历到叶子节点时，&quot;递&quot;阶段就结束了，随之而来的是&quot;归&quot;的过程</strong>。因此这种情况下，就会调用 completeUnitOfWork，执行当前节点对应的 completeWork 逻辑。</p><p>接下来我们在 Demo 代码的 completeWork 处打上断点，看看第一个走到 completeWork 的节点是哪个，结果如下图所示：</p>`,4),u=n("p",null,"显然，第一个进入 completeWork 的节点是 h1，这也符合我们上一讲所构建出来的 Fiber 树中的节点关系，如下图所示：",-1),f=p(`<p>由图可知，按照深度优先遍历的原则，h1 确实将是第一个被遍历到的叶子节点。接下来我们就以 h1 为例，一起看看 completeWork 都围绕它做了哪些事情。</p><h4 id="completework-的工作原理" tabindex="-1">completeWork 的工作原理 <a class="header-anchor" href="#completework-的工作原理" aria-label="Permalink to &quot;completeWork 的工作原理&quot;">​</a></h4><p>这里仍然为你提取一下 completeWork 的源码结构和主体逻辑，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">completeWork</span><span style="color:#E1E4E8;">(current, workInProgress, renderLanes) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 取出 Fiber 节点的属性值，存储在 newProps 里</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> newProps </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress.pendingProps;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 根据 workInProgress 节点的 tag 属性的不同，决定要进入哪段逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (workInProgress.tag) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> ......</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> ClassComponent</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      {</span></span>
<span class="line"><span style="color:#E1E4E8;">        .....</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> HostRoot</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ......</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// h1 节点的类型属于 HostComponent，因此这里为你讲解的是这段逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> HostComponent</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">popHostContext</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> rootContainerInstance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getRootHostContainer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> type </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> workInProgress.type;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 判断 current 节点是否存在，因为目前是挂载阶段，因此 current 节点是不存在的</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (current </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> workInProgress.stateNode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#B392F0;">updateHostComponent$1</span><span style="color:#E1E4E8;">(current, workInProgress, type, newProps, rootContainerInstance);</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (current.ref </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> workInProgress.ref) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">markRef$1</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 这里首先是针对异常情况进行 return 处理</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">newProps) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(workInProgress.stateNode </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">              {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">              }</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 接下来就为 DOM 节点的创建做准备了</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> currentHostContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getHostContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// _wasHydrated 是一个与服务端渲染有关的值，这里不用关注</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> _wasHydrated </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">popHydrationState</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 判断是否是服务端渲染</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (_wasHydrated) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这里不用关注，请你关注 else 里面的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">prepareToHydrateHostInstance</span><span style="color:#E1E4E8;">(workInProgress, rootContainerInstance, currentHostContext)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#B392F0;">markUpdate</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">          } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这一步很关键， createInstance 的作用是创建 DOM 节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> instance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createInstance</span><span style="color:#E1E4E8;">(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// appendAllChildren 会尝试把上一步创建好的 DOM 节点挂载到 DOM 树上去</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">appendAllChildren</span><span style="color:#E1E4E8;">(instance, workInProgress, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// stateNode 用于存储当前 Fiber 节点对应的 DOM 节点</span></span>
<span class="line"><span style="color:#E1E4E8;">            workInProgress.stateNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> instance; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// finalizeInitialChildren 用来为 DOM 节点设置属性</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">finalizeInitialChildren</span><span style="color:#E1E4E8;">(instance, type, newProps, rootContainerInstance)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#B392F0;">markUpdate</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">          ......</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> HostText</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ......</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> SuspenseComponent</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ......</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> HostPortal</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      ......</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> ContextProvider</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      ......</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    ......</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Unknown unit of work tag (&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> workInProgress.tag </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">completeWork</span><span style="color:#24292E;">(current, workInProgress, renderLanes) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 取出 Fiber 节点的属性值，存储在 newProps 里</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> newProps </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress.pendingProps;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 根据 workInProgress 节点的 tag 属性的不同，决定要进入哪段逻辑</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (workInProgress.tag) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> ......</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> ClassComponent</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      {</span></span>
<span class="line"><span style="color:#24292E;">        .....</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> HostRoot</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      {</span></span>
<span class="line"><span style="color:#24292E;">        ......</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// h1 节点的类型属于 HostComponent，因此这里为你讲解的是这段逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> HostComponent</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">popHostContext</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> rootContainerInstance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getRootHostContainer</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> type </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> workInProgress.type;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 判断 current 节点是否存在，因为目前是挂载阶段，因此 current 节点是不存在的</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (current </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> workInProgress.stateNode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6F42C1;">updateHostComponent$1</span><span style="color:#24292E;">(current, workInProgress, type, newProps, rootContainerInstance);</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (current.ref </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> workInProgress.ref) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">markRef$1</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 这里首先是针对异常情况进行 return 处理</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">newProps) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(workInProgress.stateNode </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">              {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">              }</span></span>
<span class="line"><span style="color:#24292E;">            } </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 接下来就为 DOM 节点的创建做准备了</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> currentHostContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getHostContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// _wasHydrated 是一个与服务端渲染有关的值，这里不用关注</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> _wasHydrated </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">popHydrationState</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 判断是否是服务端渲染</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (_wasHydrated) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这里不用关注，请你关注 else 里面的逻辑</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">prepareToHydrateHostInstance</span><span style="color:#24292E;">(workInProgress, rootContainerInstance, currentHostContext)) {</span></span>
<span class="line"><span style="color:#24292E;">              </span><span style="color:#6F42C1;">markUpdate</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">          } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这一步很关键， createInstance 的作用是创建 DOM 节点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> instance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createInstance</span><span style="color:#24292E;">(type, newProps, rootContainerInstance, currentHostContext, workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// appendAllChildren 会尝试把上一步创建好的 DOM 节点挂载到 DOM 树上去</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">appendAllChildren</span><span style="color:#24292E;">(instance, workInProgress, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// stateNode 用于存储当前 Fiber 节点对应的 DOM 节点</span></span>
<span class="line"><span style="color:#24292E;">            workInProgress.stateNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> instance; </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// finalizeInitialChildren 用来为 DOM 节点设置属性</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">finalizeInitialChildren</span><span style="color:#24292E;">(instance, type, newProps, rootContainerInstance)) {</span></span>
<span class="line"><span style="color:#24292E;">              </span><span style="color:#6F42C1;">markUpdate</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">          ......</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> HostText</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      {</span></span>
<span class="line"><span style="color:#24292E;">        ......</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> SuspenseComponent</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      {</span></span>
<span class="line"><span style="color:#24292E;">        ......</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> HostPortal</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      ......</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> ContextProvider</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">      ......</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    ......</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">    {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Unknown unit of work tag (&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> workInProgress.tag </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;). This error is likely caused by a bug in React. Please file an issue.&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>试图捋顺这段 completeWork 逻辑，你需要掌握以下几个要点。</p><ol><li><p>completeWork 的核心逻辑是一段体量巨大的 switch 语句，在这段 switch 语句中，<strong>completeWork 将根据 workInProgress 节点的 tag 属性的不同，进入不同的 DOM 节点的创建、处理逻辑</strong>。</p></li><li><p>在 Demo 示例中，h1 节点的 tag 属性对应的类型应该是 HostComponent，也就是&quot;原生 DOM 元素类型&quot;。</p></li><li><p>completeWork 中的 current、 workInProgress 分别对应的是下图中左右两棵 Fiber 树上的节点：</p></li></ol>`,6),g=p("<p>其中 workInProgress 树代表的是&quot;当前正在 render 中的树&quot;，而 current 树则代表&quot;已经存在的树&quot;。</p><p>workInProgress 节点和 current 节点之间用 alternate 属性相互连接。在组件的挂载阶段，current 树只有一个 rootFiber 节点，并没有其他内容。因此 h1 这个 workInProgress 节点对应的 current 节点是 null。</p><p>带着上面这些前提，再去结合注释读一遍上面提炼出来的源码，思路是不是就清晰多了？</p><p>捋顺思路后，我们直接来提取知识点。关于 completeWork，你需要明白以下几件事。</p><p>（1）用一句话来总结 completeWork 的工作内容：<strong>负责处理 Fiber 节点到 DOM 节点的映射逻辑</strong>。</p><p>（2）completeWork 内部有 3 个关键动作：</p><ul><li><p><strong>创建</strong>DOM 节点（CreateInstance）</p></li><li><p>将 DOM 节点<strong>插入</strong>到 DOM 树中（AppendAllChildren）</p></li><li><p>为 DOM 节点<strong>设置属性</strong>（FinalizeInitialChildren）</p></li></ul><p>（3）<strong>创建好的 DOM 节点会被赋值给 workInProgress 节点的 stateNode 属性</strong>。也就是说当我们想要定位一个 Fiber 对应的 DOM 节点时，访问它的 stateNode 属性就可以了。这里我们可以尝试访问运行时的 h1 节点的 stateNode 属性，结果如下图所示：</p>",8),d=p(`<p>（4）将 DOM 节点插入到 DOM 树的操作是通过 appendAllChildren 函数来完成的。</p><p>说是将 DOM 节点插入到 DOM 树里去，实际上是将<strong>子 Fiber 节点所对应的 DOM 节点</strong> 挂载到其<strong>父 Fiber 节点所对应的 DOM 节点里去</strong>。比如说在本讲 Demo 所构建出的 Fiber 树中，h1 节点的父结点是 div，那么 h1 对应的 DOM 节点就理应被挂载到 div 对应的 DOM 节点里去。</p><p>那么如果执行 appendAllChildren 时，父级的 DOM 节点还不存在怎么办？</p><p>比如 h1 节点作为第一个进入 completeWork 的节点，它的父节点 div 对应的 DOM 就尚不存在。其实不存在也没关系，反正 h1 DOM 节点被创建后，会作为 h1 Fiber 节点的 stateNode 属性存在，丢不掉的。当父节点 div 进入 appendAllChildren 逻辑后，会逐个向下查找并添加自己的后代节点，这时候，h1 就会被它的父级 DOM 节点&quot;收入囊中&quot;啦~</p><h3 id="completeunitofwork-开启收集-effectlist-的-大循环" tabindex="-1">completeUnitOfWork ------ 开启收集 EffectList 的&quot;大循环&quot; <a class="header-anchor" href="#completeunitofwork-开启收集-effectlist-的-大循环" aria-label="Permalink to &quot;completeUnitOfWork ------ 开启收集 EffectList 的&quot;大循环&quot;&quot;">​</a></h3><p>completeUnitOfWork 的作用是开启一个大循环，在这个大循环中，将会重复地做下面三件事：</p><ol><li><p><strong>针对传入的当前节点，调用 completeWork</strong>，completeWork 的工作内容前面已经讲过，这一步应该是没有异议的；</p></li><li><p>将<strong>当前节点的副作用链</strong> （EffectList）插入到其<strong>父节点对应的副作用链</strong>（EffectList）中；</p></li><li><p>以当前节点为起点，循环遍历其兄弟节点及其父节点。当遍历到兄弟节点时，将 return 掉当前调用，触发兄弟节点对应的 performUnitOfWork 逻辑；而遍历到父节点时，则会直接进入下一轮循环，也就是重复 1、2 的逻辑。</p></li></ol><p>步骤 1 无须多言，接下来我将为你解读步骤 2 和步骤 3 的含义。</p><h4 id="completeunitofwork-开启下一轮循环的原则" tabindex="-1">completeUnitOfWork 开启下一轮循环的原则 <a class="header-anchor" href="#completeunitofwork-开启下一轮循环的原则" aria-label="Permalink to &quot;completeUnitOfWork 开启下一轮循环的原则&quot;">​</a></h4><p>在理解副作用链之前，首先要理解 completeUnitOfWork 开启下一轮循环的原则，也就是步骤 3。步骤 3 相关的源码如下所示（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里省略步骤 1 和步骤 2 的逻辑 </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 获取当前节点的兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> siblingFiber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> completedWork.sibling;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 若兄弟节点存在</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (siblingFiber </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 workInProgress 赋值为当前节点的兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    workInProgress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> siblingFiber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将正在进行的 completeUnitOfWork 逻辑 return 掉</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 若兄弟节点不存在，completeWork 会被赋值为 returnFiber，也就是当前节点的父节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  completedWork </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> returnFiber; </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这一步与上一步是相辅相成的，上下文中要求 workInProgress 与 completedWork 保持一致</span></span>
<span class="line"><span style="color:#E1E4E8;">  workInProgress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> completedWork;</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (completedWork </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里省略步骤 1 和步骤 2 的逻辑 </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 获取当前节点的兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> siblingFiber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> completedWork.sibling;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 若兄弟节点存在</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (siblingFiber </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 workInProgress 赋值为当前节点的兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">    workInProgress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> siblingFiber;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将正在进行的 completeUnitOfWork 逻辑 return 掉</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 若兄弟节点不存在，completeWork 会被赋值为 returnFiber，也就是当前节点的父节点</span></span>
<span class="line"><span style="color:#24292E;">  completedWork </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> returnFiber; </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这一步与上一步是相辅相成的，上下文中要求 workInProgress 与 completedWork 保持一致</span></span>
<span class="line"><span style="color:#24292E;">  workInProgress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> completedWork;</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (completedWork </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span></code></pre></div><p>步骤 3 是整个循环体的收尾工作，它会在当前节点相关的各种工作都做完之后执行。</p><p>当前节点处理完了，自然是去寻找下一个可以处理的节点。我们知道，当前的 Fiber 节点之所以会进入 completeWork，是因为&quot;递无可递&quot;了，才会进入&quot;归&quot;的逻辑，这就意味着当前 Fiber 要么没有 child 节点、要么 child 节点的 completeWork 早就执行过了。因此 child 节点不会是下次循环需要考虑的对象，下次循环只需要考虑兄弟节点（siblingFiber）和父节点（returnFiber）。</p><p>那么为什么在源码中，遇到兄弟节点会 return，遇到父节点才会进入下次循环呢？这里我以 h1 节点的节点关系为例进行说明。请看下图：</p>`,14),F=p('<p>结合前面的分析和图示可知，<strong>h1 节点是递归过程中所触及的第一个叶子节点，也是其兄弟节点中被遍历到的第一个节点</strong>；而剩下的两个 p 节点，此时都还没有被遍历到，也就是说连 beginWork 都没有执行过。</p><p><strong>因此对于 h1 节点的兄弟节点来说，当下的第一要务是回去从 beginWork 开始走起，直到 beginWork &quot;递无可递&quot;时，才能够执行 completeWork 的逻辑</strong>。beginWork 的调用是在 performUnitOfWork 里发生的，因此 completeUnitOfWork 一旦识别到当前节点的兄弟节点不为空，就会终止后续的逻辑，退回到上一层的 performUnitOfWork 里去。</p><p>接下来我们再来看 h1 的父节点 div：在向下递归到 h1 的过程中，div 必定已经被遍历过了，也就是说 div 的&quot;递&quot;阶段（ beginWork） 已经执行完毕，只剩下&quot;归&quot;阶段的工作要处理了。因此，对于父节点，completeUnitOfWork 会毫不犹豫地把它推到下一次循环里去，让它进入 completeWork 的逻辑。</p><p>值得注意的是，completeUnitOfWork 中处理兄弟节点和父节点的顺序是：先检查兄弟节点是否存在，若存在则优先处理兄弟节点；确认没有待处理的兄弟节点后，才转而处理父节点。这也就意味着，<strong>completeWork 的执行是严格自底向上的</strong>，子节点的 completeWork 总会先于父节点执行。</p><h4 id="副作用链-effectlist-的设计与实现" tabindex="-1">副作用链（effectList）的设计与实现 <a class="header-anchor" href="#副作用链-effectlist-的设计与实现" aria-label="Permalink to &quot;副作用链（effectList）的设计与实现&quot;">​</a></h4><p>无论是 beginWork 还是 completeWork，它们的应用对象都是 workInProgress 树上的节点。我们说 render 阶段是一个递归的过程，&quot;递归&quot;的对象，正是这棵 workInProgress 树（见下图右侧高亮部分）：</p>',6),A=n("p",null,"那么我们递归的目的是什么呢？或者说，render 阶段的工作目标是什么呢？",-1),m=n("p",null,[n("strong",null,"render 阶段的工作目标是找出界面中需要处理的更新"),s("。")],-1),D=n("p",null,"在实际的操作中，并不是所有的节点上都会产生需要处理的更新。比如在挂载阶段，对图中的整棵 workInProgress 递归完毕后，React 会发现实际只需要对 App 节点执行一个挂载操作就可以了；而在更新阶段，这种现象更为明显。",-1),k=n("p",null,"更新阶段与挂载阶段的主要区别在于更新阶段的 current 树不为空，比如说情况可以是下图这样子的：",-1),_=p("<p>假如说我的某一次操作，仅仅对 p 节点产生了影响，那么对于渲染器来说，它理应只关注 p 节点这一处的更新。这时候问题就来了：<strong>怎样做才能让渲染器又快又好地定位到那些真正需要更新的节点呢</strong>？</p><p>在 render 阶段，我们通过艰难的递归过程来明确&quot;p 节点这里有一处更新&quot;这件事情。按照 React 的设计思路，render 阶段结束后，&quot;找不同&quot;这件事情其实也就告一段落了。<strong>commit 只负责实现更新，而不负责寻找更新</strong> ，这就意味着我们必须找到一个办法能让 commit 阶段&quot;坐享其成&quot;，能直接拿到 render 阶段的工作成果。而这，正是<strong>副作用链</strong> （<strong>effectList</strong>）的价值所在。</p><p><strong>副作用链（effectList）</strong> 可以理解为 render 阶段&quot;工作成果&quot;的一个集合：每个 Fiber 节点都维护着一个属于它自己的 effectList，effectList 在数据结构上以链表的形式存在，链表内的每一个元素都是一个 Fiber 节点。这些 Fiber 节点需要满足两个共性：</p><ol><li><p>都是当前 Fiber 节点的后代节点</p></li><li><p>都有待处理的副作用</p></li></ol><p>没错，Fiber 节点的 effectList 里记录的并非它自身的更新，而是其<strong>需要更新的后代节点</strong>。带着这个结论，我们再来品品小节开头 completeUnitOfWork 中的&quot;步骤 2&quot;：</p><blockquote><p>将<strong>当前节点的副作用链</strong> （effectList）插入到其<strong>父节点对应的副作用链</strong>（effectList）中。</p></blockquote><p>咱们前面已经分析过，&quot;<strong>completeWork 是自底向上执行的</strong> &quot;，也就是说，子节点的 completeWork 总是比父节点先执行。试想，若每次处理到一个节点，都将当前节点的 effectList 插入到其父节点的 effectList 中。那么当所有节点的 completeWork 都执行完毕时，我是不是就可以从&quot;终极父节点&quot;，也就是 rootFiber 上，拿到一个<strong>存储了当前 Fiber 树所有 effect Fiber</strong>的&quot;终极版&quot;的 effectList 了？</p><p><strong>把所有需要更新的 Fiber 节点单独串成一串链表，方便后续有针对性地对它们进行更新，这就是所谓的&quot;收集副作用&quot;的过程</strong>。</p><p>这里我以挂载过程为例，带你分析一下这个过程是如何实现的。</p><p>首先我们要知道的是，这个 effectList 链表在 Fiber 节点中是通过 firstEffect 和 lastEffect 来维护的，如下图所示：</p>",10),h=p(`<p>其中 firstEffect 表示 effectList 的第一个节点，而 lastEffect 则记录最后一个节点。</p><p>对于挂载过程来说，我们唯一要做的就是把 App 组件挂载到界面上去，因此 App 后代节点们的 effectList 其实都是不存在的。effectList 只有在 App 的父节点（rootFiber）这才不为空。</p><p>那么 effectList 的创建逻辑又是怎样的呢？其实非常简单，只需要为 firstEffect 和 lastEffect 各赋值一个引用即可。以下是从 completeUnitOfWork 源码中提取出的相关逻辑（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 若副作用类型的值大于&quot;PerformedWork&quot;，则说明这里存在一个需要记录的副作用</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (flags </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> PerformedWork) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// returnFiber 是当前节点的父节点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (returnFiber.lastEffect </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若父节点的 effectList 不为空，则将当前节点追加到 effectList 的末尾去</span></span>
<span class="line"><span style="color:#E1E4E8;">    returnFiber.lastEffect.nextEffect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> completedWork;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若父节点的 effectList 为空，则当前节点就是 effectList 的 firstEffect</span></span>
<span class="line"><span style="color:#E1E4E8;">    returnFiber.firstEffect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> completedWork;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 将 effectList 的 lastEffect 指针后移一位</span></span>
<span class="line"><span style="color:#E1E4E8;">  returnFiber.lastEffect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> completedWork;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 若副作用类型的值大于&quot;PerformedWork&quot;，则说明这里存在一个需要记录的副作用</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (flags </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> PerformedWork) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// returnFiber 是当前节点的父节点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (returnFiber.lastEffect </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若父节点的 effectList 不为空，则将当前节点追加到 effectList 的末尾去</span></span>
<span class="line"><span style="color:#24292E;">    returnFiber.lastEffect.nextEffect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> completedWork;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若父节点的 effectList 为空，则当前节点就是 effectList 的 firstEffect</span></span>
<span class="line"><span style="color:#24292E;">    returnFiber.firstEffect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> completedWork;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 将 effectList 的 lastEffect 指针后移一位</span></span>
<span class="line"><span style="color:#24292E;">  returnFiber.lastEffect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> completedWork;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>代码中的 flags 咱们已经反复强调过了，它旧时的名字叫&quot;effectTag&quot;，是用来标识副作用类型的；而&quot;completedWork&quot;这个变量，在当前上下文中存储的就是&quot;正在被执行 completeWork 相关逻辑&quot;的节点；至于&quot;PerformedWork&quot;，它是一个值为 1 的常量，React 规定若 flags（又名 effectTag）的值小于等于 1，则不必提交到 commit 阶段。因此 completeUnitOfWork 只会对 flags 大于 PerformedWork 的 effect fiber 进行收集。</p><p>结合这些信息，再去读一遍源码片段，相信你的理解过程就会很流畅了。这里我以 App 节点为例，带你走一遍 effectList 的创建过程：</p><ol><li><p>App FiberNode 的 flags 属性为 3，大于 PerformedWork，因此会进入 effectList 的创建逻辑；</p></li><li><p>创建 effectList 时，并不是为当前 Fiber 节点创建，而是为它的父节点创建，App 节点的父节点是 rootFiber，rootFiber 的 effectList 此时为空；</p></li><li><p>rootFiber 的 firstEffect 和 lastEffect 指针都会指向 App 节点，App 节点由此成为 effectList 中的唯一一个 FiberNode，如下图所示。</p></li></ol>`,7),C=n("p",null,"OK，读到这里，相信你已经对 effectList 的创建过程知根知底了。",-1),b=n("p",null,'现在，即便你对部分源码细节的消化可能没有那么快，也请你不要因为这些细节去中断自己串联整个渲染链路的思路。你只需要把握住"根节点（rootFiber）上的 effectList 信息，是 commit 阶段的更新线索"这个结论，就足以将 render 阶段和 commit 阶段串联起来。',-1),W=n("h3",{id:"commit-阶段工作流简析",tabindex:"-1"},[s("commit 阶段工作流简析 "),n("a",{class:"header-anchor",href:"#commit-阶段工作流简析","aria-label":'Permalink to "commit 阶段工作流简析"'},"​")],-1),q=n("p",null,'在整个 ReactDOM.render 的渲染链路中，render 阶段是 Fiber 架构的核心体现，也是我们讲解的重点。对于 render 阶段，我对你的期望是"熟悉"，为了达成这个目标，我们对 render 阶段的学习还会再持续一个课时；而对于 commit 阶段，我只要求你做到"了解"。因此这里我会快速地带你过一遍 commit 阶段的重点知识，不占用你太多时间。',-1),P=n("p",null,"commit 会在 performSyncWorkOnRoot 中被调用，如下图所示：",-1),w=p('<p>这里的入参 root 并不是 rootFiber，而是 fiberRoot（FiberRootNode）实例。fiberRoot 的 current 节点指向 rootFiber，因此拿到 effectList 对后续的 commit 流程来说不是什么难事。</p><p>从流程上来说，commit 共分为 3 个阶段：<strong>before mutation、mutation、layout。</strong></p><ul><li><p>before mutation 阶段，<strong>这个阶段 DOM 节点还没有被渲染到界面上去</strong>，过程中会触发 getSnapshotBeforeUpdate，也会处理 useEffect 钩子相关的调度逻辑。</p></li><li><p>mutation，<strong>这个阶段负责 DOM 节点的渲染</strong>。在渲染过程中，会遍历 effectList，根据 flags（effectTag）的不同，执行不同的 DOM 操作。</p></li><li><p>layout，<strong>这个阶段处理 DOM 渲染完毕之后的收尾逻辑</strong> 。比如调用 componentDidMount/componentDidUpdate，调用 useLayoutEffect 钩子函数的回调等。除了这些之外，它还会<strong>把 fiberRoot 的 current 指针指向 workInProgress Fiber 树</strong>。</p></li></ul><p>关于 commit 阶段的实现细节，感兴趣的同学课下可以参阅 <a href="https://github.com/facebook/react/blob/a81c02ac150233bdb5f31380d4135397fb8f4660/packages/react-reconciler/src/ReactFiberWorkLoop.new.js" target="_blank" rel="noreferrer">commit 相关源码</a>，这里不再展开讨论。对于 commit，如果你只能记住一个知识点，我希望你记住<strong>它是一个绝对同步的过程</strong>。render 阶段可以同步也可以异步，但 commit 一定是同步的。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲我们完成了对 ReactDOM.render 调用栈的分析。表面上剖析的是首次渲染的渲染链路，实际上将包括同步模式下的挂载、更新链路（与挂载链路的调用栈非常相似）都串联了一遍。</p><p>虽然还没有正式介入更新链路、包括异步更新模式的讲解，但你此时其实已经具备了理解这些知识的基础：Concurrent 模式（异步渲染）与 Legacy 模式（同步渲染）在数据结构设计、核心 API 调用等方面都是一致的。<strong>这也就意味着我们这三讲所讲解的知识，都是可以在后续的学习中复用的</strong>。</p><p>接下来，我们就将进入更新过程的学习，揭开 Concurrent 模式及 Scheduler 的神秘面纱。同时，针对上一讲遗留下来的&quot;为什么需要两棵树&quot;的问题，我也会在下一讲中为你解答。</p>',8);function I(O,v,M,T,B,R){const a=e("Image");return t(),r("div",null,[E,l(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/72/1B/CgqCHl_AsdSAQuGuAAC09U5X0K0556.png"}),s(),y,l(a,{alt:"图片10.png",src:"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2PuADu50AABVUspw4O0014.png"}),s(),i,l(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_AseOADKNDAALdERWik0M525.png"}),s(),u,l(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/72/1B/CgqCHl_AsgSAJoM0AAEYVWI-PXg056.png"}),s(),f,l(a,{alt:"图片12.png",src:"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2R-AWalhAAD-42SivEU001.png"}),s(),g,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_Ash-AW32XAABIXg8drFo176.png"}),s(),d,l(a,{alt:"图片8.png",src:"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2UCAeC8WAAByZUWVwpM770.png"}),s(),F,l(a,{alt:"图片13.png",src:"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2VCAHbHdAAEBwCIJFE4253.png"}),s(),A,m,D,k,l(a,{alt:"图片14.png",src:"https://s0.lgstatic.com/i/image/M00/72/29/CgqCHl_A2VyAUxeJAAIrypFDLh4388.png"}),s(),_,l(a,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/72/1C/CgqCHl_AspmALRFDAADaKY8wTqc180.png"}),s(),h,l(a,{alt:"图片15.png",src:"https://s0.lgstatic.com/i/image/M00/72/1E/Ciqc1F_A2W-AVmmRAABDdji0MoI238.png"}),s(),C,b,W,q,P,l(a,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image/M00/72/10/Ciqc1F_AsqiAENXWAAF6r2_37Lc521.png"}),s(),w])}const x=o(c,[["render",I]]);export{H as __pageData,x as default};
