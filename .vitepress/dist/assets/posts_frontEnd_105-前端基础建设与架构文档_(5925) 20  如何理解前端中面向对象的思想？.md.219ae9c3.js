import{_ as l,D as o,o as e,g as t,J as p,h as a,Q as c,m as s}from"./chunks/framework.f67d7268.js";const B=JSON.parse('{"title":"20如何理解前端中面向对象的思想？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/105-前端基础建设与架构文档/(5925) 20  如何理解前端中面向对象的思想？.md","filePath":"posts/frontEnd/105-前端基础建设与架构文档/(5925) 20  如何理解前端中面向对象的思想？.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/105-前端基础建设与架构文档/(5925) 20  如何理解前端中面向对象的思想？.md"},E=c(`<h1 id="_20如何理解前端中面向对象的思想" tabindex="-1">20如何理解前端中面向对象的思想？ <a class="header-anchor" href="#_20如何理解前端中面向对象的思想" aria-label="Permalink to &quot;20如何理解前端中面向对象的思想？&quot;">​</a></h1><p>&quot;对象&quot;------这个概念在编程中非常重要，任何语言和领域的开发者都应该具有面向对象思维，才能够有效运用对象。良好的面向对象系统设计将是应用强健性、可维护性和可扩展性的关键；反之，如果面向对象环节有失误，将成为项目的灾难。</p><p>说到 JavaScript 面向对象，它实质是基于原型的对象系统，而不是基于类的。这是设计之初，由语言设计所决定的。随着 ES Next 标准的进化和新特性的添加，使得 JavaScript 面向对象更加贴近其他传统面向对象型语言。有幸目睹语言的发展和变迁，伴随着某种语言的成长，我认为是开发者之幸。</p><p>这一讲就让我们深入对象和原型，理解 JavaScript 在这个方向上的能力。请注意，今天的内容我们不再过多赘述基础，而是面向进阶，需要你具有一定的知识准备。</p><h3 id="实现-new-没有那么容易" tabindex="-1">实现 new 没有那么容易 <a class="header-anchor" href="#实现-new-没有那么容易" aria-label="Permalink to &quot;实现 new 没有那么容易&quot;">​</a></h3><p>说起 JavaScript 当中的 new 关键字，有一段很有趣的历史。其实 JavaScript 创造者 Brendan Eich 实现 new 是为了获得更高的流行度，它是强行学习 Java 的一个残留产出，创造者想让 JavaScript 成为 Java 的小弟。当然，也有很多人认为这个设计掩盖了 JavaScript 中真正的原型继承，只是表面上看，更像是基于类的继承。</p><p>这样的误会使得很多传统 Java 开发者并不能很好理解 JavaScript。实际上，我们前端工程师应该明白，new 关键字到底做了什么事情。</p><p>step1：创建一个空对象，这个对象将会作为执行 new 构造函数() 之后，返回的对象实例。</p><p>step2：将上面创建的空对象的原型（<strong>proto</strong>），指向构造函数的 prototype 属性。</p><p>step3：将这个空对象赋值给构造函数内部的 this，并执行构造函数逻辑。</p><p>step4：根据构造函数执行逻辑，返回第一步创建的对象或者构造函数的显式返回值。</p><p>因为 new 是 JavaScript 的关键字，我们不能直接覆盖，实现一个 newFunc 来进行模拟，预计使用方式：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">Person</span><span style="color:#E1E4E8;">(name) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> name</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> person </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">newFunc</span><span style="color:#E1E4E8;">(Person, </span><span style="color:#9ECBFF;">&#39;lucas&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(person)</span></span>
<span class="line"><span style="color:#6A737D;">// {name: &quot;lucas&quot;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">Person</span><span style="color:#24292E;">(name) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> person </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">newFunc</span><span style="color:#24292E;">(Person, </span><span style="color:#032F62;">&#39;lucas&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(person)</span></span>
<span class="line"><span style="color:#6A737D;">// {name: &quot;lucas&quot;}</span></span></code></pre></div><p>实现为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">newFunc</span><span style="color:#E1E4E8;">(...args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 取出 args 数组第一个参数，即目标构造函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> constructor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> args.</span><span style="color:#B392F0;">shift</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 创建一个空对象，且这个空对象继承构造函数的 prototype 属性</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 即实现 obj.__proto__ === constructor.prototype</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">(constructor.prototype)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 执行构造函数，得到构造函数返回结果</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 注意这里我们使用 apply，将构造函数内的 this 指向为 obj</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> constructor.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(obj, args)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (typeof result </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;object&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> result </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> obj</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">newFunc</span><span style="color:#24292E;">(...args) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 取出 args 数组第一个参数，即目标构造函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> constructor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> args.</span><span style="color:#6F42C1;">shift</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 创建一个空对象，且这个空对象继承构造函数的 prototype 属性</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 即实现 obj.__proto__ === constructor.prototype</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> obj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(constructor.prototype)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 执行构造函数，得到构造函数返回结果</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 注意这里我们使用 apply，将构造函数内的 this 指向为 obj</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> constructor.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(obj, args)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果构造函数执行后，返回结果是对象类型，就直接返回，否则返回 obj 对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (typeof result </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;object&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> result </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> result </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> obj</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上述代码并不复杂，几个关键点需要注意：</p><ul><li><p>使用 Object.create 将 obj 的 <strong>proto</strong> 指向为构造函数的原型；</p></li><li><p>使用 apply 方法，将构造函数内的 this 指向为 obj；</p></li><li><p>在 newFunc 返回时，使用三目运算符决定返回结果。</p></li></ul><p>我们知道，<strong>构造函数如果有显式返回值，且返回值为对象类型</strong>，那么构造函数返回结果不再是目标实例。</p><p>如下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">Person</span><span style="color:#E1E4E8;">(name) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> name</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span><span style="color:#79B8FF;">1</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> person </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Person</span><span style="color:#E1E4E8;">(Person, </span><span style="color:#9ECBFF;">&#39;lucas&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(person)</span></span>
<span class="line"><span style="color:#6A737D;">// {1: 1}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">Person</span><span style="color:#24292E;">(name) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span><span style="color:#005CC5;">1</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> person </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Person</span><span style="color:#24292E;">(Person, </span><span style="color:#032F62;">&#39;lucas&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(person)</span></span>
<span class="line"><span style="color:#6A737D;">// {1: 1}</span></span></code></pre></div><p>了解这些注意点，对于理解 newFunc 的实现就不再困难了。</p><h3 id="如何优雅地实现继承" tabindex="-1">如何优雅地实现继承 <a class="header-anchor" href="#如何优雅地实现继承" aria-label="Permalink to &quot;如何优雅地实现继承&quot;">​</a></h3><p>实现继承式是面向对象的一个重点概念。我们前面提到过 JavaScript 的面向对象系统是基于原型的，它的继承不同于其他大多数语言。</p><p>社区上对于 JavaScript 继承讲解的资料不在少数，这里我不再赘述每一种继承方式的实现过程，还需要你提前了解。</p><h4 id="es5-相对可用的继承方案" tabindex="-1">ES5 相对可用的继承方案 <a class="header-anchor" href="#es5-相对可用的继承方案" aria-label="Permalink to &quot;ES5 相对可用的继承方案&quot;">​</a></h4><p>我们仅总结以下 JavaScript 中实现继承的关键点。</p><p>如果想使 Child 继承 Parent，那么采用原型链实现继承最关键的要点是：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Child.prototype </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Parent</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Child.prototype </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Parent</span><span style="color:#24292E;">()</span></span></code></pre></div><p>这样的实现，不同的 Child 实例的 <strong>proto</strong> 会引用同一 Parent 的实例。</p><p>构造函数实现继承的要点是：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">Child</span><span style="color:#E1E4E8;"> (args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    Parent.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, args)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">Child</span><span style="color:#24292E;"> (args) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">    Parent.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, args)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这样的实现，问题也比较大，其实只是实现了实例属性继承，<strong>Parent 原型的方法在 Child 实例中并不可用</strong>。</p><p>组合继承的实现才基本可用，其要点是：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">Child</span><span style="color:#E1E4E8;"> (args1, args2) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.args2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> args2</span></span>
<span class="line"><span style="color:#E1E4E8;">    Parent.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, args1)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">Child.prototype </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Parent</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">Child.prototype.constrcutor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Child</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">Child</span><span style="color:#24292E;"> (args1, args2) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.args2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> args2</span></span>
<span class="line"><span style="color:#24292E;">    Parent.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, args1)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">Child.prototype </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Parent</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">Child.prototype.constrcutor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Child</span></span></code></pre></div><p>它的问题在于，Child 实例会存在 Parent 的实例属性。因为我们在 Child 构造函数中执行了 Parent 构造函数。同时，Child.<strong>proto</strong> 也会存在同样的 Parent 的实例属性，且所有 Child 实例的 <strong>proto</strong> 指向同一内存地址。同时上述实现也都没有对静态属性的继承。</p><p>还有一些其他不完美的继承方式，我们这里不再过多介绍。</p><p>下面我们给出一个比较完整的方案，它解决了上面一系列的问题，我们先看代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">inherit</span><span style="color:#E1E4E8;">(Child, Parent) {</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">// 继承原型上的属性 </span></span>
<span class="line"><span style="color:#E1E4E8;">    Child.prototype </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Object.</span><span style="color:#B392F0;">create</span><span style="color:#E1E4E8;">(Parent.prototype)</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">// 修复 constructor</span></span>
<span class="line"><span style="color:#E1E4E8;">    Child.prototype.constructor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Child</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 存储超类</span></span>
<span class="line"><span style="color:#E1E4E8;">    Child.super </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Parent</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 静态属性继承</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Object.setPrototypeOf) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// setPrototypeOf es6</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object.</span><span style="color:#B392F0;">setPrototypeOf</span><span style="color:#E1E4E8;">(Child, Parent)</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Child.__proto__) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// __proto__ es6 引入，但是部分浏览器早已支持</span></span>
<span class="line"><span style="color:#E1E4E8;">        Child.__proto__ </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Parent</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 兼容 IE10 等陈旧浏览器</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (var k in Parent) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Parent.</span><span style="color:#B392F0;">hasOwnProperty</span><span style="color:#E1E4E8;">(k) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(k in Child)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">Child</span><span style="color:#E1E4E8;">[k] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Parent</span><span style="color:#E1E4E8;">[k]</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">inherit</span><span style="color:#24292E;">(Child, Parent) {</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">// 继承原型上的属性 </span></span>
<span class="line"><span style="color:#24292E;">    Child.prototype </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Object.</span><span style="color:#6F42C1;">create</span><span style="color:#24292E;">(Parent.prototype)</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">// 修复 constructor</span></span>
<span class="line"><span style="color:#24292E;">    Child.prototype.constructor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Child</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 存储超类</span></span>
<span class="line"><span style="color:#24292E;">    Child.super </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Parent</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 静态属性继承</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Object.setPrototypeOf) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// setPrototypeOf es6</span></span>
<span class="line"><span style="color:#24292E;">        Object.</span><span style="color:#6F42C1;">setPrototypeOf</span><span style="color:#24292E;">(Child, Parent)</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Child.__proto__) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// __proto__ es6 引入，但是部分浏览器早已支持</span></span>
<span class="line"><span style="color:#24292E;">        Child.__proto__ </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Parent</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 兼容 IE10 等陈旧浏览器</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将 Parent 上的静态属性和方法拷贝一份到 Child 上，不会覆盖 Child 上的方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (var k in Parent) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Parent.</span><span style="color:#6F42C1;">hasOwnProperty</span><span style="color:#24292E;">(k) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(k in Child)) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">Child</span><span style="color:#24292E;">[k] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Parent</span><span style="color:#24292E;">[k]</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>具体原理已经包含在了注释当中。需要指出的是，上述静态属性继承仍然存在一个问题：在陈旧浏览器中，属性和方法的继承我们是静态拷贝的，继承完后续父类的改动不会自动同步到子类。这是不同于正常面向对象思想的，但是这种组合式继承，已经相对完美、优雅。</p><h4 id="继承-date" tabindex="-1">继承 Date <a class="header-anchor" href="#继承-date" aria-label="Permalink to &quot;继承 Date&quot;">​</a></h4><p>值得一提的一个小细节是：前面几种继承方式<strong>无法实现对 Date 对象的继承</strong>。我们来进行测试：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">DateConstructor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Date.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, arguments)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.foo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;bar&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">inherit</span><span style="color:#E1E4E8;">(DateConstructor, Date)</span></span>
<span class="line"><span style="color:#E1E4E8;">DateConstructor.prototype.getMyTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">let date </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DateConstructor</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(date.</span><span style="color:#B392F0;">getMyTime</span><span style="color:#E1E4E8;">())</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">DateConstructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    Date.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, arguments)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.foo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;bar&#39;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">inherit</span><span style="color:#24292E;">(DateConstructor, Date)</span></span>
<span class="line"><span style="color:#24292E;">DateConstructor.prototype.getMyTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">let date </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DateConstructor</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(date.</span><span style="color:#6F42C1;">getMyTime</span><span style="color:#24292E;">())</span></span></code></pre></div><p>将会得到报错：<code>Uncaught TypeError: this is not a Date object.</code></p><p>究其原因，是因为 JavaScript 的日期对象只能通过 JavaScript Date 作为构造函数来实例化得到。因此 v8 引擎实现代码中就一定有所限制，如果发现调用 getTime() 方法的对象不是 Date 构造函数构造出来的实例，则抛出错误。</p><p>那么如何实现对 Date 的继承呢？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">DateConstructor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> dateObj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;">(Function.prototype.bind.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Date, [Date].</span><span style="color:#B392F0;">concat</span><span style="color:#E1E4E8;">(Array.prototype.slice.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(arguments))))()</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object.</span><span style="color:#B392F0;">setPrototypeOf</span><span style="color:#E1E4E8;">(dateObj, DateConstructor.prototype)</span></span>
<span class="line"><span style="color:#E1E4E8;">    dateObj.foo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;bar&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> dateObj</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">setPrototypeOf</span><span style="color:#E1E4E8;">(DateConstructor.prototype, Date.prototype)</span></span>
<span class="line"><span style="color:#E1E4E8;">DateConstructor.prototype.getMyTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">let date </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DateConstructor</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(date.</span><span style="color:#B392F0;">getMyTime</span><span style="color:#E1E4E8;">())</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">DateConstructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> dateObj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;">(Function.prototype.bind.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Date, [Date].</span><span style="color:#6F42C1;">concat</span><span style="color:#24292E;">(Array.prototype.slice.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(arguments))))()</span></span>
<span class="line"><span style="color:#24292E;">    Object.</span><span style="color:#6F42C1;">setPrototypeOf</span><span style="color:#24292E;">(dateObj, DateConstructor.prototype)</span></span>
<span class="line"><span style="color:#24292E;">    dateObj.foo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;bar&#39;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> dateObj</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">setPrototypeOf</span><span style="color:#24292E;">(DateConstructor.prototype, Date.prototype)</span></span>
<span class="line"><span style="color:#24292E;">DateConstructor.prototype.getMyTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">let date </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DateConstructor</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(date.</span><span style="color:#6F42C1;">getMyTime</span><span style="color:#24292E;">())</span></span></code></pre></div><p>我们来分析一下代码，调用构造函数 DateConstructor 返回的对象 dateObj 有：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">dateObj.__proto__ </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> DateConstructor.prototype</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">dateObj.__proto__ </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> DateConstructor.prototype</span></span></code></pre></div><p>而我们通过：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Object.</span><span style="color:#B392F0;">setPrototypeOf</span><span style="color:#E1E4E8;">(DateConstructor.prototype, Date.prototype)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Object.</span><span style="color:#6F42C1;">setPrototypeOf</span><span style="color:#24292E;">(DateConstructor.prototype, Date.prototype)</span></span></code></pre></div><p>实现了：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">DateConstructor.prototype.__proto__ </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Date.prototype</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">DateConstructor.prototype.__proto__ </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Date.prototype</span></span></code></pre></div><p>所以连起来就是：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">date.__proto__.__proto__ </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Date.prototype</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">date.__proto__.__proto__ </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Date.prototype</span></span></code></pre></div><p>继续分析，DateConstructor 构造函数里，返回的 dateObj 是一个真正的 Date 对象，因为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> dateObj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;">(Function.prototype.bind.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Date, [Date].</span><span style="color:#B392F0;">concat</span><span style="color:#E1E4E8;">(Array.prototype.slice.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(arguments))))()</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> dateObj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;">(Function.prototype.bind.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(Date, [Date].</span><span style="color:#B392F0;">concat</span><span style="color:#E1E4E8;">(Array.prototype.slice.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(arguments))))()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> dateObj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;">(Function.prototype.bind.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Date, [Date].</span><span style="color:#6F42C1;">concat</span><span style="color:#24292E;">(Array.prototype.slice.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(arguments))))()</span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> dateObj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;">(Function.prototype.bind.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(Date, [Date].</span><span style="color:#6F42C1;">concat</span><span style="color:#24292E;">(Array.prototype.slice.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(arguments))))()</span></span></code></pre></div><p>它终归还是由 Date 构造函数实例化出来的，因此它有权调用 Date 原型上的方法，而不会被引擎限制。</p><p>整个实现过程通过<strong>更改原型关系</strong> ，在构造函数里调用原生构造函数 Date，并返回其实例的方法，&quot;欺骗了&quot;浏览器。当然这样的做法比较取巧，其<strong>副作用是更改了原型关系</strong>，这样也会干扰浏览器某些优化操作。</p><p>那么有没有更加&quot;体面&quot;的方式呢？</p><p>其实随着 ES6 class 的推出，我们完全可以直接使用 extends 关键字了：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DateConstructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Date</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.foo </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&#39;bar&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">getMyTime</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">let date </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DateConstructor</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DateConstructor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Date</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.foo </span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&#39;bar&#39;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">getMyTime</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">let date </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DateConstructor</span><span style="color:#24292E;">()</span></span></code></pre></div><p>上面的方法可以完美执行：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">date.</span><span style="color:#B392F0;">getMyTime</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#6A737D;">// 1558921640586</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">date.</span><span style="color:#6F42C1;">getMyTime</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#6A737D;">// 1558921640586</span></span></code></pre></div><p>直接在支持 ES6 class 的浏览器中使用完全没有问题，可是我们项目大部分都是使用 Babel 进行编译。按照 Babel 编译 class 的方法，运行其产出后，仍然会得到报错&quot;Uncaught TypeError: this is not a Date object.&quot;，因此我们可以得知：Babel 并没有对继承 Date 进行特殊处理，无法做到兼容。</p><h3 id="jquery-中的对象思想" tabindex="-1">jQuery 中的对象思想 <a class="header-anchor" href="#jquery-中的对象思想" aria-label="Permalink to &quot;jQuery 中的对象思想&quot;">​</a></h3><p>可能你会有这样的问题：&quot;所有的面试官都那么注重面向对象，可是我在工作中很少涉及啊？面向对象到底有什么用？&quot;</p><p>对于这个问题我想说，&quot;如果你没有开发大型复杂项目的经验，不具备封装抽象的思想，也许确实用不到面向对象，也很难解释为什么要有面向对象的设计和考察。&quot;接下来，我就从 jQuery 源码架构设计入手，分析一下基本的原型以及原型链知识如何在 jQuery 源码中发挥作用。</p><p>&quot;什么，这都哪一年了你还在说 jQuery？&quot;</p><p>其实优秀的思想是永远不过时的，研究清楚 jQuery 的设计思想，你仍然会会受益匪浅。</p><p>我们从一个问题开始：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> pNodes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;p&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 我们得到一个数组</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> divNodes</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 我们得到一个数组</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> pNodes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;p&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 我们得到一个数组</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> divNodes</span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;div&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6A737D;">// 我们得到一个数组</span></span></code></pre></div><p>但是我们又可以：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> pNodes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;p&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">pNodes.</span><span style="color:#B392F0;">addClass</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;className&#39;</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> pNodes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;p&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">pNodes.</span><span style="color:#6F42C1;">addClass</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;className&#39;</span><span style="color:#24292E;">)</span></span></code></pre></div><p>数组上可是没有 addClass 方法的吧？</p><p>这个问题先放一边。我们想一想<code>$</code>是什么？你的第一反应可能是一个函数，因此我们可以这样调用执行：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;p&#39;</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;p&#39;</span><span style="color:#24292E;">)</span></span></code></pre></div><p>但是你一定又见过这样的使用：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$.</span><span style="color:#B392F0;">ajax</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$.</span><span style="color:#6F42C1;">ajax</span><span style="color:#24292E;">()</span></span></code></pre></div><p>那么<code>$</code>又是一个对象，它有 Ajax 的静态方法。</p><p>类似：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 构造函数</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">$.ajax </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 构造函数</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">$.ajax </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>实际上，我们翻看 <a href="https://github.com/jquery/jquery/" target="_blank" rel="noreferrer">jQuery 源码架构</a>会发现（具体内容有删减和改动）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> jQuery </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">    var $</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    $ </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(selector, context) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> (selector, context) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> dom </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">            dom.__proto__ </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> $.fn</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> dom</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    $.fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        addClass</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">        },</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    $.ajax </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> $</span></span>
<span class="line"><span style="color:#E1E4E8;">})()</span></span>
<span class="line"><span style="color:#E1E4E8;">window.jQuery </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> jQuery</span></span>
<span class="line"><span style="color:#E1E4E8;">window.$ </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> undefined </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (window.$ </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> jQuery)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> jQuery </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">    var $</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">    $ </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(selector, context) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> (selector, context) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> dom </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#24292E;">            dom.__proto__ </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> $.fn</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> dom</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    $.fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        addClass</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">        },</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    $.ajax </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> $</span></span>
<span class="line"><span style="color:#24292E;">})()</span></span>
<span class="line"><span style="color:#24292E;">window.jQuery </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> jQuery</span></span>
<span class="line"><span style="color:#24292E;">window.$ </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> undefined </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (window.$ </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> jQuery)</span></span></code></pre></div><p>我们顺着源码分析，当调用<code>$(&#39;p&#39;)</code>时，最终返回的是 dom，而 dom.<strong>proto</strong> 指向了<code>$.fn</code>，<code>$.fn</code>是包含了多种方法的对象集合。因此返回的结果（dom）可以在其原型链上找到 addClass 这样的方法。同理，<code>$(&#39;span&#39;)</code>也不例外，任何实例都不例外。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;span&#39;</span><span style="color:#E1E4E8;">).__proto__ </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> $.fn</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;span&#39;</span><span style="color:#24292E;">).__proto__ </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> $.fn</span></span></code></pre></div><p>同时 Ajax 方法直接挂载在构造函数<code>$</code>上，它是一个<strong>静态属性</strong>方法。</p><p>请你仔细体会整个 jQuery 的架构，其实翻译成 ES class 就很好理解了（不完全对等）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ajax</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">selector</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">context</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.selector </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> selector</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.context </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> context</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">addClass</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//  ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ajax</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">selector</span><span style="color:#24292E;">, </span><span style="color:#E36209;">context</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.selector </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> selector</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.context </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> context</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">addClass</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//  ...</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这个应用虽然并不复杂，但还是很微妙地表现出来了面向对象的精妙设计。</p><h3 id="类继承和原型继承的区别" tabindex="-1">类继承和原型继承的区别 <a class="header-anchor" href="#类继承和原型继承的区别" aria-label="Permalink to &quot;类继承和原型继承的区别&quot;">​</a></h3><p>上面我们已经了解了 JavaScript 中的原型继承，那么它和传统面向对象语言的类继承有什么不同呢？这就涉及编程语言范畴了，传统的面向对象语言的类继承，会引发一些问题：</p><ul><li><p>紧耦合问题</p></li><li><p>脆弱基类问题</p></li><li><p>层级僵化问题</p></li><li><p>必然重复性问题</p></li><li><p>大猩猩---香蕉问题</p></li></ul><p>以上这些内容属于纯理论，下面我借用 Eric Elliott 的著名文章&quot;<a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noreferrer">Difference between class prototypal inheritance</a>&quot;，来展开说明类继承和原型继承的优劣。我们先看下图：</p>`,93),y=s("p",null,'通过上图，我们看出一些问题（单一继承、紧耦合以及层级分类问题），对于类 8，只想继承五边形的属性，却得到了继承链上其他并不需要的属性，比如五角星，正方形属性。这就是大猩猩/香蕉问题，"我只想要一个香蕉，但是你给我了整个森林"。',-1),i=s("p",null,"对于类 9，对比其父类，我只需要把五角星属性修改成四角星，但是五角星继承自基类 1，如果要去修改，那就会影响整个继承树（脆弱基类/层级僵化问题）；好吧，我不去修改，那就需要给类 9 新建一个基类（必然重复性问题）。",-1),d=s("p",null,"那么基于原型的继承如何解决上述问题呢？",-1),u=s("p",null,[a("采用原型继承，其实"),s("strong",null,"本质是对象组合"),a("，可以避免复杂纵深的层级关系。当类 1 需要四角星特性的时候，只需要组合新特性即可，不会影响到其他实例。")],-1),F=s("h3",{id:"总结",tabindex:"-1"},[a("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),h=s("p",null,'面向对象是一个永远说不完的话题，更是一个永远不会过时的话题，具备良好的面向对象架构能力，对于开发者来说至关重要。同时由于 JavaScript 面向对象的特殊性，它区别于其他语言，显得"与众不同"。我们在了解 JavaScript 原型、原型链知识的前提下，对比其他语言的思想，就变得非常重要和有意义了。',-1),g=s("p",null,"本讲内容总结如下：",-1),C=s("p",null,"从下一讲开始，我们将深入数据结构这个话题。数据结构是算法的基础，其本身也包含了算法的部分内容。如果你想要掌握算法，一定要先有一个巩固的数据结构基础。下一讲我们将用 JavaScript 实现几个常见的数据结构，帮助你在不同的场景中，找到最为适合的数据结构处理问题。",-1);function v(D,A,b,_,j,m){const n=o("Image");return e(),t("div",null,[E,p(n,{alt:"2021217-163948.png",src:"https://s0.lgstatic.com/i/image6/M00/04/83/CioPOWAs1oqAK7n6AAD_bt3FABw414.png"}),a(),y,i,d,p(n,{alt:"2021217-163944.gif",src:"https://s0.lgstatic.com/i/image6/M00/04/83/CioPOWAs1quAXIdzAC9wcK4g428951.gif"}),a(),u,F,h,g,p(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M00/03/02/Cgp9HWAeXoaAKvD-AAG_qfSV0Ls210.png"}),a(),C])}const f=l(r,[["render",v]]);export{B as __pageData,f as default};
