import{_ as n,j as l,o as i,g as r,k as e,h as a,s as t,Q as o}from"./chunks/framework.a0d18f64.js";const Z=JSON.parse('{"title":"第03讲：链表基础原理","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/097-数据结构精讲：从原理到实战文档/(517) 第 03 讲：链表基础原理.md","filePath":"posts/backEnd/097-数据结构精讲：从原理到实战文档/(517) 第 03 讲：链表基础原理.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/097-数据结构精讲：从原理到实战文档/(517) 第 03 讲：链表基础原理.md"},_=t("h1",{id:"第03讲-链表基础原理",tabindex:"-1"},[a("第03讲：链表基础原理 "),t("a",{class:"header-anchor",href:"#第03讲-链表基础原理","aria-label":'Permalink to "第03讲：链表基础原理"'},"​")],-1),h=t("p",null,'你好，我是你的数据结构课老师蔡元楠，欢迎进入第 03 课时的内容"链表基础原理"。',-1),d=t("p",null,"这一讲，我想和你一起研究数据结构中另外一个基本的知识点------链表（Linked List）。在讲解这个概念之前，先来复习一下数组的内存模型。",-1),p=t("h2",{id:"内存管理器",tabindex:"-1"},[a("内存管理器 "),t("a",{class:"header-anchor",href:"#内存管理器","aria-label":'Permalink to "内存管理器"'},"​")],-1),g=t("p",null,[a("当我们在使用高级语言创建一个数组的时候，实际上是将这个指令传达了给操作系统里面的"),t("strong",null,"内存管理器（Memory Manager）"),a("，内存管理器在收到指令后会在内存中分配一块相应大小的连续存储空间给这个数组。")],-1),A=t("p",null,"例如，当想创建一个大小为 5 的数组时，内存管理器有可能会从 0x80000000 这个地址开始分配一个连续的内存块给我们，我们便可以操作这个数组了，如下图所示。",-1),m=t("p",null,"而因为数组的大小在一开始是已经确定好的，所以当我们想要增加一个元素的时候，内存管理器无法满足这个需求，只能重新创建一个新的大小为 6 的数组。然后将原来大小为 5 的数组里的值一一复制到新的数组中去，再对新的元素进行赋值。我们假设内存管理器将新的数组的起始地址设在了 0x80000018 这里，那这个时候的内存如下图所示。",-1),u=t("p",null,"所以我们看到，当每次要增加一个元素的时候，底层的内存管理器必须为我们重新分配一次内存，我们自己还必须将原来数组上的元素重新复制一遍到新的数组上。那有没有办法当每次增加元素的时候能减少这种内存上的消耗呢？其实可以想到的是，当每次新增加一个元素的时候让内存管理器不要分配一段连续的内存空间就可以了。",-1),b=t("p",null,"假设这时候我们想要保存 3 个元素，但是我们想告诉系统的内存管理器不需要一次性分配 3 个连续的字节内存空间出来了，而是当我们声明它们的时候才分配一个相应的内存空间出来。假设内存管理器所分配出来的内存空间如下图所示：",-1),k=t("p",null,"这三个元素被分配在了非相邻的内存空间里。但从上图中我们可以知道这三个元素各自的地址，所以想要遍历它们的话，我们需要保存一些额外的信息，比如，下一个能遍历到的元素地址。这样的话，每一个元素就保存了两部分的内容，一部分是元素本身的值，另一部分是下一个元素的地址，而最后一个元素的下一个地址我们可以保存一个 0x0 的值来表示这个元素是最后一个了。这时候这些数据的内存就如下图所示：",-1),O=o("",5),f=t("p",null,"当我们要插入的一个值为 4 的新节点进这个链表的时候，系统的内存管理器会分配一个新的内存空间给我们，然后我们再将值为 3 这个尾节点的地址更新为它的地址，如下图所示：",-1),x=o("",13),I=t("h3",{id:"双向链表",tabindex:"-1"},[t("strong",null,"双向链表"),a(),t("a",{class:"header-anchor",href:"#双向链表","aria-label":'Permalink to "**双向链表**"'},"​")],-1),N=t("p",null,[a("单向链表有着只能朝着一个方向遍历的局限性，既然我们可以保存指向下一个节点地址的信息，也可以保存指向上一个节点地址的信息。这种在一个节点中保存了我们需要的数据也保存了连向下一个和上一个节点地址信息的链表，称之为"),t("strong",null,"双向链表（Doubly Linked List）"),a("。和链表中尾节点的下一个节点只保存空地址一样，链表中头节点的上一个节点地址也保存着空地址，抽象的数据图就如下图所示：")],-1),q=t("h3",{id:"循环链表",tabindex:"-1"},[t("strong",null,"循环链表"),a(),t("a",{class:"header-anchor",href:"#循环链表","aria-label":'Permalink to "**循环链表**"'},"​")],-1),C=t("p",null,[a("无论是单向链表或者是双向链表，当我们遍历至尾节点之后就无法再遍历下去了，如果将尾节点指向下一个节点地址的信息更新成指向头节点的话，这样整个链表就形成了一个环，这种链表称之为"),t("strong",null,"循环链表（Circular Linked List）"),a("。抽象的数据图就如下图所示：")],-1),P=t("br",null,null,-1),T=t("p",null,"今天我们一起学习了链表这个基本概念以及了解了链表的内存结构，同时我们也对比了数组与链表中空间利用率以及基本操作的时间复杂度，在最后也学习了链表的不同表达形式。在下一讲中，我将会和你一起看看环形链表这种数据结构是如何被大量应用在操作系统定时器和 Apache Kafka 中的。",-1),L=t("br",null,null,-1),S=t("p",null,'OK，这节课就讲到这里啦，下一课时我将分享"链表在 Apache Kafka 中的应用"，记得按时来听课哈。',-1);function V(M,E,K,y,W,D){const s=l("Image");return i(),r("div",null,[_,h,d,p,g,A,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/Cgq2xl4AIOWAZ6THAACHwZEOYVY362.png"}),a(),m,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/CgpOIF4AIOWAK6kkAAEC4H66pm0031.png"}),a(),u,b,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/Cgq2xl4AIOWAchXsAAEZpyKkQww678.png"}),a(),k,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/CgpOIF4AIOWAVKDyAAGU9LGmqZ8125.png"}),a(),O,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/CgpOIF4AIOWAVKDyAAGU9LGmqZ8125.png"}),a(),f,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/CgpOIF4AIOWAJPpAAAIi-N9WUvE182.png"}),a(),x,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/Cgq2xl4AIOaASKi0AAAtOVcJUJY844.png"}),a(),I,N,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/CgpOIF4AIOaASfugAAAv9abtHU0606.png"}),a(),q,C,P,e(s,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5A/31/Cgq2xl4AIOaAQyG7AAA7Z4BCAiw317.png"}),a(),T,L,S])}const v=n(c,[["render",V]]);export{Z as __pageData,v as default};
