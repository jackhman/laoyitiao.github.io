import{_ as p,j as o,o as e,g as c,k as a,h as l,Q as s}from"./chunks/framework.4e7d56ce.js";const q=JSON.parse('{"title":"Go 语言 RPC 过程调用实践 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Go 微服务实战 38 讲_文档/(3814) 16  Go RPC 如何实现服务间通信？.md","filePath":"posts/backEnd/Go 微服务实战 38 讲_文档/(3814) 16  Go RPC 如何实现服务间通信？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/Go 微服务实战 38 讲_文档/(3814) 16  Go RPC 如何实现服务间通信？.md"},t=s(`<p>在上一课时，我们讲解了 RPC 的相关概念和常见的 RPC 框架。其中， Go RPC 是指 Go 语言原生支持的 RPC 框架，它虽然简单但却十分经典，非常适合作为你后续深入了解 RPC 框架时的研究对象。</p><p>在本课时，我们将先通过一个字符串服务为案例简单讲解 Go RPC 是如何进行通信的，然后再具体剖析 Go RPC 的底层原理和实现，对以服务端注册服务、接收并处理客户端请求和客户端发起请求等步骤分别进行详细介绍，相信你学习后，一定会对 Go RPC 有更加全面的了解和认识。</p><h3 id="go-语言-rpc-过程调用实践" tabindex="-1">Go 语言 RPC 过程调用实践 <a class="header-anchor" href="#go-语言-rpc-过程调用实践" aria-label="Permalink to &quot;Go 语言 RPC 过程调用实践&quot;">​</a></h3><p>Go 语言原生的 RPC 过程调用实现起来非常简单。服务端只需实现对外提供的远程过程方法和结构体，然后将其注册到 RPC 服务中，客户端就可以通过其服务名称和方法名称进行 RPC 方法调用。</p><p>本课时我们就使用字符串操作的服务来展示如何使用 Go 语言原生的 RPC 来进行过程调用。</p><p>第一步，定义远程过程调用相关接口传入参数和返回参数的数据结构。如下代码所示，调用字符串操作的请求包括两个参数：字符串 A 和字符串 B。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">StringRequest</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  A </span><span style="color:#F97583;">string</span></span>
<span class="line"><span style="color:#E1E4E8;">  B </span><span style="color:#F97583;">string</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">StringRequest</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  A </span><span style="color:#D73A49;">string</span></span>
<span class="line"><span style="color:#24292E;">  B </span><span style="color:#D73A49;">string</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>第二步，定义一个服务对象。这个服务对象可以很简单，比如类型是 int 或者是 interface{}，重要的是它输出的方法。这里我们定义一个字符串服务类型的 interface，其名称为 Service，它有一个字符串拼接函数 Concat；然后定义一个名为 StringService 的结构体，实现 Service 接口，并给出 Concat 具体实现。代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Service</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// Concat a and b</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Concat</span><span style="color:#E1E4E8;">(req StringRequest, ret </span><span style="color:#F97583;">*</span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">error</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">StringService</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (s StringService) </span><span style="color:#B392F0;">Concat</span><span style="color:#E1E4E8;">(req StringRequest, ret </span><span style="color:#F97583;">*</span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">error</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// test for length overflow</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(req.A)</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(req.B) </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> StrMaxSize {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ret </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ErrMaxSize</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">ret </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> req.A </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> req.B</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Service</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// Concat a and b</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#005CC5;">Concat</span><span style="color:#24292E;">(req StringRequest, ret </span><span style="color:#D73A49;">*</span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">error</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">StringService</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (s StringService) </span><span style="color:#6F42C1;">Concat</span><span style="color:#24292E;">(req StringRequest, ret </span><span style="color:#D73A49;">*</span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">error</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// test for length overflow</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(req.A)</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(req.B) </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> StrMaxSize {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ret </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ErrMaxSize</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">ret </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> req.A </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> req.B</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>第三步，实现 RPC 服务器。这里我们生成了一个 StringSevice 结构体，并使用 rpc.Register 注册这个服务，然后通过 net.Listen 监听对应 socket 并对外提供服务。客户端可以访问服务 StringService 以及它的方法 Concat，代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;"> stringService </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">new</span><span style="color:#E1E4E8;">(service.StringService)</span></span>
<span class="line"><span style="color:#E1E4E8;"> rpc.</span><span style="color:#79B8FF;">Register</span><span style="color:#E1E4E8;">(stringService)</span></span>
<span class="line"><span style="color:#E1E4E8;"> rpc.</span><span style="color:#79B8FF;">HandleHTTP</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;"> l, e </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> net.</span><span style="color:#79B8FF;">Listen</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;tcp&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;127.0.0.1:1234&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> e </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   log.</span><span style="color:#79B8FF;">Fatal</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;listen error:&quot;</span><span style="color:#E1E4E8;">, e)</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;"> http.</span><span style="color:#79B8FF;">Serve</span><span style="color:#E1E4E8;">(l, </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;"> stringService </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">new</span><span style="color:#24292E;">(service.StringService)</span></span>
<span class="line"><span style="color:#24292E;"> rpc.</span><span style="color:#005CC5;">Register</span><span style="color:#24292E;">(stringService)</span></span>
<span class="line"><span style="color:#24292E;"> rpc.</span><span style="color:#005CC5;">HandleHTTP</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;"> l, e </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> net.</span><span style="color:#005CC5;">Listen</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;tcp&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;127.0.0.1:1234&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> e </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   log.</span><span style="color:#005CC5;">Fatal</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;listen error:&quot;</span><span style="color:#24292E;">, e)</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;"> http.</span><span style="color:#005CC5;">Serve</span><span style="color:#24292E;">(l, </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>第四步，建立 HTTP 客户端，然后通过 Call 方法调用远程 StringService 的对应方法，比如使用同步的方式，代码如下所示。这时客户端就可以进行远程调用了。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;"> client, err </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> rpc.</span><span style="color:#79B8FF;">DialHTTP</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;tcp&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;127.0.0.1:1234&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   log.</span><span style="color:#79B8FF;">Fatal</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;dialing:&quot;</span><span style="color:#E1E4E8;">, err)</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;"> stringReq </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">service.StringRequest{</span><span style="color:#9ECBFF;">&quot;A&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;B&quot;</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> reply </span><span style="color:#F97583;">string</span></span>
<span class="line"><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> client.</span><span style="color:#79B8FF;">Call</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;StringService.Concat&quot;</span><span style="color:#E1E4E8;">, stringReq, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">reply)</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   log.</span><span style="color:#79B8FF;">Fatal</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Concat error:&quot;</span><span style="color:#E1E4E8;">, err)</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 异步的调用方式 </span></span>
<span class="line"><span style="color:#E1E4E8;"> call </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> client.</span><span style="color:#79B8FF;">Call</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;StringService.Concat&quot;</span><span style="color:#E1E4E8;">, stringReq, </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">reply)</span></span>
<span class="line"><span style="color:#E1E4E8;"> _ </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">call.Done</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;"> client, err </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> rpc.</span><span style="color:#005CC5;">DialHTTP</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;tcp&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;127.0.0.1:1234&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   log.</span><span style="color:#005CC5;">Fatal</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;dialing:&quot;</span><span style="color:#24292E;">, err)</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;"> stringReq </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">service.StringRequest{</span><span style="color:#032F62;">&quot;A&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;B&quot;</span><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> reply </span><span style="color:#D73A49;">string</span></span>
<span class="line"><span style="color:#24292E;"> err </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> client.</span><span style="color:#005CC5;">Call</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;StringService.Concat&quot;</span><span style="color:#24292E;">, stringReq, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">reply)</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   log.</span><span style="color:#005CC5;">Fatal</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Concat error:&quot;</span><span style="color:#24292E;">, err)</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 异步的调用方式 </span></span>
<span class="line"><span style="color:#24292E;"> call </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> client.</span><span style="color:#005CC5;">Call</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;StringService.Concat&quot;</span><span style="color:#24292E;">, stringReq, </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">reply)</span></span>
<span class="line"><span style="color:#24292E;"> _ </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">call.Done</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过上述代码的编写就可以实现两个 Go 服务之间的 RPC 调用了。那 Go RPC 又是如何实现的呢？</p><h3 id="go-rpc-原理解析" tabindex="-1">Go RPC 原理解析 <a class="header-anchor" href="#go-rpc-原理解析" aria-label="Permalink to &quot;Go RPC 原理解析&quot;">​</a></h3><p>接下来我们将对 Go 语言的 RPC 原生实现进行源码分析，细致讲解其具体实现和原理。首先我们会对 RPC 的服务（Server）端代码进行分析，包括注册服务、反射处理和存根保存，然后讲解服务端处理 RPC 请求的流程，最后讲解客户（Client）端的 RPC 请求处理。</p><h4 id="_1-go-rpc-服务端原理" tabindex="-1">1. Go RPC 服务端原理 <a class="header-anchor" href="#_1-go-rpc-服务端原理" aria-label="Permalink to &quot;1. Go RPC 服务端原理&quot;">​</a></h4><p>服务端的 RPC 代码主要分为两个部分：①服务方法注册，包括调用注册接口，通过反射处理将方法取出，并存到 map 中；②处理网络调用，主要是监听端口、读取数据包、解码请求和调用反射处理后的方法，将返回值编码，返回给客户端。</p><p>在上面的示例代码中，我们使用 rpc.Register 对 StringService 进行了注册，Register 是进行 RPC 服务注册的入口方法，其参数 interface{} 类型的 rcvr 就是要注册的 RPC 服务类型，该注册过程的流程如下图所示。</p>`,19),E=s(`<p>服务端注册 RPC 服务示意图</p><p>Register 方法中通过反射获取接口类型和值，并通过 suitableMethods 函数判断注册的 RPC 是否符合规范，最后调用 serviceMap 的 LoadOrStore(sname, s) 方法将对应 RPC 存根存放于 map 中，供之后查找。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (server </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Server) </span><span style="color:#B392F0;">register</span><span style="color:#E1E4E8;">(rcvr </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{}, name </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">, useName </span><span style="color:#F97583;">bool</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">error</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果服务为空，默认注册一个 </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> server.serviceMap </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    server.serviceMap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">map</span><span style="color:#E1E4E8;">[</span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">]</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">service) </span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 获取注册服务的反射信息 </span></span>
<span class="line"><span style="color:#E1E4E8;">  s </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">new</span><span style="color:#E1E4E8;">(service) </span></span>
<span class="line"><span style="color:#E1E4E8;">  s.typ </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> reflect.</span><span style="color:#79B8FF;">TypeOf</span><span style="color:#E1E4E8;">(rcvr) </span></span>
<span class="line"><span style="color:#E1E4E8;">  s.rcvr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> reflect.</span><span style="color:#79B8FF;">ValueOf</span><span style="color:#E1E4E8;">(rcvr) </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 可以使用自定义名称 </span></span>
<span class="line"><span style="color:#E1E4E8;">  sname </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> reflect.</span><span style="color:#79B8FF;">Indirect</span><span style="color:#E1E4E8;">(s.rcvr).</span><span style="color:#79B8FF;">Type</span><span style="color:#E1E4E8;">().</span><span style="color:#79B8FF;">Name</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> useName { </span></span>
<span class="line"><span style="color:#E1E4E8;">    sname </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> name </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 方法必须是暴露的，既服务名首字符大写；不允许重复注册。代码有省略</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#79B8FF;">isExported</span><span style="color:#E1E4E8;">(sname) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">useName { </span></span>
<span class="line"><span style="color:#E1E4E8;">  }   </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> _, present </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> server.serviceMap[sname]; present { </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  s.name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> sname </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 开始注册 rpc struct 内部的方法存根 </span></span>
<span class="line"><span style="color:#E1E4E8;">  s.method </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">suitableMethods</span><span style="color:#E1E4E8;">(s.typ, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(s.method) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#6A737D;">// 如果struct内部一个方法也没，那么直接报错，打印详细的错误信息</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 保存在server的serviceMap中 </span></span>
<span class="line"><span style="color:#E1E4E8;">  server.serviceMap[s.name] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (server </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Server) </span><span style="color:#6F42C1;">register</span><span style="color:#24292E;">(rcvr </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{}, name </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">, useName </span><span style="color:#D73A49;">bool</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">error</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果服务为空，默认注册一个 </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> server.serviceMap </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    server.serviceMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">map</span><span style="color:#24292E;">[</span><span style="color:#D73A49;">string</span><span style="color:#24292E;">]</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">service) </span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 获取注册服务的反射信息 </span></span>
<span class="line"><span style="color:#24292E;">  s </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">new</span><span style="color:#24292E;">(service) </span></span>
<span class="line"><span style="color:#24292E;">  s.typ </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> reflect.</span><span style="color:#005CC5;">TypeOf</span><span style="color:#24292E;">(rcvr) </span></span>
<span class="line"><span style="color:#24292E;">  s.rcvr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> reflect.</span><span style="color:#005CC5;">ValueOf</span><span style="color:#24292E;">(rcvr) </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 可以使用自定义名称 </span></span>
<span class="line"><span style="color:#24292E;">  sname </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> reflect.</span><span style="color:#005CC5;">Indirect</span><span style="color:#24292E;">(s.rcvr).</span><span style="color:#005CC5;">Type</span><span style="color:#24292E;">().</span><span style="color:#005CC5;">Name</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> useName { </span></span>
<span class="line"><span style="color:#24292E;">    sname </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> name </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 方法必须是暴露的，既服务名首字符大写；不允许重复注册。代码有省略</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#005CC5;">isExported</span><span style="color:#24292E;">(sname) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">useName { </span></span>
<span class="line"><span style="color:#24292E;">  }   </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> _, present </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> server.serviceMap[sname]; present { </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  s.name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> sname </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 开始注册 rpc struct 内部的方法存根 </span></span>
<span class="line"><span style="color:#24292E;">  s.method </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">suitableMethods</span><span style="color:#24292E;">(s.typ, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(s.method) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#6A737D;">// 如果struct内部一个方法也没，那么直接报错，打印详细的错误信息</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 保存在server的serviceMap中 </span></span>
<span class="line"><span style="color:#24292E;">  server.serviceMap[s.name] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来，我们来看一下服务端处理 RPC 请求的实现。如下图就展示了服务端 RPC 程序处理请求的过程，它会一直循环处理接收到的客户端 RPC 请求，将其交由 ReadRequestHandler 处理，然后从之前 Register 方法保存的 map 中获取到要调用的对应方法；接着从请求中解码出对应的参数，使用反射调用其方法，获取到结果后将结果编码成响应消息返回给客户端。</p>`,4),y=s(`<p>RPC 服务端处理流程示意图</p><p>下面，我们来看一下服务端接收并处理 RPC 请求的具体代码实现。</p><p><strong>（1）接收请求</strong></p><p>Server 的 Accept 函数会无限循环地调用 net.Listener 的 Accept 函数来获取客户端建立连接的请求，获取到连接请求后，再使用协程来处理请求。代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (server </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Server) </span><span style="color:#B392F0;">Accept</span><span style="color:#E1E4E8;">(lis net.Listener) { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    conn, err </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> lis.</span><span style="color:#79B8FF;">Accept</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">      log.</span><span style="color:#79B8FF;">Fatal</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;rpc.Serve: accept:&quot;</span><span style="color:#E1E4E8;">, err.</span><span style="color:#79B8FF;">Error</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// accept连接以后，打开一个goroutine处理请求 </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> server.</span><span style="color:#79B8FF;">ServeConn</span><span style="color:#E1E4E8;">(conn) </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (server </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Server) </span><span style="color:#6F42C1;">Accept</span><span style="color:#24292E;">(lis net.Listener) { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    conn, err </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> lis.</span><span style="color:#005CC5;">Accept</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">      log.</span><span style="color:#005CC5;">Fatal</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;rpc.Serve: accept:&quot;</span><span style="color:#24292E;">, err.</span><span style="color:#005CC5;">Error</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// accept连接以后，打开一个goroutine处理请求 </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> server.</span><span style="color:#005CC5;">ServeConn</span><span style="color:#24292E;">(conn) </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>（2）读取并解析请求</strong></p><p>ServeConn 函数会从建立的连接中读取数据，然后创建一个 gobServerCodec，并将其交由 Server 的 ServeCodec 函数处理，如下所示：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (server </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Server) </span><span style="color:#B392F0;">ServeConn</span><span style="color:#E1E4E8;">(conn io.ReadWriteCloser) { </span></span>
<span class="line"><span style="color:#E1E4E8;">  buf </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> bufio.</span><span style="color:#79B8FF;">NewWriter</span><span style="color:#E1E4E8;">(conn) </span></span>
<span class="line"><span style="color:#E1E4E8;">  srv </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">gobServerCodec{ </span></span>
<span class="line"><span style="color:#E1E4E8;">    rwc:  conn, </span></span>
<span class="line"><span style="color:#E1E4E8;">    dec:  gob.</span><span style="color:#79B8FF;">NewDecoder</span><span style="color:#E1E4E8;">(conn), </span></span>
<span class="line"><span style="color:#E1E4E8;">    enc:  gob.</span><span style="color:#79B8FF;">NewEncoder</span><span style="color:#E1E4E8;">(buf), </span></span>
<span class="line"><span style="color:#E1E4E8;">    encBuf: buf, </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 根据指定的codec进行协议解析 </span></span>
<span class="line"><span style="color:#E1E4E8;">  server.</span><span style="color:#79B8FF;">ServeCodec</span><span style="color:#E1E4E8;">(srv) </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (server </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Server) </span><span style="color:#6F42C1;">ServeConn</span><span style="color:#24292E;">(conn io.ReadWriteCloser) { </span></span>
<span class="line"><span style="color:#24292E;">  buf </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> bufio.</span><span style="color:#005CC5;">NewWriter</span><span style="color:#24292E;">(conn) </span></span>
<span class="line"><span style="color:#24292E;">  srv </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">gobServerCodec{ </span></span>
<span class="line"><span style="color:#24292E;">    rwc:  conn, </span></span>
<span class="line"><span style="color:#24292E;">    dec:  gob.</span><span style="color:#005CC5;">NewDecoder</span><span style="color:#24292E;">(conn), </span></span>
<span class="line"><span style="color:#24292E;">    enc:  gob.</span><span style="color:#005CC5;">NewEncoder</span><span style="color:#24292E;">(buf), </span></span>
<span class="line"><span style="color:#24292E;">    encBuf: buf, </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 根据指定的codec进行协议解析 </span></span>
<span class="line"><span style="color:#24292E;">  server.</span><span style="color:#005CC5;">ServeCodec</span><span style="color:#24292E;">(srv) </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ServeCodec 函数会循环地调用 readRequest 函数，读取网络连接上的字节流，解析出请求，然后开启协程执行 Server 的 call 函数，处理对应的 RPC 调用。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (server </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Server) </span><span style="color:#B392F0;">ServeCodec</span><span style="color:#E1E4E8;">(codec ServerCodec) { </span></span>
<span class="line"><span style="color:#E1E4E8;">  sending </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">new</span><span style="color:#E1E4E8;">(sync.Mutex) </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 解析请求 </span></span>
<span class="line"><span style="color:#E1E4E8;">    service, mtype, req, argv, replyv, keepReading, err </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> server.readRequest (codec)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> debugLog </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> io.EOF { </span></span>
<span class="line"><span style="color:#E1E4E8;">        log.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;rpc:&quot;</span><span style="color:#E1E4E8;">, err) </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">keepReading { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// send a response if we actually managed to read a header. </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果当前请求错误了，我们应该返回信息，然后继续处理 </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> req </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">        server.</span><span style="color:#79B8FF;">sendResponse</span><span style="color:#E1E4E8;">(sending, req, invalidRequest, codec, err.</span><span style="color:#79B8FF;">Error</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">        server.</span><span style="color:#79B8FF;">freeRequest</span><span style="color:#E1E4E8;">(req) </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 因为需要继续处理后续请求，所以开一个gorutine处理rpc方法 </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> service.</span><span style="color:#79B8FF;">call</span><span style="color:#E1E4E8;">(server, sending, mtype, req, argv, replyv, codec) </span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果连接关闭了需要释放资源 </span></span>
<span class="line"><span style="color:#E1E4E8;">  codec.</span><span style="color:#79B8FF;">Close</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (server </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Server) </span><span style="color:#6F42C1;">ServeCodec</span><span style="color:#24292E;">(codec ServerCodec) { </span></span>
<span class="line"><span style="color:#24292E;">  sending </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">new</span><span style="color:#24292E;">(sync.Mutex) </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 解析请求 </span></span>
<span class="line"><span style="color:#24292E;">    service, mtype, req, argv, replyv, keepReading, err </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> server.readRequest (codec)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> debugLog </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> io.EOF { </span></span>
<span class="line"><span style="color:#24292E;">        log.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;rpc:&quot;</span><span style="color:#24292E;">, err) </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">keepReading { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// send a response if we actually managed to read a header. </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果当前请求错误了，我们应该返回信息，然后继续处理 </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> req </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">        server.</span><span style="color:#005CC5;">sendResponse</span><span style="color:#24292E;">(sending, req, invalidRequest, codec, err.</span><span style="color:#005CC5;">Error</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">        server.</span><span style="color:#005CC5;">freeRequest</span><span style="color:#24292E;">(req) </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 因为需要继续处理后续请求，所以开一个gorutine处理rpc方法 </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> service.</span><span style="color:#005CC5;">call</span><span style="color:#24292E;">(server, sending, mtype, req, argv, replyv, codec) </span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果连接关闭了需要释放资源 </span></span>
<span class="line"><span style="color:#24292E;">  codec.</span><span style="color:#005CC5;">Close</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>（3）执行远程方法并返回响应</strong></p><p>Server 的 call 函数就是通过 Func.Call 反射调用对应 RPC 过程的方法，它还会调用 send Response 将返回值发送给 RPC 客户端，代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">service) </span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(server </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Server, sending </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">sync.Mutex, mtype </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">methodType, req </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Request, argv, replyv reflect.Value, codec ServerCodec) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  function </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> mtype.method.Func </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里是真正调用rpc方法的地方 </span></span>
<span class="line"><span style="color:#E1E4E8;">  returnValues </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> function.</span><span style="color:#79B8FF;">Call</span><span style="color:#E1E4E8;">([]reflect.Value{s.rcvr, argv, replyv}) </span></span>
<span class="line"><span style="color:#E1E4E8;">  errInter </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> returnValues[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">].</span><span style="color:#79B8FF;">Interface</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">  errmsg </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 处理返回请求了 </span></span>
<span class="line"><span style="color:#E1E4E8;">  server.</span><span style="color:#79B8FF;">sendResponse</span><span style="color:#E1E4E8;">(sending, req, replyv.</span><span style="color:#79B8FF;">Interface</span><span style="color:#E1E4E8;">(), codec, errmsg) </span></span>
<span class="line"><span style="color:#E1E4E8;">  server.</span><span style="color:#79B8FF;">freeRequest</span><span style="color:#E1E4E8;">(req) </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">service) </span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(server </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Server, sending </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">sync.Mutex, mtype </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">methodType, req </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Request, argv, replyv reflect.Value, codec ServerCodec) {</span></span>
<span class="line"><span style="color:#24292E;">  function </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> mtype.method.Func </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里是真正调用rpc方法的地方 </span></span>
<span class="line"><span style="color:#24292E;">  returnValues </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> function.</span><span style="color:#005CC5;">Call</span><span style="color:#24292E;">([]reflect.Value{s.rcvr, argv, replyv}) </span></span>
<span class="line"><span style="color:#24292E;">  errInter </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> returnValues[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">].</span><span style="color:#005CC5;">Interface</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">  errmsg </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 处理返回请求了 </span></span>
<span class="line"><span style="color:#24292E;">  server.</span><span style="color:#005CC5;">sendResponse</span><span style="color:#24292E;">(sending, req, replyv.</span><span style="color:#005CC5;">Interface</span><span style="color:#24292E;">(), codec, errmsg) </span></span>
<span class="line"><span style="color:#24292E;">  server.</span><span style="color:#005CC5;">freeRequest</span><span style="color:#24292E;">(req) </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="_2-客户端发送-rpc-请求原理" tabindex="-1">2. 客户端发送 RPC 请求原理 <a class="header-anchor" href="#_2-客户端发送-rpc-请求原理" aria-label="Permalink to &quot;2. 客户端发送 RPC 请求原理&quot;">​</a></h4><p>无论是同步调用还是异步调用，每次 RPC 请求都会生成一个 Call 对象，并使用 seq 作为 key 保存在 map 中，服务端返回响应值时再根据响应值中的 seq 从 map 中取出 Call，进行相应处理。客户端发起 RPC 调用的过程大致如下图所示。</p>`,15),i=s(`<p>客户端发送和接收请求流程示意图</p><p>下面我们将依次讲解同步调用和异步调用、请求参数编码和接收服务器响应三个部分的具体实现。</p><p><strong>（1）同步调用和异步调用</strong></p><p>本课时的案例展示了 Go 原生 RPC 的客户端支持同步和异步两种调用，下面我们来介绍一下这两种调用的函数以及调用的数据结构。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (client </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Client) </span><span style="color:#B392F0;">Call</span><span style="color:#E1E4E8;">(serviceMethod </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">, args </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{}, reply </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{}) </span><span style="color:#F97583;">error</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> call </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">client.</span><span style="color:#79B8FF;">Go</span><span style="color:#E1E4E8;">(serviceMethod, args, reply, </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)).Done</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> call.Error</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (client </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Client) </span><span style="color:#6F42C1;">Call</span><span style="color:#24292E;">(serviceMethod </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">, args </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{}, reply </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{}) </span><span style="color:#D73A49;">error</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> call </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">client.</span><span style="color:#005CC5;">Go</span><span style="color:#24292E;">(serviceMethod, args, reply, </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)).Done</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> call.Error</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Call 方法直接调用了 Go 方法，而 Go 方法则是先创建并初始化了 Call 对象，记录下此次调用的方法、参数和返回值，并生成 DoneChannel；然后调用 Client 的 send 方法进行真正的请求发送处理，代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 异步调用实现</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (client </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Client) </span><span style="color:#B392F0;">Go</span><span style="color:#E1E4E8;">(serviceMethod </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">, args </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{}, reply </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{}, done </span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call) </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 初始化 Call </span></span>
<span class="line"><span style="color:#E1E4E8;"> call </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">new</span><span style="color:#E1E4E8;">(Call)</span></span>
<span class="line"><span style="color:#E1E4E8;"> call.ServiceMethod </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> serviceMethod</span></span>
<span class="line"><span style="color:#E1E4E8;"> call.Args </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> args</span></span>
<span class="line"><span style="color:#E1E4E8;"> call.Reply </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> reply</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> done </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   done </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call, </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// buffered.</span></span>
<span class="line"><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">cap</span><span style="color:#E1E4E8;">(done) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">     log.</span><span style="color:#79B8FF;">Panic</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;rpc: done channel is unbuffered&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;"> call.Done </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> done</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 调用 Client 的 send 方法</span></span>
<span class="line"><span style="color:#E1E4E8;"> client.</span><span style="color:#79B8FF;">send</span><span style="color:#E1E4E8;">(call)</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> call</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Call</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ServiceMethod </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 服务名及方法名 格式:服务.方法</span></span>
<span class="line"><span style="color:#E1E4E8;">  Args     </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{} </span><span style="color:#6A737D;">// 函数的请求参数 (*struct).</span></span>
<span class="line"><span style="color:#E1E4E8;">  Reply     </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;">{} </span><span style="color:#6A737D;">// 函数的响应参数 (*struct).</span></span>
<span class="line"><span style="color:#E1E4E8;">  Error     </span><span style="color:#F97583;">error</span><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 方法完成后 error的状态.</span></span>
<span class="line"><span style="color:#E1E4E8;">  Done     </span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 异步调用实现</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (client </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Client) </span><span style="color:#6F42C1;">Go</span><span style="color:#24292E;">(serviceMethod </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">, args </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{}, reply </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{}, done </span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call) </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 初始化 Call </span></span>
<span class="line"><span style="color:#24292E;"> call </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">new</span><span style="color:#24292E;">(Call)</span></span>
<span class="line"><span style="color:#24292E;"> call.ServiceMethod </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> serviceMethod</span></span>
<span class="line"><span style="color:#24292E;"> call.Args </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> args</span></span>
<span class="line"><span style="color:#24292E;"> call.Reply </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> reply</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> done </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   done </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call, </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// buffered.</span></span>
<span class="line"><span style="color:#24292E;"> } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">cap</span><span style="color:#24292E;">(done) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">     log.</span><span style="color:#005CC5;">Panic</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;rpc: done channel is unbuffered&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;"> call.Done </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> done</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 调用 Client 的 send 方法</span></span>
<span class="line"><span style="color:#24292E;"> client.</span><span style="color:#005CC5;">send</span><span style="color:#24292E;">(call)</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> call</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Call</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  ServiceMethod </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 服务名及方法名 格式:服务.方法</span></span>
<span class="line"><span style="color:#24292E;">  Args     </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{} </span><span style="color:#6A737D;">// 函数的请求参数 (*struct).</span></span>
<span class="line"><span style="color:#24292E;">  Reply     </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;">{} </span><span style="color:#6A737D;">// 函数的响应参数 (*struct).</span></span>
<span class="line"><span style="color:#24292E;">  Error     </span><span style="color:#D73A49;">error</span><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 方法完成后 error的状态.</span></span>
<span class="line"><span style="color:#24292E;">  Done     </span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>（2）请求参数编码</strong></p><p>Client 的 send 函数首先会判断客户端实例的状态，如果处于关闭状态，则直接返回结果；否则会生成唯一的 seq 值，将 Call 保存到客户端的哈希表 pending 中，然后调用客户端编码器的WriteRequest 来编码请求并发送，代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (client </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Client) </span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(call </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ....</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//生成seq,每次调用均生成唯一的seq,在服务端返回结果后会通过该值进行匹配</span></span>
<span class="line"><span style="color:#E1E4E8;">  seq </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> client.seq</span></span>
<span class="line"><span style="color:#E1E4E8;">  client.seq</span><span style="color:#F97583;">++</span></span>
<span class="line"><span style="color:#E1E4E8;">  client.pending[seq] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> call</span></span>
<span class="line"><span style="color:#E1E4E8;">  client.mutex.</span><span style="color:#79B8FF;">Unlock</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 请求并发送请求</span></span>
<span class="line"><span style="color:#E1E4E8;">  client.request.Seq </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> seq</span></span>
<span class="line"><span style="color:#E1E4E8;">  client.request.ServiceMethod </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> call.ServiceMethod</span></span>
<span class="line"><span style="color:#E1E4E8;">  err </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> client.codec.</span><span style="color:#79B8FF;">WriteRequest</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;">client.request, call.Args)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//发送请求错误时,将map中call对象删除.</span></span>
<span class="line"><span style="color:#E1E4E8;">    client.mutex.</span><span style="color:#79B8FF;">Lock</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    call </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> client.pending[seq]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">delete</span><span style="color:#E1E4E8;">(client.pending, seq)</span></span>
<span class="line"><span style="color:#E1E4E8;">    client.mutex.</span><span style="color:#79B8FF;">Unlock</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (client </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Client) </span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(call </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ....</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//生成seq,每次调用均生成唯一的seq,在服务端返回结果后会通过该值进行匹配</span></span>
<span class="line"><span style="color:#24292E;">  seq </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> client.seq</span></span>
<span class="line"><span style="color:#24292E;">  client.seq</span><span style="color:#D73A49;">++</span></span>
<span class="line"><span style="color:#24292E;">  client.pending[seq] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> call</span></span>
<span class="line"><span style="color:#24292E;">  client.mutex.</span><span style="color:#005CC5;">Unlock</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 请求并发送请求</span></span>
<span class="line"><span style="color:#24292E;">  client.request.Seq </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> seq</span></span>
<span class="line"><span style="color:#24292E;">  client.request.ServiceMethod </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> call.ServiceMethod</span></span>
<span class="line"><span style="color:#24292E;">  err </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> client.codec.</span><span style="color:#005CC5;">WriteRequest</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;">client.request, call.Args)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//发送请求错误时,将map中call对象删除.</span></span>
<span class="line"><span style="color:#24292E;">    client.mutex.</span><span style="color:#005CC5;">Lock</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    call </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> client.pending[seq]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">delete</span><span style="color:#24292E;">(client.pending, seq)</span></span>
<span class="line"><span style="color:#24292E;">    client.mutex.</span><span style="color:#005CC5;">Unlock</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>（3）接收返回值</strong></p><p>接下来我们来看一下客户端是如何接收并处理服务端返回值的。客户端的 input 函数接收服务端返回的响应值，它进行无限 for 循环，不断调用 codec 也就是 gobClientCodecd 的 ReadResponseHeader 函数，然后根据其返回数据中的 seq 来判断是否是本客户端发出请求的响应值。如果是，则获取对应的 Call 对象，并将其从 pending 哈希表中删除，继续调用 codec 的 ReadReponseBody 方法获取返回值 Reply 对象，并调用 Call 对象的 done 方法，代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (client </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Client) </span><span style="color:#B392F0;">input</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">error</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> response Response</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    response </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Response{}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//通过response中的 Seq获取call对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    seq </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> response.Seq</span></span>
<span class="line"><span style="color:#E1E4E8;">    client.mutex.</span><span style="color:#79B8FF;">Lock</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    call </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> client.pending[seq]</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">delete</span><span style="color:#E1E4E8;">(client.pending, seq)</span></span>
<span class="line"><span style="color:#E1E4E8;">    client.mutex.</span><span style="color:#79B8FF;">Unlock</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> call </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> response.Error </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">//上述两个case，一个处理call为nil，另外处理服务端返回的错误,直接将错误返回</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">//通过编码器,将Resonse的body部分解码成reply对象.</span></span>
<span class="line"><span style="color:#E1E4E8;">      err </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> client.codec.</span><span style="color:#79B8FF;">ReadResponseBody</span><span style="color:#E1E4E8;">(call.Reply)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">nil</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        call.Error </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> errors.</span><span style="color:#79B8FF;">New</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;reading body &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> err.</span><span style="color:#79B8FF;">Error</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      call.</span><span style="color:#79B8FF;">done</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (client </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Client) </span><span style="color:#6F42C1;">input</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">error</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> response Response</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    response </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Response{}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通过response中的 Seq获取call对象</span></span>
<span class="line"><span style="color:#24292E;">    seq </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> response.Seq</span></span>
<span class="line"><span style="color:#24292E;">    client.mutex.</span><span style="color:#005CC5;">Lock</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    call </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> client.pending[seq]</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">delete</span><span style="color:#24292E;">(client.pending, seq)</span></span>
<span class="line"><span style="color:#24292E;">    client.mutex.</span><span style="color:#005CC5;">Unlock</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> call </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> response.Error </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">//上述两个case，一个处理call为nil，另外处理服务端返回的错误,直接将错误返回</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">default</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">//通过编码器,将Resonse的body部分解码成reply对象.</span></span>
<span class="line"><span style="color:#24292E;">      err </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> client.codec.</span><span style="color:#005CC5;">ReadResponseBody</span><span style="color:#24292E;">(call.Reply)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">nil</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        call.Error </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> errors.</span><span style="color:#005CC5;">New</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;reading body &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> err.</span><span style="color:#005CC5;">Error</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      call.</span><span style="color:#005CC5;">done</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上述代码中，gobClientCodecd 的 ReadResponseHeader、ReadReponseBody 方法和上文中的 WriteRequest 类似，这里不做赘述。Call 对象的 done 方法则通过 Call 的 DoneChannel，将获得返回值的结果通知到调用层，代码如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> (call </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">Call) </span><span style="color:#B392F0;">done</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> call.Done </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> call:</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// ok</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> debugLog {</span></span>
<span class="line"><span style="color:#E1E4E8;">     log.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;rpc: discarding Call reply due to insufficient Done chan capacity&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> (call </span><span style="color:#D73A49;">*</span><span style="color:#24292E;">Call) </span><span style="color:#6F42C1;">done</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> call.Done </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> call:</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// ok</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">default</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> debugLog {</span></span>
<span class="line"><span style="color:#24292E;">     log.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;rpc: discarding Call reply due to insufficient Done chan capacity&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>客户端接收到 RPC 请求的响应后会进行其他业务逻辑操作，RPC 框架则会对进行 RPC 请求所需要的资源进行回收，下次进行 RPC 请求时则需要再次建立相应的结构体并获取对应的资源。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>Go 语言原生 RPC 算是个基础版本的 RPC 框架，代码精简，可扩展性高，但是只实现了 RPC 最基本的网络通信，而超时熔断、链接管理（保活与重连）、服务注册发现等功能还是欠缺的。因此还是达不到生产环境&quot;开箱即用&quot;的水准，不过 GitHub 就有一个基于 RPC 的功能增强版本------rpcx，支持了大部分主流 RPC 的特性。</p><p>虽然目前官方已经宣布不再添加新功能，并推荐使用 gRPC，但是作为 Go 标准库中的 RPC 框架，还是有很多地方值得我们借鉴和学习，比如注册服务时如何保存反射信息等。本课时我们从源码角度分析了 Go 语言原生 RPC 框架，希望能给你带来对 RPC 框架的整体认知。</p><p>如果 Go 官方团队准备为 Go RPC 添加新功能，那么你最希望添加哪一项目前尚未支持的功能呢？欢迎你在留言区分享你的想法。</p>`,20);function F(C,d,g,u,A,D){const n=o("Image");return e(),c("div",null,[t,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/44/E9/CgqCHl8_if-AUnxAAAAfdOrTNHw006.png"}),l(),E,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/44/EA/CgqCHl8_igqAG76TAABYy-4KsGk165.png"}),l(),y,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/44/EA/CgqCHl8_iiGAdkeMAABxSJbVfuw198.png"}),l(),i])}const h=p(r,[["render",F]]);export{q as __pageData,h as default};
