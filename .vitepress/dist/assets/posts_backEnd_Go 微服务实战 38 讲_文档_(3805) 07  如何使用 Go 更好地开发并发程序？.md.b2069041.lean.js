import{_ as o,j as e,o as t,g as c,k as a,h as l,Q as p,s}from"./chunks/framework.4e7d56ce.js";const B=JSON.parse('{"title":"07如何使用Go更好地开发并发程序？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Go 微服务实战 38 讲_文档/(3805) 07  如何使用 Go 更好地开发并发程序？.md","filePath":"posts/backEnd/Go 微服务实战 38 讲_文档/(3805) 07  如何使用 Go 更好地开发并发程序？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/Go 微服务实战 38 讲_文档/(3805) 07  如何使用 Go 更好地开发并发程序？.md"},E=p("",15),y=s("ul",null,[s("li",null,[s("p",null,"M，即 machine，相当于内核线程在 Go 进程中的映射，它与内核线程一一对应，代表真正执行计算的资源。在 M 的生命周期内，它只会与一个内核线程关联。")]),s("li",null,[s("p",null,"P，即 processor，代表 Go 代码片段执行所需的上下文环境。M 和 P 的结合能够为 G 提供有效的运行环境，它们之间的结合关系不是固定的。P 的最大数量决定了 Go 程序的并发规模，由 runtime.GOMAXPROCS 变量决定。")]),s("li",null,[s("p",null,"G，即 goroutine，是一种轻量级的用户线程，是对代码片段的封装，拥有执行时的栈、状态和代码片段等信息。")])],-1),i=s("p",null,"在实际执行过程中，M 和 P 共同为 G 提供有效的运行环境（如下图），多个可执行的 G 顺序挂载在 P 的可执行 G 队列下面，等待调度和执行。当 G 中存在一些 I/O 系统调用阻塞了 M 时，P 将会断开与 M 的联系，从调度器空闲 M 队列中获取一个 M 或者创建一个新的 M 组合执行， 保证 P 中可执行 G 队列中其他 G 得到执行，且由于程序中并行执行的 M 数量没变，保证了程序 CPU 的高利用率。",-1),F=p("",39);function u(C,d,h,g,D,A){const n=e("Image");return t(),c("div",null,[E,a(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/36/9A/Ciqc1F8X5ymAf7NvAAE_PDbjFtw120.png"}),l(),y,i,a(n,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/36/9A/Ciqc1F8X5zuAQrDLAAEpRhFm8n4546.png"}),l(),F])}const v=o(r,[["render",u]]);export{B as __pageData,v as default};
