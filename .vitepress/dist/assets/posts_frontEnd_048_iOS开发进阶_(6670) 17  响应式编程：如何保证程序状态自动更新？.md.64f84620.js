import{_ as l,D as e,o as c,g as t,J as o,h as s,m as n,Q as p}from"./chunks/framework.f67d7268.js";const B=JSON.parse('{"title":"17响应式编程：如何保证程序状态自动更新？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/048_iOS开发进阶/(6670) 17  响应式编程：如何保证程序状态自动更新？.md","filePath":"posts/frontEnd/048_iOS开发进阶/(6670) 17  响应式编程：如何保证程序状态自动更新？.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/048_iOS开发进阶/(6670) 17  响应式编程：如何保证程序状态自动更新？.md"},E=n("h1",{id:"_17响应式编程-如何保证程序状态自动更新",tabindex:"-1"},[s("17响应式编程：如何保证程序状态自动更新？ "),n("a",{class:"header-anchor",href:"#_17响应式编程-如何保证程序状态自动更新","aria-label":'Permalink to "17响应式编程：如何保证程序状态自动更新？"'},"​")],-1),y=n("p",null,"在 iOS 开发中，随着 App 功能不断增强，处理各种异步事件，保持程序状态实时更新，也变得越来越困难。",-1),i=p('<p>以 ViewController 来为例，我们需要处理许多异步事件，比如来自 Delegate 和 DataSource 的回调，来自 NotificationCenter 的通知消息，来自 View 的 Target-Action 事件，等等。</p><p>由于它们随机发生且可能来自不同的线程，本身就会比较复杂，再加上其他新事件的引入，代码处理的逻辑会呈指数式增长。那么，怎样才能从根本上解决这些问题呢？这一讲我们所介绍的<strong>响应式编程就可以解决</strong>。</p><h3 id="响应式编程与-rxswift" tabindex="-1">响应式编程与 RxSwift <a class="header-anchor" href="#响应式编程与-rxswift" aria-label="Permalink to &quot;响应式编程与 RxSwift&quot;">​</a></h3><p>所谓<strong>响应式编程</strong>,就是使用异步数据流（Asynchronous data streams）进行编程。在传统的指令式编程语言里，代码不仅要告诉程序做什么，还要告诉程序什么时候做。而在响应式编程里，我们只需要处理各个事件，程序会自动响应状态的更新。而且，这些事件可以单独封装，能有效提高代码复用性并简化错误处理的逻辑。</p><p>现在，响应式编程已慢慢成为主流的编程范式，比如 Android 平台的 Architecture Components 提供了支持响应式编程的 LiveData， SwiftUI 也配套了 Combine 框架。在 Moments App 中，我采用的也是响应式编程模式。</p><p>目前比较流行的响应式编程框架有 ReactiveKit、ReactiveSwift 和 Combine。在这里，我们推荐使用<strong>RxSwift</strong>。因为 RxSwift 遵循了 ReactiveX 的 API 标准，由于 ReactiveX 提供了多种语言的实现，学会 RxSwift 能有效把知识迁移到其他平台。还有 RxSwift 项目非常活跃，也比较成熟。更重要的是，RxSwift 提供的 RxCocoa 能帮助我们为 UIKit 扩展响应式编程的能力，而 Combine 所对应的 CombineCocoa 还不成熟。</p>',6),d=p(`<p>为了让 App 可以自动更新状态，我们在 Moments App 里面使用 RxSwift 把 MVVM 各层连接起来。</p><p>从上图可以看出，当用户打开朋友圈页面，App 会使用<strong>后台排程器</strong> 向 BFF 发起一个网络请求，Networking 模块把返回结果通过<strong>Observable 序列</strong> 发送给 Repository 模块。Repository 模块订阅接收后，把数据发送到<strong>Subject</strong> 里面，然后经过<strong>map 操作符</strong> 转换，原先的 Model 类型转换成了 ViewModel 类型。 ViewModel 模块订阅经过操作符转换的数据，发送给下一个<strong>Subject</strong> ，之后，这个数据被 ViewController 订阅，并通过<strong>主排程器</strong>更新了 UI。</p><p>整个过程中，Repository 模块、 ViewModel模块、ViewController 都是订阅者，分别接收来自前一层的信息。就这样，当 App 得到网络返回数据时，就能自动更新每一层的状态信息，也能实时更新 UI 显示。</p><p>这其中的 Observable 序列、订阅者、Subject 、操作符、排程器属于 RxSwift 中的关键概念，它们该如何理解，如何使用呢？接下来我就一一介绍下。</p><h3 id="异步数据序列-observable" tabindex="-1">异步数据序列 Observable <a class="header-anchor" href="#异步数据序列-observable" aria-label="Permalink to &quot;异步数据序列 Observable&quot;">​</a></h3><p>为了保证程序状态的同步，我们需要把各种异步事件都发送到异步数据流里，供响应式编程发挥作用。在 RxSwfit 中，异步数据流称为 Observable 序列，它表示可观察的异步数据序列，也可以理解为消息发送序列。</p><p>在实际应用中，我们通常使用 Observable 序列作为入口，把外部事件连接到响应式编程框架里面。比如在 Moments App ，我通过 Observable 把网络请求的结果连接进 MVVM 架构中。</p><p>那么怎样创建 Observable 序列呢？为方便我们生成 Observable 序列， RxSwfit 的<code>Observable</code>类型提供了如下几个工厂方法：</p><ul><li><p><code>just</code>方法，用于生成只有一个事件的 Observable 序列；</p></li><li><p><code>of</code>方法，生成包含多个事件的 Observable 序列；</p></li><li><p><code>from</code>方法，和<code>of</code>方法一样，<code>from</code>方法也能生成包含多个事件的 Observable 序列，但它只接受数组为入口参数。</p></li></ul><p>以下是相关代码示例。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observable1: Observable&lt;</span><span style="color:#79B8FF;">Int</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">just</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 序列包含 1</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observable2: Observable&lt;</span><span style="color:#79B8FF;">Int</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 序列包含 1, 2, 3 </span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observable3: Observable&lt;</span><span style="color:#79B8FF;">Int</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">from</span><span style="color:#E1E4E8;">([</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">]) </span><span style="color:#6A737D;">// 序列包含 1, 2, 3</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observable4: Observable&lt;[</span><span style="color:#79B8FF;">Int</span><span style="color:#E1E4E8;">]&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">([</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">]) </span><span style="color:#6A737D;">// 序列包含 [1, 2, 3]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> observable1: Observable&lt;</span><span style="color:#005CC5;">Int</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">just</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 序列包含 1</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> observable2: Observable&lt;</span><span style="color:#005CC5;">Int</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 序列包含 1, 2, 3 </span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> observable3: Observable&lt;</span><span style="color:#005CC5;">Int</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">from</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">]) </span><span style="color:#6A737D;">// 序列包含 1, 2, 3</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> observable4: Observable&lt;[</span><span style="color:#005CC5;">Int</span><span style="color:#24292E;">]&gt; </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">([</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">]) </span><span style="color:#6A737D;">// 序列包含 [1, 2, 3]</span></span></code></pre></div><p>当你需要生成只有一个事件的 Observable 序列时，可以使用<code>just</code>方法，如<code>observable1</code>只包含了<code>1</code>。</p><p>当需要生成包含多个事件的 Observable 序列时，可以使用<code>of</code>或者<code>from</code>方法。它们的区别是，<code>of</code>接收多个参数而<code>from</code>只接收一个数组。如上所示，我们分别使用了<code>of</code>和<code>from</code>方法来生成<code>observable2</code>和<code>observable3</code>，它们都包含了 1、2 和 3 三个事件。</p><p>这里需要注意，<code>of</code>方法也能接收数组作为参数的。与<code>from</code>方法会拆分数组为独立元素的做法不同，<code>of</code>方法只是把这个数组当成唯一的事件，例如<code>observable4</code>只包含值为<code>[1, 2, 3]</code>的一个事件。</p><p>在开发当中，Observable 序列不仅仅存放数值，比如 Moments App 的异步数据流就需要存放朋友圈信息来更新 UI，<code>Observable</code>也支持存放任意类型的数据。像在下面的例子中，<code>peopleObservable</code>就存放了两条类型为<code>Person</code>的数据，其中 Jake 的收入是 10 而 Ken 的收入是 20。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">struct</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Person</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> name: </span><span style="color:#79B8FF;">String</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> income: </span><span style="color:#79B8FF;">Int</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> peopleObservable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Person</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;Jake&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">income</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">), </span><span style="color:#79B8FF;">Person</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;">: </span><span style="color:#9ECBFF;">&quot;Ken&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">income</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">struct</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Person</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> name: </span><span style="color:#005CC5;">String</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> income: </span><span style="color:#005CC5;">Int</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> peopleObservable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Person</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">name</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;Jake&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">income</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">), </span><span style="color:#005CC5;">Person</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">name</span><span style="color:#24292E;">: </span><span style="color:#032F62;">&quot;Ken&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">income</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">))</span></span></code></pre></div><h3 id="订阅者" tabindex="-1">订阅者 <a class="header-anchor" href="#订阅者" aria-label="Permalink to &quot;订阅者&quot;">​</a></h3><p>在响应式编程模式里，订阅者是一个重要的角色。在 Moments App 里面，上层模块都担任订阅者角色，主要订阅下层模块的 Observable 序列。那订阅者怎样才能订阅和接收数据呢？</p><p>在 RxSwift 中，订阅者可以调用<code>Observable</code>对象的<code>subscribe</code>方法来订阅。如下所示。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> observable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">observable.subscribe { event </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(event)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> observable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">observable.subscribe { event </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(event)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>订阅者调用<code>subscribe</code>方法订阅<code>observable</code>，并接收事件，当程序执行时会打印以下信息：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">completed</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">completed</span></span></code></pre></div><p>你可能会问上面的<code>next</code>和<code>completed</code>是什么呢？其实它们都是事件，用来表示异步数据流上的一条信息。RxSwift 使用了<code>Event</code>枚举来表示事件，定义如下。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">enum</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Event</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Element</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/// Next element is produced.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Element</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/// Sequence terminated with an error.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">error</span><span style="color:#E1E4E8;">(Swift.</span><span style="color:#79B8FF;">Error</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">/// Sequence completed successfully.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> completed</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">enum</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Event</span><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">Element</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/// Next element is produced.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Element</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/// Sequence terminated with an error.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">error</span><span style="color:#24292E;">(Swift.</span><span style="color:#005CC5;">Error</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">/// Sequence completed successfully.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> completed</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li><p><code>.next(value: T)</code>：用于装载数据的事件。当 Observable 序列发送数据时，订阅者会收到<code>next</code>事件，我们可以从该事件中取出实际的数据。</p></li><li><p><code>.error(error: Error)</code>：用于装载错误事件。当发生错误的时候，Observable 序列会发出<code>error</code>事件并关闭该序列，订阅者一旦收到<code>error</code>事件后就无法接收其他事件了。</p></li><li><p><code>.completed</code>：用于正常关闭序列的事件。当 Observable 序列发出<code>completed</code>事件时就会关闭自己，订阅者在收到<code>completed</code>事件以后就无法收到任何其他事件了。</p></li></ul><p>怎么理解呢？下面我通过两个例子来介绍下。由于之前讲过的<code>of</code>和<code>from</code>等方法都不能发出<code>error</code>和<code>completed</code>事件 ，在这里我就使用了<code>create</code>方法来创建 Observable 序列。</p><p>首先我们看一下发送<code>error</code>事件的例子。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Observable</span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;">Int</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">.create { observer </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onError</span><span style="color:#E1E4E8;">(MyError.anError)</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Disposables.</span><span style="color:#79B8FF;">create</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}.subscribe { event </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(event)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Observable</span><span style="color:#D73A49;">&lt;</span><span style="color:#005CC5;">Int</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">.create { observer </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onError</span><span style="color:#24292E;">(MyError.anError)</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Disposables.</span><span style="color:#005CC5;">create</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">}.subscribe { event </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(event)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个例子中，我们调用了<code>create</code>方法来生成一个 Observable 序列，该 Observable 发出<code>next(1)</code>、<code>next(2)</code>、<code>error</code>和<code>next(3)</code>事件。由于<code>next(3)</code>事件在错误事件之后，因此订阅者无法接收到<code>next(3)</code>事件。程序执行时会打印下面的日志。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(anError)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(anError)</span></span></code></pre></div><p>接着我们看一下发送<code>completed</code>事件的例子。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Observable</span><span style="color:#F97583;">&lt;</span><span style="color:#79B8FF;">Int</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">.create { observer </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onCompleted</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    observer.</span><span style="color:#79B8FF;">onNext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Disposables.</span><span style="color:#79B8FF;">create</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}.subscribe { event </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(event)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Observable</span><span style="color:#D73A49;">&lt;</span><span style="color:#005CC5;">Int</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">.create { observer </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onCompleted</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    observer.</span><span style="color:#005CC5;">onNext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Disposables.</span><span style="color:#005CC5;">create</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">}.subscribe { event </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(event)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这里，我调用<code>create</code>方法来生成一个 Observable 序列，该 Observable 发出了<code>next(1)</code>、<code>completed</code>、<code>next(2)</code>和<code>next(3)</code>事件。因为<code>next(2)</code>和<code>next(3)</code>都在完成事件之后发出的，所以订阅者也无法接收它们，程序执行时会打印如下的日志。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">completed</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">completed</span></span></code></pre></div><p>在现实生活中，当我们订阅了报刊时可以自己选择退订，却无法让发行方停刊。在 RxSwift 里面也一样，订阅者无法强行让 Observable 序列发出<code>completed</code>事件来关闭数据流。那订阅者该怎样取消订阅呢？</p><p>如果你仔细观察就会发现，<code>subscribe</code>方法返回的类型为<code>Disposable</code>的对象，我们可以通过调用该对象的<code>dispose</code>方法来取消订阅。</p><p>为了更好地理解<code>dispose</code>方法的作用和触发时机，我通过<code>subscribe()</code>方法来打印出各个事件，如下所示。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> disposable </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">).subscribe { element </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(element) </span><span style="color:#6A737D;">// next event</span></span>
<span class="line"><span style="color:#E1E4E8;">} onError</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> { error </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(error)</span></span>
<span class="line"><span style="color:#E1E4E8;">} onCompleted</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Completed&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">} onDisposed</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Disposed&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">disposable.</span><span style="color:#79B8FF;">dispose</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> disposable </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">).subscribe { element </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(element) </span><span style="color:#6A737D;">// next event</span></span>
<span class="line"><span style="color:#24292E;">} onError</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> { error </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(error)</span></span>
<span class="line"><span style="color:#24292E;">} onCompleted</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Completed&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">} onDisposed</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Disposed&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">disposable.</span><span style="color:#005CC5;">dispose</span><span style="color:#24292E;">()</span></span></code></pre></div><p>我们在<code>onNext</code>闭包里面处理<code>next</code>事件；在<code>onError</code>闭包里处理<code>error</code>事件；在<code>onCompleted</code>闭包里处理<code>completed</code>事件；而在<code>onDisposed</code>闭包里处理退订事件。</p><p>在这里，我们调用<code>subscribe</code>方法后，它又马上调用了<code>dispose</code>方法，因此程序会在调用<code>onCompleted</code>之后立刻调用<code>onDisposed</code>。其执行效果如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">Completed</span></span>
<span class="line"><span style="color:#E1E4E8;">Disposed</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#005CC5;">2</span></span>
<span class="line"><span style="color:#24292E;">Completed</span></span>
<span class="line"><span style="color:#24292E;">Disposed</span></span></code></pre></div><p>假如我在订阅前调用<code>delay</code>方法，那么所有的事件都会延时两秒钟后才通知订阅者，代码如下：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> disposableWithDelay </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">).</span><span style="color:#79B8FF;">delay</span><span style="color:#E1E4E8;">(.</span><span style="color:#79B8FF;">seconds</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">), </span><span style="color:#79B8FF;">scheduler</span><span style="color:#E1E4E8;">: MainScheduler.instance).subscribe { element </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(element) </span><span style="color:#6A737D;">// next event</span></span>
<span class="line"><span style="color:#E1E4E8;">} onError</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> { error </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(error)</span></span>
<span class="line"><span style="color:#E1E4E8;">} onCompleted</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Completed&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">} onDisposed</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Disposed&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">disposableWithDelay.</span><span style="color:#79B8FF;">dispose</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> disposableWithDelay </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">).</span><span style="color:#005CC5;">delay</span><span style="color:#24292E;">(.</span><span style="color:#005CC5;">seconds</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">), </span><span style="color:#005CC5;">scheduler</span><span style="color:#24292E;">: MainScheduler.instance).subscribe { element </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(element) </span><span style="color:#6A737D;">// next event</span></span>
<span class="line"><span style="color:#24292E;">} onError</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> { error </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(error)</span></span>
<span class="line"><span style="color:#24292E;">} onCompleted</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Completed&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">} onDisposed</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Disposed&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">disposableWithDelay.</span><span style="color:#005CC5;">dispose</span><span style="color:#24292E;">()</span></span></code></pre></div><p>和上面没有延时的例子一样，我们在调用<code>subscribe</code>方法以后马上调用了<code>dispose</code>方法，由于 Observable 序列上所有事件还在延时等待中，程序会直接调用<code>onDisposed</code>并退订了<code>disposableWithDelay</code>序列，因此没办法再收到两秒钟后所发出的<code>next(1)</code>、<code>next(2)</code>和<code>completed</code>事件了。 其执行效果如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Disposed</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Disposed</span></span></code></pre></div><p>在很多时候，订阅后马上退订并不是我们想要的结果，我们希望订阅者一直监听事件直到自身消亡的时候才取消订阅。那有什么好的办法能做到这一点呢？</p><p>RxSwift 为我们提供了<code>DisposeBag</code>类型，方便存放和管理各个<code>Disposable</code>对象。其用法也非常简单，只需调用<code>Disposable</code>的<code>disposed(by:)</code>方法即可。代码如下：</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> disposeBag: DisposeBag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> .</span><span style="color:#F97583;">init</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">Observable.</span><span style="color:#79B8FF;">just</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">).subscribe { event </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(event)</span></span>
<span class="line"><span style="color:#E1E4E8;">}.</span><span style="color:#79B8FF;">disposed</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">by</span><span style="color:#E1E4E8;">: disposeBag)</span></span>
<span class="line"><span style="color:#E1E4E8;">Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">).subscribe { event </span><span style="color:#F97583;">in</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">print</span><span style="color:#E1E4E8;">(event)</span></span>
<span class="line"><span style="color:#E1E4E8;">}.</span><span style="color:#79B8FF;">disposed</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">by</span><span style="color:#E1E4E8;">: disposeBag)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> disposeBag: DisposeBag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> .</span><span style="color:#D73A49;">init</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">Observable.</span><span style="color:#005CC5;">just</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">).subscribe { event </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(event)</span></span>
<span class="line"><span style="color:#24292E;">}.</span><span style="color:#005CC5;">disposed</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">by</span><span style="color:#24292E;">: disposeBag)</span></span>
<span class="line"><span style="color:#24292E;">Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;b&quot;</span><span style="color:#24292E;">).subscribe { event </span><span style="color:#D73A49;">in</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">print</span><span style="color:#24292E;">(event)</span></span>
<span class="line"><span style="color:#24292E;">}.</span><span style="color:#005CC5;">disposed</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">by</span><span style="color:#24292E;">: disposeBag)</span></span></code></pre></div><p>代码中的<code>disposeBag</code>存放了两个<code>Disposable</code>对象。当订阅者调用其<code>deinit</code>方法时，同时也会调用<code>disposeBag</code>的<code>deinit</code>方法。在这时候，<code>disposeBag</code>会取出存放的所有<code>Disposable</code>对象，并调用它们的<code>dispose</code>方法来取消所有订阅。</p><p>在实际情况下，我建议只需为一个订阅者定义一个<code>disposeBag</code>即可。例如 Repository 模块同时订阅了 Networking 模块和 DataStore 模块，但它只定义了一个<code>disposeBag</code>来管理所有的订阅。</p><h4 id="事件中转-subject" tabindex="-1">事件中转 Subject <a class="header-anchor" href="#事件中转-subject" aria-label="Permalink to &quot;事件中转 Subject&quot;">​</a></h4><p>以上是如何生成、订阅和退订 Observable 序列。使用<code>Observable</code>的工厂方法所生成的对象都是&quot;只读&quot;，一旦生成，就无法添加新的事件。但很多时候，我们需要往 Observable 序列增加事件，比如要把用户点击 UI 的事件添加到 Observable 中，或者把底层模块的事件加工并添加到上层模块的序列中。</p><p>那么，有什么好办法能为异步数据序列添加新的事件呢？RxSwift 为我们提供的 Subject 及其<code>onNext</code>方法可以完成这项操作。</p><p>具体来说，<strong>Subject</strong>作为一种特殊的 Observable 序列，它既能接收又能发送，我们一般用它来做事件的中转。在 Moments App 的 MVVM 架构里面，我们就大量使用 Subject 发挥这一作用。 比如，当 Repository 模块从 Networking 模块中接收到事件时，会把该事件转送到自身的 Subject 来通知 ViewModel，从而保证 ViewModel 的状态同步。</p><p>那么，都有哪些常见的 Subject 呢？一般有 PublishSubject、BehaviorSubject 和 ReplaySubject。它们的区别在于订阅者能否收到订阅前的事件。</p><ul><li><p><strong>PublishSubject</strong>：如果你想订阅者只收到订阅后的事件，可以使用 PublishSubject。</p></li><li><p><strong>BehaviorSubject</strong>：如果你想订阅者在订阅时能收到订阅前最后一条事件，可以使用 BehaviorSubject。</p></li><li><p><strong>ReplaySubject</strong> ：如果你想订阅者在订阅 <s>的</s> 时 <s>候</s>能收到订阅前的 N 条事件，那么可以使用 ReplaySubject。</p></li></ul><p>在订阅以后，它们的行为都是一致的，当 Subject 发出<code>error</code>或者<code>completed</code>事件以后，订阅者将无法接收到新的事件。与之相关的详细的内容，我会在第 19 讲数据层架构里展开介绍。</p><h3 id="操作符" tabindex="-1">操作符 <a class="header-anchor" href="#操作符" aria-label="Permalink to &quot;操作符&quot;">​</a></h3><p>操作符（Operator）是 RxSwift 另外一个重要的概念，它能帮助订阅者在接收事件之前把 Observable 序列中的事件进行过滤、转换或者合并。</p><p>例如在 Moments App 里面，我们使用 map 操作符把 Model 数据转换成 ViewModel 类型来更新 UI。这里的 map 操作符就属于<strong>转换操作符</strong>，能帮助我们从一种数据类型转变成另外一种类型。除了map ，compactMap 和 flapMap 也属于转换操作符。</p><p>此外还有 filter 和 distinctUntilChanged等<strong>过滤操作符，<strong>我们可以使用过滤操作符把订阅者不关心的事件给过滤掉。还有</strong>合并操作符</strong>如 startWith，concat，merge，combineLatest 和 zip，可用于组装与合并多个 Observable 序列。</p><p>除了上面提到过的常用操作符，RxSwift 还为我们提供了 50 多个操作符，那怎样才能学会它们呢？我推荐你到 rxmarbles.com 或者到 App Store 下载 RxMarbles App，然后打开各个操作符并修改里面的参数，通过输入的事件和执行的结果来理解这些操作的作用。在之后的第 20 讲，我也会详细介绍一些常用的操作符的用法，到时候可以留意哦。</p><h3 id="排程器" tabindex="-1">排程器 <a class="header-anchor" href="#排程器" aria-label="Permalink to &quot;排程器&quot;">​</a></h3><p>保持程序状态自动更新之所以困难，很大原因在于处理并发的异步事件是一件烦琐的事情。为了方便处理来自不同线程的并发异步事件，RxSwift 为我们提供了排程器。它可以帮我们把繁重的任务调度到后台排程器完成，并能指定其运行方式（如是串行还是并发），也能保证 UI 的任务都在主线程上执行。</p><p>比如在 Moments App 里面，Networking 和 DataStore 模块都在后台排程器上执行，而 View 模块都在主排程器上执行。</p><p>根据串行或者并发来归类，我们可以把排程器分成两大类<strong>串行的排程器和并发的排程器</strong>。</p><p>串行的排程器包括 CurrentThreadScheduler、MainScheduler、SerialDispatchQueueScheduler。</p><p>其中，<strong>CurrentThreadScheduler</strong> 可以把任务安排在当前的线程上执行，这是默认的排程器。当我们不指定排程器的时候，RxSwift 都会使用 CurrentThreadScheduler 把任务放在当前线程里串行执行；<strong>MainScheduler</strong> 是把任务调度到主线程<code>MainThread</code>里并马上执行，它主要用于执行 UI 相关的任务；而<strong>SerialDispatchQueueScheduler</strong> 则会把任务放在<code>dispatch_queue_t</code>里面并串行执行。</p><p>并发的排程器包括 ConcurrentDispatchQueueScheduler 和 OperationQueueScheduler。</p><p>其中，<strong>ConcurrentDispatchQueueScheduler</strong> 把任务安排到<code>dispatch_queue_t</code>里面，且以并发的方式执行。该排程器一般用于执行后台任务，例如网络访问和数据缓存等等。在创建的时候，我们可以指定<code>DispatchQueue</code>的类型，例如使用<code>ConcurrentDispatchQueueScheduler(qos: .background)</code>来指定使用后台线程执行任务。</p><p><strong>OperationQueueScheduler</strong> 是把任务放在<code>NSOperationQueue</code>里面，以并发的方式执行。这个排程器一般用于执行繁重的后台任务，并通过设置<code>maxConcurrentOperationCount</code>来控制所执行并发任务的最大数量。它可以用于下载大文件。</p><p>那么，如何用排程器进行调度，处理好不同线程的并发异步事件呢？请看下面的代码实现。</p><div class="language-swift vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">swift</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Observable.</span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#79B8FF;">subscribeOn</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">ConcurrentDispatchQueueScheduler</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">qos</span><span style="color:#E1E4E8;">: .background))</span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#79B8FF;">dumpObservable</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#79B8FF;">map</span><span style="color:#E1E4E8;"> { </span><span style="color:#9ECBFF;">&quot;</span><span style="color:#9ECBFF;">\\(</span><span style="color:#79B8FF;">getThreadName</span><span style="color:#9ECBFF;">())</span><span style="color:#9ECBFF;">: </span><span style="color:#9ECBFF;">\\(</span><span style="color:#79B8FF;">$0</span><span style="color:#9ECBFF;">)</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#79B8FF;">observeOn</span><span style="color:#E1E4E8;">(MainScheduler.instance)</span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#79B8FF;">dumpObserver</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">    .</span><span style="color:#79B8FF;">disposed</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">by</span><span style="color:#E1E4E8;">: disposeBag)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Observable.</span><span style="color:#005CC5;">of</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#005CC5;">subscribeOn</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">ConcurrentDispatchQueueScheduler</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">qos</span><span style="color:#24292E;">: .background))</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#005CC5;">dumpObservable</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#005CC5;">map</span><span style="color:#24292E;"> { </span><span style="color:#032F62;">&quot;</span><span style="color:#032F62;">\\(</span><span style="color:#005CC5;">getThreadName</span><span style="color:#032F62;">())</span><span style="color:#032F62;">: </span><span style="color:#032F62;">\\(</span><span style="color:#005CC5;">$0</span><span style="color:#032F62;">)</span><span style="color:#032F62;">&quot;</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#005CC5;">observeOn</span><span style="color:#24292E;">(MainScheduler.instance)</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#005CC5;">dumpObserver</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">    .</span><span style="color:#005CC5;">disposed</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">by</span><span style="color:#24292E;">: disposeBag)</span></span></code></pre></div><p>首先我们传入<code>ConcurrentDispatchQueueScheduler(qos: .background)</code>来调用<code>subscribeOn</code>方法，把 Observable 序列发出事件的执行代码都调度到后台排程器去执行。然后通过传入<code>MainScheduler.instance</code>来调用<code>observeOn</code>，把订阅者执行的逻辑都调度主排程器去执行。</p><p>这是一种常用的模式，我们通常使用后台排程器来进行网络访问并处理返回数据，然后通过主排程器把数据呈现到 UI 中去。</p><p>由于后台线程不能保证执行的顺序，其执行效果如下，当你执行的时候可能会有点变化。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[Observable] </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observable] </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observer] Unnamed Thread</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> received on Main Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observable] </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observer] Unnamed Thread</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> received on Main Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observable] </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observer] Unnamed Thread</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> received on Main Thread</span></span>
<span class="line"><span style="color:#E1E4E8;">[Observer] Unnamed Thread</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> received on Main Thread</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[Observable] </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observable] </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observer] Unnamed Thread</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> received on Main Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observable] </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observer] Unnamed Thread</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> received on Main Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observable] </span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> emitted on Unnamed Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observer] Unnamed Thread</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> received on Main Thread</span></span>
<span class="line"><span style="color:#24292E;">[Observer] Unnamed Thread</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> received on Main Thread</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>在这一讲中我们介绍了 RxSwift 的五个关键概念：Observable 序列、订阅者、Subject、操作符以及排程器。我把本讲的代码都放在 Moments App 项目中的<strong>RxSwift Playground 文件</strong>里面，希望你能多练习，把五个概念融会贯通。</p><p>以下是我在实际工作中使用 RxSwift 的一些经验总结，希望能帮助到你。</p><ol><li><p>当我们拿到需求的时候，先把任务进行分解，找出哪个部分是事件<strong>发布者</strong> ，哪部分是事件<strong>订阅者</strong>，例如一个新功能页面，网络请求部分一般是事件发布者，当得到网络请求的返回结果时会发出事件，而 UI 部分一般为事件订阅者，通过订阅事件来保持 UI 的自动更新。</p></li><li><p>找到事件发布者以后，要分析事件发布的频率与间隔。如果只是发布一次，可以使用<strong>Obervable</strong> ；如果需要多次发布，可以使用<strong>Subject</strong>；如果需要缓存之前多个事件，可以使用 ReplaySubject。</p></li><li><p>当我们有了事件发布者和订阅者以后，接着可以分析发送和订阅事件的类型差异，选择合适的<strong>操作符</strong>来进行转换。我们可以先使用本讲中提到的常用操作符，如果它们还不能解决你的问题，可以查看 RxMarbles 来寻找合适的操作符。</p></li><li><p>最后，我们可以根据事件发布者和订阅者所执行的任务性质，通过<strong>排程器</strong>进行调度。例如把网络请求和数据缓存任务都安排在后台排程器，而 UI 更新任务放在主排程器。</p></li></ol><p>我在后面几讲中会详细介绍如何把 RxSwift 应用到在 MVVM 架构来保证程序状态信息的自动更新。希望能帮助你把今天所学知识灵活应用到真实场景中。</p><p><strong>思考题</strong></p><blockquote><p>据我所知，很多 iOS 开发者都想学习响应式编程和 RxSwift，但也不少人最终放弃了，如何你也曾经学习过并放弃了，请分享一下你的经验，哪一部分使你放弃学习和使用 RxSwift 呢？</p></blockquote><p>可以把你的想法写得留言区哦，下一讲我将介绍如何设计网络访问与 JSON 数据解析。</p><p><strong>源码地址：</strong></p><blockquote><p>RxSwift Playground 文件地址：<a href="https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift" target="_blank" rel="noreferrer">https://github.com/lagoueduCol/iOS-linyongjian/blob/main/Playgrounds/RxSwiftPlayground.playground/Contents.swift</a></p></blockquote>`,87);function b(F,C,u,v,g,h){const a=e("Image");return c(),t("div",null,[E,y,o(a,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image6/M01/39/F5/Cgp9HWB9VNqAdUpJAAelf-Mqcao388.png"}),s(),i,o(a,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image6/M01/39/F5/Cgp9HWB9VOOAEzp4AAKF1WzKJBs733.png"}),s(),d])}const D=l(r,[["render",b]]);export{B as __pageData,D as default};
