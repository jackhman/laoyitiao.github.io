import{_ as o,j as e,o as t,g as r,k as l,h as a,s,Q as p}from"./chunks/framework.4e7d56ce.js";const T=JSON.parse('{"title":"16如何从架构师角度回答系统容错、降级等高可用问题？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/架构设计面试精讲_文档/(6066) 16  如何从架构师角度回答系统容错、降级等高可用问题？.md","filePath":"posts/backEnd/架构设计面试精讲_文档/(6066) 16  如何从架构师角度回答系统容错、降级等高可用问题？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/架构设计面试精讲_文档/(6066) 16  如何从架构师角度回答系统容错、降级等高可用问题？.md"},i=s("h1",{id:"_16如何从架构师角度回答系统容错、降级等高可用问题",tabindex:"-1"},[a("16如何从架构师角度回答系统容错、降级等高可用问题？ "),s("a",{class:"header-anchor",href:"#_16如何从架构师角度回答系统容错、降级等高可用问题","aria-label":'Permalink to "16如何从架构师角度回答系统容错、降级等高可用问题？"'},"​")],-1),E=s("p",null,'上一讲，我带你学习了"评估系统高可用的指标"以及"如何监控系统高可用"今天这一讲，我们继续学习保证系统高可用的有效手段，比如系统容错、降级等，以及在面试时的重要考察点。',-1),y=s("p",null,"系统容错、降级等手段你肯定不陌生，很多文章都反复重申过，所以我的重点不再是普及相关理论知识，而是带你深入面试中对架构高可用问题的考察，带你避免面试中的易错点。",-1),u=s("h3",{id:"案例背景",tabindex:"-1"},[a("案例背景 "),s("a",{class:"header-anchor",href:"#案例背景","aria-label":'Permalink to "案例背景"'},"​")],-1),d=s("p",null,"先来看这样一道面试题：",-1),_=p('<p>商品的一次查询</p><blockquote><p>某电商平台中有商品系统、促销系统、积分系统。商品的一次查询操作是由网关系统先调用商品系统查询商品列表，然后根据返回的商品列表信息，再查询促销和积分系统，匹配商品信息的促销活动和积分奖励，最终返回给客户端展示给用户。</p><p>大部分互联网公司，会有专门的研发团队分别负责这三个系统（比如 A 团队负责商品系统、 B 团队负责促销系统）。这会带来一个问题：出现流量高峰期时，虽然作为服务请求入口的商品系统很容易扩容，但对于商品系统依赖的其他服务，就不会有实时性的响应。</p><p>那么促销或积分系统就可能因为无法承担大流量，请求处理缓慢，从而让执行商品查询操作的服务线程阻塞，不能释放，直到所有线程资源被占满，无法处理后续的请求。</p></blockquote><p>对于这种问题，你该如何处理呢？</p><h3 id="案例分析" tabindex="-1">案例分析 <a class="header-anchor" href="#案例分析" aria-label="Permalink to &quot;案例分析&quot;">​</a></h3><p>这道面试题就涉及了高可用架构的设计，我们再来分析一下商品的调用链条。在电商平台的商品系统中，一次系统查询的流程经历了三次调用，从网关系统开始，然后依次调用商品系统、促销系统、积分系统的三个服务，如果此时积分系统的响应时间变长，那么整条请求的响应时间也会因此变长，整体服务甚至会发生宕机。<strong>这就是服务雪崩现象：即局部故障最终导致了全局故障。</strong></p><p>在分布式环境下，系统某一个服务或者组件响应缓慢，从而拖垮整个系统的情况随处可见。那你要怎么避免呢？这就涉及我们在 15 讲中的内容了。在 15 讲中我提到了，对于系统可用性，你要通过三个方面来解决：分别是&quot;评估&quot;&quot;检测&quot;和&quot;保证&quot;，具体如下。</p><ol><li><p>用科学的方法评估<strong>系统的可用性指标；</strong></p></li><li><p>通过实时监控预警<strong>检测系统的可用性</strong>；</p></li><li><p>通过系统架构设计<strong>保证系统的可用性。</strong></p></li></ol><p>解决的思路是：在分布式系统中，当检测到某一个系统或服务响应时长出现异常时，要想办法停止调用该服务，让服务的调用快速返回失败，从而释放此次请求持有的资源。<strong>这就是架构设计中经常提到的降级和熔断机制。</strong></p><p>对应到面试中，面试官一般会通过如下两个问题考察候选者：</p><ul><li><p>熔断和降级是怎么做的（考察你对原理性知识的掌握）？</p></li><li><p>你在项目中如何实现熔断降级（考察你的实战能力）？</p></li></ul><p>你先要了解熔断和降级的原理，再结合实践设计实现它们。</p><h3 id="案例解答" tabindex="-1">案例解答 <a class="header-anchor" href="#案例解答" aria-label="Permalink to &quot;案例解答&quot;">​</a></h3><h4 id="熔断设计的原理" tabindex="-1">熔断设计的原理 <a class="header-anchor" href="#熔断设计的原理" aria-label="Permalink to &quot;熔断设计的原理&quot;">​</a></h4><p>形象一点儿说：熔断机制参考了电路中保险丝的保护原理，当电路出现短路、过载时，保险丝就会自动熔断，保证整体电路的安全。</p><p>而在微服务架构中，服务的熔断机制是指：在服务 A 调用服务 B 时，如果 B 返回错误或超时的次数超过一定阈值，服务 A 的后续请求将不再调用服务 B。<strong>这种设计方式就是断路器模式。</strong></p><p>在这种模式下，服务调用方为每一个调用的服务维护一个有限状态机，在这个状态机中存在<strong>关闭</strong> 、<strong>半打开</strong> 和<strong>打开三种状态。</strong></p><ul><li><p>关闭：正常调用远程服务。</p></li><li><p>半打开：尝试调用远程服务。</p></li><li><p>打开：直接返回错误，不调用远程服务。</p></li></ul><p>这三种状态之间切换的过程如下。</p><ul><li><p><strong>&quot;关闭&quot;转换&quot;打开&quot;</strong>：当服务调用失败的次数累积到一定的阈值时，服务熔断状态，将从关闭态切换到打开态。</p></li><li><p><strong>&quot;打开&quot;转换&quot;半打开&quot;</strong>：当熔断处于打开状态时，我们会启动一个超时计时器，当计时器超时后，状态切换到半打开态。</p></li><li><p><strong>&quot;半打开&quot;转换&quot;关闭&quot;</strong>：在熔断处于半打开状态时，请求可以达到后端服务，如果累计一定的成功次数后，状态切换到关闭态。</p></li></ul>',19),g=s("p",null,"熔断状态变更示意图",-1),h=s("p",null,"在工作中，研发工程师经常会通过 Netflix 的开源项目 Hystrix 来实现熔断的功能，并不会探究其中的原理，我在 07 讲中就说过：",-1),A=s("blockquote",null,[s("p",null,'虽然在实际工作中不推荐重复"造轮子"，但在面试中要证明自己具备"造轮子"的能力，因为要评价一个程序员是否对技术栈有全面的认识，考察其"造轮子"的能力是一个不错的切入点。')],-1),q=s("p",null,"所以很多时候，面试官也会考察你在不通过开源组件的前提下，怎么实现断路器的功能。",-1),b=s("h3",{id:"如何设计实现一个断路器",tabindex:"-1"},[a("如何设计实现一个断路器 "),s("a",{class:"header-anchor",href:"#如何设计实现一个断路器","aria-label":'Permalink to "如何设计实现一个断路器"'},"​")],-1),k=p(`<p>断路器的流程图</p><ul><li><strong>&quot;关闭&quot;转&quot;打开&quot;：</strong> 当请求到来，首先判断是否在熔断中，如果没有熔断，则正常调用系统服务，此时统计系统的调用状态，如果失败次数超过阈值，则断路器&quot;打开&quot;。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 如果是关闭状态</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(breaker.</span><span style="color:#B392F0;">isClose</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 失败次数超过阈值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(failCount.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> FAILS_THRESHOLD) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 设置为打开状态</span></span>
<span class="line"><span style="color:#E1E4E8;">        breaker.</span><span style="color:#B392F0;">setOpen</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 如果是关闭状态</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;">(breaker.</span><span style="color:#6F42C1;">isClose</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 失败次数超过阈值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(failCount.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> FAILS_THRESHOLD) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 设置为打开状态</span></span>
<span class="line"><span style="color:#24292E;">        breaker.</span><span style="color:#6F42C1;">setOpen</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li><strong>&quot;打开&quot;转&quot;半打开&quot;：</strong> 如果已经熔断，就初始化一个定时器，定期检测服务状态的可用性，如果服务达到了熔断的倒计时，则设置当前熔断器为&quot;半打开&quot;状态。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 初始化定时器定期检测服务是否可用</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Timer</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Service-Recover&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">scheduleAtFixedRate</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TimerTask</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (breaker.</span><span style="color:#B392F0;">isOpen</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 设置为半打开态</span></span>
<span class="line"><span style="color:#E1E4E8;">            breaker.</span><span style="color:#B392F0;">setHalfOpen</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, recoverInterval);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 初始化定时器定期检测服务是否可用</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Timer</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Service-Recover&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">scheduleAtFixedRate</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TimerTask</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (breaker.</span><span style="color:#6F42C1;">isOpen</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 设置为半打开态</span></span>
<span class="line"><span style="color:#24292E;">            breaker.</span><span style="color:#6F42C1;">setHalfOpen</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, recoverInterval);</span></span></code></pre></div><ul><li><strong>&quot;半打开&quot;转&quot;关闭&quot;：</strong> 如果服务状态是半打开，则判断成功次数是否超过阈值，超过则设置断路器的状态为&quot;关闭&quot;。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 如果断路器是半打开状态</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(breaker.</span><span style="color:#B392F0;">isHalfOpen</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判断成功次数是否超过阈值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(successCount.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> SUCCESS_THRESHOLD) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 设置断路器为关闭状态</span></span>
<span class="line"><span style="color:#E1E4E8;">        breaker.</span><span style="color:#B392F0;">setClose</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 如果断路器是半打开状态</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;">(breaker.</span><span style="color:#6F42C1;">isHalfOpen</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判断成功次数是否超过阈值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(successCount.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> SUCCESS_THRESHOLD) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 设置断路器为关闭状态</span></span>
<span class="line"><span style="color:#24292E;">        breaker.</span><span style="color:#6F42C1;">setClose</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这样，当某一个服务节点出现问题，服务调用者的熔断器就会实时监测到，并且不再请求有问题的服务节点，避免单个节点的故障导致整体系统的雪崩。</p><p>说完了熔断设计的原理和实现，我们再来看看降级设计的原理。</p><h4 id="降级设计的原理" tabindex="-1">降级设计的原理 <a class="header-anchor" href="#降级设计的原理" aria-label="Permalink to &quot;降级设计的原理&quot;">​</a></h4><p>降级设计本质上是站在系统整体可用性的角度上考虑问题：当资源和访问量出现矛盾时，在有限的资源下，放弃部分非核心功能或者服务，保证整体的可用性。这是一种有损的系统容错方式。</p><p>这样看来，熔断也是降级的一种手段（除此之外还有限流、兜底服务等）。</p><p>降级的实现手段是：在请求流量突增的情况下，放弃一些非核心流程或非关键业务，释放系统资源，让核心业务正常运行。比如 618 零点大促，电商平台一般会暂时关闭评论、退款功能。</p><p>那么问题来了，当你被问到&quot;怎么做降级设计？&quot;时，要怎么回答呢？</p><h4 id="如何设计一个降级机制" tabindex="-1">如何设计一个降级机制 <a class="header-anchor" href="#如何设计一个降级机制" aria-label="Permalink to &quot;如何设计一个降级机制&quot;">​</a></h4><p>从架构设计的角度出发，<strong>降级设计就是在做取舍，<strong>你要从</strong>服务降级</strong> 和<strong>功能降级</strong>两方面来考虑。</p><p>在实现上，服务降级可以分为读操作降级和写操作降级。</p><ul><li><p><strong>读操作降级：</strong> 做数据兜底服务，比如将兜底数据提前存储在缓存中，当系统触发降级时，读操作直接降级到缓存，从缓存中读取兜底数据，如果此时缓存中也不存在查询数据，则返回默认值，不在请求数据库。</p></li><li><p><strong>写操作降级：</strong> 同样的，将之前直接同步调用写数据库的操作，降级为先写缓存，然后再异步写入数据库。</p></li></ul><p>我们提炼一下这两种情况的设计原则。</p><ul><li><p>读操作降级的设计原则，就是取舍非核心服务。</p></li><li><p>写操作降级的设计原则，就是取舍系统一致性：实现方式是把强一致性转换成最终一致性。比如，两个系统服务通过 RPC 来交互，在触发降级时，将同步 RPC 服务调用降级到异步 MQ 消息队列中，然后再由消费服务异步处理。</p></li></ul><p><strong>而功能降级</strong>就是在做产品功能上的取舍，既然在做服务降级时，已经取舍掉了非核心服务，那么同样的产品功能层面也要相应的进行简化。在实现方式上，可以通过降级开关控制功能的可用或不可用。</p><p>另外，在设计降级时，离不开降级开关的配置，一般是通过参数化配置的方式存储在配置中心（如 Zookeeper），在高并发场景下，手动或自动开启开关，实现系统降级。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲我带你了解了雪崩产生的原因，服务熔断的实现方式以及服务降级的策略，今天你需要了解的重点是：</p><ul><li><p>服务熔断其实是一个有限状态机，实现的关键是三种状态之间的转换过程。</p></li><li><p>降级就是在做取舍（取舍服务、取舍功能），本质上是为了解决资源不足和访问量过大的问题。实现上可以降低系统一致性、裁剪非核心服务，以及简化产品功能。</p></li></ul><p>总之，服务的熔断和降级是互联网保证系统稳定性和可用性的重要手段，在你的架构设计中，如果涉及系统与第三方服务调用的情况下，都需要考虑增加服务熔断和降级方案。当然，高可用的设计方案不仅仅只有熔断和降级，还有如服务冗余、负载均衡、故障隔离、服务限流等设计方式。</p><p>总而言之，既然系统出故障是不可避免的，那做架构设计时就要把故障当作不可或缺的一环来处理，因此在分布式系统设计的和开发的过程中，要通过各种架构手段来提高系统可用性。</p><p>本节课的思考题是：结合你项目中的实际工作经历，说一说你在项目中都制定了哪些降级的策略？我们下一讲见。</p>`,28);function F(C,m,v,f,D,B){const n=e("Image");return t(),r("div",null,[i,E,y,u,d,l(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image6/M00/07/87/Cgp9HWAzkoCANywAAAAX6qOl804638.png"}),a(),_,l(n,{alt:"image (8).png",src:"https://s0.lgstatic.com/i/image6/M00/07/84/CioPOWAzkrSAfZ7ZAAAzMHsPttE231.png"}),a(),g,h,A,q,b,l(n,{alt:"image (9).png",src:"https://s0.lgstatic.com/i/image6/M00/07/87/Cgp9HWAzkqOAfaG_AABo0kM-2s4680.png"}),a(),k])}const P=o(c,[["render",F]]);export{T as __pageData,P as default};
