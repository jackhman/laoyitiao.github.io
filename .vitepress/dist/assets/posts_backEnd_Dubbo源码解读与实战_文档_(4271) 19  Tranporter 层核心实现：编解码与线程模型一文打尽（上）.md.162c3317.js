import{_ as o,j as e,o as t,g as r,k as l,h as n,s,Q as p}from"./chunks/framework.4e7d56ce.js";const w=JSON.parse('{"title":"AbstractPeer 抽象类 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4271) 19  Tranporter 层核心实现：编解码与线程模型一文打尽（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4271) 19  Tranporter 层核心实现：编解码与线程模型一文打尽（上）.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4271) 19  Tranporter 层核心实现：编解码与线程模型一文打尽（上）.md"},E=s("p",null,[n("在"),s("a",{href:"https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4269",target:"_blank",rel:"noreferrer"},"第 17 课时"),n("中，我们详细介绍了 dubbo-remoting-api 模块中 Transporter 相关的核心抽象接口，本课时将继续介绍 dubbo-remoting-api 模块的其他内容。这里我们依旧从 Transporter 层的 RemotingServer、Client、Channel、ChannelHandler 等核心接口出发，介绍这些核心接口的实现。")],-1),y=s("h3",{id:"abstractpeer-抽象类",tabindex:"-1"},[n("AbstractPeer 抽象类 "),s("a",{class:"header-anchor",href:"#abstractpeer-抽象类","aria-label":'Permalink to "AbstractPeer 抽象类"'},"​")],-1),i=s("p",null,"首先，我们来看 AbstractPeer 这个抽象类，它同时实现了 Endpoint 接口和 ChannelHandler 接口，如下图所示，它也是 AbstractChannel、AbstractEndpoint 抽象类的父类。",-1),d=p(`<p>AbstractPeer 继承关系</p><blockquote><p>Netty 中也有 ChannelHandler、Channel 等接口，但无特殊说明的情况下，这里的接口指的都是 Dubbo 中定义的接口。如果涉及 Netty 中的接口，会进行特殊说明。</p></blockquote><p>AbstractPeer 中有四个字段：一个是表示该端点自身的 URL 类型的字段，还有两个 Boolean 类型的字段（closing 和 closed）用来记录当前端点的状态，这三个字段都与 Endpoint 接口相关；第四个字段指向了一个 ChannelHandler 对象，AbstractPeer 对 ChannelHandler 接口的所有实现，都是委托给了这个 ChannelHandler 对象。从上面的继承关系图中，我们可以得出这样一个结论：AbstractChannel、AbstractServer、AbstractClient 都是要关联一个 ChannelHandler 对象的。</p><h3 id="abstractendpoint-抽象类" tabindex="-1">AbstractEndpoint 抽象类 <a class="header-anchor" href="#abstractendpoint-抽象类" aria-label="Permalink to &quot;AbstractEndpoint 抽象类&quot;">​</a></h3><p>我们顺着上图的继承关系继续向下看，AbstractEndpoint 继承了 AbstractPeer 这个抽象类。AbstractEndpoint 中维护了一个 Codec2 对象（codec 字段）和两个超时时间（timeout 字段和 connectTimeout 字段），在 AbstractEndpoint 的构造方法中会根据传入的 URL 初始化这三个字段：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractEndpoint</span><span style="color:#E1E4E8;">(URL url, ChannelHandler handler) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(url, handler); </span><span style="color:#6A737D;">// 调用父类AbstractPeer的构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据URL中的codec参数值，确定此处具体的Codec2实现类</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.codec </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getChannelCodec</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据URL中的timeout参数确定timeout字段的值，默认1000</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.timeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getPositiveParameter</span><span style="color:#E1E4E8;">(TIMEOUT_KEY,</span></span>
<span class="line"><span style="color:#E1E4E8;">         DEFAULT_TIMEOUT);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据URL中的connect.timeout参数确定connectTimeout字段的值，默认3000</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.connectTimeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getPositiveParameter</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractEndpoint</span><span style="color:#24292E;">(URL url, ChannelHandler handler) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(url, handler); </span><span style="color:#6A737D;">// 调用父类AbstractPeer的构造方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据URL中的codec参数值，确定此处具体的Codec2实现类</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.codec </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getChannelCodec</span><span style="color:#24292E;">(url);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据URL中的timeout参数确定timeout字段的值，默认1000</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.timeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getPositiveParameter</span><span style="color:#24292E;">(TIMEOUT_KEY,</span></span>
<span class="line"><span style="color:#24292E;">         DEFAULT_TIMEOUT);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据URL中的connect.timeout参数确定connectTimeout字段的值，默认3000</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.connectTimeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getPositiveParameter</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    Constants.CONNECT_TIMEOUT_KEY, Constants.DEFAULT_CONNECT_TIMEOUT);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4269" target="_blank" rel="noreferrer">第 17 课时</a>介绍 Codec2 接口的时候提到它是一个 SPI 扩展点，这里的 AbstractEndpoint.getChannelCodec() 方法就是基于 Dubbo SPI 选择其扩展实现的，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Codec2 </span><span style="color:#B392F0;">getChannelCodec</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据URL的codec参数获取扩展名</span></span>
<span class="line"><span style="color:#E1E4E8;">    String codecName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(Constants.CODEC_KEY, </span><span style="color:#9ECBFF;">&quot;telnet&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ExtensionLoader.</span><span style="color:#B392F0;">getExtensionLoader</span><span style="color:#E1E4E8;">(Codec2.class).</span><span style="color:#B392F0;">hasExtension</span><span style="color:#E1E4E8;">(codecName)) { </span><span style="color:#6A737D;">// 通过ExtensionLoader加载并实例化Codec2的具体扩展实现</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ExtensionLoader.</span><span style="color:#B392F0;">getExtensionLoader</span><span style="color:#E1E4E8;">(Codec2.class).</span><span style="color:#B392F0;">getExtension</span><span style="color:#E1E4E8;">(codecName);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// Codec2接口不存在相应的扩展名，就尝试从Codec这个老接口的扩展名中查找，目前Codec接口已经废弃了，所以省略这部分逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Codec2 </span><span style="color:#6F42C1;">getChannelCodec</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据URL的codec参数获取扩展名</span></span>
<span class="line"><span style="color:#24292E;">    String codecName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(Constants.CODEC_KEY, </span><span style="color:#032F62;">&quot;telnet&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ExtensionLoader.</span><span style="color:#6F42C1;">getExtensionLoader</span><span style="color:#24292E;">(Codec2.class).</span><span style="color:#6F42C1;">hasExtension</span><span style="color:#24292E;">(codecName)) { </span><span style="color:#6A737D;">// 通过ExtensionLoader加载并实例化Codec2的具体扩展实现</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ExtensionLoader.</span><span style="color:#6F42C1;">getExtensionLoader</span><span style="color:#24292E;">(Codec2.class).</span><span style="color:#6F42C1;">getExtension</span><span style="color:#24292E;">(codecName);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// Codec2接口不存在相应的扩展名，就尝试从Codec这个老接口的扩展名中查找，目前Codec接口已经废弃了，所以省略这部分逻辑</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>另外，AbstractEndpoint 还实现了 Resetable 接口（只有一个 reset() 方法需要实现），虽然 AbstractEndpoint 中的 reset() 方法比较长，但是逻辑非常简单，就是根据传入的 URL 参数重置 AbstractEndpoint 的三个字段。下面是重置 codec 字段的代码片段，还是调用 getChannelCodec() 方法实现的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reset</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测当前AbstractEndpoint是否已经关闭(略)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 省略重置timeout、connectTimeout两个字段的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (url.</span><span style="color:#B392F0;">hasParameter</span><span style="color:#E1E4E8;">(Constants.CODEC_KEY)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.codec </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getChannelCodec</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        logger.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(t.</span><span style="color:#B392F0;">getMessage</span><span style="color:#E1E4E8;">(), t);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reset</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测当前AbstractEndpoint是否已经关闭(略)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 省略重置timeout、connectTimeout两个字段的逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (url.</span><span style="color:#6F42C1;">hasParameter</span><span style="color:#24292E;">(Constants.CODEC_KEY)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.codec </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getChannelCodec</span><span style="color:#24292E;">(url);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        logger.</span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(t.</span><span style="color:#6F42C1;">getMessage</span><span style="color:#24292E;">(), t);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="server-继承路线分析" tabindex="-1">Server 继承路线分析 <a class="header-anchor" href="#server-继承路线分析" aria-label="Permalink to &quot;Server 继承路线分析&quot;">​</a></h3><p>AbstractServer 和 AbstractClient 都实现了 AbstractEndpoint 抽象类，我们先来看 AbstractServer 的实现。AbstractServer 在继承了 AbstractEndpoint 的同时，还实现了 RemotingServer 接口，如下图所示：</p>`,12),u=p(`<p>AbstractServer 继承关系图</p><p><strong>AbstractServer 是对服务端的抽象，实现了服务端的公共逻辑</strong>。AbstractServer 的核心字段有下面几个。</p><ul><li><p>localAddress、bindAddress（InetSocketAddress 类型）：分别对应该 Server 的本地地址和绑定的地址，都是从 URL 中的参数中获取。bindAddress 默认值与 localAddress 一致。</p></li><li><p>accepts（int 类型）：该 Server 能接收的最大连接数，从 URL 的 accepts 参数中获取，默认值为 0，表示没有限制。</p></li><li><p>executorRepository（ExecutorRepository 类型）：负责管理线程池，后面我们会深入介绍 ExecutorRepository 的具体实现。</p></li><li><p>executor（ExecutorService 类型）：当前 Server 关联的线程池，由上面的 ExecutorRepository 创建并管理。</p></li></ul><p>在 AbstractServer 的构造方法中会根据传入的 URL初始化上述字段，并调用 doOpen() 这个抽象方法完成该 Server 的启动，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbstractServer</span><span style="color:#E1E4E8;">(URL url, ChannelHandler handler) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(url, handler); </span><span style="color:#6A737D;">// 调用父类的构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据传入的URL初始化localAddress和bindAddress</span></span>
<span class="line"><span style="color:#E1E4E8;">    localAddress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">toInetSocketAddress</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    String bindIp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(Constants.BIND_IP_KEY, </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getHost</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> bindPort </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(Constants.BIND_PORT_KEY, </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getPort</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(ANYHOST_KEY, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> NetUtils.</span><span style="color:#B392F0;">isInvalidLocalHost</span><span style="color:#E1E4E8;">(bindIp)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        bindIp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ANYHOST_VALUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    bindAddress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InetSocketAddress</span><span style="color:#E1E4E8;">(bindIp, bindPort);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化accepts等字段</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.accepts </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(ACCEPTS_KEY, DEFAULT_ACCEPTS);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.idleTimeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doOpen</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 调用doOpen()这个抽象方法，启动该Server</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RemotingException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;...&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取该Server关联的线程池</span></span>
<span class="line"><span style="color:#E1E4E8;">    executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executorRepository.</span><span style="color:#B392F0;">createExecutorIfAbsent</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbstractServer</span><span style="color:#24292E;">(URL url, ChannelHandler handler) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(url, handler); </span><span style="color:#6A737D;">// 调用父类的构造方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据传入的URL初始化localAddress和bindAddress</span></span>
<span class="line"><span style="color:#24292E;">    localAddress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">toInetSocketAddress</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    String bindIp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(Constants.BIND_IP_KEY, </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getHost</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> bindPort </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(Constants.BIND_PORT_KEY, </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getPort</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(ANYHOST_KEY, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> NetUtils.</span><span style="color:#6F42C1;">isInvalidLocalHost</span><span style="color:#24292E;">(bindIp)) {</span></span>
<span class="line"><span style="color:#24292E;">        bindIp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ANYHOST_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    bindAddress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InetSocketAddress</span><span style="color:#24292E;">(bindIp, bindPort);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化accepts等字段</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.accepts </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(ACCEPTS_KEY, DEFAULT_ACCEPTS);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.idleTimeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doOpen</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 调用doOpen()这个抽象方法，启动该Server</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RemotingException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;...&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取该Server关联的线程池</span></span>
<span class="line"><span style="color:#24292E;">    executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executorRepository.</span><span style="color:#6F42C1;">createExecutorIfAbsent</span><span style="color:#24292E;">(url);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="executorrepository" tabindex="-1">ExecutorRepository <a class="header-anchor" href="#executorrepository" aria-label="Permalink to &quot;ExecutorRepository&quot;">​</a></h4><p>在继续分析 AbstractServer 的具体实现类之前，我们先来了解一下 ExecutorRepository 这个接口。</p><p>ExecutorRepository 负责创建并管理 Dubbo 中的线程池，该接口虽然是个 SPI 扩展点，但是只有一个默认实现------ DefaultExecutorRepository。在该默认实现中维护了一个 ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, ExecutorService&gt;&gt; 集合（data 字段）缓存已有的线程池，第一层 Key 值表示线程池属于 Provider 端还是 Consumer 端，第二层 Key 值表示线程池关联服务的端口。</p><p>DefaultExecutorRepository.createExecutorIfAbsent() 方法会根据 URL 参数创建相应的线程池并缓存在合适的位置，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> ExecutorService </span><span style="color:#B392F0;">createExecutorIfAbsent</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据URL中的side参数值决定第一层key</span></span>
<span class="line"><span style="color:#E1E4E8;">    String componentKey </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> EXECUTOR_SERVICE_COMPONENT_KEY;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CONSUMER_SIDE.</span><span style="color:#B392F0;">equalsIgnoreCase</span><span style="color:#E1E4E8;">(url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(SIDE_KEY))) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        componentKey </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CONSUMER_SIDE; </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">ExecutorService</span><span style="color:#E1E4E8;">&gt; executors </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> data.</span><span style="color:#B392F0;">computeIfAbsent</span><span style="color:#E1E4E8;">(componentKey, k </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ConcurrentHashMap&lt;&gt;());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据URL中的port值确定第二层key</span></span>
<span class="line"><span style="color:#E1E4E8;">    Integer portKey </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getPort</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService executor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executors.</span><span style="color:#B392F0;">computeIfAbsent</span><span style="color:#E1E4E8;">(portKey, k </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createExecutor</span><span style="color:#E1E4E8;">(url));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果缓存中相应的线程池已关闭，则同样需要调用createExecutor()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建新的线程池，并替换掉缓存中已关闭的线程持，这里省略这段逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> executor;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> ExecutorService </span><span style="color:#6F42C1;">createExecutorIfAbsent</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据URL中的side参数值决定第一层key</span></span>
<span class="line"><span style="color:#24292E;">    String componentKey </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> EXECUTOR_SERVICE_COMPONENT_KEY;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CONSUMER_SIDE.</span><span style="color:#6F42C1;">equalsIgnoreCase</span><span style="color:#24292E;">(url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(SIDE_KEY))) {</span></span>
<span class="line"><span style="color:#24292E;">        componentKey </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CONSUMER_SIDE; </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">ExecutorService</span><span style="color:#24292E;">&gt; executors </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> data.</span><span style="color:#6F42C1;">computeIfAbsent</span><span style="color:#24292E;">(componentKey, k </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ConcurrentHashMap&lt;&gt;());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据URL中的port值确定第二层key</span></span>
<span class="line"><span style="color:#24292E;">    Integer portKey </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getPort</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService executor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executors.</span><span style="color:#6F42C1;">computeIfAbsent</span><span style="color:#24292E;">(portKey, k </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createExecutor</span><span style="color:#24292E;">(url));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果缓存中相应的线程池已关闭，则同样需要调用createExecutor()方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建新的线程池，并替换掉缓存中已关闭的线程持，这里省略这段逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> executor;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 createExecutor() 方法中，会通过 Dubbo SPI 查找 ThreadPool 接口的扩展实现，并调用其 getExecutor() 方法创建线程池。ThreadPool 接口被 @SPI 注解修饰，默认使用 FixedThreadPool 实现，但是 ThreadPool 接口中的 getExecutor() 方法被 @Adaptive 注解修饰，动态生成的适配器类会优先根据 URL 中的 threadpool 参数选择 ThreadPool 的扩展实现。ThreadPool 接口的实现类如下图所示：</p>`,11),F=p(`<p>ThreadPool 继承关系图</p><p>不同实现会根据 URL 参数创建不同特性的线程池，这里以<strong>CacheThreadPool</strong>为例进行分析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Executor </span><span style="color:#B392F0;">getExecutor</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(THREAD_NAME_KEY, DEFAULT_THREAD_NAME);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 核心线程数量</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> cores </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(CORE_THREADS_KEY, DEFAULT_CORE_THREADS);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 最大线程数量</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> threads </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(THREADS_KEY, Integer.MAX_VALUE);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 缓冲队列的最大长度</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> queues </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(QUEUES_KEY, DEFAULT_QUEUES);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 非核心线程的最大空闲时长，当非核心线程空闲时间超过该值时，会被回收</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> alive </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(ALIVE_KEY, DEFAULT_ALIVE);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 下面就是依赖JDK的ThreadPoolExecutor创建指定特性的线程池并返回</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadPoolExecutor</span><span style="color:#E1E4E8;">(cores, threads, alive, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#E1E4E8;">            queues </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> SynchronousQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt;() </span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">                    (queues </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedBlockingQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt;()</span></span>
<span class="line"><span style="color:#E1E4E8;">                            </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedBlockingQueue&lt;</span><span style="color:#F97583;">Runnable</span><span style="color:#E1E4E8;">&gt;(queues)),</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NamedInternalThreadFactory</span><span style="color:#E1E4E8;">(name, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">), </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AbortPolicyWithReport</span><span style="color:#E1E4E8;">(name, url));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Executor </span><span style="color:#6F42C1;">getExecutor</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    String name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(THREAD_NAME_KEY, DEFAULT_THREAD_NAME);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 核心线程数量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> cores </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(CORE_THREADS_KEY, DEFAULT_CORE_THREADS);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 最大线程数量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> threads </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(THREADS_KEY, Integer.MAX_VALUE);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 缓冲队列的最大长度</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> queues </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(QUEUES_KEY, DEFAULT_QUEUES);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 非核心线程的最大空闲时长，当非核心线程空闲时间超过该值时，会被回收</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> alive </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(ALIVE_KEY, DEFAULT_ALIVE);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 下面就是依赖JDK的ThreadPoolExecutor创建指定特性的线程池并返回</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadPoolExecutor</span><span style="color:#24292E;">(cores, threads, alive, TimeUnit.MILLISECONDS,</span></span>
<span class="line"><span style="color:#24292E;">            queues </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> SynchronousQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt;() </span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">                    (queues </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedBlockingQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt;()</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedBlockingQueue&lt;</span><span style="color:#D73A49;">Runnable</span><span style="color:#24292E;">&gt;(queues)),</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NamedInternalThreadFactory</span><span style="color:#24292E;">(name, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">), </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AbortPolicyWithReport</span><span style="color:#24292E;">(name, url));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>再简单说一下其他 ThreadPool 实现创建的线程池。</p><ul><li><p><strong>LimitedThreadPool</strong>：与 CacheThreadPool 一样，可以指定核心线程数、最大线程数以及缓冲队列长度。区别在于，LimitedThreadPool 创建的线程池的非核心线程不会被回收。</p></li><li><p><strong>FixedThreadPool</strong>：核心线程数和最大线程数一致，且不会被回收。</p></li></ul><p>上述三种类型的线程池都是基于 JDK ThreadPoolExecutor 线程池，在核心线程全部被占用的时候，会优先将任务放到缓冲队列中缓存，在缓冲队列满了之后，才会尝试创建新线程来处理任务。</p><p>EagerThreadPool 创建的线程池是 EagerThreadPoolExecutor（继承了 JDK 提供的 ThreadPoolExecutor），使用的队列是 TaskQueue（继承了LinkedBlockingQueue）。该线程池与 ThreadPoolExecutor 不同的是：在线程数没有达到最大线程数的前提下，EagerThreadPoolExecutor 会优先创建线程来执行任务，而不是放到缓冲队列中；当线程数达到最大值时，EagerThreadPoolExecutor 会将任务放入缓冲队列，等待空闲线程。</p><p>EagerThreadPoolExecutor 覆盖了 ThreadPoolExecutor 中的两个方法：execute() 方法和 afterExecute() 方法，具体实现如下，我们可以看到其中维护了一个 submittedTaskCount 字段（AtomicInteger 类型），用来记录当前在线程池中的任务总数（正在线程中执行的任务数+队列中等待的任务数）。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(Runnable command) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务提交之前，递增submittedTaskCount</span></span>
<span class="line"><span style="color:#E1E4E8;">    submittedTaskCount.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(command); </span><span style="color:#6A737D;">// 提交任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (RejectedExecutionException </span><span style="color:#FFAB70;">rx</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> TaskQueue queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (TaskQueue) </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getQueue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 任务被拒绝之后，会尝试再次放入队列中缓存，等待空闲线程执行</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">queue.</span><span style="color:#B392F0;">retryOffer</span><span style="color:#E1E4E8;">(command, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, TimeUnit.MILLISECONDS)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 再次入队被拒绝，则队列已满，无法执行任务</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 递减submittedTaskCount</span></span>
<span class="line"><span style="color:#E1E4E8;">                submittedTaskCount.</span><span style="color:#B392F0;">decrementAndGet</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RejectedExecutionException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Queue capacity is full.&quot;</span><span style="color:#E1E4E8;">, rx);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (InterruptedException </span><span style="color:#FFAB70;">x</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 再次入队列异常，递减submittedTaskCount</span></span>
<span class="line"><span style="color:#E1E4E8;">            submittedTaskCount.</span><span style="color:#B392F0;">decrementAndGet</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RejectedExecutionException</span><span style="color:#E1E4E8;">(x);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 任务提交异常，递减submittedTaskCount</span></span>
<span class="line"><span style="color:#E1E4E8;">        submittedTaskCount.</span><span style="color:#B392F0;">decrementAndGet</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">afterExecute</span><span style="color:#E1E4E8;">(Runnable r, Throwable t) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 任务指定结束，递减submittedTaskCount</span></span>
<span class="line"><span style="color:#E1E4E8;">    submittedTaskCount.</span><span style="color:#B392F0;">decrementAndGet</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(Runnable command) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务提交之前，递增submittedTaskCount</span></span>
<span class="line"><span style="color:#24292E;">    submittedTaskCount.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(command); </span><span style="color:#6A737D;">// 提交任务</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (RejectedExecutionException </span><span style="color:#E36209;">rx</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> TaskQueue queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (TaskQueue) </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">getQueue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 任务被拒绝之后，会尝试再次放入队列中缓存，等待空闲线程执行</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">queue.</span><span style="color:#6F42C1;">retryOffer</span><span style="color:#24292E;">(command, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, TimeUnit.MILLISECONDS)) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 再次入队被拒绝，则队列已满，无法执行任务</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 递减submittedTaskCount</span></span>
<span class="line"><span style="color:#24292E;">                submittedTaskCount.</span><span style="color:#6F42C1;">decrementAndGet</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RejectedExecutionException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Queue capacity is full.&quot;</span><span style="color:#24292E;">, rx);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (InterruptedException </span><span style="color:#E36209;">x</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 再次入队列异常，递减submittedTaskCount</span></span>
<span class="line"><span style="color:#24292E;">            submittedTaskCount.</span><span style="color:#6F42C1;">decrementAndGet</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RejectedExecutionException</span><span style="color:#24292E;">(x);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 任务提交异常，递减submittedTaskCount</span></span>
<span class="line"><span style="color:#24292E;">        submittedTaskCount.</span><span style="color:#6F42C1;">decrementAndGet</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">afterExecute</span><span style="color:#24292E;">(Runnable r, Throwable t) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 任务指定结束，递减submittedTaskCount</span></span>
<span class="line"><span style="color:#24292E;">    submittedTaskCount.</span><span style="color:#6F42C1;">decrementAndGet</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>看到这里，你可能会有些疑惑：没有看到优先创建线程执行任务的逻辑啊。其实重点在关联的 TaskQueue 实现中，它覆盖了 LinkedBlockingQueue.offer() 方法，会判断线程池的 submittedTaskCount 值是否已经达到最大线程数，如果未超过，则会返回 false，迫使线程池创建新线程来执行任务。示例代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(Runnable runnable) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取当前线程池中的活跃线程数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> currentPoolThreadSize </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">getPoolSize</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前有线程空闲，直接将任务提交到队列中，空闲线程会直接从中获取任务执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (executor.</span><span style="color:#B392F0;">getSubmittedTaskCount</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> currentPoolThreadSize) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(runnable);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前没有空闲线程，但是还可以创建新线程，则返回false，迫使线程池创建</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 新线程来执行任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (currentPoolThreadSize </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> executor.</span><span style="color:#B392F0;">getMaximumPoolSize</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前线程数已经达到上限，只能放到队列中缓存了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(runnable);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(Runnable runnable) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前线程池中的活跃线程数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> currentPoolThreadSize </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">getPoolSize</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前有线程空闲，直接将任务提交到队列中，空闲线程会直接从中获取任务执行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (executor.</span><span style="color:#6F42C1;">getSubmittedTaskCount</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> currentPoolThreadSize) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(runnable);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前没有空闲线程，但是还可以创建新线程，则返回false，迫使线程池创建</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 新线程来执行任务</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (currentPoolThreadSize </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> executor.</span><span style="color:#6F42C1;">getMaximumPoolSize</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前线程数已经达到上限，只能放到队列中缓存了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(runnable);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>线程池最后一个相关的小细节是 AbortPolicyWithReport ，它继承了 ThreadPoolExecutor.AbortPolicy，覆盖的 rejectedExecution 方法中会输出包含线程池相关信息的 WARN 级别日志，然后进行 dumpJStack() 方法，最后才会抛出RejectedExecutionException 异常。</p><p>我们回到 Server 的继承线上，下面来看基于 Netty 4 实现的 NettyServer，它继承了前文介绍的 AbstractServer，实现了 doOpen() 方法和 doClose() 方法。这里重点看 doOpen() 方法，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doOpen</span><span style="color:#E1E4E8;">() throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建ServerBootstrap</span></span>
<span class="line"><span style="color:#E1E4E8;">    bootstrap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ServerBootstrap</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建boss EventLoopGroup</span></span>
<span class="line"><span style="color:#E1E4E8;">    bossGroup </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NettyEventLoopFactory.</span><span style="color:#B392F0;">eventLoopGroup</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;NettyServerBoss&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建worker EventLoopGroup</span></span>
<span class="line"><span style="color:#E1E4E8;">    workerGroup </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NettyEventLoopFactory.</span><span style="color:#B392F0;">eventLoopGroup</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getPositiveParameter</span><span style="color:#E1E4E8;">(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#9ECBFF;">&quot;NettyServerWorker&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建NettyServerHandler，它是一个Netty中的ChannelHandler实现，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 不是Dubbo Remoting层的ChannelHandler接口的实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> NettyServerHandler nettyServerHandler </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NettyServerHandler</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取当前NettyServer创建的所有Channel，这里的channels集合中的</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Channel不是Netty中的Channel对象，而是Dubbo Remoting层的Channel对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    channels </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nettyServerHandler.</span><span style="color:#B392F0;">getChannels</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化ServerBootstrap，指定boss和worker EventLoopGroup</span></span>
<span class="line"><span style="color:#E1E4E8;">    bootstrap.</span><span style="color:#B392F0;">group</span><span style="color:#E1E4E8;">(bossGroup, workerGroup)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">channel</span><span style="color:#E1E4E8;">(NettyEventLoopFactory.</span><span style="color:#B392F0;">serverSocketChannelClass</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">option</span><span style="color:#E1E4E8;">(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">childOption</span><span style="color:#E1E4E8;">(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">childOption</span><span style="color:#E1E4E8;">(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">childHandler</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ChannelInitializer&lt;</span><span style="color:#F97583;">SocketChannel</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">initChannel</span><span style="color:#E1E4E8;">(SocketChannel </span><span style="color:#FFAB70;">ch</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 连接空闲超时时间</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> idleTimeout </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UrlUtils.</span><span style="color:#B392F0;">getIdleTimeout</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// NettyCodecAdapter中会创建Decoder和Encoder</span></span>
<span class="line"><span style="color:#E1E4E8;">                    NettyCodecAdapter adapter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NettyCodecAdapter</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getCodec</span><span style="color:#E1E4E8;">(), </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), NettyServer.this);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    ch.</span><span style="color:#B392F0;">pipeline</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                            </span><span style="color:#6A737D;">// 注册Decoder和Encoder</span></span>
<span class="line"><span style="color:#E1E4E8;">                            .</span><span style="color:#B392F0;">addLast</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;decoder&quot;</span><span style="color:#E1E4E8;">, adapter.</span><span style="color:#B392F0;">getDecoder</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                            .</span><span style="color:#B392F0;">addLast</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;encoder&quot;</span><span style="color:#E1E4E8;">, adapter.</span><span style="color:#B392F0;">getEncoder</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                            </span><span style="color:#6A737D;">// 注册IdleStateHandler</span></span>
<span class="line"><span style="color:#E1E4E8;">                            .</span><span style="color:#B392F0;">addLast</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;server-idle-handler&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IdleStateHandler</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, idleTimeout, MILLISECONDS))</span></span>
<span class="line"><span style="color:#E1E4E8;">                            </span><span style="color:#6A737D;">// 注册NettyServerHandler</span></span>
<span class="line"><span style="color:#E1E4E8;">                            .</span><span style="color:#B392F0;">addLast</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;handler&quot;</span><span style="color:#E1E4E8;">, nettyServerHandler);</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            });</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 绑定指定的地址和端口</span></span>
<span class="line"><span style="color:#E1E4E8;">    ChannelFuture channelFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bootstrap.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getBindAddress</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    channelFuture.</span><span style="color:#B392F0;">syncUninterruptibly</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 等待bind操作完成</span></span>
<span class="line"><span style="color:#E1E4E8;">    channel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> channelFuture.</span><span style="color:#B392F0;">channel</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doOpen</span><span style="color:#24292E;">() throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建ServerBootstrap</span></span>
<span class="line"><span style="color:#24292E;">    bootstrap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ServerBootstrap</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建boss EventLoopGroup</span></span>
<span class="line"><span style="color:#24292E;">    bossGroup </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NettyEventLoopFactory.</span><span style="color:#6F42C1;">eventLoopGroup</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;NettyServerBoss&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建worker EventLoopGroup</span></span>
<span class="line"><span style="color:#24292E;">    workerGroup </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NettyEventLoopFactory.</span><span style="color:#6F42C1;">eventLoopGroup</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getPositiveParameter</span><span style="color:#24292E;">(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#032F62;">&quot;NettyServerWorker&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建NettyServerHandler，它是一个Netty中的ChannelHandler实现，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 不是Dubbo Remoting层的ChannelHandler接口的实现</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> NettyServerHandler nettyServerHandler </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NettyServerHandler</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前NettyServer创建的所有Channel，这里的channels集合中的</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Channel不是Netty中的Channel对象，而是Dubbo Remoting层的Channel对象</span></span>
<span class="line"><span style="color:#24292E;">    channels </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nettyServerHandler.</span><span style="color:#6F42C1;">getChannels</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化ServerBootstrap，指定boss和worker EventLoopGroup</span></span>
<span class="line"><span style="color:#24292E;">    bootstrap.</span><span style="color:#6F42C1;">group</span><span style="color:#24292E;">(bossGroup, workerGroup)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">channel</span><span style="color:#24292E;">(NettyEventLoopFactory.</span><span style="color:#6F42C1;">serverSocketChannelClass</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">option</span><span style="color:#24292E;">(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">childOption</span><span style="color:#24292E;">(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">childOption</span><span style="color:#24292E;">(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">childHandler</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ChannelInitializer&lt;</span><span style="color:#D73A49;">SocketChannel</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">                @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">initChannel</span><span style="color:#24292E;">(SocketChannel </span><span style="color:#E36209;">ch</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Exception {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 连接空闲超时时间</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> idleTimeout </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UrlUtils.</span><span style="color:#6F42C1;">getIdleTimeout</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// NettyCodecAdapter中会创建Decoder和Encoder</span></span>
<span class="line"><span style="color:#24292E;">                    NettyCodecAdapter adapter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NettyCodecAdapter</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getCodec</span><span style="color:#24292E;">(), </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), NettyServer.this);</span></span>
<span class="line"><span style="color:#24292E;">                    ch.</span><span style="color:#6F42C1;">pipeline</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#6A737D;">// 注册Decoder和Encoder</span></span>
<span class="line"><span style="color:#24292E;">                            .</span><span style="color:#6F42C1;">addLast</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;decoder&quot;</span><span style="color:#24292E;">, adapter.</span><span style="color:#6F42C1;">getDecoder</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                            .</span><span style="color:#6F42C1;">addLast</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;encoder&quot;</span><span style="color:#24292E;">, adapter.</span><span style="color:#6F42C1;">getEncoder</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#6A737D;">// 注册IdleStateHandler</span></span>
<span class="line"><span style="color:#24292E;">                            .</span><span style="color:#6F42C1;">addLast</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;server-idle-handler&quot;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IdleStateHandler</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, idleTimeout, MILLISECONDS))</span></span>
<span class="line"><span style="color:#24292E;">                            </span><span style="color:#6A737D;">// 注册NettyServerHandler</span></span>
<span class="line"><span style="color:#24292E;">                            .</span><span style="color:#6F42C1;">addLast</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;handler&quot;</span><span style="color:#24292E;">, nettyServerHandler);</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            });</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 绑定指定的地址和端口</span></span>
<span class="line"><span style="color:#24292E;">    ChannelFuture channelFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bootstrap.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getBindAddress</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    channelFuture.</span><span style="color:#6F42C1;">syncUninterruptibly</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 等待bind操作完成</span></span>
<span class="line"><span style="color:#24292E;">    channel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> channelFuture.</span><span style="color:#6F42C1;">channel</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>看完 NettyServer 实现的 doOpen() 方法之后，你会发现它和简易版 RPC 框架中启动一个 Netty 的 Server 端基本流程类似：初始化 ServerBootstrap、创建 Boss EventLoopGroup 和 Worker EventLoopGroup、创建 ChannelInitializer 指定如何初始化 Channel 上的 ChannelHandler 等一系列 Netty 使用的标准化流程。</p><p>其实在 Transporter 这一层看，功能的不同其实就是注册在 Channel 上的 ChannelHandler 不同，通过 doOpen() 方法得到的 Server 端结构如下：</p>`,16),A=s("p",null,"NettyServer 模型",-1),C=s("h4",{id:"核心-channelhandler",tabindex:"-1"},[n("核心 ChannelHandler "),s("a",{class:"header-anchor",href:"#核心-channelhandler","aria-label":'Permalink to "核心 ChannelHandler"'},"​")],-1),h=s("p",null,"下面我们来逐个看看这四个 ChannelHandler 的核心功能。",-1),D=s("p",null,[n("首先是"),s("strong",null,"decoder 和 encoder"),n("，它们都是 NettyCodecAdapter 的内部类，如下图所示，分别继承了 Netty 中的 ByteToMessageDecoder 和 MessageToByteEncoder：")],-1),g=p(`<p>还记得 AbstractEndpoint 抽象类中的 codec 字段（Codec2 类型）吗？InternalDecoder 和 InternalEncoder 会将真正的编解码功能委托给 NettyServer 关联的这个 Codec2 对象去处理，这里以 InternalDecoder 为例进行分析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InternalDecoder</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ByteToMessageDecoder</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">decode</span><span style="color:#E1E4E8;">(ChannelHandlerContext </span><span style="color:#FFAB70;">ctx</span><span style="color:#E1E4E8;">, ByteBuf </span><span style="color:#FFAB70;">input</span><span style="color:#E1E4E8;">, List&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">out</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将ByteBuf封装成统一的ChannelBuffer</span></span>
<span class="line"><span style="color:#E1E4E8;">        ChannelBuffer message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NettyBackedChannelBuffer</span><span style="color:#E1E4E8;">(input);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 拿到关联的Channel</span></span>
<span class="line"><span style="color:#E1E4E8;">        NettyChannel channel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NettyChannel.</span><span style="color:#B392F0;">getOrAddChannel</span><span style="color:#E1E4E8;">(ctx.</span><span style="color:#B392F0;">channel</span><span style="color:#E1E4E8;">(), url, handler);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 记录当前readerIndex的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> saveReaderIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> message.</span><span style="color:#B392F0;">readerIndex</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 委托给Codec2进行解码</span></span>
<span class="line"><span style="color:#E1E4E8;">            Object msg </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> codec.</span><span style="color:#B392F0;">decode</span><span style="color:#E1E4E8;">(channel, message);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 当前接收到的数据不足一个消息的长度，会返回NEED_MORE_INPUT，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这里会重置readerIndex，继续等待接收更多的数据</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (msg </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> Codec2.DecodeResult.NEED_MORE_INPUT) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                message.</span><span style="color:#B392F0;">readerIndex</span><span style="color:#E1E4E8;">(saveReaderIndex);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (msg </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 将读取到的消息传递给后面的Handler处理</span></span>
<span class="line"><span style="color:#E1E4E8;">                    out.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(msg);</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (message.</span><span style="color:#B392F0;">readable</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InternalDecoder</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ByteToMessageDecoder</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">decode</span><span style="color:#24292E;">(ChannelHandlerContext </span><span style="color:#E36209;">ctx</span><span style="color:#24292E;">, ByteBuf </span><span style="color:#E36209;">input</span><span style="color:#24292E;">, List&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">out</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Exception {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将ByteBuf封装成统一的ChannelBuffer</span></span>
<span class="line"><span style="color:#24292E;">        ChannelBuffer message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NettyBackedChannelBuffer</span><span style="color:#24292E;">(input);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 拿到关联的Channel</span></span>
<span class="line"><span style="color:#24292E;">        NettyChannel channel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NettyChannel.</span><span style="color:#6F42C1;">getOrAddChannel</span><span style="color:#24292E;">(ctx.</span><span style="color:#6F42C1;">channel</span><span style="color:#24292E;">(), url, handler);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 记录当前readerIndex的位置</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> saveReaderIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> message.</span><span style="color:#6F42C1;">readerIndex</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 委托给Codec2进行解码</span></span>
<span class="line"><span style="color:#24292E;">            Object msg </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> codec.</span><span style="color:#6F42C1;">decode</span><span style="color:#24292E;">(channel, message);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 当前接收到的数据不足一个消息的长度，会返回NEED_MORE_INPUT，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这里会重置readerIndex，继续等待接收更多的数据</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (msg </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> Codec2.DecodeResult.NEED_MORE_INPUT) {</span></span>
<span class="line"><span style="color:#24292E;">                message.</span><span style="color:#6F42C1;">readerIndex</span><span style="color:#24292E;">(saveReaderIndex);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (msg </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 将读取到的消息传递给后面的Handler处理</span></span>
<span class="line"><span style="color:#24292E;">                    out.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(msg);</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (message.</span><span style="color:#6F42C1;">readable</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>你是不是发现 InternalDecoder 的实现与我们简易版 RPC 的 Decoder 实现非常相似呢？</p><p>InternalEncoder 的具体实现就不再展开讲解了，你若感兴趣可以翻看源码进行研究和分析。</p><p>接下来是<strong>IdleStateHandler</strong>，它是 Netty 提供的一个工具型 ChannelHandler，用于定时心跳请求的功能或是自动关闭长时间空闲连接的功能。它的原理到底是怎样的呢？在 IdleStateHandler 中通过 lastReadTime、lastWriteTime 等几个字段，记录了最近一次读/写事件的时间，IdleStateHandler 初始化的时候，会创建一个定时任务，定时检测当前时间与最后一次读/写时间的差值。如果超过我们设置的阈值（也就是上面 NettyServer 中设置的 idleTimeout），就会触发 IdleStateEvent 事件，并传递给后续的 ChannelHandler 进行处理。后续 ChannelHandler 的 userEventTriggered() 方法会根据接收到的 IdleStateEvent 事件，决定是关闭长时间空闲的连接，还是发送心跳探活。</p><p>最后来看<strong>NettyServerHandler</strong>，它继承了 ChannelDuplexHandler，这是 Netty 提供的一个同时处理 Inbound 数据和 Outbound 数据的 ChannelHandler，从下面的继承图就能看出来。</p>`,6),b=s("p",null,"NettyServerHandler 继承关系图",-1),v=s("p",null,"在 NettyServerHandler 中有 channels 和 handler 两个核心字段。",-1),_=s("ul",null,[s("li",null,"channels（Map<String,Channel>集合）：记录了当前 Server 创建的所有 Channel，从下图中可以看到，连接创建（触发 channelActive() 方法）、连接断开（触发 channelInactive()方法）会操作 channels 集合进行相应的增删。")],-1),m=s("ul",null,[s("li",null,"handler（ChannelHandler 类型）：NettyServerHandler 内几乎所有方法都会触发该 Dubbo ChannelHandler 对象（如下图）。")],-1),T=p(`<p>这里以 write() 方法为例进行简单分析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">write</span><span style="color:#E1E4E8;">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">write</span><span style="color:#E1E4E8;">(ctx, msg, promise); </span><span style="color:#6A737D;">// 将发送的数据继续向下传递</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 并不影响消息的继续发送，只是触发sent()方法进行相关的处理，这也是方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 名称是动词过去式的原因，可以仔细体会一下。其他方法可能没有那么明显，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里以write()方法为例进行说明</span></span>
<span class="line"><span style="color:#E1E4E8;">    NettyChannel channel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> NettyChannel.</span><span style="color:#B392F0;">getOrAddChannel</span><span style="color:#E1E4E8;">(ctx.</span><span style="color:#B392F0;">channel</span><span style="color:#E1E4E8;">(), url, handler);</span></span>
<span class="line"><span style="color:#E1E4E8;">    handler.</span><span style="color:#B392F0;">sent</span><span style="color:#E1E4E8;">(channel, msg);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">write</span><span style="color:#24292E;">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">write</span><span style="color:#24292E;">(ctx, msg, promise); </span><span style="color:#6A737D;">// 将发送的数据继续向下传递</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 并不影响消息的继续发送，只是触发sent()方法进行相关的处理，这也是方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 名称是动词过去式的原因，可以仔细体会一下。其他方法可能没有那么明显，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里以write()方法为例进行说明</span></span>
<span class="line"><span style="color:#24292E;">    NettyChannel channel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> NettyChannel.</span><span style="color:#6F42C1;">getOrAddChannel</span><span style="color:#24292E;">(ctx.</span><span style="color:#6F42C1;">channel</span><span style="color:#24292E;">(), url, handler);</span></span>
<span class="line"><span style="color:#24292E;">    handler.</span><span style="color:#6F42C1;">sent</span><span style="color:#24292E;">(channel, msg);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 NettyServer 创建 NettyServerHandler 的时候，可以看到下面的这行代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> NettyServerHandler nettyServerHandler </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NettyServerHandler</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> NettyServerHandler nettyServerHandler </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NettyServerHandler</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span></code></pre></div><p>其中第二个参数传入的是 NettyServer 这个对象，你可以追溯一下 NettyServer 的继承结构，会发现它的最顶层父类 AbstractPeer 实现了 ChannelHandler，并且将所有的方法委托给其中封装的 ChannelHandler 对象，如下图所示：</p>`,5),B=s("p",null,"也就是说，NettyServerHandler 会将数据委托给这个 ChannelHandler。",-1),S=s("p",null,"到此为止，Server 这条继承线就介绍完了。你可以回顾一下，从 AbstractPeer 开始往下，一路继承下来，NettyServer 拥有了 Endpoint、ChannelHandler 以及RemotingServer多个接口的能力，关联了一个 ChannelHandler 对象以及 Codec2 对象，并最终将数据委托给这两个对象进行处理。所以，上层调用方只需要实现 ChannelHandler 和 Codec2 这两个接口就可以了。",-1),x=s("h3",{id:"总结",tabindex:"-1"},[n("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),I=s("p",null,"本课时重点介绍了 Dubbo Transporter 层中 Server 相关的实现。",-1),P=s("p",null,"首先，我们介绍了 AbstractPeer 这个最顶层的抽象类，了解了 Server、Client 和 Channel 的公共属性。接下来，介绍了 AbstractEndpoint 抽象类，它提供了编解码等 Server 和 Client 所需的公共能力。最后，我们深入分析了 AbstractServer 抽象类以及基于 Netty 4 实现的 NettyServer，同时，还深入剖析了涉及的各种组件，例如，ExecutorRepository、NettyServerHandler 等。",-1);function k(N,R,L,U,f,H){const a=e("Image");return t(),r("div",null,[E,y,i,l(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wb8eAHyD_AAFkwn8xp18694.png"}),n(),d,l(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wb-iAMAgtAACJWi59iSc812.png"}),n(),u,l(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/58/FE/CgqCHl9wcBeAYMZ1AABRTGzl5uY627.png"}),n(),F,l(a,{alt:"5.png",src:"https://s0.lgstatic.com/i/image/M00/59/E4/Ciqc1F9y4LaAIHSsAADBytWDQ3U695.png"}),n(),A,C,h,D,l(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/58/FE/CgqCHl9wcESANfPCAABDUdzhtNU066.png"}),g,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wcFKAQQZ3AAB282frbWw282.png"}),n(),b,v,_,l(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wcFuABJWsAAaIoTwCIA0958.png"}),m,l(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/58/FE/CgqCHl9wcGOAE_ykAAFvy5a4X58367.png"}),T,l(a,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/58/F3/Ciqc1F9wcGuADQi3AAD6EEURlNU871.png"}),B,S,l(a,{alt:"6.png",src:"https://s0.lgstatic.com/i/image/M00/59/E4/Ciqc1F9y4MyAR8XLAABTLdOZqrc228.png"}),x,I,P])}const q=o(c,[["render",k]]);export{w as __pageData,q as default};
