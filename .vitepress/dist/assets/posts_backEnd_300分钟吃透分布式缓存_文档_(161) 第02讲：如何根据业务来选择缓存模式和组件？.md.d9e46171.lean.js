import{_ as h,j as i,o,g as l,k as t,s as e,h as a,Q as s}from"./chunks/framework.e0c66c3f.js";const w=JSON.parse('{"title":"缓存读写模式 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(161) 第02讲：如何根据业务来选择缓存模式和组件？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(161) 第02讲：如何根据业务来选择缓存模式和组件？.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(161) 第02讲：如何根据业务来选择缓存模式和组件？.md"},n=e("p",null,'你好，我是你的缓存老师陈波，欢迎进入第 2 课时"缓存的读写模式及分类"。这一课时我们主要学习缓存的读写模式以及缓存的分类。',-1),d=e("h6",{id:"缓存读写模式",tabindex:"-1"},[a("缓存读写模式 "),e("a",{class:"header-anchor",href:"#缓存读写模式","aria-label":'Permalink to "缓存读写模式"'},"​")],-1),_=e("p",null,"如下图，业务系统读写缓存有 3 种模式：",-1),p=e("ul",null,[e("li",null,[e("p",null,"Cache Aside（旁路缓存）")]),e("li",null,[e("p",null,"Read/Write Through（读写穿透）")]),e("li",null,[e("p",null,"Write Behind Caching（异步缓存写入）")])],-1),u=e("h6",{id:"cache-aside",tabindex:"-1"},[a("Cache Aside "),e("a",{class:"header-anchor",href:"#cache-aside","aria-label":'Permalink to "Cache Aside"'},"​")],-1),g=e("br",null,null,-1),B=e("p",null,"如上图所示，Cache Aside 模式中，业务应用方对于写，是更新 DB 后，直接将 key 从 cache 中删除，然后由 DB 驱动缓存数据的更新；而对于读，是先读 cache，如果 cache 没有，则读 DB，同时将从 DB 中读取的数据回写到 cache。",-1),m=e("p",null,"这种模式的特点是，业务端处理所有数据访问细节，同时利用 Lazy 计算的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率。",-1),C=e("p",null,"如果没有专门的存储服务，同时是对数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务，这些情况都比较适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式，这些缓存数据需要通过多个原始数据进行计算后设置。在部分数据变更后，直接删除缓存。同时，使用一个 Trigger 组件，实时读取 DB 的变更日志，然后重新计算并更新缓存。如果读缓存的时候，Trigger 还没写入 cache，则由调用方自行到 DB 加载计算并写入 cache。",-1),b=e("h6",{id:"read-write-through",tabindex:"-1"},[a("Read/Write Through "),e("a",{class:"header-anchor",href:"#read-write-through","aria-label":'Permalink to "Read/Write Through"'},"​")],-1),D={id:"",tabindex:"-1"},k=e("a",{class:"header-anchor",href:"#","aria-label":'Permalink to "<Image alt="" src="http://s0.lgstatic.com/i/image2/M01/99/8F/CgotOV2kRdSAGi0EAAFFkVZArO4978.png"/>"'},"​",-1),A=e("br",null,null,-1),f=e("br",null,null,-1),x=e("p",null,"如上图，对于 Cache Aside 模式，业务应用需要同时维护 cache 和 DB 两个数据存储方，过于繁琐，于是就有了 Read/Write Through 模式。在这种模式下，业务应用只关注一个存储服务即可，业务方的读写 cache 和 DB 的操作，都由存储服务代理。存储服务收到业务应用的写请求时，会首先查 cache，如果数据在 cache 中不存在，则只更新 DB，如果数据在 cache 中存在，则先更新 cache，然后更新 DB。而存储服务收到读请求时，如果命中 cache 直接返回，否则先从 DB 加载，回种到 cache 后返回响应。",-1),P=e("p",null,"这种模式的特点是，存储服务封装了所有的数据处理细节，业务应用端代码只用关注业务逻辑本身，系统的隔离性更佳。另外，进行写操作时，如果 cache 中没有数据则不更新，有缓存数据才更新，内存效率更高。",-1),R=e("p",null,"微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。",-1),T=e("h6",{id:"write-behind-caching",tabindex:"-1"},[a("Write Behind Caching "),e("a",{class:"header-anchor",href:"#write-behind-caching","aria-label":'Permalink to "Write Behind Caching"'},"​")],-1),F=s("",17);function S(V,O,W,E,q,M){const c=i("Image");return o(),l("div",null,[n,d,_,p,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/8F/CgotOV2kRdSARL_yAABgmkQ_X6k170.png"}),u,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/6F/CgoB5l2kRdSAE8I4AAFjGcx_DP4974.png"}),g,B,m,C,b,e("h6",D,[t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/8F/CgotOV2kRdSAGi0EAAFFkVZArO4978.png"}),a(),k]),A,f,x,P,R,T,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/6F/CgoB5l2kRdSAKsw-AAFBxhGDxBU820.png"}),F])}const N=h(r,[["render",S]]);export{w as __pageData,N as default};
