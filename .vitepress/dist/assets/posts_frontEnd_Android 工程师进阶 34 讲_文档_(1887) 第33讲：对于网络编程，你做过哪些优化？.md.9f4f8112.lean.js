import{_ as e,j as o,o as t,g as c,k as l,h as n,Q as p,s}from"./chunks/framework.4e7d56ce.js";const W=JSON.parse('{"title":"第33讲：对于网络编程，你做过哪些优化？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1887) 第33讲：对于网络编程，你做过哪些优化？.md","filePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1887) 第33讲：对于网络编程，你做过哪些优化？.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1887) 第33讲：对于网络编程，你做过哪些优化？.md"},i=p("",10),d=s("p",null,"在接口 Dns 中只有一个方法需要实现------lookup，这个方法返回查找到的服务器地址集合。并且 OkHttp 已经实现了一个默认的 DNS 解析器，也就是图中红框标识的 SYSTEM，它使用 java net 包中的 InetAddress 获取某域名的 IP 地址集合。",-1),E=s("p",null,"我们可以实现 Dns 接口，使用 Http 的请求方式实现自己的域名解析器，具体实现就是使用七牛云提供的 happy-dns SDK。首先需要添加依赖库：",-1),y=s("p",null,"然后在自己实现的 Dns 类中，使用如下方式实现：",-1),_=s("p",null,"这样我们就可以在安全方面做到防劫持的功能了。",-1),h=s("h4",{id:"速度方面",tabindex:"-1"},[n("速度方面 "),s("a",{class:"header-anchor",href:"#速度方面","aria-label":'Permalink to "速度方面"'},"​")],-1),u=s("p",null,"关于 DNS 解析的速度优化方面，我们可以从以下几个方面进行突破：",-1),g=s("ul",null,[s("li",null,[s("strong",null,"IP 直连方式")])],-1),C=s("p",null,"IP 直连方式经常会针对不同的开发环境使用，比如针对在 qa、staging 测试环境下，可以直接配置 IP 白名单，跳过 DNS 解析流程，但这样同样需要实现 OkHttp 的 Dns 接口，如下所示：",-1),F=s("p",null,[n("听说有的一线互联网公司也会在线上版本采用这种方式，但是这种方式开发成本较高。因为 IP 列表是维护在本地，因此需要建立一套 IP 地址的更新机制。另外 IP 直连方式摒弃了 HTTPS 的安全机制，由于 HTTPS 要求证书绑定域名，因此客户端需要增加额外的代码改造，具体参考："),s("a",{href:"https://blog.csdn.net/github_34613936/article/details/51490032",target:"_blank",rel:"noreferrer"},"https信任证书的三种方式"),n("。")],-1),m=s("ul",null,[s("li",null,[s("strong",null,"DNS 解析超时")])],-1),D=s("p",null,"当我们在做网络请求时，如果网络设备切换路由，访问网络出现长时间无响应，很久之后会抛出 UnknownHostException，并且我们在 OkHttp 中设置的 connectTimeout 属性对 DNS 的解析不起作用。这种情况我们可以在自定义的 Dns 类中做超时判断，如下所示：",-1),k=s("p",null,[n("更具体的分析可以参考："),s("a",{href:"https://blog.csdn.net/quwei3930921/article/details/85336552",target:"_blank",rel:"noreferrer"},"Android笔记之解决OkHttp解析dns超时时间无法设置的问题"),n("。")],-1),A=s("h3",{id:"网络请求缓存优化",tabindex:"-1"},[n("网络请求缓存优化 "),s("a",{class:"header-anchor",href:"#网络请求缓存优化","aria-label":'Permalink to "网络请求缓存优化"'},"​")],-1),S=s("p",null,"实际上有时在做网络请求数据可达优化的时候，经常会不可避免地与本地持久化绑定在一起。比如当一次网络请求失败时，我们需要将这次请求保存在本地，并尝试重新发送；或者请求数据成功，我们需要将数据缓存在本地，当下一次请求数据展示 UI 之前，先将缓存中的数据展示到页面，只有当新的请求返回数据之后，再次刷新页面。",-1),b=s("p",null,"一般的做法是创建一个数据库 Entity 类，并根据自家公司的业务逻辑设置公共参数，通常都会有 user_id、更新时间 update_time 等，如下所示：",-1),H=s("p",null,"上图中 key 表示缓存的标识，插入请求都是根据 key 操作；value 字段用来保存网络请求的数据，当网络请求成功后，将数据以 JSON 字符串的格式缓存到数据库中，如下所示：",-1),v=s("p",null,"解释说明：",-1),B=s("ul",null,[s("li",null,[s("p",null,"图中 1 处构建 HttpDataCache 类，并设置公共参数；")]),s("li",null,[s("p",null,"图中 2 处将网络请求数据转化为 JSON 字符串格式；")]),s("li",null,[s("p",null,"图中 3 处执行数据库操作，将网络请求数据缓存到本地数据库中。")])],-1),q=s("p",null,"后续当我们再次执行相同 key 的网络请求时，就可以先将本地数据库中的数据展示到页面，并进行异步请求操作刷新页面。",-1),N=p("",12);function P(T,f,w,I,x,M){const a=o("Image");return t(),c("div",null,[i,l(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/31/E8/CgqCHl8NWruAKGDtAAKZ0jnzg3Q313.png"}),n(),d,E,l(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/31/DD/Ciqc1F8NWseAT-qRAAGopWQJJdk020.png"}),n(),y,l(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/31/DD/Ciqc1F8NWtiAcSarAAXhhcWSncY098.png"}),n(),_,h,u,g,C,l(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/31/E8/CgqCHl8NWuWAUVw8AARDZIMsUzQ440.png"}),n(),F,m,D,l(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/31/DD/Ciqc1F8NWvCAUC-MAAOYHr_p3YA810.png"}),n(),k,A,S,b,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/31/E8/CgqCHl8NWvqAa6c6AAKHO9HwxlA228.png"}),n(),H,l(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/31/E8/CgqCHl8NWwGAcwIKAAIvUFTgrIk684.png"}),n(),v,B,q,l(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/31/E8/CgqCHl8NWwqAQMQlAAFFFewQO9M971.png"}),n(),N])}const j=e(r,[["render",P]]);export{W as __pageData,j as default};
