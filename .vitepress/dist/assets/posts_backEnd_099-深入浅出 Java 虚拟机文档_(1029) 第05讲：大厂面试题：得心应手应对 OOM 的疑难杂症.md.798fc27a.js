import{_ as p,j as o,o as t,h as c,k as e,f as a,Q as l,s}from"./chunks/framework.d3daa342.js";const B=JSON.parse('{"title":"第05讲：大厂面试题：得心应手应对OOM的疑难杂症","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1029) 第05讲：大厂面试题：得心应手应对 OOM 的疑难杂症.md","filePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1029) 第05讲：大厂面试题：得心应手应对 OOM 的疑难杂症.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1029) 第05讲：大厂面试题：得心应手应对 OOM 的疑难杂症.md"},E=l('<h1 id="第05讲-大厂面试题-得心应手应对oom的疑难杂症" tabindex="-1">第05讲：大厂面试题：得心应手应对OOM的疑难杂症 <a class="header-anchor" href="#第05讲-大厂面试题-得心应手应对oom的疑难杂症" aria-label="Permalink to &quot;第05讲：大厂面试题：得心应手应对OOM的疑难杂症&quot;">​</a></h1><p>在前面几个课时中，我们不止一次提到了堆（heap），堆是一个巨大的对象池。在这个对象池中管理着数量巨大的对象实例。</p><p>而池中对象的引用层次，有的是很深的。一个被频繁调用的接口，每秒生成对象的速度，也是非常可观的。对象之间的关系，形成了一张巨大的网。虽然 Java 一直在营造一种无限内存的氛围，但对象不能只增不减，所以需要垃圾回收。</p><p>那 JVM 是如何判断哪些对象应该被回收？哪些应该被保持呢？</p><p>在古代，刑罚中有诛九族一说。指的是有些人犯大事时，皇上杀一人不足以平复内心的愤怒时，会对亲朋好友产生连带责任。诛九族时首先需要追溯到一个共同的祖先，再往下细数连坐。堆上的垃圾回收也有同样的思路。我们接下来就具体分析 JVM 中是如何进行垃圾回收的。</p><p>JVM 的 GC 动作，是不受程序控制的，它会在满足条件的时候，自动触发。</p><p>在发生 GC 的时候，一个对象，JVM 总能够找到引用它的祖先。找到最后，如果发现这个祖先已经名存实亡了，它们都会被清理掉。而能够躲过垃圾回收的那些祖先，比较特殊，它们的名字就叫作 GC Roots。</p><p>从 GC Roots 向下追溯、搜索，会产生一个叫作 Reference Chain 的链条。当一个对象不能和任何一个 GC Root 产生关系时，就会被无情的诛杀掉。</p><p>如图所示，Obj5、Obj6、Obj7，由于不能和 GC Root 产生关联，发生 GC 时，就会被摧毁。</p>',9),i=l('<p>垃圾回收就是围绕着 GC Roots 去做的。同时，它也是很多内存泄露的根源，因为其他引用根本没有这样的权利。</p><p>那么，什么样的对象，才会是 GC Root 呢？这不在于它是什么样的对象，而在于它所处的位置。</p><h3 id="gc-roots-有哪些" tabindex="-1">GC Roots 有哪些 <a class="header-anchor" href="#gc-roots-有哪些" aria-label="Permalink to &quot;GC Roots 有哪些&quot;">​</a></h3><p>GC Roots 是一组必须活跃的引用。用通俗的话来说，就是程序接下来通过直接引用或者间接引用，能够访问到的潜在被使用的对象。</p><p>GC Roots 包括：</p><ul><li>Java 线程中，当前所有正在被调用的方法的引用类型参数、局部变量、临时值等。也就是与我们栈帧相关的各种引用。</li><li>所有当前被加载的 Java 类。</li><li>Java 类的引用类型静态变量。</li><li>运行时常量池里的引用类型常量（String 或 Class 类型）。</li><li>JVM 内部数据结构的一些引用，比如 sun.jvm.hotspot.memory.Universe 类。</li><li>用于同步的监控对象，比如调用了对象的 wait() 方法。</li><li>JNI handles，包括 global handles 和 local handles。</li></ul><p>这些 GC Roots 大体可以分为三大类，下面这种说法更加好记一些：</p><ul><li>活动线程相关的各种引用。</li><li>类的静态变量的引用。</li><li>JNI 引用。</li></ul>',8),y=s("p",null,"有两个注意点：",-1),d=s("ul",null,[s("li",null,"我们这里说的是活跃的引用，而不是对象，对象是不能作为 GC Roots 的。"),s("li",null,'GC 过程是找出所有活对象，并把其余空间认定为"无用"；而不是找出所有死掉的对象，并回收它们占用的空间。所以，哪怕 JVM 的堆非常的大，基于 tracing 的 GC 方式，回收速度也会非常快。')],-1),h=s("h3",{id:"引用级别",tabindex:"-1"},[a("引用级别 "),s("a",{class:"header-anchor",href:"#引用级别","aria-label":'Permalink to "引用级别"'},"​")],-1),u=s("p",null,"接下来的一道面试题就有意思多了：能够找到 Reference Chain 的对象，就一定会存活么？",-1),g=s("p",null,'我在面试的时候，经常会问这些问题，比如"弱引用有什么用处"？令我感到奇怪的是，即使是一些工作多年的 Java 工程师，对待这个问题也是一知半解，错失了很多机会。',-1),_=s("p",null,"对象对于另外一个对象的引用，要看关系牢靠不牢靠，可能在链条的其中一环，就断掉了。",-1),f=l(`<p>根据发生 GC 时，这条链条的表现，可以对这个引用关系进行更加细致的划分。</p><p>它们的关系，可以分为强引用、软引用、弱引用、虚引用等。</p><h4 id="强引用-strong-references" tabindex="-1">强引用 Strong references <a class="header-anchor" href="#强引用-strong-references" aria-label="Permalink to &quot;强引用 Strong references&quot;">​</a></h4><p>当内存空间不足，系统撑不住了，JVM 就会抛出 OutOfMemoryError 错误。即使程序会异常终止，这种对象也不会被回收。这种引用属于最普通最强硬的一种存在，只有在和 GC Roots 断绝关系时，才会被消灭掉。</p><p>这种引用，你每天的编码都在用。例如：new 一个普通的对象。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Object obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Object obj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">()</span></span></code></pre></div><p>这种方式可能是有问题的。假如你的系统被大量用户（User）访问，你需要记录这个 User 访问的时间。可惜的是，User 对象里并没有这个字段，所以我们决定将这些信息额外开辟一个空间进行存放。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Map&lt;</span><span style="color:#F97583;">User</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">Long</span><span style="color:#E1E4E8;">&gt; userVisitMap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">...</span></span>
<span class="line"><span style="color:#E1E4E8;">userVisitMap.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(user, time);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Map&lt;</span><span style="color:#D73A49;">User</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">Long</span><span style="color:#24292E;">&gt; userVisitMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">...</span></span>
<span class="line"><span style="color:#24292E;">userVisitMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(user, time);</span></span></code></pre></div><p>当你用完了 User 对象，其实你是期望它被回收掉的。但是，由于它被 userVisitMap 引用，我们没有其他手段 remove 掉它。这个时候，就发生了内存泄漏（memory leak）。</p><p>这种情况还通常发生在一个没有设定上限的 Cache 系统，由于设置了不正确的引用方式，加上不正确的容量，很容易造成 OOM。</p><h4 id="软引用-soft-references" tabindex="-1">软引用 Soft references <a class="header-anchor" href="#软引用-soft-references" aria-label="Permalink to &quot;软引用 Soft references&quot;">​</a></h4><p>软引用用于维护一些可有可无的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p><p>可以看到，这种特性非常适合用在缓存技术上。比如网页缓存、图片缓存等。</p><p>Guava 的 CacheBuilder，就提供了软引用和弱引用的设置方式。在这种场景中，软引用比强引用安全的多。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p>我们可以看一下它的代码。软引用需要显式的声明，使用泛型来实现。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 伪代码</span></span>
<span class="line"><span style="color:#E1E4E8;">Object object </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">SoftReference&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; softRef </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SoftReference</span><span style="color:#E1E4E8;">(object);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 伪代码</span></span>
<span class="line"><span style="color:#24292E;">Object object </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">SoftReference&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; softRef </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SoftReference</span><span style="color:#24292E;">(object);</span></span></code></pre></div><p>这里有一个相关的 JVM 参数。它的意思是：每 MB 堆空闲空间中 SoftReference 的存活时间。这个值的默认时间是1秒（1000）。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">XX</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">SoftRefLRUPolicyMSPerMB</span><span style="color:#F97583;">=&lt;</span><span style="color:#E1E4E8;">N</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">-</span><span style="color:#24292E;">XX</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">SoftRefLRUPolicyMSPerMB</span><span style="color:#D73A49;">=&lt;</span><span style="color:#24292E;">N</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><p>这里要特别说明的是，网络上一些流传的优化方法，即把这个值设置成 0，其实是错误的，这样容易引发故障，感兴趣的话你可以自行搜索一下。</p><p>这种比较偏门的优化手段，除非在你对其原理相当了解的情况下，才能设置一些比较特殊的值。比如 0 值，无限大等，这种值在 JVM 的设置中，最好不要发生。</p><h4 id="弱引用-weak-references" tabindex="-1">弱引用 Weak references <a class="header-anchor" href="#弱引用-weak-references" aria-label="Permalink to &quot;弱引用 Weak references&quot;">​</a></h4><p>弱引用对象相比较软引用，要更加无用一些，它拥有更短的生命周期。</p><p>当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。弱引用拥有更短的生命周期，在 Java 中，用 java.lang.ref.WeakReference 类来表示。</p><p>它的应用场景和软引用类似，可以在一些对内存更加敏感的系统里采用。它的使用方式类似于这段的代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 伪代码</span></span>
<span class="line"><span style="color:#E1E4E8;">Object object </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">WeakReference&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; softRef </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">WeakReference</span><span style="color:#E1E4E8;">(object);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 伪代码</span></span>
<span class="line"><span style="color:#24292E;">Object object </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">WeakReference&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; softRef </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">WeakReference</span><span style="color:#24292E;">(object);</span></span></code></pre></div><h4 id="虚引用-phantom-references" tabindex="-1">虚引用 Phantom References <a class="header-anchor" href="#虚引用-phantom-references" aria-label="Permalink to &quot;虚引用 Phantom References&quot;">​</a></h4><p>这是一种形同虚设的引用，在现实场景中用的不是很多。虚引用必须和引用队列（ReferenceQueue）联合使用。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p>实际上，虚引用的 get，总是返回 null。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Object  object </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">ReferenceQueue queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ReferenceQueue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 虚引用，必须与一个引用队列关联</span></span>
<span class="line"><span style="color:#E1E4E8;">PhantomReference pr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PhantomReference</span><span style="color:#E1E4E8;">(object, queue);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Object  object </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">ReferenceQueue queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ReferenceQueue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 虚引用，必须与一个引用队列关联</span></span>
<span class="line"><span style="color:#24292E;">PhantomReference pr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PhantomReference</span><span style="color:#24292E;">(object, queue);</span></span></code></pre></div><p>虚引用主要用来跟踪对象被垃圾回收的活动。</p><p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象之前，把这个虚引用加入到与之关联的引用队列中。</p><p>程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>下面的方法，就是一个用于监控 GC 发生的例子。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">startMonitoring</span><span style="color:#E1E4E8;">(ReferenceQueue</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">MyObject</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> referenceQueue, Reference</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">MyObject</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> ref) {</span></span>
<span class="line"><span style="color:#E1E4E8;">     ExecutorService ex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Executors.</span><span style="color:#B392F0;">newSingleThreadExecutor</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">     ex.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">         </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (referenceQueue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;">ref) {</span></span>
<span class="line"><span style="color:#E1E4E8;">             </span><span style="color:#6A737D;">//don&#39;t hang forever</span></span>
<span class="line"><span style="color:#E1E4E8;">             </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(finishFlag){</span></span>
<span class="line"><span style="color:#E1E4E8;">                 </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">         System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;-- ref gc&#39;ed --&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">     ex.</span><span style="color:#B392F0;">shutdown</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">startMonitoring</span><span style="color:#24292E;">(ReferenceQueue</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">MyObject</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> referenceQueue, Reference</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">MyObject</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> ref) {</span></span>
<span class="line"><span style="color:#24292E;">     ExecutorService ex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Executors.</span><span style="color:#6F42C1;">newSingleThreadExecutor</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">     ex.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">         </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (referenceQueue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">!=</span><span style="color:#24292E;">ref) {</span></span>
<span class="line"><span style="color:#24292E;">             </span><span style="color:#6A737D;">//don&#39;t hang forever</span></span>
<span class="line"><span style="color:#24292E;">             </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(finishFlag){</span></span>
<span class="line"><span style="color:#24292E;">                 </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">         System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;-- ref gc&#39;ed --&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">     ex.</span><span style="color:#6F42C1;">shutdown</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>基于虚引用，有一个更加优雅的实现方式，那就是 Java 9 以后新加入的 Cleaner，用来替代 Object 类的 finalizer 方法。</p><h3 id="典型-oom-场景" tabindex="-1">典型 OOM 场景 <a class="header-anchor" href="#典型-oom-场景" aria-label="Permalink to &quot;典型 OOM 场景&quot;">​</a></h3><p>OOM 的全称是 Out Of Memory，那我们的内存区域有哪些会发生 OOM 呢？我们可以从内存区域划分图上，看一下彩色部分。</p>`,38),b=s("p",null,"可以看到除了程序计数器，其他区域都有OOM溢出的可能。但是最常见的还是发生在堆上。",-1),v=s("p",null,"所以 OOM 到底是什么引起的呢？有几个原因：",-1),A=s("ul",null,[s("li",null,"内存的容量太小了，需要扩容，或者需要调整堆的空间。"),s("li",null,"错误的引用方式，发生了内存泄漏。没有及时的切断与 GC Roots 的关系。比如线程池里的线程，在复用的情况下忘记清理 ThreadLocal 的内容。"),s("li",null,"接口没有进行范围校验，外部传参超出范围。比如数据库查询时的每页条数等。"),s("li",null,"对堆外内存无限制的使用。这种情况一旦发生更加严重，会造成操作系统内存耗尽。")],-1),C=s("p",null,"典型的内存泄漏场景，原因在于对象没有及时的释放自己的引用。比如一个局部变量，被外部的静态集合引用。",-1),F=s("p",null,"你在平常写代码时，一定要注意这种情况，千万不要为了方便把对象到处引用。即使引用了，也要在合适时机进行手动清理。关于这部分的问题根源排查，我们将在实践课程中详细介绍。",-1),O=s("h3",{id:"小结",tabindex:"-1"},[a("小结 "),s("a",{class:"header-anchor",href:"#小结","aria-label":'Permalink to "小结"'},"​")],-1),m=s("p",null,"你可以注意到 GC Roots 的专业叫法，就是可达性分析法。另外，还有一种叫作引用计数法的方式，在判断对象的存活问题上，经常被提及。",-1),j=s("p",null,"因为有循环依赖的硬伤，现在主流的 JVM，没有一个是采用引用计数法来实现 GC 的，所以我们大体了解一下就可以。引用计数法是在对象头里维护一个 counter 计数器，被引用一次数量 +1，引用失效记数 -1。计数器为 0 时，就被认为无效。你现在可以忘掉引用计数的方式了。",-1),M=s("p",null,"本课时，我们详细介绍了 GC Roots 都包含哪些内容。HostSpot 采用 tracing 的方式进行 GC，内存回收的速度与处于 living 状态的对象数量有关。",-1),k=s("p",null,"这部分涉及的内容较多，如果面试被问到，你可以采用白话版的方式进行介绍，然后举例深入。",-1),R=s("p",null,"接下来，我们了解到四种不同强度的引用类型，尤其是软引用和虚引用，在平常工作中使用还是比较多的。这里面最不常用的就是虚引用，但是它引申出来的 Cleaner 类，是用来替代 finalizer 方法的，这是一个比较重要的知识点。",-1),D=s("p",null,"本课时最后讨论了几种典型的 OOM 场景，你可能现在对其概念比较模糊。接下来的课时，我们将详细介绍几个常见的垃圾回收算法，然后对这些 OOM 的场景逐个击破。",-1);function x(S,q,w,P,J,V){const n=o("Image");return t(),c("div",null,[E,e(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/62/12/CgpOIF4heVuAPrWVAACK3qrA9-0011.png"}),a(),i,e(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/62/13/Cgq2xl4hefWAWKFZAAMwndGjScg437.png"}),a(),y,d,h,u,g,_,e(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/62/13/Cgq2xl4hehyAEx1JAABb83OQ5S0469.png"}),a(),f,e(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/62/13/Cgq2xl4hepeAAwhWAAJfLYUzaPI499.png"}),a(),b,e(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/62/13/Cgq2xl4heqWAZMlOAAA-Cqk2QcM143.png"}),a(),v,A,C,e(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/62/13/Cgq2xl4hesWATlosAAJxxYIdMjs057.png"}),a(),F,O,m,j,M,k,R,D])}const T=p(r,[["render",x]]);export{B as __pageData,T as default};
