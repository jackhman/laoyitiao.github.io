import{_ as o,j as e,o as t,g as c,k as a,h as s,Q as p,s as l}from"./chunks/framework.a0d18f64.js";const U=JSON.parse('{"title":"13ReactDOM.render是如何串联渲染链路的？（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(4862) 13  ReactDOM.render 是如何串联渲染链路的？（上）.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(4862) 13  ReactDOM.render 是如何串联渲染链路的？（上）.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/046_深入浅出搞定 React/(4862) 13  ReactDOM.render 是如何串联渲染链路的？（上）.md"},E=p(`<h1 id="_13reactdom-render是如何串联渲染链路的-上" tabindex="-1">13ReactDOM.render是如何串联渲染链路的？（上） <a class="header-anchor" href="#_13reactdom-render是如何串联渲染链路的-上" aria-label="Permalink to &quot;13ReactDOM.render是如何串联渲染链路的？（上）&quot;">​</a></h1><p>由于 ReactDOM.render 的内容比较多，所以这里拆分了上中下三讲来讲解。</p><p>在上一讲，我们站在宏观角度对 Fiber 的架构分层和迭代动机有了充分的把握。从本讲开始，我们将以首次渲染为切入点，拆解 Fiber 架构下 ReactDOM.render 所触发的渲染链路，结合源码理解整个链路中所涉及的初始化、render 和 commit 等过程。</p><h3 id="reactdom-render-调用栈的逻辑分层" tabindex="-1">ReactDOM.render 调用栈的逻辑分层 <a class="header-anchor" href="#reactdom-render-调用栈的逻辑分层" aria-label="Permalink to &quot;ReactDOM.render 调用栈的逻辑分层&quot;">​</a></h3><p>开篇先给到你一个简单的 React AppDemo：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> React from &quot;react&quot;;</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> ReactDOM from &quot;react</span><span style="color:#FDAEB7;font-style:italic;">-</span><span style="color:#E1E4E8;">dom&quot;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">App</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">div className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;App&quot;</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">div className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;container&quot;</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">h1</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">我是标题</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">h1</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">我是第一段话</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">我是第二段话</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">p</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">div</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">div</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> rootElement </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">getElementById</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;root&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">ReactDOM.</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">App </span><span style="color:#F97583;">/&gt;</span><span style="color:#E1E4E8;">, rootElement);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> React from &quot;react&quot;;</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> ReactDOM from &quot;react</span><span style="color:#B31D28;font-style:italic;">-</span><span style="color:#24292E;">dom&quot;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">App</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">div className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;App&quot;</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">div className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;container&quot;</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">h1</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">我是标题</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">h1</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">我是第一段话</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">我是第二段话</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">p</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">div</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">div</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> rootElement </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">getElementById</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;root&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">ReactDOM.</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">App </span><span style="color:#D73A49;">/&gt;</span><span style="color:#24292E;">, rootElement);</span></span></code></pre></div><p>Demo 启动后，渲染出的界面如下图所示：</p>`,7),y=l("p",null,'现在请你打开 Chrome 的 Performance 面板，点击下图红色圈圈所圈住的这个"记录"按钮：',-1),i=l("p",null,"然后重新访问 Demo 页面对应的本地服务地址，待页面刷新后，终止记录，便能够得到如下图右下角所示的这样一个调用栈大图：",-1),d=l("p",null,'放大该图，定位"src/index.js"这个文件路径，我们就可以找到 ReactDOM.render 方法对应的调用栈，如下图所示：',-1),u=l("p",null,"从图中你可以看到，ReactDOM.render 方法对应的调用栈非常深，中间涉及的函数量也比较大。如果这张图使你心里发虚，请先不要急于撤退------分析调用栈只是我们理解渲染链路的一个手段，我们的目的是借此提取关键逻辑，而非理解调用栈中的每一个方法。就这张图来说，你首先需要把握的，就是整个调用链路中所包含的三个阶段：",-1),F=p('<p>图中 scheduleUpdateOnFiber 方法的作用是调度更新，在由 ReactDOM.render 发起的首屏渲染这个场景下，它触发的就是 performSyncWorkOnRoot。performSyncWorkOnRoot 开启的正是我们反复强调的 <strong>render 阶段</strong> ；而 commitRoot 方法开启的则是真实 DOM 的渲染过程（<strong>commit 阶段</strong>）。因此以scheduleUpdateOnFiber 和 commitRoot 两个方法为界，我们可以大致把 ReactDOM.render 的调用栈划分为三个阶段：</p><ol><li><p>初始化阶段</p></li><li><p>render 阶段</p></li><li><p>commit 阶段</p></li></ol><p>接下来，我们就一起来看看这三个阶段分别做了哪些事情。</p><blockquote><p>注：渲染链路串讲已被拆分为 3 个课时，本课时讲解的是初始化阶段。</p></blockquote><h3 id="拆解-reactdom-render-调用栈-初始化阶段" tabindex="-1">拆解 ReactDOM.render 调用栈------初始化阶段 <a class="header-anchor" href="#拆解-reactdom-render-调用栈-初始化阶段" aria-label="Permalink to &quot;拆解 ReactDOM.render 调用栈------初始化阶段&quot;">​</a></h3><p>首先我们提取出初始化过程中涉及的调用栈大图：</p>',6),g=p(`<p>图中的方法虽然看上去又多又杂，但做的事情清清爽爽，那就是<strong>完成 Fiber 树中基本实体的创建</strong>。</p><p>什么是基本实体？基本实体有哪些？问题的答案藏在源码里，这里我为你提取了源码中的关键逻辑，首先是 legacyRenderSubtreeIntoContainer 方法。在 ReactDOM.render 函数体中，以下面代码所示的姿势调用了它：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">legacyRenderSubtreeIntoContainer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, element, container, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, callback);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">legacyRenderSubtreeIntoContainer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, element, container, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, callback);</span></span></code></pre></div><p>而 legacyRenderSubtreeIntoContainer 的关键逻辑如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">legacyRenderSubtreeIntoContainer</span><span style="color:#E1E4E8;">(parentComponent, children, container, forceHydrate, callback) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// container 对应的是我们传入的真实 DOM 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> container._reactRootContainer;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 初始化 fiberRoot 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> fiberRoot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span></span>
<span class="line"><span style="color:#E1E4E8;">    root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> container._reactRootContainer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">legacyCreateRootFromDOMContainer</span><span style="color:#E1E4E8;">(container, forceHydrate);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span></span>
<span class="line"><span style="color:#E1E4E8;">    fiberRoot </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root._internalRoot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof callback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> originalCallback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">      callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> instance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getPublicRootInstance</span><span style="color:#E1E4E8;">(fiberRoot);</span></span>
<span class="line"><span style="color:#E1E4E8;">        originalCallback.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(instance);</span></span>
<span class="line"><span style="color:#E1E4E8;">      };</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#6A737D;">// Initial mount should not be batched.</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 进入 unbatchedUpdates 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">unbatchedUpdates</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">updateContainer</span><span style="color:#E1E4E8;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span></span>
<span class="line"><span style="color:#E1E4E8;">    fiberRoot </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root._internalRoot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof callback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> _originalCallback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">      callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> instance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getPublicRootInstance</span><span style="color:#E1E4E8;">(fiberRoot);</span></span>
<span class="line"><span style="color:#E1E4E8;">        _originalCallback.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(instance);</span></span>
<span class="line"><span style="color:#E1E4E8;">      };</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#6A737D;">// Update</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">updateContainer</span><span style="color:#E1E4E8;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getPublicRootInstance</span><span style="color:#E1E4E8;">(fiberRoot);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">legacyRenderSubtreeIntoContainer</span><span style="color:#24292E;">(parentComponent, children, container, forceHydrate, callback) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// container 对应的是我们传入的真实 DOM 对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> container._reactRootContainer;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 初始化 fiberRoot 对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> fiberRoot;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// DOM 对象本身不存在 _reactRootContainer 属性，因此 root 为空</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">root) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若 root 为空，则初始化 _reactRootContainer，并将其值赋值给 root</span></span>
<span class="line"><span style="color:#24292E;">    root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> container._reactRootContainer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">legacyCreateRootFromDOMContainer</span><span style="color:#24292E;">(container, forceHydrate);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// legacyCreateRootFromDOMContainer 创建出的对象会有一个 _internalRoot 属性，将其赋值给 fiberRoot</span></span>
<span class="line"><span style="color:#24292E;">    fiberRoot </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root._internalRoot;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里处理的是 ReactDOM.render 入参中的回调函数，你了解即可</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof callback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> originalCallback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"><span style="color:#24292E;">      callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> instance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getPublicRootInstance</span><span style="color:#24292E;">(fiberRoot);</span></span>
<span class="line"><span style="color:#24292E;">        originalCallback.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(instance);</span></span>
<span class="line"><span style="color:#24292E;">      };</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#6A737D;">// Initial mount should not be batched.</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 进入 unbatchedUpdates 方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">unbatchedUpdates</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">updateContainer</span><span style="color:#24292E;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// else 逻辑处理的是非首次渲染的情况（即更新），其逻辑除了跳过了初始化工作，与楼上基本一致</span></span>
<span class="line"><span style="color:#24292E;">    fiberRoot </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root._internalRoot;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof callback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> _originalCallback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"><span style="color:#24292E;">      callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> instance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getPublicRootInstance</span><span style="color:#24292E;">(fiberRoot);</span></span>
<span class="line"><span style="color:#24292E;">        _originalCallback.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(instance);</span></span>
<span class="line"><span style="color:#24292E;">      };</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#6A737D;">// Update</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">updateContainer</span><span style="color:#24292E;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getPublicRootInstance</span><span style="color:#24292E;">(fiberRoot);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里我为你总结一下首次渲染过程中 legacyRenderSubtreeIntoContainer 方法的主要逻辑链路：</p>`,6),D=l("p",null,"在这个流程中，你需要关注到 fiberRoot 这个对象。fiberRoot 到底是什么呢？这里我将运行时的 root 和 fiberRoot 为你截取出来，其中 root 对象的结构如下图所示：",-1),b=l("p",null,"可以看出，root 对象（container._reactRootContainer）上有一个 _internalRoot 属性，这个 _internalRoot 也就是 fiberRoot。fiberRoot 的本质是一个 FiberRootNode 对象，其中包含一个 current 属性，该属性同样需要划重点。这里我为你高亮出 current 属性的部分内容：",-1),A=l("p",null,[s('或许你会对 current 对象包含的海量属性感到陌生和头大，但这并不妨碍你 Get 到"current 对象是一个 FiberNode 实例"这一点，'),l("strong",null,"而 FiberNode，正是 Fiber 节点对应的对象类型"),s(" 。current 对象是一个 Fiber 节点，不仅如此，它还是"),l("strong",null,"当前 Fiber 树的头部节点"),s("。")],-1),m=l("p",null,"考虑到 current 属性对应的 FiberNode 节点，在调用栈中实际是由 createHostRootFiber 方法创建的，React 源码中也有多处以 rootFiber 代指 current 对象，因此下文中我们将以 rootFiber 指代 current 对象。",-1),h=l("p",null,"读到这里，你脑海中应该不难形成一个这样的指向关系：",-1),C=p(`<p>其中，fiberRoot 的关联对象是真实 DOM 的容器节点；而 rootFiber 则作为虚拟 DOM 的根节点存在。<strong>这两个节点，将是后续整棵 Fiber 树构建的起点</strong>。</p><p>接下来，fiberRoot 将和 ReactDOM.render 方法的其他入参一起，被传入 updateContainer 方法，从而形成一个回调。这个回调，正是接下来要调用的 unbatchedUpdates 方法的入参。我们一起看看 unbatchedUpdates 做了什么，下面代码是对 unbatchedUpdates 主体逻辑的提取：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">unbatchedUpdates</span><span style="color:#E1E4E8;">(fn, a) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里是对上下文的处理，不必纠结</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> prevExecutionContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> executionContext;</span></span>
<span class="line"><span style="color:#E1E4E8;">  executionContext </span><span style="color:#F97583;">&amp;=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">~</span><span style="color:#E1E4E8;">BatchedContext;</span></span>
<span class="line"><span style="color:#E1E4E8;">  executionContext </span><span style="color:#F97583;">|=</span><span style="color:#E1E4E8;"> LegacyUnbatchedContext;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(a);</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// finally 逻辑里是对回调队列的处理，此处不用太关注</span></span>
<span class="line"><span style="color:#E1E4E8;">    executionContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> prevExecutionContext;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (executionContext </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> NoContext) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// Flush the immediate callbacks that were scheduled during this batch</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">resetRenderTimer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">flushSyncCallbackQueue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">unbatchedUpdates</span><span style="color:#24292E;">(fn, a) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里是对上下文的处理，不必纠结</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> prevExecutionContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> executionContext;</span></span>
<span class="line"><span style="color:#24292E;">  executionContext </span><span style="color:#D73A49;">&amp;=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">~</span><span style="color:#24292E;">BatchedContext;</span></span>
<span class="line"><span style="color:#24292E;">  executionContext </span><span style="color:#D73A49;">|=</span><span style="color:#24292E;"> LegacyUnbatchedContext;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 重点在这里，直接调用了传入的回调函数 fn，对应当前链路中的 updateContainer 方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(a);</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// finally 逻辑里是对回调队列的处理，此处不用太关注</span></span>
<span class="line"><span style="color:#24292E;">    executionContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> prevExecutionContext;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (executionContext </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> NoContext) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// Flush the immediate callbacks that were scheduled during this batch</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">resetRenderTimer</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">flushSyncCallbackQueue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 unbatchedUpdates 函数体里，当下你只需要 Get 到一个信息：它直接调用了传入的回调 fn。而在当前链路中，fn 是什么呢？<strong>fn 是一个针对 updateContainer 的调用</strong>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">unbatchedUpdates</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">updateContainer</span><span style="color:#E1E4E8;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">unbatchedUpdates</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">updateContainer</span><span style="color:#24292E;">(children, fiberRoot, parentComponent, callback);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>接下来我们很有必要去看看 updateContainer 里面的逻辑。这里我将主体代码提取如下（解析在注释里，如果没有耐心读完可以直接看文字解读）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">updateContainer</span><span style="color:#E1E4E8;">(element, container, parentComponent, callback) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这是一个 event 相关的入参，此处不必关注</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> eventTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">requestEventTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这是一个比较关键的入参，lane 表示优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> lane </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">requestUpdateLane</span><span style="color:#E1E4E8;">(current$1);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> update </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createUpdate</span><span style="color:#E1E4E8;">(eventTime, lane); </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// update 的 payload 对应的是一个 React 元素</span></span>
<span class="line"><span style="color:#E1E4E8;">  update.payload </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    element</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> element</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span>
<span class="line"><span style="color:#E1E4E8;">  callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callback </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> undefined </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (callback </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof callback </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;render(...): Expected the last optional \`callback\` argument to be a &#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function. Instead received: %s.&#39;</span><span style="color:#E1E4E8;">, callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    update.callback </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callback;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 将 update 入队</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">enqueueUpdate</span><span style="color:#E1E4E8;">(current$1, update);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 调度 fiberRoot </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">scheduleUpdateOnFiber</span><span style="color:#E1E4E8;">(current$1, lane, eventTime);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 返回当前节点（fiberRoot）的优先级</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lane;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">updateContainer</span><span style="color:#24292E;">(element, container, parentComponent, callback) {</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这是一个 event 相关的入参，此处不必关注</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> eventTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">requestEventTime</span><span style="color:#24292E;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这是一个比较关键的入参，lane 表示优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> lane </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">requestUpdateLane</span><span style="color:#24292E;">(current$1);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 结合 lane（优先级）信息，创建 update 对象，一个 update 对象意味着一个更新</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> update </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createUpdate</span><span style="color:#24292E;">(eventTime, lane); </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// update 的 payload 对应的是一个 React 元素</span></span>
<span class="line"><span style="color:#24292E;">  update.payload </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    element</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> element</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 处理 callback，这个 callback 其实就是我们调用 ReactDOM.render 时传入的 callback</span></span>
<span class="line"><span style="color:#24292E;">  callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> undefined </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (callback </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof callback </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;render(...): Expected the last optional \`callback\` argument to be a &#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function. Instead received: %s.&#39;</span><span style="color:#24292E;">, callback);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    update.callback </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callback;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 将 update 入队</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">enqueueUpdate</span><span style="color:#24292E;">(current$1, update);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 调度 fiberRoot </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">scheduleUpdateOnFiber</span><span style="color:#24292E;">(current$1, lane, eventTime);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 返回当前节点（fiberRoot）的优先级</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lane;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>updateContainer 的逻辑相对来说丰富了点，但大部分逻辑也是在干杂活，它做的最关键的事情可以总结为三件：</p><ol><li><p>请求当前 Fiber 节点的 lane（优先级）；</p></li><li><p>结合 lane（优先级），创建当前 Fiber 节点的 update 对象，并将其入队；</p></li><li><p>调度当前节点（rootFiber）。</p></li></ol><p>函数体中的 scheduleWork 其实就是 scheduleUpdateOnFiber，scheduleUpdateOnFiber 函数的任务是调度当前节点的更新。在这个函数中，会处理一系列与优先级、打断操作相关的逻辑。但是<strong>在 ReactDOM.render 发起的首次渲染链路中，这些意义都不大，因为这个渲染过程其实是同步的</strong>。我们可以尝试在 Source 面板中为该函数打上断点，逐行执行代码，会发现逻辑最终会走到下图的高亮处：</p>`,10),_=p('<p>performSyncWorkOnRoot直译过来就是&quot;执行根节点的同步任务&quot;，<strong>这里的&quot;同步&quot;二字需要注意，它明示了接下来即将开启的是一个同步的过程</strong>。这也正是为什么在整个渲染链路中，调度（Schedule）动作没有存在感的原因。</p><p>前面我们曾经提到过，performSyncWorkOnRoot 是 render 阶段的起点，render 阶段的任务就是完成 Fiber 树的构建，它是整个渲染链路中最核心的一环。在异步渲染的模式下，render 阶段应该是一个可打断的异步过程（下一讲我们就将针对 render 过程作详细的逻辑拆解）。</p><p>而现在，我相信你心里更多的疑惑在于：<strong>都说 Fiber 架构带来的异步渲染是 React 16 的亮点，为什么分析到现在，竟然发现 ReactDOM.render 触发的首次渲染是个同步过程呢</strong>？</p><h3 id="同步的-reactdom-render-异步的-reactdom-createroot" tabindex="-1">同步的 ReactDOM.render，异步的 ReactDOM.createRoot <a class="header-anchor" href="#同步的-reactdom-render-异步的-reactdom-createroot" aria-label="Permalink to &quot;同步的 ReactDOM.render，异步的 ReactDOM.createRoot&quot;">​</a></h3><p>其实在 React 16，包括近期发布的 React 17 小版本中，React 都有以下 3 种启动方式：</p><p><strong>legacy 模式</strong> ：<br><code>ReactDOM.render(&lt;App /&gt;, rootNode)</code>。这是当前 React App 使用的方式，当前没有计划删除本模式，但是这个模式可能不支持这些新功能。<br><strong>blocking 模式</strong> ：<br><code>ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code>。目前正在实验中，作为迁移到 concurrent 模式的第一个步骤。</p><p><strong>concurrent 模式</strong> ：<br><code>ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>。目前在实验中，未来稳定之后，打算作为 React 的默认开发模式，这个模式开启了所有的新功能。</p><p>在这 3 种模式中，<strong>我们常用的 ReactDOM.render 对应的是 legacy 模式，它实际触发的仍然是同步的渲染链路</strong> 。blocking 模式可以理解为 legacy 和 concurrent 之间的一个过渡形态，之所以会有这个模式，是因为 React 官方希望能够提供<a href="https://zh-hans.reactjs.org/docs/faq-versioning.html#commitment-to-stability" target="_blank" rel="noreferrer">渐进的迁移策略</a>，帮助我们更加顺滑地过渡到 Concurrent 模式。blocking 在实际应用中是比较低频的一个模式，了解即可。</p><p>按照官方的说法，&quot;<strong>长远来看，模式的数量会收敛，不用考虑不同的模式</strong>，但就目前而言，模式是一项重要的迁移策略，让每个人都能决定自己什么时候迁移，并按照自己的速度进行迁移&quot;。由此可以看出，Concurrent 模式确实是 React 的终极目标，也是其创作团队使用 Fiber 架构重写核心算法的动机所在。</p><h3 id="拓展-关于异步模式下的首次渲染链路" tabindex="-1">拓展：关于异步模式下的首次渲染链路 <a class="header-anchor" href="#拓展-关于异步模式下的首次渲染链路" aria-label="Permalink to &quot;拓展：关于异步模式下的首次渲染链路&quot;">​</a></h3><p>当下，如果想要开启异步渲染，我们需要调用 <code>ReactDOM.createRoot</code>方法来启动应用，那<code>ReactDOM.createRoot</code>开启的渲染链路与 ReactDOM.render 有何不同呢？</p><p>这里我修改一下调用方式，给你展示一下调用栈。由于本讲的源码取材于 React 17.0.0 版本，在这个版本中，createRoot 仍然是一个 unstable 的方法。因此实际调用的 API 应该是&quot;unstable_createRoot&quot;：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">ReactDOM.</span><span style="color:#B392F0;">unstable_createRoot</span><span style="color:#E1E4E8;">(rootElement).</span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">App </span><span style="color:#F97583;">/&gt;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">ReactDOM.</span><span style="color:#6F42C1;">unstable_createRoot</span><span style="color:#24292E;">(rootElement).</span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">App </span><span style="color:#D73A49;">/&gt;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>Concurrent 模式开启后，首次渲染的调用栈变成了如下图所示的样子：</p>',14),R=l("p",null,"乍一看，好像和 ReactDOM.render 差别很大，其实不然。图中 createRoot 所触发的逻辑仍然是一些准备性质的初始化工作，此处不必太纠结。关键在于下面我给你框出来的这部分，如下图所示：",-1),f=l("p",null,"我们拉近一点来看，如下图所示：",-1),k=l("p",null,"你会发现这地方也调用了一个 render。再顺着这个调用往下看，发现有大量的熟悉面孔：updateContainer、requestUpdateLane、createUpdate、scheduleUpdateOnFiber......这些函数在 ReactDOM.render 的调用栈中也出现过。",-1),v=l("p",null,"其实，当前你看到的这个 render 调用链路，和 ReactDOM.render 的调用链路是非常相似的，主要的区别在 scheduleUpdateOnFiber 的这个判断里：",-1),M=p(`<p>在异步渲染模式下，由于请求到的 lane 不再是 SyncLane（同步优先级），故不会再走到 performSyncWorkOnRoot 这个调用，而是会转而执行 else 中调度相关的逻辑。</p><p>这里有个点要给你点出来------React 是如何知道当前处于哪个模式的呢？我们可以以 requestUpdateLane 函数为例，下面是它局部的代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">requestUpdateLane</span><span style="color:#E1E4E8;">(fiber) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 获取 mode 属性</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> mode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fiber.mode;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 结合 mode 属性判断当前的</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((mode </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> BlockingMode) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> NoMode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> SyncLane;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((mode </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> ConcurrentMode) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> NoMode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getCurrentPriorityLevel</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> ImmediatePriority$1 </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> SyncLane </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> SyncBatchedLane;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lane;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">requestUpdateLane</span><span style="color:#24292E;">(fiber) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 获取 mode 属性</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> mode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fiber.mode;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 结合 mode 属性判断当前的</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((mode </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> BlockingMode) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> NoMode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> SyncLane;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((mode </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> ConcurrentMode) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> NoMode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getCurrentPriorityLevel</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> ImmediatePriority$1 </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> SyncLane </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> SyncBatchedLane;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lane;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面代码中需要注意 fiber节点上的 mode 属性：<strong>React 将会通过修改 mode 属性为不同的值，来标识当前处于哪个渲染模式；在执行过程中，也是通过判断这个属性，来区分不同的渲染模式</strong>。</p><p>因此不同的渲染模式在挂载阶段的差异，本质上来说并不是工作流的差异（其工作流涉及 初始化 → render → commit 这 3 个步骤），而是 mode 属性的差异。mode 属性决定着这个工作流是一气呵成（同步）的，还是分片执行（异步）的。</p><p>关于异步挂载/更新的实现细节，我们将在后续的第 16 讲&quot;Fiber 架构实现原理与编码形态&quot;中详细探讨。</p><h3 id="fiber-架构一定是异步渲染吗" tabindex="-1">Fiber 架构一定是异步渲染吗？ <a class="header-anchor" href="#fiber-架构一定是异步渲染吗" aria-label="Permalink to &quot;Fiber 架构一定是异步渲染吗？&quot;">​</a></h3><p>之前我曾经被读者朋友问到过这样的问题：<strong>React 16 如果没有开启 Concurrent 模式，那它还能叫 Fiber 架构吗</strong>？</p><p>这个问题很有意思，从动机上来看，Fiber 架构的设计确实主要是为了 Concurrent 而存在。但经过了本讲紧贴源码的讲解，相信你也能够看出，在 React 16，包括已发布的 React 17 版本中，不管是否是 Concurrent，整个数据结构层面的设计、包括贯穿整个渲染链路的处理逻辑，已经完全用 Fiber 重构了一遍。站在这个角度来看，Fiber 架构在 React 中并不能够和异步渲染画严格的等号，它是一种<strong>同时兼容了同步渲染与异步渲染的设计</strong>。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>从本讲开始，我们以 ReactDOM.render 所触发的首次渲染为切入点，试图串联 React Fiber 架构下完整的工作链路，本讲为整个源码链路分析的前半部分。</p><p>正所谓&quot;磨刀不误砍柴工&quot;。虽然当前的进度条只推到了初始化这个位置，但在这部分的分析过程中，相信你已经对Fiber 树的初始形态、Fiber 根节点的创建过程建立了感性的认知，同时把握住了 ReactDOM.render 同步渲染的过程特征，理解了 React 当下共存的3种渲染方式。在此基础上，我们再去理解 render 过程，就会轻松得多。</p><p>整个初始化的工作过程都是在为后续的 render 阶段做准备。现在，我们的 Fiber Tree 还处在只有根节点的起始状态。接下来，我们就要进入到最最关键的 render 阶段里去，一起去看看这棵树是怎么一点点丰满起来的，加油！</p>`,13);function q(O,B,x,T,S,I){const n=e("Image");return t(),c("div",null,[E,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmEOAGbJ5AAAxGM0SPWA261.png"}),s(),y,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmEuALVycAAEENjoXJ6E407.png"}),s(),i,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmFKAFeHBAAQn6ZuFPrI619.png"}),s(),d,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmFmAXkYlAAI2ONTKc9s081.png"}),s(),u,a(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmGKAFb5NAAItD2ouVoc061.png"}),s(),F,a(n,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmGqAU-42AABcbqaOzFc800.png"}),s(),g,a(n,{alt:"Lark20201120-182606.png",src:"https://s0.lgstatic.com/i/image/M00/70/03/CgqCHl-3mfWABLi5AADUzMV7iHA320.png"}),s(),D,a(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmH6AKzPPAADcEbfK6K4199.png"}),s(),b,a(n,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmISANlmfAADLqX8jue0154.png"}),s(),A,m,h,a(n,{alt:"Lark20201120-182610.png",src:"https://s0.lgstatic.com/i/image/M00/6F/F8/Ciqc1F-3mh-AZrlvAABgy8S1u44402.png"}),s(),C,a(n,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmJGATpFIAAPP-sFYf70749.png"}),s(),_,a(n,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image/M00/6E/D9/CgqCHl-zmJyAbYZNAAFI67qKm98019.png"}),s(),R,a(n,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmKKAF0ODAADhhdYWzo0441.png"}),s(),f,a(n,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image/M00/70/75/CgqCHl-7GiaAUY_zAAxz8mfEvT0309.png"}),s(),k,v,a(n,{alt:"image.png",src:"https://s0.lgstatic.com/i/image/M00/6E/CE/Ciqc1F-zmMKAJFKYAAMfoIVWxeM650.png"}),s(),M])}const N=o(r,[["render",q]]);export{U as __pageData,N as default};
