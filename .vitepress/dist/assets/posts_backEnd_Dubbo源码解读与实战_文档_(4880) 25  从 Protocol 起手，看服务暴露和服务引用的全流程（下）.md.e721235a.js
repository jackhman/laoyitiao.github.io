import{_ as o,j as e,o as t,g as c,k as n,h as a,Q as l,s as p}from"./chunks/framework.4e7d56ce.js";const f=JSON.parse('{"title":"25从Protocol起手，看服务暴露和服务引用的全流程（下）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4880) 25  从 Protocol 起手，看服务暴露和服务引用的全流程（下）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4880) 25  从 Protocol 起手，看服务暴露和服务引用的全流程（下）.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4880) 25  从 Protocol 起手，看服务暴露和服务引用的全流程（下）.md"},E=l(`<h1 id="_25从protocol起手-看服务暴露和服务引用的全流程-下" tabindex="-1">25从Protocol起手，看服务暴露和服务引用的全流程（下） <a class="header-anchor" href="#_25从protocol起手-看服务暴露和服务引用的全流程-下" aria-label="Permalink to &quot;25从Protocol起手，看服务暴露和服务引用的全流程（下）&quot;">​</a></h1><p>在上一课时，我们以 DubboProtocol 实现为基础，详细介绍了 Dubbo 服务发布的核心流程。在本课时，我们继续介绍 DubboProtocol 中<strong>服务引用</strong>相关的实现。</p><h3 id="refer-流程" tabindex="-1">refer 流程 <a class="header-anchor" href="#refer-流程" aria-label="Permalink to &quot;refer 流程&quot;">​</a></h3><p>下面我们开始介绍 DubboProtocol 中引用服务的相关实现，其核心实现在 protocolBindingRefer() 方法中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">protocolBindingRefer</span><span style="color:#E1E4E8;">(Class</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> serviceType, URL url) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">optimizeSerialization</span><span style="color:#E1E4E8;">(url); </span><span style="color:#6A737D;">// 进行序列化优化，注册需要优化的类</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建DubboInvoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    DubboInvoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> DubboInvoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;(serviceType, url, </span><span style="color:#B392F0;">getClients</span><span style="color:#E1E4E8;">(url), invokers);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将上面创建DubboInvoker对象添加到invoker集合之中</span></span>
<span class="line"><span style="color:#E1E4E8;">    invokers.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(invoker); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">protocolBindingRefer</span><span style="color:#24292E;">(Class</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> serviceType, URL url) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">optimizeSerialization</span><span style="color:#24292E;">(url); </span><span style="color:#6A737D;">// 进行序列化优化，注册需要优化的类</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建DubboInvoker对象</span></span>
<span class="line"><span style="color:#24292E;">    DubboInvoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> DubboInvoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;(serviceType, url, </span><span style="color:#6F42C1;">getClients</span><span style="color:#24292E;">(url), invokers);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将上面创建DubboInvoker对象添加到invoker集合之中</span></span>
<span class="line"><span style="color:#24292E;">    invokers.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(invoker); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invoker;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>关于 DubboInvoker 的具体实现，我们先暂时不做深入分析。这里我们需要先关注的是<strong>getClients() 方法</strong> ，它创建了底层发送请求和接收响应的 Client 集合，其核心分为了两个部分，一个是针对<strong>共享连接</strong> 的处理，另一个是针对<strong>独享连接</strong>的处理，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ExchangeClient</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">getClients</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 是否使用共享连接</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> useShareConnect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// CONNECTIONS_KEY参数值决定了后续建立连接的数量</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> connections </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(CONNECTIONS_KEY, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">ReferenceCountExchangeClient</span><span style="color:#E1E4E8;">&gt; shareClients </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (connections </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 如果没有连接数的相关配置，默认使用共享连接的方式</span></span>
<span class="line"><span style="color:#E1E4E8;">        useShareConnect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 确定建立共享连接的条数，默认只建立一条共享连接</span></span>
<span class="line"><span style="color:#E1E4E8;">        String shareConnectionsStr </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(SHARE_CONNECTIONS_KEY, (String) </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        connections </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.</span><span style="color:#B392F0;">parseInt</span><span style="color:#E1E4E8;">(StringUtils.</span><span style="color:#B392F0;">isBlank</span><span style="color:#E1E4E8;">(shareConnectionsStr) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> ConfigUtils.</span><span style="color:#B392F0;">getProperty</span><span style="color:#E1E4E8;">(SHARE_CONNECTIONS_KEY,</span></span>
<span class="line"><span style="color:#E1E4E8;">                DEFAULT_SHARE_CONNECTIONS) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> shareConnectionsStr);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 创建公共ExchangeClient集合</span></span>
<span class="line"><span style="color:#E1E4E8;">        shareClients </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getSharedClient</span><span style="color:#E1E4E8;">(url, connections);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 整理要返回的ExchangeClient集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">ExchangeClient</span><span style="color:#E1E4E8;">[] clients </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ExchangeClient</span><span style="color:#E1E4E8;">[connections];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> clients.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (useShareConnect) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            clients[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> shareClients.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 不使用公共连接的情况下，会创建单独的ExchangeClient实例</span></span>
<span class="line"><span style="color:#E1E4E8;">            clients[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">initClient</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> clients;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ExchangeClient</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">getClients</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 是否使用共享连接</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> useShareConnect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// CONNECTIONS_KEY参数值决定了后续建立连接的数量</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> connections </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(CONNECTIONS_KEY, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">ReferenceCountExchangeClient</span><span style="color:#24292E;">&gt; shareClients </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (connections </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 如果没有连接数的相关配置，默认使用共享连接的方式</span></span>
<span class="line"><span style="color:#24292E;">        useShareConnect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 确定建立共享连接的条数，默认只建立一条共享连接</span></span>
<span class="line"><span style="color:#24292E;">        String shareConnectionsStr </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(SHARE_CONNECTIONS_KEY, (String) </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        connections </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.</span><span style="color:#6F42C1;">parseInt</span><span style="color:#24292E;">(StringUtils.</span><span style="color:#6F42C1;">isBlank</span><span style="color:#24292E;">(shareConnectionsStr) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> ConfigUtils.</span><span style="color:#6F42C1;">getProperty</span><span style="color:#24292E;">(SHARE_CONNECTIONS_KEY,</span></span>
<span class="line"><span style="color:#24292E;">                DEFAULT_SHARE_CONNECTIONS) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> shareConnectionsStr);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 创建公共ExchangeClient集合</span></span>
<span class="line"><span style="color:#24292E;">        shareClients </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getSharedClient</span><span style="color:#24292E;">(url, connections);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 整理要返回的ExchangeClient集合</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">ExchangeClient</span><span style="color:#24292E;">[] clients </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ExchangeClient</span><span style="color:#24292E;">[connections];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> clients.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (useShareConnect) {</span></span>
<span class="line"><span style="color:#24292E;">            clients[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> shareClients.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 不使用公共连接的情况下，会创建单独的ExchangeClient实例</span></span>
<span class="line"><span style="color:#24292E;">            clients[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">initClient</span><span style="color:#24292E;">(url);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> clients;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>当使用独享连接的时候，对每个 Service 建立固定数量的 Client，每个 Client 维护一个底层连接。如下图所示，就是针对每个 Service 都启动了两个独享连接：</p>`,8),y=p("p",null,"Service 独享连接示意图",-1),i=p("p",null,"当使用共享连接的时候，会区分不同的网络地址（host:port），一个地址只建立固定数量的共享连接。如下图所示，Provider 1 暴露了多个服务，Consumer 引用了 Provider 1 中的多个服务，共享连接是说 Consumer 调用 Provider 1 中的多个服务时，是通过固定数量的共享 TCP 长连接进行数据传输，这样就可以达到减少服务端连接数的目的。",-1),C=l(`<p>Service 共享连接示意图</p><p>那怎么去创建共享连接呢？<strong>创建共享连接的实现细节是在 getSharedClient() 方法中</strong> ，它首先从 referenceClientMap 缓存（Map&lt;String, List<code>&lt;ReferenceCountExchangeClient&gt;</code>&gt; 类型）中查询 Key（host 和 port 拼接成的字符串）对应的共享 Client 集合，如果查找到的 Client 集合全部可用，则直接使用这些缓存的 Client，否则要创建新的 Client 来补充替换缓存中不可用的 Client。示例代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ReferenceCountExchangeClient</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getSharedClient</span><span style="color:#E1E4E8;">(URL url, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> connectNum) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getAddress</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 获取对端的地址(host:port)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从referenceClientMap集合中，获取与该地址连接的ReferenceCountExchangeClient集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">ReferenceCountExchangeClient</span><span style="color:#E1E4E8;">&gt; clients </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> referenceClientMap.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// checkClientCanUse()方法中会检测clients集合中的客户端是否全部可用</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">checkClientCanUse</span><span style="color:#E1E4E8;">(clients)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">batchClientRefIncr</span><span style="color:#E1E4E8;">(clients); </span><span style="color:#6A737D;">// 客户端全部可用时</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> clients;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    locks.</span><span style="color:#B392F0;">putIfAbsent</span><span style="color:#E1E4E8;">(key, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> (locks.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(key)) { </span><span style="color:#6A737D;">// 针对指定地址的客户端进行加锁，分区加锁可以提高并发度</span></span>
<span class="line"><span style="color:#E1E4E8;">        clients </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> referenceClientMap.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">checkClientCanUse</span><span style="color:#E1E4E8;">(clients)) { </span><span style="color:#6A737D;">// double check，再次检测客户端是否全部可用</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">batchClientRefIncr</span><span style="color:#E1E4E8;">(clients); </span><span style="color:#6A737D;">// 增加应用Client的次数</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> clients;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        connectNum </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(connectNum, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 至少一个共享连接</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果当前Clients集合为空，则直接通过initClient()方法初始化所有共享客户端</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CollectionUtils.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(clients)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            clients </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buildReferenceCountExchangeClientList</span><span style="color:#E1E4E8;">(url, connectNum);</span></span>
<span class="line"><span style="color:#E1E4E8;">            referenceClientMap.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(key, clients);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 如果只有部分共享客户端不可用，则只需要处理这些不可用的客户端</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> clients.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">(); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                ReferenceCountExchangeClient referenceCountExchangeClient </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> clients.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (referenceCountExchangeClient </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> referenceCountExchangeClient.</span><span style="color:#B392F0;">isClosed</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    clients.</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">(i, </span><span style="color:#B392F0;">buildReferenceCountExchangeClient</span><span style="color:#E1E4E8;">(url));</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 增加引用</span></span>
<span class="line"><span style="color:#E1E4E8;">                referenceCountExchangeClient.</span><span style="color:#B392F0;">incrementAndGetCount</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 清理locks集合中的锁对象，防止内存泄漏，如果key对应的服务宕机或是下线，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里不进行清理的话，这个用于加锁的Object对象是无法被GC的，从而出现内存泄漏</span></span>
<span class="line"><span style="color:#E1E4E8;">        locks.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(key); </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> clients;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ReferenceCountExchangeClient</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getSharedClient</span><span style="color:#24292E;">(URL url, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> connectNum) {</span></span>
<span class="line"><span style="color:#24292E;">    String key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getAddress</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 获取对端的地址(host:port)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从referenceClientMap集合中，获取与该地址连接的ReferenceCountExchangeClient集合</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">ReferenceCountExchangeClient</span><span style="color:#24292E;">&gt; clients </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> referenceClientMap.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// checkClientCanUse()方法中会检测clients集合中的客户端是否全部可用</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">checkClientCanUse</span><span style="color:#24292E;">(clients)) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">batchClientRefIncr</span><span style="color:#24292E;">(clients); </span><span style="color:#6A737D;">// 客户端全部可用时</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> clients;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    locks.</span><span style="color:#6F42C1;">putIfAbsent</span><span style="color:#24292E;">(key, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> (locks.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(key)) { </span><span style="color:#6A737D;">// 针对指定地址的客户端进行加锁，分区加锁可以提高并发度</span></span>
<span class="line"><span style="color:#24292E;">        clients </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> referenceClientMap.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">checkClientCanUse</span><span style="color:#24292E;">(clients)) { </span><span style="color:#6A737D;">// double check，再次检测客户端是否全部可用</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">batchClientRefIncr</span><span style="color:#24292E;">(clients); </span><span style="color:#6A737D;">// 增加应用Client的次数</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> clients;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        connectNum </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(connectNum, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 至少一个共享连接</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果当前Clients集合为空，则直接通过initClient()方法初始化所有共享客户端</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CollectionUtils.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(clients)) {</span></span>
<span class="line"><span style="color:#24292E;">            clients </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buildReferenceCountExchangeClientList</span><span style="color:#24292E;">(url, connectNum);</span></span>
<span class="line"><span style="color:#24292E;">            referenceClientMap.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(key, clients);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 如果只有部分共享客户端不可用，则只需要处理这些不可用的客户端</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> clients.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">(); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                ReferenceCountExchangeClient referenceCountExchangeClient </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> clients.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (referenceCountExchangeClient </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> referenceCountExchangeClient.</span><span style="color:#6F42C1;">isClosed</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                    clients.</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">(i, </span><span style="color:#6F42C1;">buildReferenceCountExchangeClient</span><span style="color:#24292E;">(url));</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 增加引用</span></span>
<span class="line"><span style="color:#24292E;">                referenceCountExchangeClient.</span><span style="color:#6F42C1;">incrementAndGetCount</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 清理locks集合中的锁对象，防止内存泄漏，如果key对应的服务宕机或是下线，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里不进行清理的话，这个用于加锁的Object对象是无法被GC的，从而出现内存泄漏</span></span>
<span class="line"><span style="color:#24292E;">        locks.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(key); </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> clients;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里使用的 ExchangeClient 实现是 ReferenceCountExchangeClient，它是 ExchangeClient 的一个装饰器，在原始 ExchangeClient 对象基础上添加了引用计数的功能。</p><p>ReferenceCountExchangeClient 中除了持有被修饰的 ExchangeClient 对象外，还有一个 referenceCount 字段（AtomicInteger 类型），用于记录该 Client 被应用的次数。从下图中我们可以看到，在 ReferenceCountExchangeClient 的构造方法以及 incrementAndGetCount() 方法中会增加引用次数，在 close() 方法中则会减少引用次数。</p>`,5),F=l(`<p>referenceCount 修改调用栈</p><p>这样，对于同一个地址的共享连接，就可以满足两个基本需求：</p><ol><li><p>当引用次数减到 0 的时候，ExchangeClient 连接关闭；</p></li><li><p>当引用次数未减到 0 的时候，底层的 ExchangeClient 不能关闭。</p></li></ol><p>还有一个需要注意的细节是 ReferenceCountExchangeClient.close() 方法，在关闭底层 ExchangeClient 对象之后，会立即创建一个 LazyConnectExchangeClient ，也有人称其为&quot;幽灵连接&quot;。具体逻辑如下所示，这里的 LazyConnectExchangeClient 主要用于异常情况的兜底：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> timeout) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 引用次数减到0，关闭底层的ExchangeClient，具体操作有：停掉心跳任务、重连任务以及关闭底层Channel，这些在前文介绍HeaderExchangeClient的时候已经详细分析过了，这里不再赘述</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (referenceCount.</span><span style="color:#B392F0;">decrementAndGet</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (timeout </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            client.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            client.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(timeout);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 创建LazyConnectExchangeClient，并将client字段指向该对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">replaceWithLazyClient</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">replaceWithLazyClient</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 在原有的URL之上，添加一些LazyConnectExchangeClient特有的参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    URL lazyUrl </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> URLBuilder.</span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;">(url)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.TRUE)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(RECONNECT_KEY, Boolean.FALSE)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(SEND_RECONNECT_KEY, Boolean.TRUE.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;warning&quot;</span><span style="color:#E1E4E8;">, Boolean.TRUE.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;_client_memo&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;referencecounthandler.replacewithlazyclient&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果当前client字段已经指向了LazyConnectExchangeClient，则不需要再次创建LazyConnectExchangeClient兜底了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(client </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> LazyConnectExchangeClient) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> client.</span><span style="color:#B392F0;">isClosed</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// ChannelHandler依旧使用原始ExchangeClient使用的Handler，即DubboProtocol中的requestHandler字段</span></span>
<span class="line"><span style="color:#E1E4E8;">        client </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LazyConnectExchangeClient</span><span style="color:#E1E4E8;">(lazyUrl, client.</span><span style="color:#B392F0;">getExchangeHandler</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> timeout) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 引用次数减到0，关闭底层的ExchangeClient，具体操作有：停掉心跳任务、重连任务以及关闭底层Channel，这些在前文介绍HeaderExchangeClient的时候已经详细分析过了，这里不再赘述</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (referenceCount.</span><span style="color:#6F42C1;">decrementAndGet</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (timeout </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            client.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            client.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(timeout);</span></span>
<span class="line"><span style="color:#24292E;">        } </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 创建LazyConnectExchangeClient，并将client字段指向该对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">replaceWithLazyClient</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">replaceWithLazyClient</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 在原有的URL之上，添加一些LazyConnectExchangeClient特有的参数</span></span>
<span class="line"><span style="color:#24292E;">    URL lazyUrl </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> URLBuilder.</span><span style="color:#6F42C1;">from</span><span style="color:#24292E;">(url)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(LAZY_CONNECT_INITIAL_STATE_KEY, Boolean.TRUE)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(RECONNECT_KEY, Boolean.FALSE)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(SEND_RECONNECT_KEY, Boolean.TRUE.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;warning&quot;</span><span style="color:#24292E;">, Boolean.TRUE.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(LazyConnectExchangeClient.REQUEST_WITH_WARNING_KEY, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;_client_memo&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;referencecounthandler.replacewithlazyclient&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果当前client字段已经指向了LazyConnectExchangeClient，则不需要再次创建LazyConnectExchangeClient兜底了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(client </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> LazyConnectExchangeClient) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> client.</span><span style="color:#6F42C1;">isClosed</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// ChannelHandler依旧使用原始ExchangeClient使用的Handler，即DubboProtocol中的requestHandler字段</span></span>
<span class="line"><span style="color:#24292E;">        client </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LazyConnectExchangeClient</span><span style="color:#24292E;">(lazyUrl, client.</span><span style="color:#6F42C1;">getExchangeHandler</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>LazyConnectExchangeClient 也是 ExchangeClient 的装饰器，它会在原有 ExchangeClient 对象的基础上添加懒加载的功能。LazyConnectExchangeClient 在构造方法中不会创建底层持有连接的 Client，而是在需要发送请求的时候，才会调用 initClient() 方法进行 Client 的创建，如下图调用关系所示：</p>`,6),u=l(`<p>initClient() 方法的调用位置</p><p>initClient() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">initClient</span><span style="color:#E1E4E8;">() throws RemotingException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (client </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 底层Client已经初始化过了，这里不再初始化</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    connectLock.</span><span style="color:#B392F0;">lock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (client </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">; } </span><span style="color:#6A737D;">// double check</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 通过Exchangers门面类，创建ExchangeClient对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.client </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Exchangers.</span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;">(url, requestHandler);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        connectLock.</span><span style="color:#B392F0;">unlock</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">initClient</span><span style="color:#24292E;">() throws RemotingException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (client </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 底层Client已经初始化过了，这里不再初始化</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    connectLock.</span><span style="color:#6F42C1;">lock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (client </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">; } </span><span style="color:#6A737D;">// double check</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 通过Exchangers门面类，创建ExchangeClient对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.client </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Exchangers.</span><span style="color:#6F42C1;">connect</span><span style="color:#24292E;">(url, requestHandler);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        connectLock.</span><span style="color:#6F42C1;">unlock</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这些发送请求的方法中，除了通过 initClient() 方法初始化底层 ExchangeClient 外，还会调用warning() 方法，其会根据当前 URL 携带的参数决定是否打印 WARN 级别日志。为了防止瞬间打印大量日志的情况发生，这里有打印的频率限制，默认每发送 5000 次请求打印 1 条日志。你可以看到在前面展示的兜底场景中，我们就开启了打印日志的选项。</p><p><strong>分析完 getSharedClient() 方法创建共享 Client 的核心流程之后，我们回到 DubboProtocol 中，继续介绍创建独享 Client 的流程。</strong></p><p>创建独享 Client 的入口在<strong>DubboProtocol.initClient() 方法</strong>，它首先会在 URL 中设置一些默认的参数，然后根据 LAZY_CONNECT_KEY 参数决定是否使用 LazyConnectExchangeClient 进行封装，实现懒加载功能，如下代码所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> ExchangeClient </span><span style="color:#B392F0;">initClient</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取客户端扩展名并进行检查，省略检测的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    String str </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(CLIENT_KEY, url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(SERVER_KEY, DEFAULT_REMOTING_CLIENT));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设置Codec2的扩展名</span></span>
<span class="line"><span style="color:#E1E4E8;">    url </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">addParameter</span><span style="color:#E1E4E8;">(CODEC_KEY, DubboCodec.NAME);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设置默认的心跳间隔</span></span>
<span class="line"><span style="color:#E1E4E8;">    url </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">addParameterIfAbsent</span><span style="color:#E1E4E8;">(HEARTBEAT_KEY, String.</span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;">(DEFAULT_HEARTBEAT));</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExchangeClient client;    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果配置了延迟创建连接的特性，则创建LazyConnectExchangeClient</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(LAZY_CONNECT_KEY, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        client </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LazyConnectExchangeClient</span><span style="color:#E1E4E8;">(url, requestHandler);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 未使用延迟连接功能，则直接创建HeaderExchangeClient</span></span>
<span class="line"><span style="color:#E1E4E8;">        client </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Exchangers.</span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;">(url, requestHandler);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> client;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> ExchangeClient </span><span style="color:#6F42C1;">initClient</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取客户端扩展名并进行检查，省略检测的逻辑</span></span>
<span class="line"><span style="color:#24292E;">    String str </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(CLIENT_KEY, url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(SERVER_KEY, DEFAULT_REMOTING_CLIENT));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设置Codec2的扩展名</span></span>
<span class="line"><span style="color:#24292E;">    url </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">addParameter</span><span style="color:#24292E;">(CODEC_KEY, DubboCodec.NAME);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设置默认的心跳间隔</span></span>
<span class="line"><span style="color:#24292E;">    url </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">addParameterIfAbsent</span><span style="color:#24292E;">(HEARTBEAT_KEY, String.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">(DEFAULT_HEARTBEAT));</span></span>
<span class="line"><span style="color:#24292E;">    ExchangeClient client;    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果配置了延迟创建连接的特性，则创建LazyConnectExchangeClient</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(LAZY_CONNECT_KEY, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">        client </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LazyConnectExchangeClient</span><span style="color:#24292E;">(url, requestHandler);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 未使用延迟连接功能，则直接创建HeaderExchangeClient</span></span>
<span class="line"><span style="color:#24292E;">        client </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Exchangers.</span><span style="color:#6F42C1;">connect</span><span style="color:#24292E;">(url, requestHandler);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> client;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里涉及的 LazyConnectExchangeClient 装饰器以及 Exchangers 门面类在前面已经深入分析过了，就不再赘述了。</p><p>DubboProtocol 中还剩下几个方法没有介绍，这里你只需要简单了解一下它们的实现即可。</p><ul><li><p>batchClientRefIncr() 方法：会遍历传入的集合，将其中的每个 ReferenceCountExchangeClient 对象的引用加一。</p></li><li><p>buildReferenceCountExchangeClient() 方法：会调用上面介绍的 initClient() 创建 Client 对象，然后再包装一层 ReferenceCountExchangeClient 进行修饰，最后返回。该方法主要用于创建共享 Client。</p></li></ul><h3 id="destroy方法" tabindex="-1">destroy方法 <a class="header-anchor" href="#destroy方法" aria-label="Permalink to &quot;destroy方法&quot;">​</a></h3><p>在 DubboProtocol 销毁的时候，会调用 destroy() 方法释放底层资源，其中就涉及 export 流程中创建的 ProtocolServer 对象以及 refer 流程中创建的 Client。</p><p>DubboProtocol.destroy() 方法首先会逐个关闭 serverMap 集合中的 ProtocolServer 对象，相关代码片段如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (String key </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;(serverMap.</span><span style="color:#B392F0;">keySet</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ProtocolServer protocolServer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> serverMap.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (protocolServer </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;}</span></span>
<span class="line"><span style="color:#E1E4E8;">    RemotingServer server </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> protocolServer.</span><span style="color:#B392F0;">getRemotingServer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 在close()方法中，发送ReadOnly请求、阻塞指定时间、关闭底层的定时任务、关闭相关线程池，最终，会断开所有连接，关闭Server。这些逻辑在前文介绍HeaderExchangeServer、NettyServer等实现的时候，已经详细分析过了，这里不再展开</span></span>
<span class="line"><span style="color:#E1E4E8;">    server.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(ConfigurationUtils.</span><span style="color:#B392F0;">getServerShutdownTimeout</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (String key </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;(serverMap.</span><span style="color:#6F42C1;">keySet</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">    ProtocolServer protocolServer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> serverMap.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (protocolServer </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;}</span></span>
<span class="line"><span style="color:#24292E;">    RemotingServer server </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> protocolServer.</span><span style="color:#6F42C1;">getRemotingServer</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 在close()方法中，发送ReadOnly请求、阻塞指定时间、关闭底层的定时任务、关闭相关线程池，最终，会断开所有连接，关闭Server。这些逻辑在前文介绍HeaderExchangeServer、NettyServer等实现的时候，已经详细分析过了，这里不再展开</span></span>
<span class="line"><span style="color:#24292E;">    server.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(ConfigurationUtils.</span><span style="color:#6F42C1;">getServerShutdownTimeout</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ConfigurationUtils.getServerShutdownTimeout() 方法返回的阻塞时长默认是 10 秒，我们可以通过 dubbo.service.shutdown.wait 或是 dubbo.service.shutdown.wait.seconds 进行配置。</p><p>之后，DubboProtocol.destroy() 方法会逐个关闭 referenceClientMap 集合中的 Client，逻辑与上述关闭ProtocolServer的逻辑相同，这里不再重复。只不过需要注意前面我们提到的 ReferenceCountExchangeClient 的存在，只有引用减到 0，底层的 Client 才会真正销毁。</p><p>最后，DubboProtocol.destroy() 方法会调用父类 AbstractProtocol 的 destroy() 方法，销毁全部 Invoker 对象，前面已经介绍过 AbstractProtocol.destroy() 方法的实现，这里也不再重复。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时我们继续上一课时的话题，以 DubboProtocol 为例，介绍了 Dubbo 在 Protocol 层实现服务引用的核心流程。我们首先介绍了 DubboProtocol 初始化 Client 的核心逻辑，分析了共享连接和独立连接的模型，后续还讲解了ReferenceCountExchangeClient、LazyConnectExchangeClient 等装饰器的功能和实现，最后说明了 destroy() 方法释放底层资源的相关实现。</p><p>关于 DubboProtocol，你若还有什么疑问或想法，欢迎你留言跟我分享。下一课时，我们将开始深入介绍 Dubbo 的&quot;心脏&quot;------ Invoker 接口的相关实现，这是我们的一篇加餐文章，记得按时来听课。</p>`,20);function g(A,h,d,D,_,v){const s=e("Image");return t(),c("div",null,[E,n(s,{alt:"Lark20201020-171207.png",src:"https://s0.lgstatic.com/i/image/M00/61/11/CgqCHl-OqnqAD_WFAAGYtk5Nou4688.png"}),a(),y,i,n(s,{alt:"Lark20201020-171159.png",src:"https://s0.lgstatic.com/i/image/M00/61/06/Ciqc1F-OqoOAHURKAAF2m0HX5qU972.png"}),a(),C,n(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/61/06/Ciqc1F-OqqeAHAStAAF3BXy1LnA608.png"}),a(),F,n(s,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/61/11/CgqCHl-OqrqAHcvUAAC9KpqKEBQ887.png"}),a(),u])}const x=o(r,[["render",g]]);export{f as __pageData,x as default};
