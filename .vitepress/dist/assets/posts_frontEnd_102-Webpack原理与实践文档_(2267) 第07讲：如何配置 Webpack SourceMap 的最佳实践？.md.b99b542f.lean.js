import{_ as o,D as e,o as c,g as t,J as p,h as a,m as s,Q as l}from"./chunks/framework.f67d7268.js";const ns=JSON.parse('{"title":"第07讲：如何配置WebpackSourceMap的最佳实践？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/102-Webpack原理与实践文档/(2267) 第07讲：如何配置 Webpack SourceMap 的最佳实践？.md","filePath":"posts/frontEnd/102-Webpack原理与实践文档/(2267) 第07讲：如何配置 Webpack SourceMap 的最佳实践？.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/102-Webpack原理与实践文档/(2267) 第07讲：如何配置 Webpack SourceMap 的最佳实践？.md"},E=s("h1",{id:"第07讲-如何配置webpacksourcemap的最佳实践",tabindex:"-1"},[a("第07讲：如何配置WebpackSourceMap的最佳实践？ "),s("a",{class:"header-anchor",href:"#第07讲-如何配置webpacksourcemap的最佳实践","aria-label":'Permalink to "第07讲：如何配置WebpackSourceMap的最佳实践？"'},"​")],-1),i=s("p",null,"上一讲我们介绍了如何使用 Webpack Dev Server 提高开发效率，今天我们来介绍需要编译的前端项目该如何调试。",-1),y=s("p",null,"通过构建或者编译之类的操作，我们将开发阶段编写的源代码转换为能够在生产环境中运行的代码，这种进步同时也意味着我们实际运行的代码和我们真正编写的代码之间存在很大的差异。",-1),u=s("p",null,"在这种情况下，如果需要调试我们的应用，或是应用运行的过程中出现意料之外的错误，那我们将无从下手。因为无论是调试还是报错，都是基于构建后的代码进行的，我们只能看到错误信息在构建后代码中具体的位置，却很难直接定位到源代码中对应的位置。",-1),d=s("p",null,"所以我们今天来聊聊如何借助工具解决现代化前端应用的调试问题。",-1),m=s("h3",{id:"source-map-简介",tabindex:"-1"},[a("Source Map 简介 "),s("a",{class:"header-anchor",href:"#source-map-简介","aria-label":'Permalink to "Source Map 简介"'},"​")],-1),g=s("p",null,"Source Map（源代码地图）就是解决此类问题最好的办法，从它的名字就能够看出它的作用：映射转换后的代码与源代码之间的关系。一段转换后的代码，通过转换过程中生成的 Source Map 文件就可以逆向解析得到对应的源代码。",-1),h=s("p",null,"目前很多第三方库在发布的文件中都会同时提供一个 .map 后缀的 Source Map 文件。例如 jQuery。我们可以打开它的 Source Map 文件看一下，如下图所示：",-1),F=s("p",null,"这是一个 JSON 格式的文件，为了更容易阅读，我提前对该文件进行了格式化。这个 JSON 里面记录的就是转换后和转换前代码之间的映射关系，主要存在以下几个属性：",-1),_=s("ul",null,[s("li",null,"version 是指定所使用的 Source Map 标准版本；"),s("li",null,"sources 中记录的是转换前的源文件名称，因为有可能出现多个文件打包转换为一个文件的情况，所以这里是一个数组；"),s("li",null,"names 是源代码中使用的一些成员名称，我们都知道一般压缩代码时会将我们开发阶段编写的有意义的变量名替换为一些简短的字符，这个属性中记录的就是原始的名称；"),s("li",null,"mappings 属性，这个属性最为关键，它是一个叫作 base64-VLQ 编码的字符串，里面记录的信息就是转换后代码中的字符与转换前代码中的字符之间的映射关系，具体如下图所示：")],-1),v=s("p",null,"一般我们会在转换后的代码中通过添加一行注释的方式来去引入 Source Map 文件。不过这个特性只是用于开发调试的，所以最新版本的 jQuery 已经去除了引入 Source Map 的注释，我们需要手动添加回来，这里我们在最后一行添加 //# sourceMappingURL=jquery-3.4.1.min.map，具体效果如下：",-1),A=s("p",null,"这样我们在 Chrome 浏览器中如果打开了开发人员工具，它就会自动请求这个文件，然后根据这个文件的内容逆向解析出来源代码，以便于调试。同时因为有了映射关系，所以代码中如果出现了错误，也就能自动定位找到源代码中的位置了。",-1),C=s("p",null,"我们回到浏览器中，打开开发人员工具，找到 Source 面板，这里我们就能看到转换前的 jQuery 源代码了，具体效果如下图所示：",-1),b=s("p",null,"我们还可以添加一个断点，然后刷新页面，进行单步调试，此时调试过程中使用的就是源代码而不是压缩过后的代码，具体效果如下图所示：",-1),k=l("",5),S=s("p",null,[a("我们再回到命令行，通过 "),s("a",{href:"http://github.com/zeit/serve",target:"_blank",rel:"noreferrer"},"serve"),a(" 工具把打包结果运行起来，然后打开浏览器，再打开开发人员工具，此时我们就可以直接定位到错误所在的位置了。当然如果需要调试，这里也可以直接调试源代码。")],-1),M=s("p",null,[a("如果你只是需要使用 Source Map 的话，操作到这里就已经实现了。"),s("strong",null,"但是只会使用这种最普通的 Source Map 模式还远远不够。")],-1),B=s("p",null,"为什么这么说呢？",-1),j=s("p",null,"因为现阶段 Webpack 支持的 Source Map 模式有很多种。每种模式下所生成的 Source Map 效果和生成速度都不一样。显然，效果好的一般生成速度会比较慢，而生成速度快的一般就没有什么效果。",-1),f=s("p",null,"那具体哪种 Source Map 模式才是最好呢？这里我们还需要继续去探索。",-1),D=s("p",null,[a("Webpack 中的 devtool 配置，除了可以使用 source-map 这个值，它还支持很多其他的选项，具体的我们可以参考"),s("a",{href:"https://webpack.js.org/configuration/devtool/#devtool",target:"_blank",rel:"noreferrer"},"文档"),a("中的不同模式的对比表。")],-1),T=l("",7),q=s("p",null,"其实我们可以通过 sourceURL 来声明这段代码所属文件路径，接下来我们再来尝试在执行的 JavaScript 字符串中添加一个 sourceURL 的声明，具体操作如下：",-1),W=l("",5),H=s("p",null,"那此时如果我们回到浏览器运行这里的 bundle.js，一旦出现错误，浏览器的控制台就可以定位到具体是哪个模块中的代码，具体效果如下：",-1),L=s("p",null,"但是当你点击控制台中的文件名打开这个文件后，看到的却是打包后的模块代码，而并非我们真正的源代码，具体如下：",-1),P=l("",13),w=l("",6),x=s("p",null,"然后我们通过 serve 把结果运行起来，打开浏览器，此时我们能够在页面中看到每一个使用不同模式 Source Map 的 HTML 文件，具体如下图：",-1),V=s("p",null,"那如果刚刚没有把 JS 文件输出到单独目录中，这里的文件就会非常多，导致 HTML 文件寻找起来特别麻烦。",-1),I=s("h4",{id:"不同模式的对比",tabindex:"-1"},[a("不同模式的对比 "),s("a",{class:"header-anchor",href:"#不同模式的对比","aria-label":'Permalink to "不同模式的对比"'},"​")],-1),R=s("p",null,"有了不同模式下生成的结果过后，我们就可以仔细去对比不同 Source Map 模式之间的具体差异了。其实也没必要真的一个一个去看，这里我先带你看几个比较典型的模式，然后找出它们的规律，这样你就再也不用头大了。",-1),J=s("p",null,"首先 eval 模式，这个模式刚刚已经单独看过了，它就是将模块代码放到 eval 函数中执行，并且通过 sourceURL 标注所属文件路径，在这种模式下没有 Source Map 文件，所以只能定位是哪个文件出错，具体效果如下图：",-1),N=s("p",null,"然后我们再来看一个叫作 eval-source-map 的模式，这个模式也是使用 eval 函数执行模块代码，不过这里有所不同的是，eval-source-map 模式除了定位文件，还可以定位具体的行列信息。相比于 eval 模式，它能够生成 Source Map 文件，可以反推出源代码，具体效果如下：",-1),U=s("p",null,"紧接着我们再来看一个叫作 cheap-eval-source-map 的模式。根据这个模式的名字就能推断出一些信息，它就是在 eval-source-map 基础上添加了一个 cheap，也就是便宜的，或者叫廉价的。用计算机行业的常用说法，就是阉割版的 eval-source-map，因为它虽然也生成了 Source Map 文件，但是这种模式下的 Source Map 只能定位到行，而定位不到列，所以在效果上差了一点点，但是构建速度会提升很多，具体效果如下图：",-1),Q=s("p",null,"接下来再看一个叫作 cheap-module-eval-source-map 的模式。慢慢地我们就发现 Webpack 中这些模式的名字不是随意的，好像都有某种规律。这里就是在 cheap-eval-source-map 的基础上多了一个 module，具体效果如下图：",-1),Y=s("p",null,"这种模式同样也只能定位到行，它的特点相比于 cheap-eval-source-map 并不明显 ，如果你没有发现差异，可以再去看看上一种模式，仔细做一个对比，相信对比之后你会发现，cheap-module-eval-source-map 中定位的源代码与我们编写的源代码是一模一样的，而 cheap-eval-source-map 模式中定位的源代码是经过 ES6 转换后的结果，具体对比如下（左图是 cheap-eval-source-map）：",-1),$=l("",21);function G(O,X,Z,K,z,ss){const n=e("Image");return c(),t("div",null,[E,i,y,u,d,m,g,p(n,{alt:"image (1).png",src:"https://s0.lgstatic.com/i/image/M00/07/31/CgqCHl65BMmAH6A5AAB71vulYEw615.png"}),a(),h,p(n,{alt:"image (2).png",src:"https://s0.lgstatic.com/i/image/M00/07/31/Ciqc1F65BNaAd1HlAAFTcrTVgBg517.png"}),a(),F,_,p(n,{alt:"image (3).png",src:"https://s0.lgstatic.com/i/image/M00/07/31/CgqCHl65BOaAYEH0AAQM_57iYlk560.png"}),a(),v,p(n,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image/M00/07/31/Ciqc1F65BPCAed3hAAD-bDL2c1w048.png"}),a(),A,C,p(n,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/07/31/CgqCHl65BPqAZ12pAAZAHqAjwBU330.png"}),a(),b,p(n,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/07/32/CgqCHl65BUqAc5WEAAxIGZoDsgw274.png"}),a(),k,p(n,{alt:"image (7).png",src:"https://s0.lgstatic.com/i/image/M00/07/32/CgqCHl65BVWAQAhuAAE7vvXo_eo963.png"}),a(),S,p(n,{alt:"source-map.gif",src:"https://s0.lgstatic.com/i/image/M00/07/68/CgqCHl65LS6AQ3RLAA8Qi5GdMKM734.gif"}),a(),M,B,j,f,D,p(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/07/35/Ciqc1F65B2aAGTvVAANPGIkqtEY706.png"}),a(),T,p(n,{alt:"image (8).png",src:"https://s0.lgstatic.com/i/image/M00/07/32/Ciqc1F65BY2AH0CCAAFYgxojzco362.png"}),a(),q,p(n,{alt:"image (9).png",src:"https://s0.lgstatic.com/i/image/M00/07/32/CgqCHl65BZSACFl5AAGGHw1vkY0791.png"}),a(),W,p(n,{alt:"image (10).png",src:"https://s0.lgstatic.com/i/image/M00/07/32/Ciqc1F65BaCAaChSAALB1bStzyo434.png"}),a(),H,p(n,{alt:"image (11).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BauAc85YAAFTP1qAxo4213.png"}),a(),L,p(n,{alt:"image (12).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/Ciqc1F65BdaAAGc0AAHURbLxs24154.png"}),a(),P,p(n,{alt:"image (13).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BfWAYAaeAAFSJ5cYfbo850.png"}),a(),w,p(n,{alt:"image (14).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BgCAbZVrAAUumD0yd4g992.png"}),a(),x,p(n,{alt:"image (15).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BgiAU1D1AAExFMFyQcc456.png"}),a(),V,I,R,J,p(n,{alt:"image (16).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/CgqCHl65BhCABeebAAFnubG2mPA332.png"}),a(),N,p(n,{alt:"eval-source-map.gif",src:"https://s0.lgstatic.com/i/image/M00/07/68/Ciqc1F65LV2ABnPSAAOQByCZ1X8805.gif"}),a(),U,p(n,{alt:"cheap-eval-source-map.gif",src:"https://s0.lgstatic.com/i/image/M00/07/68/CgqCHl65LXKAL1X9AAQvU6NQre0545.gif"}),a(),Q,p(n,{alt:"cheap-module-eval-source-map.gif",src:"https://s0.lgstatic.com/i/image/M00/07/68/Ciqc1F65LYKAb35fAAWpO16gIpE536.gif"}),a(),Y,p(n,{alt:"image (17).png",src:"https://s0.lgstatic.com/i/image/M00/07/33/Ciqc1F65BjSAE-KLAAFGXAIp67I615.png"}),a(),$])}const ps=o(r,[["render",G]]);export{ns as __pageData,ps as default};
