import{_ as o,j as e,o as t,g as c,k as a,h as n,Q as l,s}from"./chunks/framework.4e7d56ce.js";const I=JSON.parse('{"title":"15理论先行：高并发设计必须学的知识点有哪些？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Node.js 应用开发实战_文档/(6797) 15  理论先行：高并发设计必须学的知识点有哪些？.md","filePath":"posts/frontEnd/Node.js 应用开发实战_文档/(6797) 15  理论先行：高并发设计必须学的知识点有哪些？.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/Node.js 应用开发实战_文档/(6797) 15  理论先行：高并发设计必须学的知识点有哪些？.md"},E=l("",13),y=l("",8),i=l("",25),_=s("p",null,"图 3 负载均衡方法",-1),d=s("p",null,"图 3 就是一个负载均衡的方案，对于域名访问按照刚才所说可以使用 Nginx，而对于服务间调用则使用名字服务。这种方案，可以适配我们现在的绝大不多数后台多服务的负载均衡方案，因此对于 Node.js 来说，我们实际开发中负载均衡也是使用这套方案。",-1),m=s("h4",{id:"并行压测",tabindex:"-1"},[n("并行压测 "),s("a",{class:"header-anchor",href:"#并行压测","aria-label":'Permalink to "并行压测"'},"​")],-1),A=s("p",null,"如果我们服务使用了刚才上面所介绍的多服务负载均衡的方案，那么我们就需要去学习一种新的方案来评估服务承载能力。接下来我们就来学习一下，怎么有效地评估服务承载的情况。",-1),h=s("p",null,[s("strong",null,"1"),n(". 首先应用 clinicjs 压测工具，检测单个接口是否存在性能问题；")],-1),g=s("p",null,[s("strong",null,"2"),n(". 计算当前服务所应该承担的最大并发情况，我们用一个渐进性的表格来分析，如表格 1。")],-1),F=s("p",null,"表格 1 预测并发压力方式",-1),u=s("p",null,"比如我们当前 DAU 1000 万，最高在线人数 12% ，因此最高的在线人数 120 万，而按照秒来计算的话，我们用当前数除以 60 就是每秒，但是由于不是严格除以 60 ，我们需要乘以 5 来确保安全，最后 10% 的在线用户会使用到该服务，所以该服务最大并发数是 1万 QPS。",-1),D=s("p",null,"假设我们有 4 台服务器，按照平均分配的话，那么每台机器处理并发数大概是 2500 的 QPS 。",-1),v=s("p",null,"得到 1 万的结论后，我们再细分接口的并发数，得到一个像表格 2 的结论。",-1),C=l("",8);function T(P,b,k,x,f,N){const p=e("Image");return t(),c("div",null,[E,a(p,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image6/M01/39/F2/Cgp9HWB9TpyAJjg1AABwcxUmgzs211.png"}),n(),y,a(p,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M01/39/F2/Cgp9HWB9TqSALKcMAACWOU_LikA525.png"}),n(),i,a(p,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M01/39/F2/Cgp9HWB9Tx6AUefLAADCvjmrv30935.png"}),n(),_,d,m,A,h,g,a(p,{alt:"image.png",src:"https://s0.lgstatic.com/i/image6/M00/3A/65/CioPOWB_g7eAJW_sAABOZsdm58g189.png"}),n(),F,u,D,v,a(p,{alt:"image (1).png",src:"https://s0.lgstatic.com/i/image6/M00/3A/65/CioPOWB_g8CAIJSsAABEY3NwObM047.png"}),n(),C])}const B=o(r,[["render",T]]);export{I as __pageData,B as default};
