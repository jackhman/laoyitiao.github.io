import{_ as r,j as a,o as s,g as n,k as e,s as l,h as t,Q as i}from"./chunks/framework.e0c66c3f.js";const _l=JSON.parse('{"title":"配置中心 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/041_300分钟搞懂 Spring Cloud/(95) 第07讲：分布式配置中心-Apollo.md","filePath":"posts/backEnd/041_300分钟搞懂 Spring Cloud/(95) 第07讲：分布式配置中心-Apollo.md","lastUpdated":1696338709000}'),p={name:"posts/backEnd/041_300分钟搞懂 Spring Cloud/(95) 第07讲：分布式配置中心-Apollo.md"},g=l("p",null,"本课时我们主要讲解：配置中心解决的业务痛点、Apollo 基础知识以及如何使用、Apollo 架构设计，以及核心源码分析等内容。",-1),c=l("h6",{id:"配置中心",tabindex:"-1"},[t("配置中心 "),l("a",{class:"header-anchor",href:"#配置中心","aria-label":'Permalink to "配置中心"'},"​")],-1),u=l("p",null,"配置中心是用来统一管理配置信息的产品，配置中心可以在微服务等场景下极大地减轻配置管理的工作量，增强配置管理的服务能力。",-1),d=l("p",null,"目前主流的配置中心有 Apollo、Spring Cloud Config、Nacos 等开源产品，每款配置中心都能满足统一管理配置的需求，不同的点在于是否能够快速让用户使用，部署难度，功能细节，扩展方法做的是否足够友好。",-1),A=l("h6",{id:"产生的必然原因",tabindex:"-1"},[t("产生的必然原因 "),l("a",{class:"header-anchor",href:"#产生的必然原因","aria-label":'Permalink to "产生的必然原因"'},"​")],-1),_=l("p",null,"在没有使用配置中管理配置的时候，我们的配置文件都是跟着项目走的，也就是存放在项目中的目录下，一个项目中可能有多个配置文件。",-1),h=l("p",null,"当项目发布的时候，会先编译打包，同时配置文件也会被打包进去，也就是配置文件会跟着项目一起发布。这样存在的问题是当我们需求修改配置的时候，需要重新在本地修改，然后重新发布才可以让新的配置生效，当请求压力越来越大，你的项目也会从 1 个节点变成多个节点，这个时候如果配置需要发生变化，对应的修改操作也是相同的，只需要在项目中修改一次即可，但对于发布操作工作量就比之前大了很多，因为要发布多个节点。",-1),C=l("p",null,"修改这些配置，发布的工作降低了整体的工作效率，为了能够提升工作效率，配置中心应运而生了，我们可以将配置统一存放在配置中心来进行管理。",-1),m=l("h6",{id:"配置中心管理配置",tabindex:"-1"},[t("配置中心管理配置 "),l("a",{class:"header-anchor",href:"#配置中心管理配置","aria-label":'Permalink to "配置中心管理配置"'},"​")],-1),S=l("p",null,"使用配置中心管理配置后，我们就可以将配置信息从项目中转移到配置中心，一般一个项目会有一个唯一的标识 ID, 也就是身份信息，通过这个 ID 从配置中心获取对应的配置内容。",-1),f=i("",38),P=i("",33),b=l("p",null,"我们接下来学习如何在 Spring Boot 中集成 Apollo，首先在 pom 中加入 apollo-client 的依赖，然后在 application 属性文件中增加 Apollo 的配置信息，app.id 是项目的唯一标识，跟 Apollo 中的项目一一对应，apollo.meta 就是 meta Server 的地址，namespaces 是我们需要加载的命名空间。这边少了环境的配置，也就是当前的配置读取哪个环境下的信息，是开发环境，还是测试环境，或是生产环境。",-1),v=l("p",null,"Apollo 中环境的指定有多种方式，在实际使用中，我推荐将环境和 meta Server 的地址配置在本地磁盘中，Linux 下配置路径是 /opt/settings/server.properties。这边为了演示方式，直接在启动的时候通过 System.setProperty 来指定对应的环境，在启动类中可以看到指定了 DEV 环境。",-1),M=l("p",null,"然后我们来演示下配置的读取，首先来看直接注入 Config 接口，通过接口的 getProperty",-1),B=l("p",null,"方法来获取配置信息，这边获取了配置 key 为 username 的配置，并指定了默认值。当配置中心无此配置时才会用默认值，访问接口可以看到输出的配置内容，然后我们在后台将配置的值修改一下，然后再次访问，可以看到值变成了最新修改的内容，秒级实时生效。",-1),T=l("p",null,"第二种方式是通过 Spring 的 @Value 注解来读取配置信息，冒号后是默认值，同样的访问接口进行测试。",-1),k=l("p",null,"第三种方式是创建一个配置类，通过 @ConfigurationProperties 来读取，可以指定配置的前缀，将一组配置统一读取，在使用时直接注入这个自定义的配置类，然后访问配置类的 get 方法获取对应的配置信息。",-1),V=l("p",null,"第四种是 @ApolloJsonValue 注解的使用，可以将配置的值存储成 JSON 格式，在读取的时候使用 @ApolloJsonValue 将 JSON 格式的值直接转换成对应的实体对象，非常方便。",-1),D=l("p",null,"最后来看下配置变更监听的使用方式，同样的只需要加一个 @ApolloConfigChangeListener",-1),R=l("p",null,"注解就可以对配置的变更进行监听了，ConfigChangeEvent 可以获取变更的 key，监听可以用来实现很多扩展工作，比如动态刷新日志级别，动态控制限流速度等场景。",-1),E=l("h6",{id:"apollo-架构设计",tabindex:"-1"},[t("Apollo 架构设计 "),l("a",{class:"header-anchor",href:"#apollo-架构设计","aria-label":'Permalink to "Apollo 架构设计"'},"​")],-1),y=i("",17),x=l("p",null,"用户会在 Portal 中进行配置的编辑和发布操作，Portal 会调用 Admin Service 提供的接口进行发布操作。Admin Service 收到请求后，发送 ReleaseMessage 给各个 Config Service，通知 Config Service 配置发生了变化。Config Service 收到 ReleaseMessage 后，通知对应的客户端，基于 HTTP 长连接实现。",-1),N=l("h6",{id:"消息设计",tabindex:"-1"},[t("消息设计 "),l("a",{class:"header-anchor",href:"#消息设计","aria-label":'Permalink to "消息设计"'},"​")],-1),I=l("p",null,"ReleaseMessage 消息是通过 MySQL 实现了一个简单的消息队列。之所有没有采用消息中间件，是为了让 Apollo 在部署的时候尽量简单，尽可能减少外部依赖，多一个依赖就多一份维护的工作，同时也就多了一份故障的风险。",-1),q=l("p",null,"如图简要描述了发送 ReleaseMessage 的大致过程。",-1),W=l("p",null,"Admin Service 在配置发布后会往 ReleaseMessage 表插入一条消息记录，Config Service 会启动一个线程定时扫描 ReleaseMessage 表，去查看是否有新的消息记录。Config Service 发现有新的消息记录，那么就会通知所有的消息监听器，消息监听器得到配置发布的信息后，则会通知对应的客户端。",-1),O=l("h6",{id:"客户端设计",tabindex:"-1"},[t("客户端设计 "),l("a",{class:"header-anchor",href:"#客户端设计","aria-label":'Permalink to "客户端设计"'},"​")],-1),F=l("p",null,"如图简要描述了 Apollo 客户端的实现原理。",-1),L=l("p",null,"客户端和服务端保持了一个长连接，编译配置的实时更新推送。定时拉取配置是客户端本地的一个定时任务，默认每 5 分钟拉取一次，也可以通过在运行时指定 System Property: apollo.refreshInterval 来进行覆盖，单位是分钟，采用推送 + 定时拉取的方式就等于双保险。",-1),J=l("p",null,"客户端从 Apollo 配置中心服务端获取到应用的最新配置后，会保存在内存中。客户端会把从服务端获取到的配置在本地文件系统中缓存一份，当服务或者网络不可用时可以使用本地的配置，也就是我们的本地开发模式 env=Local。",-1),Q=l("h6",{id:"集成-spring",tabindex:"-1"},[t("集成 Spring "),l("a",{class:"header-anchor",href:"#集成-spring","aria-label":'Permalink to "集成 Spring"'},"​")],-1),Y=l("p",null,"Apollo 除了支持 API 方式获取配置，也支持和 Spring/Spring Boot 集成，集成后可以直接通过 Spring 的 @Value 注解获取配置，我们来分析下集成的原理。",-1),G=l("p",null,"Spring 从 3.1 版本开始增加了 ConfigurableEnvironment 和 PropertySource：",-1),H=l("ul",null,[l("li",null,[l("p",null,"ConfigurableEnvironment 实现了 Environment 接口，并且包含了多个 PropertySource。")]),l("li",null,[l("p",null,"PropertySource 可以理解为很多个 Key - Value 的属性配置。")])],-1),K=l("p",null,"在运行时的结构如图所示，需要注意的是，PropertySource 之间是有优先级顺序的，如果有一个 Key 在多个 PropertySource 中都存在，那么在前面的 PropertySource 优先级高。",-1),z=l("p",null,"集成的原理就是在应用启动阶段，Apollo 从远端获取配置，然后组装成 PropertySource 并插入到第一个即可。",-1),j=l("h6",{id:"可用性设计",tabindex:"-1"},[t("可用性设计 "),l("a",{class:"header-anchor",href:"#可用性设计","aria-label":'Permalink to "可用性设计"'},"​")],-1),U=i("",22),Z=l("p",null,"打开 NotificationControllerV2 类，定义了一个 AddMsg 的方法，发送 ReleaseMessage 的逻辑基于 AddMsg 接口，用于队列存储，测试的时候就调用这个接口模拟配置有更新的情况，发送 ReleaseMessage 消息。",-1),$=l("p",null,"消息发送后，Config Service 会启动一个线程定时扫描 ReleaseMessage 表，去查看是否有新的消息记录，然后通知客户端，这里我们也启动一个线程去扫描 ReleaseMessage 表。打开 ReleaseMessageScanner 类，这里用了一个线程一直负责读取队列，如果读到了数据就调用 NotificationControllerV2 中的 handleMessage 方法。handleMessage 就是当配置发生变化的时候，通知对应的客户端。",-1),w=l("p",null,"Apollo 的实时推送是基于 Spring DeferredResult 实现的，在 handleMessage() 方法中可以看到是通过 deferredResults 获取 DeferredResult，deferredResults 就是第一行的 Multimap，Key 其实就是消息内容，Value 就是 DeferredResult 的业务包装类 DeferredResultWrapper。",-1),X=l("p",null,"客户端接入流程：NotificationControllerV2 中提供了一个 /getConfig 的接口，客户端在启动的时候会调用这个接口，这个时候会执行 getApolloConfigNotifications() 方法获取是否有配置变更的信息，如果有的话证明配置修改过，直接就通过 deferredResultWrapper.setResult(newNotifications); 返回结果给客户端了，客户端收到结果后重新拉取配置的信息进行覆盖本地的配置。",-1),ll=l("p",null,"如果 getApolloConfigNotifications() 方法没有返回配置修改的信息，证明配置没有发生修改，就将 DeferredResultWrapper 对象添加到 deferredResults 中，等待后续配置发生变化时消息监听器进行通知。",-1),ol=l("p",null,"在创建 DeferredResult 对象的时候指定了超时的时间和超时后返回的响应码，请求会挂起，如果 60 秒内没有消息监听器进行通知，那么这个请求就会超时，超时后客户端就收到的响应码就是 304。",-1),el=l("p",null,"打开 ClientTest，首先启动 /getConfig 接口所在的服务，然后启动客户端，客户端就会发起注册请求，如果有修改直接获取结果，进行配置的更新操作。如果无修改，请求会挂起，这边客户端设置的读取超时时间是 90 秒，大于服务端的 60 秒超时时间。",-1),tl=l("p",null,"每次收到结果后，无论是否有修改，都必须重新进行注册，通过这样的方式就可以达到配置实时推送的效果。我们可以调用之前写的 /addMsg 接口来模拟配置发生变化的情况，可以看到调用之后客户端就能马上得到返回结果。",-1),il=l("br",null,null,-1),rl=l("p",null,"本课时主要学习了什么是配置中心及配置中心解决的业务痛点然后对比了 Apollo 和 Spring Cloud Config 的优缺点，介绍了 Apollo 的基本概念及如何使用，重点分析了 Apollo 的架构设计，最后分析了 Apollo 的核心源码，希望你在课后能够熟练掌握本课时的内容。",-1),al=l("br",null,null,-1);function sl(nl,pl,gl,cl,ul,dl){const o=a("Image");return s(),n("div",null,[g,c,u,d,A,_,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1SAeUNlAACArRLtcVE240.png"}),h,C,m,S,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1WAF4S2AACIYGiePW0196.png"}),f,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1WASOkYAAA7y7Kuj4o675.png"}),P,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1WADhfnAB8q0bmRRTo125.gif"}),b,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1WALZEnAAxQ0fjk4zw209.gif"}),v,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1WAKNDDAB_aoNBv2HE107.gif"}),M,B,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1aAG317AAzM665afCY996.gif"}),T,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1aAZEtlAB8bZLHtO8E954.gif"}),k,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1eAPvH2ACNIdFxKCQE837.gif"}),V,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1eARWYpACY4cb3myAE618.gif"}),D,R,E,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1eAT_QKAAIrr-cSeiQ864.png"}),y,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1eAVl80AADzD_Lkc-w754.png"}),x,N,I,q,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1iAJa9tAACfTre4O3g300.png"}),W,O,F,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1iAHJTnAAFK5jsOc0Q150.png"}),L,J,Q,Y,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1iAJYdPAAC-xjP6WLY903.png"}),G,H,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1iASfMgAAC9F683nHQ059.png"}),K,z,j,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1iAUjSmAACLZzn0M5k680.png"}),U,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1iAWyxDABkOCzxySSk513.gif"}),Z,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1mAE2PEACNyf_DgdlM536.gif"}),$,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1mABbzLACEV1Y3rpmc397.gif"}),w,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1mAY3zKACn0z-Qllgc346.gif"}),X,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1qAWg5yABKC0bm7mpY637.gif"}),ll,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/D1/CgoB5l28B1qANYhRAA5S_s3eu2Q160.gif"}),ol,e(o,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A2/F1/CgotOV28B1qAdAIIACT9ajneUpY998.gif"}),el,tl,il,rl,al])}const hl=r(p,[["render",sl]]);export{_l as __pageData,hl as default};
