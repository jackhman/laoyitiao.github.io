import{_ as o,j as e,o as t,g as r,k as l,h as s,Q as p,s as a}from"./chunks/framework.4e7d56ce.js";const k=JSON.parse('{"title":"05多进程解决方案：cluter模式以及PM2工具的原理介绍","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Node.js 应用开发实战_文档/(6787) 05  多进程解决方案：cluter 模式以及 PM2 工具的原理介绍.md","filePath":"posts/frontEnd/Node.js 应用开发实战_文档/(6787) 05  多进程解决方案：cluter 模式以及 PM2 工具的原理介绍.md","lastUpdated":1696682708000}'),c={name:"posts/frontEnd/Node.js 应用开发实战_文档/(6787) 05  多进程解决方案：cluter 模式以及 PM2 工具的原理介绍.md"},E=p('<h1 id="_05多进程解决方案-cluter模式以及pm2工具的原理介绍" tabindex="-1">05多进程解决方案：cluter模式以及PM2工具的原理介绍 <a class="header-anchor" href="#_05多进程解决方案-cluter模式以及pm2工具的原理介绍" aria-label="Permalink to &quot;05多进程解决方案：cluter模式以及PM2工具的原理介绍&quot;">​</a></h1><p>前几讲我们都使用了一种非常简单暴力的方式（node app.js）启动 Node.js 服务器，而在线上我们要考虑使用多核 CPU，充分利用服务器资源，这里就用到多进程解决方案，所以本讲介绍 PM2 的原理以及如何应用一个 cluster 模式启动 Node.js 服务。</p><h3 id="单线程问题" tabindex="-1">单线程问题 <a class="header-anchor" href="#单线程问题" aria-label="Permalink to &quot;单线程问题&quot;">​</a></h3><p>在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=694#/detail/pc?id=6783" target="_blank" rel="noreferrer">《01 | 事件循环：高性能到底是如何做到的？》</a>中我们分析了 Node.js 主线程是单线程的，如果我们使用 node app.js 方式运行，就启动了一个进程，只能在<strong>一个 CPU 中进行运算</strong> ，无法应用服务器的多核 CPU，因此我们需要寻求一些解决方案。你能想到的解决方案肯定是<strong>多进程分发策略</strong> ，即主进程接收所有请求，然后通过一定的<strong>负载均衡策略</strong>分发到不同的 Node.js 子进程中。如图 1 的方案所示：</p>',4),y=p(`<p>这一方案有 2 个不同的实现：</p><ul><li><p>主进程监听一个端口，子进程不监听端口，通过主进程分发请求到子进程；</p></li><li><p>主进程和子进程分别监听不同端口，通过主进程分发请求到子进程。</p></li></ul><p>在 Node.js 中的 cluster 模式使用的是第一个实现。</p><h3 id="cluster-模式" tabindex="-1">cluster 模式 <a class="header-anchor" href="#cluster-模式" aria-label="Permalink to &quot;cluster 模式&quot;">​</a></h3><p>cluster 模式其实就是我们上面图 1 所介绍的模式，<strong>一个主进程</strong> 和<strong>多个子进程</strong>，从而形成一个集群的概念。我们先来看看 cluster 模式的应用例子。</p><h4 id="应用" tabindex="-1">应用 <a class="header-anchor" href="#应用" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p>我们先实现一个简单的 app.js，代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">http</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;http&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * 创建 http 服务，简单返回</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">server</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> http.</span><span style="color:#B392F0;">createServer</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">req</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">res</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">write</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`hello world, start with cluster \${</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.</span><span style="color:#B392F0;">end</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * 启动服务</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;">server.</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3000</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;server start http://127.0.0.1:3000&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`Worker \${</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">} started\`</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">http</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;http&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * 创建 http 服务，简单返回</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">server</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> http.</span><span style="color:#6F42C1;">createServer</span><span style="color:#24292E;">((</span><span style="color:#E36209;">req</span><span style="color:#24292E;">, </span><span style="color:#E36209;">res</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    res.</span><span style="color:#6F42C1;">write</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`hello world, start with cluster \${</span><span style="color:#24292E;">process</span><span style="color:#032F62;">.</span><span style="color:#24292E;">pid</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    res.</span><span style="color:#6F42C1;">end</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * 启动服务</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#24292E;">server.</span><span style="color:#6F42C1;">listen</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3000</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;server start http://127.0.0.1:3000&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`Worker \${</span><span style="color:#24292E;">process</span><span style="color:#032F62;">.</span><span style="color:#24292E;">pid</span><span style="color:#032F62;">} started\`</span><span style="color:#24292E;">);</span></span></code></pre></div><p>这是最简单的一个 Node.js 服务，接下来我们应用 cluster 模式来包装这个服务，代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">cluster</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;cluster&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">instances</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 启动进程数量</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cluster.isMaster) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;i</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">instances;i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 使用 cluster.fork 创建子进程</span></span>
<span class="line"><span style="color:#E1E4E8;">        cluster.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;./app.js&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">cluster</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;cluster&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">instances</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 启动进程数量</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cluster.isMaster) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;i</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">instances;i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 使用 cluster.fork 创建子进程</span></span>
<span class="line"><span style="color:#24292E;">        cluster.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./app.js&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>首先判断是否为主进程：</p><ul><li><p>如果是则使用 cluster.fork 创建子进程；</p></li><li><p>如果不是则为子进程 require 具体的 app.js。</p></li></ul><p>然后运行下面命令启动服务。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ node cluster.js</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ node cluster.js</span></span></code></pre></div><p>启动成功后，再打开另外一个命令行窗口，多次运行以下命令：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">curl </span><span style="color:#9ECBFF;">&quot;http://127.0.0.1:3000/&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">curl </span><span style="color:#032F62;">&quot;http://127.0.0.1:3000/&quot;</span></span></code></pre></div><p>你可以看到如下输出：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">hello world, start with cluster </span><span style="color:#79B8FF;">4543</span></span>
<span class="line"><span style="color:#E1E4E8;">hello world, start with cluster </span><span style="color:#79B8FF;">4542</span></span>
<span class="line"><span style="color:#E1E4E8;">hello world, start with cluster </span><span style="color:#79B8FF;">4543</span></span>
<span class="line"><span style="color:#E1E4E8;">hello world, start with cluster </span><span style="color:#79B8FF;">4542</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">hello world, start with cluster </span><span style="color:#005CC5;">4543</span></span>
<span class="line"><span style="color:#24292E;">hello world, start with cluster </span><span style="color:#005CC5;">4542</span></span>
<span class="line"><span style="color:#24292E;">hello world, start with cluster </span><span style="color:#005CC5;">4543</span></span>
<span class="line"><span style="color:#24292E;">hello world, start with cluster </span><span style="color:#005CC5;">4542</span></span></code></pre></div><p>后面的进程 ID 是比较有规律的随机数，有时候输出 4543，有时候输出 4542，4543 和 4542 就是我们 <strong>fork 出来的两个子进程</strong>，接下来我们看下为什么是这样的。</p><h4 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h4><p>首先我们需要搞清楚两个问题：</p><ul><li><p>Node.js 的 cluster 是如何做到多个进程监听一个端口的；</p></li><li><p>Node.js 是如何进行负载均衡请求分发的。</p></li></ul><p><strong>多进程端口问题</strong></p><p>在 cluster 模式中存在 master 和 worker 的概念，<strong>master 就是主进程</strong> ，<strong>worker 则是子进程</strong>，因此这里我们需要看下 master 进程和 worker 进程的创建方式。如下代码所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">cluster</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;cluster&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">instances</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 启动进程数量</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cluster.isMaster) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;i</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">instances;i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 使用 cluster.fork 创建子进程</span></span>
<span class="line"><span style="color:#E1E4E8;">        cluster.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;./app.js&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">cluster</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;cluster&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">instances</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 启动进程数量</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cluster.isMaster) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;i</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">instances;i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 使用 cluster.fork 创建子进程</span></span>
<span class="line"><span style="color:#24292E;">        cluster.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;./app.js&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这段代码中，第一次 require 的 cluster 对象就默认是一个 master，这里的判断逻辑在<a href="https://github.com/nodejs/node/blob/master/lib/cluster.js" target="_blank" rel="noreferrer">源码</a>中，如下代码所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">&#39;use strict&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">childOrPrimary</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;NODE_UNIQUE_ID&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> p<wbr>rocess.env </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;child&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;primary&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`internal/cluster/\${</span><span style="color:#E1E4E8;">childOrPrimary</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">&#39;use strict&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">childOrPrimary</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;NODE_UNIQUE_ID&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> p<wbr>rocess.env </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;child&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;primary&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`internal/cluster/\${</span><span style="color:#24292E;">childOrPrimary</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;">);</span></span></code></pre></div><p>通过<strong>进程环境变量设置</strong>来判断：</p><ul><li><p>如果没有设置则为 master 进程；</p></li><li><p>如果有设置则为子进程。</p></li></ul><p>因此第一次调用 cluster 模块是 master 进程，而后都是子进程。</p><p>主进程和子进程 require 文件不同：</p><ul><li><p>前者是 internal/cluster/primary；</p></li><li><p>后者是 internal/cluster/child。</p></li></ul><p>我们先来看下 master 进程的创建过程，这部分<a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/primary.js#L60" target="_blank" rel="noreferrer">代码在这里</a>。</p><p>可以看到 cluster.fork，一开始就会调用 setupPrimary 方法，创建主进程，由于该方法是通过 cluster.fork 调用，因此会调用多次，但是该模块有个全局变量 initialized 用来区分是否为首次，如果是首次则创建，否则则跳过，如下代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (initialized </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> process.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(setupSettingsNT, settings);</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	  initialized </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (initialized </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> process.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(setupSettingsNT, settings);</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	  initialized </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span></code></pre></div><p>接下来继续看 cluster.fork 方法，源码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">cluster.</span><span style="color:#B392F0;">fork</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">env</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  cluster.</span><span style="color:#B392F0;">setupPrimary</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">id</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">ids;</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">workerProcess</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createWorkerProcess</span><span style="color:#E1E4E8;">(id, env);</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">worker</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Worker</span><span style="color:#E1E4E8;">({</span></span>
<span class="line"><span style="color:#E1E4E8;">	    id: id,</span></span>
<span class="line"><span style="color:#E1E4E8;">	    process: workerProcess</span></span>
<span class="line"><span style="color:#E1E4E8;">	  });</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	  worker.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;message&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">message</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">handle</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    cluster.</span><span style="color:#B392F0;">emit</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;message&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, message, handle);</span></span>
<span class="line"><span style="color:#E1E4E8;">	  });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">cluster.</span><span style="color:#6F42C1;">fork</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">env</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	  cluster.</span><span style="color:#6F42C1;">setupPrimary</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">id</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">++</span><span style="color:#24292E;">ids;</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">workerProcess</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createWorkerProcess</span><span style="color:#24292E;">(id, env);</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">worker</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Worker</span><span style="color:#24292E;">({</span></span>
<span class="line"><span style="color:#24292E;">	    id: id,</span></span>
<span class="line"><span style="color:#24292E;">	    process: workerProcess</span></span>
<span class="line"><span style="color:#24292E;">	  });</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	  worker.</span><span style="color:#6F42C1;">on</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;message&#39;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">message</span><span style="color:#24292E;">, </span><span style="color:#E36209;">handle</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	    cluster.</span><span style="color:#6F42C1;">emit</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;message&#39;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, message, handle);</span></span>
<span class="line"><span style="color:#24292E;">	  });</span></span></code></pre></div><p>在上面代码中第 2 行就是<strong>创建主进程</strong> ，第 4 行就是<strong>创建 worker 子进程</strong>，在这个 createWorkerProcess 方法中，最终是使用 child_process 来创建子进程的。在初始化代码中，我们调用了两次 cluster.fork 方法，因此会创建 2 个子进程，在创建后又会调用我们项目根目录下的 cluster.js 启动一个新实例，这时候由于 cluster.isMaster 是 false，因此会 require 到 internal/cluster/child 这个方法。</p><p>由于是 worker 进程，因此代码会 require (&#39;./app.js&#39;) 模块，在该模块中会监听具体的端口，代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * 启动服务</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#E1E4E8;">server.</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3000</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;server start http://127.0.0.1:3000&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`Worker \${</span><span style="color:#E1E4E8;">process</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">pid</span><span style="color:#9ECBFF;">} started\`</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/**</span></span>
<span class="line"><span style="color:#6A737D;"> * </span></span>
<span class="line"><span style="color:#6A737D;"> * 启动服务</span></span>
<span class="line"><span style="color:#6A737D;"> */</span></span>
<span class="line"><span style="color:#24292E;">server.</span><span style="color:#6F42C1;">listen</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3000</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;server start http://127.0.0.1:3000&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`Worker \${</span><span style="color:#24292E;">process</span><span style="color:#032F62;">.</span><span style="color:#24292E;">pid</span><span style="color:#032F62;">} started\`</span><span style="color:#24292E;">);</span></span></code></pre></div><p>这里的 server.listen 方法很重要，这部分<a href="https://github.com/nodejs/node/blob/15164cebcebfcad9822d3f065234a8c1511776a4/lib/net.js" target="_blank" rel="noreferrer">源代码在这里</a>，其中的 server.listen 会调用该模块中的 listenInCluster 方法，该方法中有一个关键信息，如下代码所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cluster.isPrimary </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> exclusive) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// Will create a new handle</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// _listen2 sets up the listened handle, it is still named like this</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// to avoid breaking code that wraps this method</span></span>
<span class="line"><span style="color:#E1E4E8;">	    server.</span><span style="color:#B392F0;">_listen2</span><span style="color:#E1E4E8;">(address, port, addressType, backlog, fd, flags);</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">serverQuery</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    address: address,</span></span>
<span class="line"><span style="color:#E1E4E8;">	    port: port,</span></span>
<span class="line"><span style="color:#E1E4E8;">	    addressType: addressType,</span></span>
<span class="line"><span style="color:#E1E4E8;">	    fd: fd,</span></span>
<span class="line"><span style="color:#E1E4E8;">	    flags,</span></span>
<span class="line"><span style="color:#E1E4E8;">	  };</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// Get the primary&#39;s server handle, and listen on it</span></span>
<span class="line"><span style="color:#E1E4E8;">	  cluster.</span><span style="color:#B392F0;">_getServer</span><span style="color:#E1E4E8;">(server, serverQuery, listenOnPrimaryHandle);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cluster.isPrimary </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> exclusive) {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// Will create a new handle</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// _listen2 sets up the listened handle, it is still named like this</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// to avoid breaking code that wraps this method</span></span>
<span class="line"><span style="color:#24292E;">	    server.</span><span style="color:#6F42C1;">_listen2</span><span style="color:#24292E;">(address, port, addressType, backlog, fd, flags);</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">serverQuery</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    address: address,</span></span>
<span class="line"><span style="color:#24292E;">	    port: port,</span></span>
<span class="line"><span style="color:#24292E;">	    addressType: addressType,</span></span>
<span class="line"><span style="color:#24292E;">	    fd: fd,</span></span>
<span class="line"><span style="color:#24292E;">	    flags,</span></span>
<span class="line"><span style="color:#24292E;">	  };</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// Get the primary&#39;s server handle, and listen on it</span></span>
<span class="line"><span style="color:#24292E;">	  cluster.</span><span style="color:#6F42C1;">_getServer</span><span style="color:#24292E;">(server, serverQuery, listenOnPrimaryHandle);</span></span></code></pre></div><p>上面代码中的第 6 行，判断为<strong>主进程</strong> ，就是<strong>真实的监听端口启动服务</strong>，而如果非主进程则调用 cluster._getServer 方法，也就是 internal/cluster/child 中的 cluster._getServer 方法。</p><p>接下来我们看下这部分代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">obj.</span><span style="color:#B392F0;">once</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;listening&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    cluster.worker.state </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;listening&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">address</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> obj.</span><span style="color:#B392F0;">address</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	    message.act </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;listening&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	    message.port </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (address </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> address.port) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> options.port;</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(message);</span></span>
<span class="line"><span style="color:#E1E4E8;">	  });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">obj.</span><span style="color:#6F42C1;">once</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;listening&#39;</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    cluster.worker.state </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;listening&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">address</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> obj.</span><span style="color:#6F42C1;">address</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">	    message.act </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;listening&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	    message.port </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (address </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> address.port) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> options.port;</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(message);</span></span>
<span class="line"><span style="color:#24292E;">	  });</span></span></code></pre></div><p>这一代码通过 send 方法，如果监听到 listening 发送一个消息给到主进程，主进程也有一个同样的 listening 事件，监听到该事件后将子进程通过 EventEmitter 绑定在主进程上，这样就完成了主子进程之间的<strong>关联绑定</strong> ，并且只监听了一个端口。而主子进程之间的通信方式，就是我们常听到的 <strong>IPC 通信方式</strong>。</p><p><strong>负载均衡原理</strong></p><p>既然 Node.js cluster 模块使用的是主子进程方式，那么它是如何进行负载均衡处理的呢，这里就会涉及 Node.js cluster 模块中的两个模块。</p><ul><li><p><a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/round_robin_handle.js" target="_blank" rel="noreferrer">round_robin_handle.js</a>（非 Windows 平台应用模式），这是一个<strong>轮询处理模式</strong>，也就是轮询调度分发给空闲的子进程，处理完成后回到 worker 空闲池子中，这里要注意的就是如果绑定过就会复用该子进程，如果没有则会重新判断，这里可以通过上面的 app.js 代码来测试，用浏览器去访问，你会发现每次调用的子进程 ID 都会不变。</p></li><li><p><a href="https://github.com/nodejs/node/blob/7397c7e4a303b1ebad84892872717c0092852921/lib/internal/cluster/shared_handle.js" target="_blank" rel="noreferrer">shared_handle.js</a>（ Windows 平台应用模式），通过将文件描述符、端口等信息传递给子进程，子进程通过信息创建相应的 SocketHandle / ServerHandle，然后进行相应的端口绑定和监听、处理请求。</p></li></ul><p>以上就是 cluster 的原理，总结一下就是 cluster 模块应用 child_process 来创建子进程，子进程通过复写掉 cluster._getServer 方法，从而在 server.listen 来保证只有主进程监听端口，主子进程通过 IPC 进行通信，其次主进程根据平台或者协议不同，应用两种不同模块（round_robin_handle.js 和 shared_handle.js）进行请求分发给子进程处理。接下来我们看一下 cluster 的成熟的应用工具 PM2 的应用和原理。</p><h3 id="pm2-原理" tabindex="-1">PM2 原理 <a class="header-anchor" href="#pm2-原理" aria-label="Permalink to &quot;PM2 原理&quot;">​</a></h3><p>PM2 是<strong>守护进程管理器</strong>，可以帮助你管理和保持应用程序在线。PM2 入门非常简单，它是一个简单直观的 CLI 工具，可以通过 NPM 安装，接下来我们看下一些简单的用法。</p><h4 id="应用-1" tabindex="-1">应用 <a class="header-anchor" href="#应用-1" aria-label="Permalink to &quot;应用&quot;">​</a></h4><p>你可以使用如下命令进行 NPM 或者 Yarn 的安装：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ npm install pm2@</span><span style="color:#F97583;">latest</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">g</span></span>
<span class="line"><span style="color:#E1E4E8;"># or</span></span>
<span class="line"><span style="color:#E1E4E8;">$ yarn global add pm2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ npm install pm2@</span><span style="color:#D73A49;">latest</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">g</span></span>
<span class="line"><span style="color:#24292E;"># or</span></span>
<span class="line"><span style="color:#24292E;">$ yarn global add pm2</span></span></code></pre></div><p>安装成功后，可以使用如下命令查看是否安装成功以及当前的版本：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ pm2 </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">version</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ pm2 </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">version</span></span></code></pre></div><p>接下来我们使用 PM2 启动一个简单的 Node.js 项目，进入本讲代码的项目根目录，然后运行下面命令：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ pm2 start app.js</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ pm2 start app.js</span></span></code></pre></div><p>运行后，再执行如下命令：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ pm2 list</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ pm2 list</span></span></code></pre></div><p>可以看到如图 2 所示的结果，代表运行成功了。</p>`,62),i=p(`<p>图 2 pm2 list 运行结果</p><p>PM2 启动时可以带一些配置化参数，具体参数列表你可以参考<a href="https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noreferrer">官方文档</a>。在开发中我总结出了一套最佳的实践，如以下配置所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">module</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">exports</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    apps : [{</span></span>
<span class="line"><span style="color:#E1E4E8;">      name: </span><span style="color:#9ECBFF;">&quot;nodejs-column&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 启动进程名</span></span>
<span class="line"><span style="color:#E1E4E8;">      script: </span><span style="color:#9ECBFF;">&quot;./app.js&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 启动文件</span></span>
<span class="line"><span style="color:#E1E4E8;">      instances: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 启动进程数</span></span>
<span class="line"><span style="color:#E1E4E8;">      exec_mode: </span><span style="color:#9ECBFF;">&#39;cluster&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 多进程多实例</span></span>
<span class="line"><span style="color:#E1E4E8;">      env_development: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        NODE_ENV: </span><span style="color:#9ECBFF;">&quot;development&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        watch: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 开发环境使用 true，其他必须设置为 false</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#E1E4E8;">      env_testing: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        NODE_ENV: </span><span style="color:#9ECBFF;">&quot;testing&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        watch: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 开发环境使用 true，其他必须设置为 false</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#E1E4E8;">      env_production: {</span></span>
<span class="line"><span style="color:#E1E4E8;">        NODE_ENV: </span><span style="color:#9ECBFF;">&quot;production&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        watch: </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 开发环境使用 true，其他必须设置为 false</span></span>
<span class="line"><span style="color:#E1E4E8;">      },</span></span>
<span class="line"><span style="color:#E1E4E8;">      log_date_format: </span><span style="color:#9ECBFF;">&#39;YYYY-MM-DD HH:mm Z&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">      error_file: </span><span style="color:#9ECBFF;">&#39;~/data/err.log&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">// 错误日志文件，必须设置在项目外的目录，这里为了测试</span></span>
<span class="line"><span style="color:#E1E4E8;">      out_file: </span><span style="color:#9ECBFF;">&#39;~/data/info.log&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#6A737D;">//  流水日志，包括 console.log 日志，必须设置在项目外的目录，这里为了测试</span></span>
<span class="line"><span style="color:#E1E4E8;">      max_restarts: </span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    }]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">module</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">exports</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    apps : [{</span></span>
<span class="line"><span style="color:#24292E;">      name: </span><span style="color:#032F62;">&quot;nodejs-column&quot;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 启动进程名</span></span>
<span class="line"><span style="color:#24292E;">      script: </span><span style="color:#032F62;">&quot;./app.js&quot;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 启动文件</span></span>
<span class="line"><span style="color:#24292E;">      instances: </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 启动进程数</span></span>
<span class="line"><span style="color:#24292E;">      exec_mode: </span><span style="color:#032F62;">&#39;cluster&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 多进程多实例</span></span>
<span class="line"><span style="color:#24292E;">      env_development: {</span></span>
<span class="line"><span style="color:#24292E;">        NODE_ENV: </span><span style="color:#032F62;">&quot;development&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        watch: </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 开发环境使用 true，其他必须设置为 false</span></span>
<span class="line"><span style="color:#24292E;">      },</span></span>
<span class="line"><span style="color:#24292E;">      env_testing: {</span></span>
<span class="line"><span style="color:#24292E;">        NODE_ENV: </span><span style="color:#032F62;">&quot;testing&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        watch: </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 开发环境使用 true，其他必须设置为 false</span></span>
<span class="line"><span style="color:#24292E;">      },</span></span>
<span class="line"><span style="color:#24292E;">      env_production: {</span></span>
<span class="line"><span style="color:#24292E;">        NODE_ENV: </span><span style="color:#032F62;">&quot;production&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        watch: </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 开发环境使用 true，其他必须设置为 false</span></span>
<span class="line"><span style="color:#24292E;">      },</span></span>
<span class="line"><span style="color:#24292E;">      log_date_format: </span><span style="color:#032F62;">&#39;YYYY-MM-DD HH:mm Z&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">      error_file: </span><span style="color:#032F62;">&#39;~/data/err.log&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">// 错误日志文件，必须设置在项目外的目录，这里为了测试</span></span>
<span class="line"><span style="color:#24292E;">      out_file: </span><span style="color:#032F62;">&#39;~/data/info.log&#39;</span><span style="color:#24292E;">, </span><span style="color:#6A737D;">//  流水日志，包括 console.log 日志，必须设置在项目外的目录，这里为了测试</span></span>
<span class="line"><span style="color:#24292E;">      max_restarts: </span><span style="color:#005CC5;">10</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    }]</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span></code></pre></div><p>在上面的配置中要特别注意 <strong>error_file</strong> 和 <strong>out_file</strong>，这里的日志目录在项目初始化时要创建好，如果不提前创建好会导致线上运行失败，特别是无权限创建目录时。其次如果存在环境差异的配置时，可以放置在不同的环境下，最终可以使用下面三种方式来启动项目，分别对应不同环境。</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pm2</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">start</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pm2.config.js</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--env</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">development</span></span>
<span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pm2</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">start</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pm2.config.js</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--env</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">testing</span></span>
<span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pm2</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">start</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">pm2.config.js</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">--env</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">production</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">pm2</span><span style="color:#24292E;"> </span><span style="color:#032F62;">start</span><span style="color:#24292E;"> </span><span style="color:#032F62;">pm2.config.js</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--env</span><span style="color:#24292E;"> </span><span style="color:#032F62;">development</span></span>
<span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">pm2</span><span style="color:#24292E;"> </span><span style="color:#032F62;">start</span><span style="color:#24292E;"> </span><span style="color:#032F62;">pm2.config.js</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--env</span><span style="color:#24292E;"> </span><span style="color:#032F62;">testing</span></span>
<span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">pm2</span><span style="color:#24292E;"> </span><span style="color:#032F62;">start</span><span style="color:#24292E;"> </span><span style="color:#032F62;">pm2.config.js</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">--env</span><span style="color:#24292E;"> </span><span style="color:#032F62;">production</span></span></code></pre></div><h4 id="原理-1" tabindex="-1">原理 <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;原理&quot;">​</a></h4><p>接下来我们来看下是如何实现的，由于整个项目是比较复杂庞大的，这里我们主要关注<strong>进程创建管理的原理</strong>。</p><p>首先我们来看下进程创建的方式，整体的流程如图 3 所示。</p>`,8),d=p('<p>图 3 PM2 源码多进程创建方式</p><p>这一方式涉及五个模块文件。</p><ul><li>CLI（lib/binaries/CLI.js）处理命令行输入，如我们运行的命令：</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">pm2 start pm2.config.js </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">env development</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">pm2 start pm2.config.js </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">env development</span></span></code></pre></div><ul><li><p>API（lib/API.js）对外暴露的各种命令行调用方法，比如上面的 start 命令对应的 API-&gt;start 方法。</p></li><li><p>Client （lib/Client.js）可以理解为命令行接收端，负责创建守护进程 Daemon，并与 Daemon（lib/Daemon.js）保持 RPC 连接。</p></li><li><p>God （lib/God.js）主要负责进程的创建和管理，主要是通过 Daemon 调用，Client 所有调用都是通过 RPC 调用 Daemon，然后 Daemon 调用 God 中的方法。</p></li><li><p>最终在 God 中调用 ClusterMode（lib/God/ClusterMode.js）模块，在 ClusterMode 中调用 Node.js 的 cluster.fork 创建子进程。</p></li></ul><p>图 3 中首先通过命令行解析调用 API，API 中的方法基本上是与 CLI 中的命令行一一对应的，API 中的 start 方法会根据传入参数判断是否是调用的方法，一般情况下使用的都是一个 JSON 配置文件，因此调用 API 中的私有方法 _startJson。</p><p>接下来就开始在 Client 模块中流转了，在 _startJson 中会调用 executeRemote 方法，该方法会先判断 PM2 的守护进程 Daemon 是否启动，如果没有启动会先调用 Daemon 模块中的方法启动守护进程 RPC 服务，启动成功后再通知 Client 并建立 RPC 通信连接。</p><p>成功建立连接后，Client 会发送启动 Node.js 子进程的命令 prepare，该命令传递 Daemon，Daemon 中有一份对应的命令的执行方法，该命令最终会调用 God 中的 prepare 方法。</p><p>在 God 中最终会调用 God 文件夹下的 ClusterMode 模块，应用 Node.js 的 cluster.fork 创建子进程，这样就完成了整个启动过程。</p><p>综上所述，PM2 通过命令行，使用 RPC 建立 Client 与 Daemon 进程之间的通信，通过 RPC 通信方式，调用 God，从而应用 Node.js 的 cluster.fork 创建子进程的。以上是启动的流程，对于其他命令指令，比如 stop、restart 等，也是一样的通信流转过程，你参照上面的流程分析就可以了，如果遇到任何问题，都可以在留言区与我交流。</p><blockquote><p>以上的分析你需要参考<a href="https://github.com/Unitech/pm2/tree/64f8ea0f2c31c7d70a415eccc6222547b3664e65" target="_blank" rel="noreferrer">PM2 的 GitHub 源码</a>。</p></blockquote><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本讲主要介绍了 Node.js 中的 cluster 模块，并深入介绍了其核心原理，其次介绍了目前比较常用的多进程管理工具 PM2 的应用和原理。学完本讲后，需要掌握 Node.js cluster 原理，并且掌握 PM2 的实现原理。</p><p>接下来我们将开始讲解一些关于 Node.js 性能相关的知识，为后续的高性能服务做一定的准备，其次也在为后续性能优化打下一定的技术基础。</p><p>下一讲会讲解，目前我们在使用的 Node.js cluster 模式存在的性能问题。</p><hr><p>[</p>',17),F=a("p",null,[s("]("),a("a",{href:"https://shenceyun.lagou.com/t/mka",target:"_blank",rel:"noreferrer"},"https://shenceyun.lagou.com/t/mka"),s(")")],-1),u=a("p",null,[a("strong",null,"《大前端高薪训练营》")],-1),h=a("p",null,[s("对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。"),a("a",{href:"https://shenceyun.lagou.com/t/mka",target:"_blank",rel:"noreferrer"},"点击链接"),s("，快来领取！")],-1);function g(C,v,m,_,A,D){const n=e("Image");return t(),r("div",null,[E,l(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M01/1D/E0/CioPOWBQKV2ABtnsAAAuF7ZUkEQ818.png"}),s(),y,l(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M01/1D/E3/Cgp9HWBQKZeAM-MIAAB0_RHaw1E022.png"}),s(),i,l(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M01/1D/E0/CioPOWBQKaWAHrR1AAKhg2CW1Z0319.png"}),s(),d,l(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M00/12/FA/CioPOWBBrAKAAod-AASyC72ZqWw233.png"}),s(),F,u,h])}const B=o(c,[["render",g]]);export{k as __pageData,B as default};
