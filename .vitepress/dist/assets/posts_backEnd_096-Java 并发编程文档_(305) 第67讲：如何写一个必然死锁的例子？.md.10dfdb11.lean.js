import{_ as o,j as e,o as t,g as c,k as l,s,h as n,Q as p}from"./chunks/framework.e0c66c3f.js";const v=JSON.parse('{"title":"死锁是什么？有什么危害? ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(305) 第67讲：如何写一个必然死锁的例子？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(305) 第67讲：如何写一个必然死锁的例子？.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/096-Java 并发编程文档/(305) 第67讲：如何写一个必然死锁的例子？.md"},E=p("",9),y=s("p",null,[n("可以看到这张漫画展示了两个绅士分别向对方鞠躬的场景，为了表示礼貌，他们弯下腰之后谁也不愿意先起身，都希望对方起身之后我再起身。可是这样一来，就"),s("strong",null,"没有任何人可以先起身"),n("，起身这个动作就一直无法继续执行，两人形成了相互等待的状态，所以这就是一种典型的死锁！")],-1),i=s("p",null,[s("strong",null,"两个线程的例子")],-1),u=s("p",null,[n("下面我们用动画的形式来看一下"),s("strong",null,"两个线程"),n("发生死锁的情况，如下图所示：")],-1),F=s("p",null,"此时我们有两个线程，分别是线程 A 和线程 B，假设线程 A 现在持有了锁 A，线程 B 持有了锁 B，然后线程 A 尝试去获取锁 B，当然它获取不到，因为线程 B 还没有释放锁 B。然后线程 B 又来尝试获取锁 A，同样线程 B 也获取不到锁 A，因为锁 A 已经被线程 A 持有了。这样一来，线程 A 和线程 B 就发生了死锁，因为它们都相互持有对方想要的资源，却又不释放自己手中的资源，形成相互等待，而且会一直等待下去。",-1),d=s("p",null,[s("strong",null,"多个线程造成死锁的情况")],-1),g=s("p",null,"死锁不仅仅存在于两个线程的场景，在多个线程中也同样存在。如果多个线程之间的依赖关系是环形，存在环路的依赖关系，那么也可能会发生死锁，如下图所示：",-1),h=p("",24),A=s("p",null,[n("所以现在的状态是，"),s("strong",null,"线程 1 卡在获取 o2 这把锁的位置，而线程 2 卡在获取 o1 这把锁的位置"),n('，这样一来线程 1 和线程 2 就形成了相互等待，需要对方持有的资源才能继续执行，从而形成了死锁。在这个例子里，如果线程 2 比线程 1 先启动，情况也是类似的，最终也会形成死锁。这就是一个"必然发生死锁的例子"。')],-1),_=s("h3",{id:"总结",tabindex:"-1"},[n("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),C=s("p",null,"在本课时中，我们首先介绍了什么是死锁，接着介绍了死锁在生活中、两个线程中以及多个线程中的例子。然后我们分析了死锁的影响，在 JVM 中如果发生死锁，可能会导致程序部分甚至全部无法继续向下执行的情况，所以死锁在 JVM 中所带来的危害和影响是比较大的，我们需要尽量避免。最后举了一个必然会发生死锁的例子代码，并且对此代码进行了详细的分析。",-1);function q(D,B,m,f,b,k){const a=e("Image");return t(),c("div",null,[E,l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/2C/Cgq2xl6NrzCAEFQ0AB-HOvxO39A990.png"}),y,i,u,l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/2C/Cgq2xl6NrzGAMfz3AABHRjw_QSE080.png"}),F,d,g,l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/2C/Cgq2xl6NrzGAeQrqAAA0YIeU1Qg392.png"}),h,s("ul",null,[s("li",null,[n("当第 1 个线程运行的时候，它会发现自己的 flag 是 1 ，所以它会尝试先获得 o1 这把锁，然后休眠 500 毫秒。"),l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/16/Ciqah16NrzGAQZWTAABLSoYg93c256.png"})]),s("li",null,[n("在线程 1 启动并休眠的期间，线程 2 同样会启动起来。由于线程 2 的 flag 是 2，所以它会进入到下面 的 if (flag == 2) 对应的代码块中，然后线程 2 首先会去获取 o2 这把锁。也就是说在线程 1 启动并获取到 o1 这把锁之后进行休眠的期间，线程 2 获取到了 o2 这把锁，然后线程 2 也开始 500 毫秒的休眠。"),l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/2C/Cgq2xl6NrzGAOxZlAABQzGeeung440.png"})]),s("li",null,[n("当线程 1 的 500 毫秒休眠时间结束后，它将尝试去获取 o2 这把锁，此时 o2 这个锁正被线程 2 持有，所以线程 1 无法获取到的 o2。"),l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/16/Ciqah16NrzKAcColAAA2HwmEHwg667.png"})]),s("li",null,[n("紧接着线程 2 也会苏醒过来，它将尝试获取 o1 这把锁，此时 o1 已被线程 1 持有。"),l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/2C/Cgq2xl6NrzKAWAc5AAA1lPZZeKo398.png"})])]),A,l(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/16/Ciqah16NrzKAQ0EzAABXlJN0J2Q517.png"}),_,C])}const M=o(r,[["render",q]]);export{v as __pageData,M as default};
