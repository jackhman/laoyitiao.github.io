import{_ as o,j as e,o as t,h as r,k as p,f as s,s as a,Q as l}from"./chunks/framework.d3daa342.js";const I=JSON.parse('{"title":"11简易版RPC框架实现（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4264) 11  简易版 RPC 框架实现（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4264) 11  简易版 RPC 框架实现（上）.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4264) 11  简易版 RPC 框架实现（上）.md"},E=a("h1",{id:"_11简易版rpc框架实现-上",tabindex:"-1"},[s("11简易版RPC框架实现（上） "),a("a",{class:"header-anchor",href:"#_11简易版rpc框架实现-上","aria-label":'Permalink to "11简易版RPC框架实现（上）"'},"​")],-1),y=a("p",null,'这是"基础知识"部分的最后一课时，我们将会运用前面介绍的基础知识来做一个实践项目 ------ 编写一个简易版本的 RPC 框架，作为"基础知识"部分的总结和回顾。',-1),i=a("p",null,[s('RPC 是"远程过程调用（Remote Procedure Call）"的缩写形式，比较通俗的解释是：'),a("strong",null,"像本地方法调用一样调用远程的服务"),s("。虽然 RPC 的定义非常简单，但是相对完整的、通用的 RPC 框架涉及很多方面的内容，例如注册发现、服务治理、负载均衡、集群容错、RPC 协议等，如下图所示：")],-1),F=l('<p>简易 RPC 框架的架构图</p><p>本课时我们主要实现<strong>RPC 框架的基石部分------远程调用</strong>，简易版 RPC 框架一次远程调用的核心流程是这样的：</p><ol><li><p>Client 首先会调用本地的代理，也就是图中的 Proxy。</p></li><li><p>Client 端 Proxy 会按照协议（Protocol），将调用中传入的数据序列化成字节流。</p></li><li><p>之后 Client 会通过网络，将字节数据发送到 Server 端。</p></li><li><p>Server 端接收到字节数据之后，会按照协议进行反序列化，得到相应的请求信息。</p></li><li><p>Server 端 Proxy 会根据序列化后的请求信息，调用相应的业务逻辑。</p></li><li><p>Server 端业务逻辑的返回值，也会按照上述逻辑返回给 Client 端。</p></li></ol><p>这个远程调用的过程，就是我们简易版本 RPC 框架的核心实现，只有理解了这个流程，才能进行后续的开发。</p><h3 id="项目结构" tabindex="-1">项目结构 <a class="header-anchor" href="#项目结构" aria-label="Permalink to &quot;项目结构&quot;">​</a></h3><p>了解了简易版 RPC 框架的工作流程和实现目标之后，我们再来看下项目的结构，为了方便起见，这里我们将整个项目放到了一个 Module 中了，如下图所示，你可以按照自己的需求进行模块划分。</p>',6),d=l('<p>那这各个包的功能是怎样的呢？我们就来一一说明。</p><ul><li><p>protocol：简易版 RPC 框架的自定义协议。</p></li><li><p>serialization：提供了自定义协议对应的序列化、反序列化的相关工具类。</p></li><li><p>codec：提供了自定义协议对应的编码器和解码器。</p></li><li><p>transport：基于 Netty 提供了底层网络通信的功能，其中会使用到 codec 包中定义编码器和解码器，以及 serialization 包中的序列化器和反序列化器。</p></li><li><p>registry：基于 ZooKeeper 和 Curator 实现了简易版本的注册中心功能。</p></li><li><p>proxy：使用 JDK 动态代理实现了一层代理。</p></li></ul><h3 id="自定义协议" tabindex="-1">自定义协议 <a class="header-anchor" href="#自定义协议" aria-label="Permalink to &quot;自定义协议&quot;">​</a></h3><p>当前已经有很多成熟的协议了，例如 HTTP、HTTPS 等，那为什么我们还要自定义 RPC 协议呢？</p><p>从功能角度考虑，HTTP 协议在 1.X 时代，只支持半双工传输模式，虽然支持长连接，但是不支持服务端主动推送数据。从效率角度来看，在一次简单的远程调用中，只需要传递方法名和加个简单的参数，此时，HTTP 请求中大部分数据都被 HTTP Header 占据，真正的有效负载非常少，效率就比较低。</p><p>当然，HTTP 协议也有自己的优势，例如，天然穿透防火墙，大量的框架和开源软件支持 HTTP 接口，而且配合 REST 规范使用也是很便捷的，所以有很多 RPC 框架直接使用 HTTP 协议，尤其是在 HTTP 2.0 之后，如 gRPC、Spring Cloud 等。</p><p>这里我们自定义一个简易版的 Demo RPC 协议，如下图所示：</p>',7),A=l(`<p>在 Demo RPC 的消息头中，包含了整个 RPC 消息的一些控制信息，例如，版本号、魔数、消息类型、附加信息、消息 ID 以及消息体的长度，在附加信息（extraInfo）中，按位进行划分，分别定义消息的类型、序列化方式、压缩方式以及请求类型。当然，你也可以自己扩充 Demo RPC 协议，实现更加复杂的功能。</p><p>Demo RPC 消息头对应的实体类是 Header，其定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Header</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">short</span><span style="color:#E1E4E8;"> magic; </span><span style="color:#6A737D;">// 魔数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> version; </span><span style="color:#6A737D;">// 协议版本</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> extraInfo; </span><span style="color:#6A737D;">// 附加信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Long messageId; </span><span style="color:#6A737D;">// 消息ID</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Integer size; </span><span style="color:#6A737D;">// 消息体长度</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span><span style="color:#6A737D;">// 省略getter/setter方法</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Header</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">short</span><span style="color:#24292E;"> magic; </span><span style="color:#6A737D;">// 魔数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> version; </span><span style="color:#6A737D;">// 协议版本</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> extraInfo; </span><span style="color:#6A737D;">// 附加信息</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Long messageId; </span><span style="color:#6A737D;">// 消息ID</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Integer size; </span><span style="color:#6A737D;">// 消息体长度</span></span>
<span class="line"><span style="color:#24292E;">    ... </span><span style="color:#6A737D;">// 省略getter/setter方法</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>确定了 Demo RPC 协议消息头的结构之后，我们再来看 Demo RPC 协议消息体由哪些字段构成，这里我们通过 Request 和 Response 两个实体类来表示请求消息和响应消息的消息体：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Request</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Serializable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String serviceName; </span><span style="color:#6A737D;">// 请求的Service类名</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String methodName; </span><span style="color:#6A737D;">// 请求的方法名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Class</span><span style="color:#E1E4E8;">[] argTypes; </span><span style="color:#6A737D;">// 请求方法的参数类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] args; </span><span style="color:#6A737D;">// 请求方法的参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span><span style="color:#6A737D;">// 省略getter/setter方法</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Response</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Serializable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> code </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 响应的错误码，正常响应为0，非0表示异常响应</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String errMsg; </span><span style="color:#6A737D;">// 异常信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Object result; </span><span style="color:#6A737D;">// 响应结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span><span style="color:#6A737D;">// 省略getter/setter方法</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Request</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String serviceName; </span><span style="color:#6A737D;">// 请求的Service类名</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String methodName; </span><span style="color:#6A737D;">// 请求的方法名称</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Class</span><span style="color:#24292E;">[] argTypes; </span><span style="color:#6A737D;">// 请求方法的参数类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] args; </span><span style="color:#6A737D;">// 请求方法的参数</span></span>
<span class="line"><span style="color:#24292E;">    ... </span><span style="color:#6A737D;">// 省略getter/setter方法</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Response</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> code </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 响应的错误码，正常响应为0，非0表示异常响应</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String errMsg; </span><span style="color:#6A737D;">// 异常信息</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Object result; </span><span style="color:#6A737D;">// 响应结果</span></span>
<span class="line"><span style="color:#24292E;">    ... </span><span style="color:#6A737D;">// 省略getter/setter方法</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>注意，Request 和 Response 对象是要进行序列化的，需要实现 Serializable 接口。为了让这两个类的对象能够在 Client 和 Server 之间跨进程传输，需要进行序列化和反序列化操作，这里定义一个 Serialization 接口，统一完成序列化相关的操作：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Serialization</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">serialize</span><span style="color:#E1E4E8;">(T </span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; T </span><span style="color:#B392F0;">deSerialize</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">, Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clz</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Serialization</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">serialize</span><span style="color:#24292E;">(T </span><span style="color:#E36209;">obj</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; T </span><span style="color:#6F42C1;">deSerialize</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">data</span><span style="color:#24292E;">, Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clz</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 Demo RPC 中默认使用 Hessian 序列化方式，下面的 HessianSerialization 就是基于 Hessian 序列化方式对 Serialization 接口的实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HessianSerialization</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Serialization</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">serialize</span><span style="color:#E1E4E8;">(T </span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ByteArrayOutputStream os </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ByteArrayOutputStream</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        HessianOutput hessianOutput </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HessianOutput</span><span style="color:#E1E4E8;">(os);</span></span>
<span class="line"><span style="color:#E1E4E8;">        hessianOutput.</span><span style="color:#B392F0;">writeObject</span><span style="color:#E1E4E8;">(obj);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> os.</span><span style="color:#B392F0;">toByteArray</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; T </span><span style="color:#B392F0;">deSerialize</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">, Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clazz</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ByteArrayInputStream is </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ByteArrayInputStream</span><span style="color:#E1E4E8;">(data);</span></span>
<span class="line"><span style="color:#E1E4E8;">        HessianInput hessianInput </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HessianInput</span><span style="color:#E1E4E8;">(is);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (T) hessianInput.</span><span style="color:#B392F0;">readObject</span><span style="color:#E1E4E8;">(clazz);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HessianSerialization</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Serialization</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">serialize</span><span style="color:#24292E;">(T </span><span style="color:#E36209;">obj</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException {</span></span>
<span class="line"><span style="color:#24292E;">        ByteArrayOutputStream os </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ByteArrayOutputStream</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        HessianOutput hessianOutput </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HessianOutput</span><span style="color:#24292E;">(os);</span></span>
<span class="line"><span style="color:#24292E;">        hessianOutput.</span><span style="color:#6F42C1;">writeObject</span><span style="color:#24292E;">(obj);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> os.</span><span style="color:#6F42C1;">toByteArray</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; T </span><span style="color:#6F42C1;">deSerialize</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">data</span><span style="color:#24292E;">, Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clazz</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException {</span></span>
<span class="line"><span style="color:#24292E;">        ByteArrayInputStream is </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ByteArrayInputStream</span><span style="color:#24292E;">(data);</span></span>
<span class="line"><span style="color:#24292E;">        HessianInput hessianInput </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HessianInput</span><span style="color:#24292E;">(is);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (T) hessianInput.</span><span style="color:#6F42C1;">readObject</span><span style="color:#24292E;">(clazz);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在有的场景中，请求或响应传输的数据比较大，直接传输比较消耗带宽，所以一般会采用压缩后再发送的方式。在前面介绍的 Demo RPC 消息头中的 extraInfo 字段中，就包含了标识消息体压缩方式的 bit 位。这里我们定义一个 Compressor 接口抽象所有压缩算法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Compressor</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">compress</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">array</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">unCompress</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">array</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Compressor</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">compress</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">array</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">unCompress</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">array</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>同时提供了一个基于 Snappy 压缩算法的实现，作为 Demo RPC 的默认压缩算法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SnappyCompressor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Compressor</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">compress</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">array</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (array </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Snappy.</span><span style="color:#B392F0;">compress</span><span style="color:#E1E4E8;">(array);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">unCompress</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">array</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (array </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Snappy.</span><span style="color:#B392F0;">uncompress</span><span style="color:#E1E4E8;">(array);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SnappyCompressor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Compressor</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">compress</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">array</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (array </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Snappy.</span><span style="color:#6F42C1;">compress</span><span style="color:#24292E;">(array);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">unCompress</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">array</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> IOException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (array </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Snappy.</span><span style="color:#6F42C1;">uncompress</span><span style="color:#24292E;">(array);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="编解码实现" tabindex="-1">编解码实现 <a class="header-anchor" href="#编解码实现" aria-label="Permalink to &quot;编解码实现&quot;">​</a></h3><p>了解了自定义协议的结构之后，我们再来解决协议的编解码问题。</p><p>前面课时介绍 Netty 核心概念的时候我们提到过，Netty 每个 Channel 绑定一个 ChannelPipeline，并依赖 ChannelPipeline 中添加的 ChannelHandler 处理接收到（或要发送）的数据，其中就包括字节到消息（以及消息到字节）的转换。Netty 中提供了 ByteToMessageDecoder、 MessageToByteEncoder、MessageToMessageEncoder、MessageToMessageDecoder 等抽象类来实现 Message 与 ByteBuf 之间的转换以及 Message 之间的转换，如下图所示：</p>`,16),D=a("p",null,"Netty 提供的 Decoder 和 Encoder 实现",-1),u=a("p",null,"在 Netty 的源码中，我们可以看到对很多已有协议的序列化和反序列化都是基于上述抽象类实现的，例如，HttpServerCodec 中通过依赖 HttpServerRequestDecoder 和 HttpServerResponseEncoder 来实现 HTTP 请求的解码和 HTTP 响应的编码。如下图所示，HttpServerRequestDecoder 继承自 ByteToMessageDecoder，实现了 ByteBuf 到 HTTP 请求之间的转换；HttpServerResponseEncoder 继承自 MessageToMessageEncoder，实现 HTTP 响应到其他消息的转换（其中包括转换成 ByteBuf 的能力）。",-1),g=l(`<p>Netty 中 HTTP 协议的 Decoder 和 Encoder 实现</p><p>在简易版 RPC 框架中，我们的自定义请求暂时没有 HTTP 协议那么复杂，只要<strong>简单继承 ByteToMessageDecoder 和 MessageToMessageEncoder 即可</strong>。</p><p>首先来看 DemoRpcDecoder，它实现了 ByteBuf 到 Demo RPC Message 的转换，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoRpcDecoder</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ByteToMessageDecoder</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">decode</span><span style="color:#E1E4E8;">(ChannelHandlerContext </span><span style="color:#FFAB70;">ctx</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">           ByteBuf </span><span style="color:#FFAB70;">byteBuf</span><span style="color:#E1E4E8;">, List&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">out</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (byteBuf.</span><span style="color:#B392F0;">readableBytes</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> Constants.HEADER_SIZE) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 不到16字节的话无法解析消息头，暂不读取</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 记录当前readIndex指针的位置，方便重置</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">markReaderIndex</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 尝试读取消息头的魔数部分</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">short</span><span style="color:#E1E4E8;"> magic </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> byteBuf.</span><span style="color:#B392F0;">readShort</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (magic </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> Constants.MAGIC) { </span><span style="color:#6A737D;">// 魔数不匹配会抛出异常</span></span>
<span class="line"><span style="color:#E1E4E8;">            byteBuf.</span><span style="color:#B392F0;">resetReaderIndex</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 重置readIndex指针</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RuntimeException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;magic number error:&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> magic);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 依次读取消息版本、附加信息、消息ID以及消息体长度四部分</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> version </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> byteBuf.</span><span style="color:#B392F0;">readByte</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> extraInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> byteBuf.</span><span style="color:#B392F0;">readByte</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> messageId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> byteBuf.</span><span style="color:#B392F0;">readLong</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> size </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> byteBuf.</span><span style="color:#B392F0;">readInt</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object request </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 心跳消息是没有消息体的，无须读取</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">Constants.</span><span style="color:#B392F0;">isHeartBeat</span><span style="color:#E1E4E8;">(extraInfo)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 对于非心跳消息，没有积累到足够的数据是无法进行反序列化的</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (byteBuf.</span><span style="color:#B392F0;">readableBytes</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> size) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                byteBuf.</span><span style="color:#B392F0;">resetReaderIndex</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 读取消息体并进行反序列化</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] payload </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[size];</span></span>
<span class="line"><span style="color:#E1E4E8;">            byteBuf.</span><span style="color:#B392F0;">readBytes</span><span style="color:#E1E4E8;">(payload);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这里根据消息头中的extraInfo部分选择相应的序列化和压缩方式</span></span>
<span class="line"><span style="color:#E1E4E8;">            Serialization serialization </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              SerializationFactory.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(extraInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">            Compressor compressor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompressorFactory.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(extraInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 经过解压缩和反序列化得到消息体</span></span>
<span class="line"><span style="color:#E1E4E8;">            request </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> serialization.</span><span style="color:#B392F0;">deserialize</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                compressor.</span><span style="color:#B392F0;">unCompress</span><span style="color:#E1E4E8;">(payload), Request.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将上面读取到的消息头和消息体拼装成完整的Message并向后传递</span></span>
<span class="line"><span style="color:#E1E4E8;">        Header header </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Header</span><span style="color:#E1E4E8;">(magic, version, extraInfo, </span></span>
<span class="line"><span style="color:#E1E4E8;">            messageId, size);</span></span>
<span class="line"><span style="color:#E1E4E8;">        Message message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Message</span><span style="color:#E1E4E8;">(header, request);</span></span>
<span class="line"><span style="color:#E1E4E8;">        out.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(message);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoRpcDecoder</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ByteToMessageDecoder</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">decode</span><span style="color:#24292E;">(ChannelHandlerContext </span><span style="color:#E36209;">ctx</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">           ByteBuf </span><span style="color:#E36209;">byteBuf</span><span style="color:#24292E;">, List&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">out</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Exception {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (byteBuf.</span><span style="color:#6F42C1;">readableBytes</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> Constants.HEADER_SIZE) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 不到16字节的话无法解析消息头，暂不读取</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 记录当前readIndex指针的位置，方便重置</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">markReaderIndex</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 尝试读取消息头的魔数部分</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">short</span><span style="color:#24292E;"> magic </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> byteBuf.</span><span style="color:#6F42C1;">readShort</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (magic </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> Constants.MAGIC) { </span><span style="color:#6A737D;">// 魔数不匹配会抛出异常</span></span>
<span class="line"><span style="color:#24292E;">            byteBuf.</span><span style="color:#6F42C1;">resetReaderIndex</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 重置readIndex指针</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RuntimeException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;magic number error:&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> magic);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 依次读取消息版本、附加信息、消息ID以及消息体长度四部分</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> version </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> byteBuf.</span><span style="color:#6F42C1;">readByte</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> extraInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> byteBuf.</span><span style="color:#6F42C1;">readByte</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> messageId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> byteBuf.</span><span style="color:#6F42C1;">readLong</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> size </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> byteBuf.</span><span style="color:#6F42C1;">readInt</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        Object request </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 心跳消息是没有消息体的，无须读取</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">Constants.</span><span style="color:#6F42C1;">isHeartBeat</span><span style="color:#24292E;">(extraInfo)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 对于非心跳消息，没有积累到足够的数据是无法进行反序列化的</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (byteBuf.</span><span style="color:#6F42C1;">readableBytes</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> size) {</span></span>
<span class="line"><span style="color:#24292E;">                byteBuf.</span><span style="color:#6F42C1;">resetReaderIndex</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 读取消息体并进行反序列化</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] payload </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[size];</span></span>
<span class="line"><span style="color:#24292E;">            byteBuf.</span><span style="color:#6F42C1;">readBytes</span><span style="color:#24292E;">(payload);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这里根据消息头中的extraInfo部分选择相应的序列化和压缩方式</span></span>
<span class="line"><span style="color:#24292E;">            Serialization serialization </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">              SerializationFactory.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(extraInfo);</span></span>
<span class="line"><span style="color:#24292E;">            Compressor compressor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompressorFactory.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(extraInfo);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 经过解压缩和反序列化得到消息体</span></span>
<span class="line"><span style="color:#24292E;">            request </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> serialization.</span><span style="color:#6F42C1;">deserialize</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                compressor.</span><span style="color:#6F42C1;">unCompress</span><span style="color:#24292E;">(payload), Request.class);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将上面读取到的消息头和消息体拼装成完整的Message并向后传递</span></span>
<span class="line"><span style="color:#24292E;">        Header header </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Header</span><span style="color:#24292E;">(magic, version, extraInfo, </span></span>
<span class="line"><span style="color:#24292E;">            messageId, size);</span></span>
<span class="line"><span style="color:#24292E;">        Message message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Message</span><span style="color:#24292E;">(header, request);</span></span>
<span class="line"><span style="color:#24292E;">        out.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(message);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来看 DemoRpcEncoder，它实现了 Demo RPC Message 到 ByteBuf 的转换，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoRpcEncoder</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MessageToByteEncoder</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">Message</span><span style="color:#E1E4E8;">&gt;{</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">encode</span><span style="color:#E1E4E8;">(ChannelHandlerContext </span><span style="color:#FFAB70;">channelHandlerContext</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                Message </span><span style="color:#FFAB70;">message</span><span style="color:#E1E4E8;">, ByteBuf </span><span style="color:#FFAB70;">byteBuf</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Header header </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> message.</span><span style="color:#B392F0;">getHeader</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 依次序列化消息头中的魔数、版本、附加信息以及消息ID</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">writeShort</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getMagic</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">writeByte</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getVersion</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">writeByte</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getExtraInfo</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">writeLong</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getMessageId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object content </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> message.</span><span style="color:#B392F0;">getContent</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Constants.</span><span style="color:#B392F0;">isHeartBeat</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getExtraInfo</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            byteBuf.</span><span style="color:#B392F0;">writeInt</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 心跳消息，没有消息体，这里写入0</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 按照extraInfo部分指定的序列化方式和压缩方式进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">        Serialization serialization </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">            SerializationFactory.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getExtraInfo</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        Compressor compressor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">            CompressorFactory.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(header.</span><span style="color:#B392F0;">getExtraInfo</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] payload </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> compressor.</span><span style="color:#B392F0;">compress</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">            serialization.</span><span style="color:#B392F0;">serialize</span><span style="color:#E1E4E8;">(content));</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">writeInt</span><span style="color:#E1E4E8;">(payload.length); </span><span style="color:#6A737D;">// 写入消息体长度</span></span>
<span class="line"><span style="color:#E1E4E8;">        byteBuf.</span><span style="color:#B392F0;">writeBytes</span><span style="color:#E1E4E8;">(payload); </span><span style="color:#6A737D;">// 写入消息体</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoRpcEncoder</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MessageToByteEncoder</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">Message</span><span style="color:#24292E;">&gt;{</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">encode</span><span style="color:#24292E;">(ChannelHandlerContext </span><span style="color:#E36209;">channelHandlerContext</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                Message </span><span style="color:#E36209;">message</span><span style="color:#24292E;">, ByteBuf </span><span style="color:#E36209;">byteBuf</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Exception {</span></span>
<span class="line"><span style="color:#24292E;">        Header header </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> message.</span><span style="color:#6F42C1;">getHeader</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 依次序列化消息头中的魔数、版本、附加信息以及消息ID</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">writeShort</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getMagic</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">writeByte</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getVersion</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">writeByte</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getExtraInfo</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">writeLong</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getMessageId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        Object content </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> message.</span><span style="color:#6F42C1;">getContent</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Constants.</span><span style="color:#6F42C1;">isHeartBeat</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getExtraInfo</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">            byteBuf.</span><span style="color:#6F42C1;">writeInt</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 心跳消息，没有消息体，这里写入0</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 按照extraInfo部分指定的序列化方式和压缩方式进行处理</span></span>
<span class="line"><span style="color:#24292E;">        Serialization serialization </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">            SerializationFactory.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getExtraInfo</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        Compressor compressor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">            CompressorFactory.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(header.</span><span style="color:#6F42C1;">getExtraInfo</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] payload </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> compressor.</span><span style="color:#6F42C1;">compress</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">            serialization.</span><span style="color:#6F42C1;">serialize</span><span style="color:#24292E;">(content));</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">writeInt</span><span style="color:#24292E;">(payload.length); </span><span style="color:#6A737D;">// 写入消息体长度</span></span>
<span class="line"><span style="color:#24292E;">        byteBuf.</span><span style="color:#6F42C1;">writeBytes</span><span style="color:#24292E;">(payload); </span><span style="color:#6A737D;">// 写入消息体</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时我们首先介绍了简易 RPC 框架的基础架构以及其处理一次远程调用的基本流程，并对整个简易 RPC 框架项目的结构进行了简单介绍。接下来，我们讲解了简易 RPC 框架使用的自定义协议格式、序列化/反序列化方式以及压缩方式，这些都是远程数据传输不可或缺的基础。然后，我们又介绍了 Netty 中的编解码体系，以及 HTTP 协议相关的编解码器实现。最后，我们还分析了简易 RPC 协议对应的编解码器，即 DemoRpcEncoder 和 DemoRpcDecoder。</p><p>在下一课时，我们将自底向上，继续介绍简易 RPC 框架的剩余部分实现。</p><p>简易版 RPC 框架 Demo 的链接：<a href="https://github.com/xxxlxy2008/demo-prc" target="_blank" rel="noreferrer">https://github.com/xxxlxy2008/demo-prc</a> 。</p>`,10);function C(B,b,h,m,v,f){const n=e("Image");return t(),r("div",null,[E,y,i,p(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/48/E4/Ciqc1F9N7ryADlJBAAIlSORjRt8863.png"}),s(),F,p(n,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image/M00/48/E4/Ciqc1F9N7suABhc9AAEN07V6uf8238.png"}),s(),d,p(n,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/48/E4/Ciqc1F9N7tiAMnZdAAC77BEcyZk305.png"}),s(),A,p(n,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/48/F3/CgqCHl9N89uAPRjFAAE8pTlyXls424.png"}),s(),D,u,p(n,{alt:"HttpServerCodec结构图.png",src:"https://s0.lgstatic.com/i/image/M00/48/FD/CgqCHl9OAneAfCv0AADjLyEPSpc098.png"}),s(),g])}const T=o(c,[["render",C]]);export{I as __pageData,T as default};
