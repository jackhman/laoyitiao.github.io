import{_ as o,D as l,o as r,g as t,J as e,h as a,m as s,Q as p}from"./chunks/framework.f67d7268.js";const H=JSON.parse('{"title":"12从应用到原理：如何高效阅读ShardingSphere源码？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3571) 12  从应用到原理：如何高效阅读 ShardingSphere 源码？.md","filePath":"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3571) 12  从应用到原理：如何高效阅读 ShardingSphere 源码？.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3571) 12  从应用到原理：如何高效阅读 ShardingSphere 源码？.md"},i=s("h1",{id:"_12从应用到原理-如何高效阅读shardingsphere源码",tabindex:"-1"},[a("12从应用到原理：如何高效阅读ShardingSphere源码？ "),s("a",{class:"header-anchor",href:"#_12从应用到原理-如何高效阅读shardingsphere源码","aria-label":'Permalink to "12从应用到原理：如何高效阅读ShardingSphere源码？"'},"​")],-1),h=s("p",null,'从本课时开始，专栏将进入："ShardingSphere 源码解析之基础设施"的模块。在介绍完 ShardingSphere 所具备的分库分表、读写分离、分布式事务、数据脱敏等各项核心功能之后，我将带领你全面剖析这些核心功能背后的实现原理和机制。我们将通过深入解析 ShardingSphere 源码这一途径来实现这一目标。',-1),E=s("h3",{id:"如何系统剖析-shardingsphere-的代码结构",tabindex:"-1"},[a("如何系统剖析 ShardingSphere 的代码结构？ "),s("a",{class:"header-anchor",href:"#如何系统剖析-shardingsphere-的代码结构","aria-label":'Permalink to "如何系统剖析 ShardingSphere 的代码结构？"'},"​")],-1),S=s("p",null,[a("在阅读开源框架时，我们碰到的一大问题在于，"),s("strong",null,"常常会不由自主地陷入代码的细节而无法把握框架代码的整体结构"),a("。市面上主流的、被大家所熟知而广泛应用的代码框架肯定考虑得非常周全，其代码结构不可避免存在一定的复杂性。对 ShardingSphere 而言，情况也是一样，我们发现 ShardingSphere 源码的一级代码结构目录就有 15 个，而这些目录内部包含的具体 Maven 工程则多达 50 余个：")],-1),y=s("p",null,"ShardingSphere 源码一级代码结构目录",-1),d=s("p",null,[s("strong",null,"如何快速把握 ShardingSphere 的代码结构呢？这是我们剖析源码时需要回答的第一个问题"),a("，为此我们需要梳理剖析 ShardingSphere 框架代码结构的系统方法。")],-1),g=s("p",null,"本课时我们将对如何系统剖析 ShardingSphere 代码结构这一话题进行抽象，梳理出应对这一问题的六大系统方法（如下图）：",-1),u=s("p",null,"接下来，我们将结合 ShardingSphere 框架对这些方法进行展开。",-1),_=s("h4",{id:"基于可扩展性设计阅读源码",tabindex:"-1"},[a("基于可扩展性设计阅读源码 "),s("a",{class:"header-anchor",href:"#基于可扩展性设计阅读源码","aria-label":'Permalink to "基于可扩展性设计阅读源码"'},"​")],-1),C=s("p",null,"ShardingSphere 在设计上采用了微内核架构模式来确保系统具有高度的可扩展性，并使用了 JDK 提供的 SPI 机制来具体实现微内核架构。在 ShardingSphere 源代码的根目录下，存在一个独立工程 shardingsphere-spi。显然，从命名上看，这个工程中应该包含了 ShardingSphere 实现 SPI 的相关代码。该工程中存在一个 TypeBasedSPI 接口，它的类层结构比较丰富，课程后面将要讲到的很多核心接口都继承了该接口，包括实现配置中心的 ConfigCenter、注册中心的 RegistryCenter 等，如下所示：",-1),D=p("",8),A=p("",7),F=s("p",null,"在阅读 ShardingSphere 源码时，JDBC 规范所提供的核心接口及其实现类，为我们高效梳理代码入口和组织方式提供了一种途径。",-1),R=s("h4",{id:"基于核心执行流程阅读源码",tabindex:"-1"},[a("基于核心执行流程阅读源码 "),s("a",{class:"header-anchor",href:"#基于核心执行流程阅读源码","aria-label":'Permalink to "基于核心执行流程阅读源码"'},"​")],-1),m=s("p",null,"事实上，还有一个比较容易理解和把握的方法可以帮我们梳理代码结构，这就是代码的执行流程。任何系统行为都可以认为是流程的组合。通过分析，看似复杂的代码结构一般都能梳理出一条贯穿全局的主流程。只要我们抓住这条主流程，就能把握框架的整体代码结构。",-1),x=s("p",null,"那么，对于 ShardingSphere 框架而言，什么才是它的主流程呢？这个问题其实不难回答。事实上，JDBC 规范为我们实现数据存储和访问提供了基本的开发流程。我们可以从 DataSource 入手，逐步引入 Connection、Statement 等对象，并完成 SQL 执行的主流程。这是从框架提供的核心功能角度梳理的一种主流程。",-1),w=s("p",null,[a("对于框架内部的代码组织结构而言，实际上也存在着核心流程的概念。最典型的就是 ShardingSphere 的分片引擎结构，整个分片引擎执行流程可以非常清晰的分成五个组成部分，"),s("strong",null,"分别是解析引擎、路由引擎、改写引擎、执行引擎和归并引擎"),a("：")],-1),b=p("",9),q=s("p",null,"关于数据脱敏以及装饰器模式的具体实现细节我们会在《数据脱敏：如何基于改写引擎实现低侵入性数据脱敏方案？》中进行详细展开。",-1),Q=s("h4",{id:"基于通用外部组件阅读源码",tabindex:"-1"},[a("基于通用外部组件阅读源码 "),s("a",{class:"header-anchor",href:"#基于通用外部组件阅读源码","aria-label":'Permalink to "基于通用外部组件阅读源码"'},"​")],-1),T=s("p",null,[a("在《开篇寄语：如何正确学习一款分库分表开源框架？》中，我们提出了一种观点，即"),s("strong",null,"技术原理存在相通性"),a("。这点同样可以帮助我们更好地阅读 ShardingSphere 源码。")],-1),k=s("p",null,"在 ShardingSphere 中集成了一批优秀的开源框架，包括用于实现配置中心和注册中心的Zookeeper、Apollo、Nacos，用于实现链路跟踪的 SkyWalking，用于实现分布式事务的 Atomikos 和 Seata 等。",-1),L=s("p",null,"我们先以分布式事务为例，ShardingSphere 提供了一个 sharding-transaction-core 代码工程，用于完成对分布式事务的抽象。然后又针对基于两阶段提交的场景，提供了 sharding-transaction-2pc 代码工程，以及针对柔性事务提供了 sharding-transaction-base 代码工程。而在 sharding-transaction-2pc 代码工程内部，又包含了如下所示的 5 个子代码工程。",-1),f=p("",22);function P(B,v,I,M,V,J){const n=l("Image");return r(),t("div",null,[i,h,E,S,e(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/37/55/CgqCHl8ZTt2ASVxWAAAShIkwDl8738.png"}),a(),y,d,g,e(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/37/55/CgqCHl8ZTuuACx6KAACdjxhg0lw729.png"}),a(),u,_,C,e(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/37/55/CgqCHl8ZTvyAET3QAABeRzWl3zI113.png"}),a(),D,e(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/37/4A/Ciqc1F8ZTxWAcdkRAACUdiRq_TI476.png"}),a(),A,e(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/37/4A/Ciqc1F8ZTyqAEYJUAACZMuFSODk999.png"}),a(),F,R,m,x,w,e(n,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/37/4A/Ciqc1F8ZTzuASMVSAACEHFtHTxA442.png"}),a(),b,e(n,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/37/4A/Ciqc1F8ZT32ASVKBAACFTeG0vcw337.png"}),a(),q,Q,T,k,L,e(n,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image/M00/37/55/CgqCHl8ZT5KASWyUAAAJVU7jHKk131.png"}),a(),f])}const K=o(c,[["render",P]]);export{H as __pageData,K as default};
