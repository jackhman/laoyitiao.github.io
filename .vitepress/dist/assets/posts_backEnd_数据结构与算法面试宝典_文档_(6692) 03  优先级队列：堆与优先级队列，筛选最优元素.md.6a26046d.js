import{_ as o,j as e,o as t,g as r,k as n,s as a,h as l,Q as p}from"./chunks/framework.b3d8e22e.js";const x=JSON.parse('{"title":"堆 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6692) 03  优先级队列：堆与优先级队列，筛选最优元素.md","filePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6692) 03  优先级队列：堆与优先级队列，筛选最优元素.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/数据结构与算法面试宝典_文档/(6692) 03  优先级队列：堆与优先级队列，筛选最优元素.md"},E=a("p",null,[l("在电影院，相信你也看到有人持有 VIP 卡，可以直接越过队列进场去看电影。对于这种情况，我们的程序也可以用"),a("strong",null,"优先级队列"),l(" （"),a("strong",null,"Priority Queue"),l("）来模拟这个场景。")],-1),y=a("p",null,[l("通常而言，"),a("strong",null,"优先级队列都是基于堆"),l(" （"),a("strong",null,"Heap"),l(" ）"),a("strong",null,"这种数据结构来实现的"),l("。因此，我们在正式开始学习优先级队列之前，还需要深入浅出地介绍一下堆及其相关的四种操作。")],-1),i=p('<h3 id="堆" tabindex="-1">堆 <a class="header-anchor" href="#堆" aria-label="Permalink to &quot;堆&quot;">​</a></h3><p>FIFO 队列能够解决广度遍历、分层遍历类似的题目，FIFO 队列在遍历的时候，有一个有趣的特点：<strong>每一层结点的先后顺序，遍历时就确定下来了</strong>。</p><p>如果把这种先后顺序当成优先级，那么这些结点之间的优先级就由遍历时的顺序决定。但是有时候我们遇到的问题，结点之间需要按照<strong>大小进行排序之后</strong> ，<strong>再决定优先级</strong> 。在这种情况下，FIFO 队列不再适用，就需要用一种新的数据结构------<strong>优先级队列</strong>。</p><p><strong>优先级队列底层依赖的数据结构一般是堆，而堆是面试中经常遇到的考点之一</strong>。因此，在这里我会先介绍堆的实现与要点，再介绍优先级队列的特点以及具体如何运用。</p><h4 id="堆的分类-大堆与小堆" tabindex="-1">堆的分类：大堆与小堆 <a class="header-anchor" href="#堆的分类-大堆与小堆" aria-label="Permalink to &quot;堆的分类：大堆与小堆&quot;">​</a></h4><p>通常堆的结构都是表现为一棵树，如果<strong>根比左右子结点都大</strong> ，那么称为<strong>大堆</strong>。如下图所示：</p>',6),A=a("p",null,[l("如果"),a("strong",null,"根比左右子结点都要小"),l("，那么称为**小堆，**如下图所示：")],-1),g=p('<p>通过堆的定义，可以发现<strong>堆的特点：大堆的根是最大值，小堆的根是最小值</strong>。</p><p>更有趣的是，每次有元素 push 或者 pop 的时候，调整堆的时间复杂度为 O(lgn)，速度也非常快。因此，<strong>堆经常被用于优先级队列</strong>。接下来，我将以大堆为例，详细介绍堆的表示方式、添加元素、移除元素。</p><p><em>注：后面的堆操作都是基于大堆。</em></p><h4 id="堆的表示" tabindex="-1">堆的表示 <a class="header-anchor" href="#堆的表示" aria-label="Permalink to &quot;堆的表示&quot;">​</a></h4><p>大部分时候都是<strong>使用数组</strong>表示一个堆，而不是使用二叉树。这是因为:</p><ul><li><p>数组的内存具有连续性，访问速度更快；</p></li><li><p>堆结构是一棵<strong>完全二叉树</strong>。</p></li></ul><p>如下图所示，堆的规律有如下几点：</p><ul><li><p>i 结点的父结点 par = (i-1)/2</p></li><li><p>i 结点的左子结点 2 * i + 1</p></li><li><p>i 结点的右子结点 2 * i + 2</p></li></ul>',8),F=a("p",null,[a("em",null,"注意：这里的下标是从 0 开始的。")],-1),u=a("p",null,[l("接下来，我们将通过具体的题目将堆的操作代码"),a("strong",null,"模板化"),l("。")],-1),D=a("h4",{id:"堆的操作",tabindex:"-1"},[l("堆的操作 "),a("a",{class:"header-anchor",href:"#堆的操作","aria-label":'Permalink to "堆的操作"'},"​")],-1),h=a("p",null,[l("堆的操作实际上只有两种："),a("strong",null,"下沉和上浮"),l("，如下图所示：")],-1),d=p(`<p>通过下沉和上浮，又可以分别得到 pop 和 push 操作，接下来我们一起讨论这四种操作的特点。</p><p>假设我们已经申请了数组 a[] 和元素 n 表示当前堆中元素的个数，代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">]; </span><span style="color:#6A737D;">// 表示堆的数组空间, 100作示例大小</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 堆中元素个数</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">100</span><span style="color:#24292E;">]; </span><span style="color:#6A737D;">// 表示堆的数组空间, 100作示例大小</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 堆中元素个数</span></span></code></pre></div><p><em>注：这个数组的大小仅作为示例讲解，你可以根据实际情况调整，我们的重点是把算法讲清楚。</em></p><p><strong>1. 下沉</strong></p><p>引起下沉操作的原因：假设 a[i] 比它的子结点要小，那么除 a[i] 以外，其他子树都满足堆的性质。这个时候，就可以通过下沉操作，帮助 a[i] 找到正确的位置。</p><p><em>注意，上述操作的是大堆。</em></p><p>为了方便你理解，我制作了下沉过程的动图演示，如下图所示：</p>`,8),C=p("<blockquote><p>Step 1. 结点 3 需要下沉。</p><p>Step 2. 将要下沉的值存入变量 t 中，腾出空位。</p><p>Step 3. 在子结点 8 和 9 中选中较大的结点 9。</p><p>Step 4. 9 比 3 大，9 需要上移，腾出空位。</p><p>Step 5. 上移之后，再查看子结点 4 与 7，选中较大结点 7。</p><p>Step 6. 由于 7 比 3 大，7 需要上移，腾出空位。</p><p>Step 7. 将 3 填入最终空出来的空位中。</p></blockquote><p>首先，写下沉代码时，需要记住一个<strong>贪心原则</strong> ：如果子结点大，那么子结点就要上移。实际上，如果我们将移动路径<strong>一维化</strong>，那么这段下沉代码就会变成如下图所示的样子：</p>",2),B=p(`<blockquote><p>Step 1. 最大堆，结点 3 需要下沉。</p><p>Step 2. 用临时变量 t 保存值 3。</p><p>Step 3.子结点 9 比 t = 3 大，向前移动。</p><p>Step 4.接着子结点 7 比 t = 3 大，向前移动。</p><p>Step 5.最终给 3 找取最终的位置。</p></blockquote><p>可以发现，下沉与经典的<strong>插入排序（递减）非常相似</strong>。只有一点略有不同：插入排序是一维的，只与后继的元素进行比较，而下沉是二维的，需要在两个后继元素中找到最大值与插入值进行比较。</p><p>根据这个原则，可以写出<strong>下沉</strong>的代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sink</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 找到i结点的左子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> ((j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 比插入排序多出来的一步：需要在两个后继中找个最大的出来</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// j &lt; n - 1判断是否有右子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果有，并且右子结点更大，那么</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// j指向右子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> a[j] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> a[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果子结点比t大</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 那么t的位置还需要往后排</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a[j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> t) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[j];</span></span>
<span class="line"><span style="color:#E1E4E8;">      i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 找到了t的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 此时t是大于所有的子结点的</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 将t放在找到的位置那里</span></span>
<span class="line"><span style="color:#E1E4E8;">  a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sink</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[i];</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 找到i结点的左子结点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ((j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 比插入排序多出来的一步：需要在两个后继中找个最大的出来</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// j &lt; n - 1判断是否有右子结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果有，并且右子结点更大，那么</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// j指向右子结点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> a[j] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> a[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">      j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果子结点比t大</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 那么t的位置还需要往后排</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a[j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> t) {</span></span>
<span class="line"><span style="color:#24292E;">      a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[j];</span></span>
<span class="line"><span style="color:#24292E;">      i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 找到了t的位置</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 此时t是大于所有的子结点的</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 将t放在找到的位置那里</span></span>
<span class="line"><span style="color:#24292E;">  a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>复杂度分析</strong>：由于堆是一个完全二叉树，所以在下沉的时候，下沉路径就是树的高度。如果堆中有 N 个元素的话，所以时间复杂度为 O(lgN)。</p><p><strong>2. 上浮</strong></p><p>上浮操作的条件：假设 a[i] 比它的父结点要大，并且除 a[i] 以外，其他子树都满足大堆的性质。</p><p><em>注意，上述操作的是大堆。</em></p><p>为了方便你理解，我同样制作了上浮过程的动图演示，如下图所示：</p>`,9),_=p("<blockquote><p>Step 1.结点 10 太大，需要上浮。</p><p>Step 2.将要上浮的 10 放到临时变量 t 中，腾出空位。</p><p>Step 3.找到空位的父结点 8。</p><p>Step 4.由于 8 比 t = 10 小，所以 8 往下移，腾出空位。</p><p>Step 5.选中空位的父结点 9。</p><p>Step 6.由于 9 仍然比 10 小，腾出空位。</p><p>Step 7.再也不能找到父结点了，将 10 放到空位中。</p></blockquote><p>同样，在<strong>上浮</strong> 的时候，可以发现<strong>一个原则</strong> ：如果父结点比&quot;我&quot;<strong>小</strong> ，那么父结点就需要下移。我们将移动路径<strong>一维化</strong>，这段插入代码就会变成如下图所示的样子：</p>",2),b=p(`<blockquote><p>Step 1.最大堆，结点 10 需要上浮。</p><p>Step 2.将需要上浮的 10 放到临时变量 t 中，腾出空位。</p><p>Step 3.8 比 t 小，移动 8，腾出空位。</p><p>Step 4.9 比 t 小，移动 9，腾出空位。</p><p>Step 5.不能再移动了，将 t 放到空位中。</p></blockquote><p>可以发现，上浮与经典的<strong>插入排序（递减的）非常相似</strong>。到这里，结点 a[i] 上浮的代码也比较容易搞定了。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 上浮</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">swim</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> par </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果还存在父结点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 由于我们的下标是从0开始</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 0结点没有父结点</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    par </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果父结点比t值小</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a[par] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> t) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 那么向下移动父结点的值。</span></span>
<span class="line"><span style="color:#E1E4E8;">      a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[par];</span></span>
<span class="line"><span style="color:#E1E4E8;">      i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> par;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 上浮</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">swim</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[i];</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> par </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果还存在父结点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 由于我们的下标是从0开始</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 0结点没有父结点</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    par </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果父结点比t值小</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a[par] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> t) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 那么向下移动父结点的值。</span></span>
<span class="line"><span style="color:#24292E;">      a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[par];</span></span>
<span class="line"><span style="color:#24292E;">      i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> par;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>复杂度分析</strong>：由于堆是一个完全二叉树，所以在上浮的时候，上浮路径就是树的高度。如果堆中有 N 个元素的话，所以时间复杂度为 O(lgN)。</p><p><strong>3. push 操作</strong>需要两步来完成：</p><p>（1）往堆的尾巴 a[n] 上添加新来的元素</p><p>（2）新来元素 a[n] 进行<strong>上浮</strong>的操作</p><p>至此，我们可以写出代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> v) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  a[n</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> v;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">swim</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> v) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span></span>
<span class="line"><span style="color:#24292E;">  a[n</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> v;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">swim</span><span style="color:#24292E;">(n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>复杂度分析</strong>：主要是上浮操作，所以时间复杂度为 O(lgN)。</p><p><strong>4. pop 操作</strong>需要以下 3 步：</p><p>（1）取出 a[0] 的值作为返回值</p><p>（2）然后将 a[n-1] 存放至 a[0]</p><p>（3）将 a[0] 进行<strong>下沉</strong>操作</p><p>有了 sink() 函数，操作还是比较简单的，我们可以直接写出代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ret </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">  a[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">n];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">sink</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ret;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ret </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">  a[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">n];</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">sink</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ret;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>复杂度分析</strong>：主要是下沉操作，所以时间复杂度为 O(lgN)。</p><p>堆的操作都梳理完成之后，这里我们给出完整的代码。虽然是一块比较基础的代码，但是我曾经在<strong>商汤</strong>的面试中就遇到过这么&quot;裸&quot;的面试题：&quot;实现堆的 push 和 pop&quot;。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Heap</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 下沉</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sink</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">i</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 找到i结点的左子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> ((j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// j &lt; n - 1判断是否有右子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果有，并且右子结点更大，那么</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// j指向右子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (j </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> a[j] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> a[j </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                j</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果子结点比t大</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 那么t的位置还需要往后排</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a[j] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> t) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[j];</span></span>
<span class="line"><span style="color:#E1E4E8;">                i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 找到了t的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 此时t是大于所有的子结点的</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将t放在找到的位置那里</span></span>
<span class="line"><span style="color:#E1E4E8;">        a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 上浮</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">swim</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">i</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> par </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果还存在父结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (par </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> i) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果父结点比t值小</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (a[par] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> t) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[par];</span></span>
<span class="line"><span style="color:#E1E4E8;">                i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> par;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        a[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">v</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        a[n</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> v;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">swim</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ret </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        a[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a[</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">n];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">sink</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ret;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Heap</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 下沉</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sink</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">i</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[i];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 找到i结点的左子结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> ((j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// j &lt; n - 1判断是否有右子结点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果有，并且右子结点更大，那么</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// j指向右子结点</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (j </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> a[j] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> a[j </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) {</span></span>
<span class="line"><span style="color:#24292E;">                j</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果子结点比t大</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 那么t的位置还需要往后排</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a[j] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> t) {</span></span>
<span class="line"><span style="color:#24292E;">                a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[j];</span></span>
<span class="line"><span style="color:#24292E;">                i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 找到了t的位置</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 此时t是大于所有的子结点的</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将t放在找到的位置那里</span></span>
<span class="line"><span style="color:#24292E;">        a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 上浮</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">swim</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">i</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[i];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> par </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果还存在父结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (par </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> i) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果父结点比t值小</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (a[par] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> t) {</span></span>
<span class="line"><span style="color:#24292E;">                a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[par];</span></span>
<span class="line"><span style="color:#24292E;">                i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> par;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        a[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">v</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// push是先把元素追加到数组尾巴上，然后再执行上浮操作</span></span>
<span class="line"><span style="color:#24292E;">        a[n</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> v;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">swim</span><span style="color:#24292E;">(n </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ret </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        a[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a[</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">n];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">sink</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ret;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> n;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>讲完了堆的四种操作，我们再来看一下如何把知识运用到题目求解和实际工作中。</p><h4 id="例-1-最小的-k-个数" tabindex="-1">例 1：最小的 k 个数 <a class="header-anchor" href="#例-1-最小的-k-个数" aria-label="Permalink to &quot;例 1：最小的 k 个数&quot;">​</a></h4><p>【<strong>题目</strong>】给定一个数组 a[]，返回这个数组中最小的 k 个数。</p><p>输入：A = [3,2,1], k = 2</p><p>输出：[2, 1]</p><p>【<strong>分析</strong> 】这是一道来自<strong>阿里</strong>的题目。首先来看，如果是先排序，然后再返回前面的 k 个数。这样操作的复杂度是 O(nlgn)，但面试官可能想要得到复杂度更低的一些算法。</p><p>现在问题的特点是，只需要 k 个最小的数就可以了。假设我们已经拿到了前面 [0 ~ i] 个数中最小的 k 个数。那么当第 a[i+1] 进来的时候，应该怎么办呢？</p><p>接下来我们按照&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690" target="_blank" rel="noreferrer">第 01</a><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6690" target="_blank" rel="noreferrer">讲</a>&quot;介绍的&quot;<strong>四步分析法&quot;</strong> 寻找解题突破口。</p><p><strong>1. 模拟</strong></p><p>可以采用&quot;挤出去的办法&quot;：</p><ul><li><p>先把 a[i+1] 加入集合中，此时集合中已经有 k+1 个数了；</p></li><li><p>再把集合 k+1 个数中的<strong>最大的数</strong>扔出去。</p></li></ul><p>此时，存留下来的 k 个数，就是 [0 ~ i + 1] 里面最小的 k 个数了，具体演示如下图所示：</p>`,31),k=p("<blockquote><p>Step 1.当 i 指向 8 时，如果我们已经得到了最小的 k = 2 个数的集合。</p><p>Step 2.i+1 指向 1 时，需要把 1 加到最小集合中。</p><p>Step 3.扔掉最大的元素 3，得到 [0~i+1] 范围里面的最小的 k 个数。</p></blockquote><p><strong>2. 规律</strong></p><p>由上述分析可以找出以下两个规律：</p><p>（1）我们要的是一个集合，这个集合并<strong>不需要有序</strong>，但需要支持 push 功能；</p><p>（2）pop 的时候，总是把<strong>最大的元素</strong>扔出去。</p><p><strong>3. 匹配</strong></p><p>基于我们发现的两个规律，可以得出，这个时候应该使用<strong>大堆</strong>。因为堆满足：</p><p>（1）内部并不是有序的，支持 push 功能；</p><p>（2）pop 时，扔掉<strong>堆里最大元素</strong>就可以了。</p><p><strong>4. 边界</strong></p><p>数据结构选定后，在面试时，你还需要思考一下问题的边界。给定数组和 k 的情况，应该有以下 7 种：</p><p>（1）数组为 null</p><p>（2）数组中元素个数小于 k</p><p>（3）数组中元素个数等于 k</p><p>（4）数组中元素个数大于 k</p><p>（5）k &lt; 0</p><p>（6）k == 0</p><p>（7）k &gt; 0</p><p>【<strong>画图</strong>】分析到这里。我们可以利用大堆完成一次模拟了，动图演示如下：</p><p>输入：[9, 3, 2, 8, 1, 7, 5, 6, 4], k = 4</p><p>输出：[1,2,3,4]</p>",21),m=p(`<blockquote><p>Step 1.push(9)。</p><p>Step 2.push(3)。</p><p>Step 3.push(2)。</p><p>Step 4.push(8)。</p><p>Step 5.push(1)，堆中元素个数 &gt; k，需要执行 pop。</p><p>Step 6.pop() 结束。</p><p>Step 7.push(7)，堆中元素个数 &gt; k，需要执行 pop。</p><p>Step 8.pop 操作结束。</p><p>Step 9.push(5)，堆中元素个数 &gt; k，需要执行 pop。</p><p>Step 10.pop 操作结束。</p><p>Step 11.push(6)，堆中元素个数 &gt; k，需要执行 pop。</p><p>Step 12.pop 结束。</p><p>Step 13.push(4)，堆中元素个数 &gt; k，需要执行 pop。</p><p>Step 14.pop 结束，最终得到最小的 k 个数 [1, 2, 3, 4]。</p></blockquote><p>【<strong>代码</strong>】接下来，就可以开始写代码了，也是时候亮出你真正的实力了。代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// .. 这里省略了堆的四种操作的代码: 参考前面的实现</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回堆中元素的个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">getLeastNumbers</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">k</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (k </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> arr </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> arr.length </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化堆, 注意大小要为k + 1</span></span>
<span class="line"><span style="color:#E1E4E8;">    a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[k </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">    n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> arr) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 首先将元素压入堆中</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果堆中已经有k个元素</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 此时压入，会有k+1个元素，</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 所以初始化时，申请数组大小需要为k+1</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(x);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果堆中元素多于k个，那么扔掉最大的元素</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回最小的k个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[k];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      ans[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// .. 这里省略了堆的四种操作的代码: 参考前面的实现</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回堆中元素的个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> n;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">getLeastNumbers</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">k</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (k </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> arr </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> arr.length </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化堆, 注意大小要为k + 1</span></span>
<span class="line"><span style="color:#24292E;">    a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[k </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">    n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> arr) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 首先将元素压入堆中</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果堆中已经有k个元素</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 此时压入，会有k+1个元素，</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 所以初始化时，申请数组大小需要为k+1</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(x);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果堆中元素多于k个，那么扔掉最大的元素</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回最小的k个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[k];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      ans[i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.%E4%BD%BF%E7%94%A8%E5%A0%86.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度，每个元素都需要入堆，而堆 push 的时间复杂度为 O(lgk)。因为我们控制了堆的大小为 k，所以总的时间复杂度为 O(Nlgk)。因为我们使用了 k 个元素的堆，所以空间复杂度为 O(k)。</p><p>【<strong>小结</strong>】在这个并不算难的题目里，我们为了深入讲解优先级队列的原理，采用了一种&quot;最费劲&quot;的方式（自己写堆）来操作。</p><p>但实际上，<strong>大部分语言都内置了堆的实现</strong> （<strong>优先级队列</strong> ）。<strong>当你面试的时候，如果面试官没有明确提出要求你自己写堆，赶紧麻溜地用内置的优先级队列啊</strong>！</p><p>接下来，我们一起看看如何用语言内置的优先级队列来解决这个问题。代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">getLeastNumbers</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">k</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (k </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> arr </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> arr.length </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 注意大堆的声明</span></span>
<span class="line"><span style="color:#E1E4E8;">        Queue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; Q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> v2 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> v1);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> arr) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Q.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(x);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 保持堆中元素小于等于k个</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 保证一直拿到的是k个最小的数</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (Q.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                Q.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 生成返回结果</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[k];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> Q) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            ans[i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">getLeastNumbers</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">k</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (k </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> arr </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> arr.length </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 注意大堆的声明</span></span>
<span class="line"><span style="color:#24292E;">        Queue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; Q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> v2 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> v1);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> arr) {</span></span>
<span class="line"><span style="color:#24292E;">            Q.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(x);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 保持堆中元素小于等于k个</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 保证一直拿到的是k个最小的数</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (Q.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">                Q.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 生成返回结果</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[k];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Q) {</span></span>
<span class="line"><span style="color:#24292E;">            ans[i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/JiYou/LaGouAlgo/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析：</strong> 首先堆的大小为 k，那么每次 push/pop 的复杂度都是 O(lgk)。一共有 n 个元素，所以复杂度为 O(nlgk)。</p><p>此外，这道题还有不使用优先级队列，直接可以达到 O(N) 复杂度的算法，你可以尝试思考一下。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E5%89%91%E6%8C%87Offer40.%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0.kth.py" target="_blank" rel="noreferrer">Python</a></p><p>注：<strong>如果看不懂也没有关系，我们在&quot;第 08 讲&quot;介绍快排时还会进一步讲解</strong>。</p></blockquote><p>关于解决这类题目的思路、重点以及分析方法，建议你先尝试自己梳理总结一下，再来看我给出的思维导图：</p>`,14),f=p('<p>例 1 是一道非常经典的题目，如果你掌握了这道题的解题思想，可以举一反三解决更多的题目。这里我给出一些堆的练习题。</p><p><strong>练习题 1</strong>：给定一个数组，求这个数组的前 k 个高频元素。如果有两个数出现次数一样，那么优先取较小的那个数。</p><p>输入：A = [1,2,1,1,3,3,2,3] k = 2</p><p>输出：[1, 3]</p><p><strong>解释</strong>：每个数字的出现频率从高到低排序&lt;1, 3次&gt;, &lt;3,3次&gt; &lt;2, 2次&gt;，取前 2 个高频数字。所以是 [1, 3]。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/347.%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 2</strong>：在练习题1的基础上，给定的是一个单词数组，求这个数组前 k 个高频单词。如果有两个单词出现频率是一样的。那么输出字典序较小的那个单词。</p><p>输入：A = [&quot;AA&quot;, &quot;BB&quot;, &quot;AA&quot;, &quot;BB&quot;, &quot;CCC&quot;, &quot;CCC&quot;, &quot;CCC&quot;, &quot;AA&quot;] k = 2</p><p>输出：[&quot;AA&quot;, &quot;CCC&quot;]</p><p><strong>解释</strong>：出现次数最多的 2 个单词就是[&quot;AA&quot;, &quot;CCC&quot;]</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/692.%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 3</strong>：给定一个点集数组 A[]，求离原点最近的 k 个点。</p><p>输入：A = [[0,1], [1,0], [100,1], [1,100]], k = 2</p><p>输出：[[0,1], [1,0]]</p><p><strong>解释</strong>：离原点最近的两个点就是 [[0,1], [1,0]]</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/973.%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-k-%E4%B8%AA%E7%82%B9.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 4</strong>：将 k 个有序的链表，合并成一个有序的链表。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/23.%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 5</strong>：给定两个有序数组，两个数组中各找一个数，凑成一对，找出相加之和最小的 k 对。</p><p>输入：A = [1, 1, 2], B = [1, 2, 3], k = 2</p><p>输出：B = [[1, 1], [1, 1]]]</p><p><strong>解释</strong>：A,B 数组中各取一个1出来凑成一对，其和 [1+1=2, 1+1=2]是最小的 2 对。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/373.%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="优先级队列" tabindex="-1">优先级队列 <a class="header-anchor" href="#优先级队列" aria-label="Permalink to &quot;优先级队列&quot;">​</a></h3><p>前面提到，优先级队列主要基于堆来实现，因此，堆具备的特性优先级队列也同样具备。比如：</p><ul><li><p>可以 O(lgn) 的复杂度往优先级队列中<strong>添加元素；</strong></p></li><li><p>可以 O(lgn) 的复杂度从优先级队列<strong>弹出最大/最小元素</strong>。</p></li></ul><p>经过简化，我们可以得到优先级队列的特性，如下图所示：</p>',27),v=p('<p>不过，如果只是知道这两个特性，你还不能从容地应对面试。接下来，我们一起看一下优先级队列的深度运用。</p><h4 id="例-2-跳跃游戏" tabindex="-1">例 2：跳跃游戏 <a class="header-anchor" href="#例-2-跳跃游戏" aria-label="Permalink to &quot;例 2：跳跃游戏&quot;">​</a></h4><p>【<strong>题目</strong> 】假设你正在玩跳跃游戏，从<strong>低处往高处跳</strong>的时候，可以有两种方法。</p><p>方法一：塞砖块，但是你拥有砖块数是有限制的。为了简单起见，高度差就是你需要砖块数。</p><p>方法二：用梯子，梯子可以无视高度差（你可以认为再高也能爬上去），但是梯子的个数是有限的(一个只能用一次)。</p><p>其他无论是<strong>平着跳</strong> ，还是<strong>从高处往低处跳</strong>，不需要借助什么就可以完成（在这道题中我们默认无论从多高跳下来，也摔不死）。</p><p>给你一个数组，用来表示不同的高度。假设你总是站在 index = 0 的高度开始。那么请问，你最远能跳到哪里?</p><p>输入：[3, 1, 6, 20, 10, 20], bricks = 5, landers = 1</p><p>输出：4</p><p><strong>解释：</strong></p><ul><li><p>Step 1. 从 3 跳到 1 时，因为是从高往低处跳，直接跳就可以了</p></li><li><p>Step 2. 从 1 到 6 时，用掉 5 个砖块</p></li><li><p>Step 3. 从 6 到 20 时，用掉梯子</p></li><li><p>Step 4. 从 20 到 10 可以直接跳</p></li><li><p>Step 5.到 10 这里就停住了，没有东西可以帮助你跳到 20 了，所以只能跳到下标 index = 4 这里。</p></li></ul><p>【<strong>分析</strong> 】这是一道来自<strong>拼多多</strong> 的面试题。首先我们想一想<strong>在什么情况下使用梯子</strong> ？因为梯子最好用，可以无视高度直接使用。但是这里有一个限制条件，只能在<strong>大高度差</strong>的时候使用梯子。如果是在小高度差的时候使用，那么最终就走不远，比如对于上面给定的例子：</p><ul><li><p>Step 1. 从 3 跳到 1 时，直接跳就可以了；</p></li><li><p>Step 2. 从 1 到 6 时，用掉梯子；</p></li><li><p>Step 3. 从 6 到 20 时，手里的 5 个砖头就不够用了！所以最远只能到下标 index = 2。</p></li></ul><p>因此，我们选择使用<strong>梯子的时候，一定要使用得当</strong>！那么应该如何判断在什么情况下使用梯子呢？</p><p>下面可以尝试换种思路，从低往高跳跃的时候，本来是要使用砖块的。但是可以想象成我随身带着一个本子，在上面<strong>记录落差(落差定义为：低往高处跳时的高度差)</strong>。比如从高度 1 跳到高度 6，就在小本子上写 5。而高处往低处跳的时候，不需要记录，因为这不是落差（题目说了高往低处跳可以直接跳，没有必要记录）。</p><p>在跳跃的时候，一定要保证小本子上的<strong>落差之和要小于等于砖块数目</strong>。可是当落差大于砖块之和时怎么办呢？</p><p>别忘了，我们还有梯子呢。梯子可是万能的（可以把梯子想象成一次性橡皮擦 ）！如果还有梯子，我们只需要从小本子上挑出最大的落差，用&quot;一次性<strong>橡皮擦</strong>&quot;将它从小本上擦掉即可。</p><p><strong>1. 模拟</strong></p><p>有了思路之后，我们来执行一次模拟。具体演示如下图所示：</p>',19),P=p(`<blockquote><p>Step 1. 首先从高度 3 出发，此时小本子为空 {}。</p><p>Step 2. 从高度 3 跳到高度 1（高往低跳，无压力），此时小本子仍然为空 {}。</p><p>Step 3. 从 1 跳到高度 6，小本子记录落差 {5} &lt;= 砖头数 5。</p><p>Step 4. 从 6 跳到 20, 小本子记录{5, 14}，总和 &gt; 砖头数 5。</p><p>Step 5.需要从小本子{5, 14}中选出最大数 14，然后梯子替换掉。</p><p>Step 6. 从 20 跳到 10，高到低跳。</p><p>Step 7. 要从 10 跳到 20，需要把落差 10 记录到本子上 {5, 10} 。</p><p>Step 8. 小本子 {5, 10} 总和 = 15，大于砖头数 5，又没有梯子可以用了。因此只能停在 4 这个位置。</p></blockquote><p><strong>2. 规律</strong>：在这里，我们发现小本子有两个有趣的地方：</p><p>（1）需要在小本子上记录落差；</p><p>（2）需要用梯子来替换最大的落差。</p><p>在我们学过的数据结构里面，满足这个 push/pop 特点的，应该就是<strong>优先级队列</strong>啦。</p><p><strong>3. 边界</strong>：注意考虑给定数组为空的情况。</p><p>【<strong>代码</strong>】到这里，可以开始写出代码了。具体代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">furthestBuilding</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">heights</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">bricks</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">ladders</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 注意处理非法输入</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (heights </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> heights.length </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 记录落并的小本子: 最大堆</span></span>
<span class="line"><span style="color:#E1E4E8;">        Queue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; Q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> v2 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> v1);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> qSum </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> lastPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> preHeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> heights[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> heights.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> curHeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> heights[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果是从高处往低处跳</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (preHeight </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> curHeight) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                lastPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果是低处往高处跳</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> delta </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> curHeight </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> preHeight;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 拿到高度的落差</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 写到小本子上</span></span>
<span class="line"><span style="color:#E1E4E8;">                Q.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(delta);</span></span>
<span class="line"><span style="color:#E1E4E8;">                qSum </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> delta;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果小本子上的总和比砖块多了</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 并且还有梯子</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (qSum </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> bricks </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> ladders </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 需要用梯子把最大的落差给抵消掉</span></span>
<span class="line"><span style="color:#E1E4E8;">                    qSum </span><span style="color:#F97583;">-=</span><span style="color:#E1E4E8;"> Q.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    Q.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    ladders</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 看看经过一番处理之后，还能不能跳到i这个位置</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (qSum </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> bricks) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    lastPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 如果经过一番处理之后，还是不能跳</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 看来不能跳到i了</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 跳出循环!</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 更新位置的高度</span></span>
<span class="line"><span style="color:#E1E4E8;">            preHeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> curHeight;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lastPos;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">furthestBuilding</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">heights</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">bricks</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">ladders</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 注意处理非法输入</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (heights </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> heights.length </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 记录落并的小本子: 最大堆</span></span>
<span class="line"><span style="color:#24292E;">        Queue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; Q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> v2 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> v1);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> qSum </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> lastPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> preHeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> heights[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> heights.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> curHeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> heights[i];</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果是从高处往低处跳</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (preHeight </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> curHeight) {</span></span>
<span class="line"><span style="color:#24292E;">                lastPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果是低处往高处跳</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> delta </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> curHeight </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> preHeight;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 拿到高度的落差</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 写到小本子上</span></span>
<span class="line"><span style="color:#24292E;">                Q.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(delta);</span></span>
<span class="line"><span style="color:#24292E;">                qSum </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> delta;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果小本子上的总和比砖块多了</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 并且还有梯子</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (qSum </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> bricks </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> ladders </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 需要用梯子把最大的落差给抵消掉</span></span>
<span class="line"><span style="color:#24292E;">                    qSum </span><span style="color:#D73A49;">-=</span><span style="color:#24292E;"> Q.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    Q.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    ladders</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 看看经过一番处理之后，还能不能跳到i这个位置</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (qSum </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> bricks) {</span></span>
<span class="line"><span style="color:#24292E;">                    lastPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 如果经过一番处理之后，还是不能跳</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 看来不能跳到i了</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 跳出循环!</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 更新位置的高度</span></span>
<span class="line"><span style="color:#24292E;">            preHeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> curHeight;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lastPos;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1642.%E5%8F%AF%E4%BB%A5%E5%88%B0%E8%BE%BE%E7%9A%84%E6%9C%80%E8%BF%9C%E5%BB%BA%E7%AD%91.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：在跳跃的过程中，最差的情况下，我们需要把所有的高度差记录下来。在这种情况下，每个高度差都需要执行 push 操作。那么时间复杂度为 O(NlgN)，空间复杂度为O(N)。</p><p>【<strong>小结</strong>】首先我们仔细总结一下这道题目的特点：</p><ul><li><p>需要将<strong>消耗的过程，转换为存储的过程</strong>（记录在小本子上），对应堆的 push；</p></li><li><p>需要优先消除一些元素，对应堆的 pop。</p></li></ul><p>与例 1 关于堆的题目相比，例 2 的求解过程不再那么直白，需要我们深入挖掘题目的特点，才能找到正确的解答方法------使用push 和 pop。</p><p>此外，我们还能挖出一些不同的东西来------关于堆中元素需要弹出时的处理方式。在 Top K 问题里，当堆中元素个数超出 k 个时，就要执行 pop 操作。而这道题，将弹出元素的条件变成了堆中的总和不能超出砖块的数目。</p><p><strong>练习题 6</strong>：一只蚂蚁在树下吃果子，第 i 天会掉 落A[i] 个果子，这些果子会在接下来的 B[i] 天（即第 i+B[i] 天）立马坏掉不能吃。给定 A，B 两个数组，蚂蚁一天只能吃一个果子。吃不完了它可以存放起来。请问最多蚂蚁可以吃多少个果子。</p><p>输入：A = [3, 1], B = [3, 1]</p><p>输出：3</p><p><strong>解释</strong>：我们假设下标从 1 开始：</p><p>第 1 天你吃 1 个第 1 天的果子</p><p>第 2 天吃 1 个第 1 天的果子，同时把第 2 天的果子存起来。</p><p>第 3 天吃 1 个第 1 天的果子，第 2 天的果子只能放 1 天，第 2 天的果子第 3 天坏了。</p><p>第 4 天没有果子吃了。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/1705.%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>你可以自己尝试总结一下解决这类题目的思路和重点，然后再来参考我给出的思维导图：</p>`,24),S=p('<h4 id="例-3-汽车加油次数" tabindex="-1">例 3：汽车加油次数 <a class="header-anchor" href="#例-3-汽车加油次数" aria-label="Permalink to &quot;例 3：汽车加油次数&quot;">​</a></h4><p>【<strong>题目</strong>】一辆汽车携带 startFuel 升汽油从位置 0 出发前往位置 target，按顺序有一系列加油站 stations。第 i 个加油站位于 stations[i][0]，可以加 stations[i][1] 升油（一个加油站只能加一次）。如果想要到达 target，输出最少加油次数。如果不能到达 target，那么返回 -1。</p><p><strong>两个条件</strong>：</p><ol><li><p>假设汽车油箱总是很大；</p></li><li><p>假设行走一单位距离，消耗一升汽油。</p></li></ol><p><strong>示例</strong>：</p><p>输入：target = 100, startFuel = 10, stations = [[10, 60], [20, 30], [30, 30], [60, 40]]</p><p>输出：2</p><p>【<strong>分析</strong>】首先带着 10 升汽油，可以顺利开到 pos = 10 的加油站，加上 60 升汽油。然后直接开车到 pos = 60 的加油站，加上 40 升汽油就可以顺利到达 target = 100 处。所以最少需要加 2 次油。</p><p>在<strong>微软和头条</strong> 都有同学遇到过这道题目。仔细读题之后，可以发现，需要加油的情况只有一种：汽<strong>车当前位置 + 车里剩余汽油 &lt; 要到达的下一个目标地点</strong>。这里的下一个目标地点，有可能是 target，也有可能是加油站。</p><p>那么问题是，当我们发现汽油不够的时候，应该如何加油呢？题目最终目的是产生尽量少的加油次数，所以每次加油加得越多越好！这就找到了一个解题方向：应该<strong>挑油量最大的加油站</strong>进行加油。</p><p>假设有一个巨大无比的副油箱，每次经过加油站的时候，都可以把加油站里面的油放到副油箱里面<strong>存起来</strong>。缺油的时候，就从副油箱里把最大量的汽油加到车里（这里才算加一次油）。</p><p><strong>1. 模拟</strong></p><p>接下来我们就利用这个副油箱进行一下模拟，具体演示如下图所示（注意：副油箱里面的汽油不能算在已经加到车的汽油里，你可以认为它还放在后面座位上呢）：</p>',13),q=p(`<blockquote><p>Step 1. 从 0 位置出发，下一站位于 pos = 10，当前汽油可以达到。</p><p>Step 2. 开到了pos = 10，将 60 升汽油放到副油箱，此时余下汽油量为 0。</p><p>Step 3. 汽油里面的汽油不足开到 pos = 20 加油站，从副油箱中取出最多汽油 60 加上。<strong>第 1 次</strong> 加油之后，余下油量变成 60。</p><p>Step 4. 开到 pos = 20 处，余下汽油 50, 并且将加油站的 30 升汽油放到副油箱。</p><p>Step 5. 开到 pos = 30 处，余下 40 升汽油，并且将加油站的 30 升汽油放到副油箱。</p><p>Step 6. 开到加油站 60 处，余下 10 升汽油，并且将加油站的 40 升汽油放到副油箱。</p><p>Step 7. 发现无法开到位置 100 处，那么将最多的汽油 40 升加到汽车里，此时余下汽油 50。</p><p>最后，成功开到了终点。</p></blockquote><p><strong>2. 规律</strong></p><p>通过观察副油箱的操作，我们发现它的行为具有两个特点：</p><p>（1）每次经过加油站会把汽油<strong>加到</strong>副油箱</p><p>（2）缺油的时候，总是把<strong>最大升</strong>的汽油拿出来加上</p><p>这两个行为让我们联想到本讲学过的 push/pop 操作。并且每次 pop 的时候，都要弹出最大的元素，这又让我们想起了今天学过的堆（不过这里不再写堆的四种操作了），就用优先级队列吧。因为总是<strong>最大升的汽油优先</strong>。</p><p><strong>3. 边界</strong></p><p>在正式写代码前，你还是要考虑到以下 3 种情况：</p><p>（1）加油站的位置都小于 target</p><p>（2）某些加油站的位置等于 target</p><p>（3）有些加油站的位置大于 target</p><p>在处理的时候，<strong>可以将 target 也当成一个站。只不过这个站，并不提供汽油</strong>。这样处理起来更容易一些。</p><p>【<strong>代码</strong>】通过了前面的分析，此时我们应该撸起袖子开始写代码了，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">minRefuelStops</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">startFuel</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[][] </span><span style="color:#FFAB70;">stations</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stations.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前汽车的状态{位置, 还余下多少汽油}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> curPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> fuelLeft </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> startFuel;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 副油箱</span></span>
<span class="line"><span style="color:#E1E4E8;">    Queue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; Q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> v2 </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> v1);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从副油箱里面往汽车加油的次数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> addFuelTimes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (curPos </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> fuelLeft </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 默认期望的下一站，站点设置为target</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 此时能加的汽油为0</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> pos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> target;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> fuel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果有位于target之前的站点, 那么更新</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 加油站的位置，以及能加到副油箱的油量</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> stations[i][</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        pos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stations[i][</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        fuel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stations[i][</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果当前汽车的状态，不能到达期望的下一站</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (curPos </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> fuelLeft </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> pos) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 拿出副油箱啊</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 惨了，副油箱没有油了，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Q.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 从副油箱里面拿出最大的汽油加上去</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> curMaxFuel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Q.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        Q.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        fuelLeft </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> curMaxFuel;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 加油次数++</span></span>
<span class="line"><span style="color:#E1E4E8;">        addFuelTimes</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 好了，现在可以到达期望的下一站了</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 不过需要把消耗的汽油扣掉</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> fuelCost </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pos </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> curPos;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 更新当前汽车的状态</span></span>
<span class="line"><span style="color:#E1E4E8;">      fuelLeft </span><span style="color:#F97583;">-=</span><span style="color:#E1E4E8;"> fuelCost;</span></span>
<span class="line"><span style="color:#E1E4E8;">      curPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pos;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 这个汽油站里面的汽油加到副油箱</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (fuel </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Q.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(fuel);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 这个站就过去了</span></span>
<span class="line"><span style="color:#E1E4E8;">      i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 能到达target吗？如果能，返回加油次数，不能返回-1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> curPos </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> fuelLeft </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> target </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> addFuelTimes </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">minRefuelStops</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">target</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">startFuel</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[][] </span><span style="color:#E36209;">stations</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> stations.length;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前汽车的状态{位置, 还余下多少汽油}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> curPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> fuelLeft </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> startFuel;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 副油箱</span></span>
<span class="line"><span style="color:#24292E;">    Queue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; Q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> v2 </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> v1);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从副油箱里面往汽车加油的次数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> addFuelTimes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (curPos </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> fuelLeft </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> target) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 默认期望的下一站，站点设置为target</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 此时能加的汽油为0</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> pos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> target;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> fuel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果有位于target之前的站点, 那么更新</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 加油站的位置，以及能加到副油箱的油量</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> stations[i][</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> target) {</span></span>
<span class="line"><span style="color:#24292E;">        pos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> stations[i][</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        fuel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> stations[i][</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果当前汽车的状态，不能到达期望的下一站</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (curPos </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> fuelLeft </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> pos) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 拿出副油箱啊</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 惨了，副油箱没有油了，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Q.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 从副油箱里面拿出最大的汽油加上去</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> curMaxFuel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Q.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        Q.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        fuelLeft </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> curMaxFuel;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 加油次数++</span></span>
<span class="line"><span style="color:#24292E;">        addFuelTimes</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 好了，现在可以到达期望的下一站了</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 不过需要把消耗的汽油扣掉</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> fuelCost </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pos </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> curPos;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 更新当前汽车的状态</span></span>
<span class="line"><span style="color:#24292E;">      fuelLeft </span><span style="color:#D73A49;">-=</span><span style="color:#24292E;"> fuelCost;</span></span>
<span class="line"><span style="color:#24292E;">      curPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pos;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 这个汽油站里面的汽油加到副油箱</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (fuel </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        Q.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(fuel);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 这个站就过去了</span></span>
<span class="line"><span style="color:#24292E;">      i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 能到达target吗？如果能，返回加油次数，不能返回-1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> curPos </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> fuelLeft </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> target </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> addFuelTimes </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/871.%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：最差情况下，需要把所有的油都收集起来，此时所有的油都需要有 push 操作，所以时间复杂度为O(NlgN)，而空间复杂度为O(N)。</p><p>【<strong>小结</strong> 】首先，当你发现这道题属于&quot;<strong>消耗物品</strong>&quot;类题目，并且优先消耗较大的油箱时，脑海中应该联想前面我们讲过的关于堆的总结：</p><ul><li><p>将消耗的过程转换为存储的过程，对应堆的 push 操作；</p></li><li><p>将优先选择大油桶的过程看成堆的 pop 操作。</p></li></ul><p>经过一番分析，我们挖出了这道题背后的考点，以及优先级队列可能存在变化地方：</p><ul><li><p>什么时候执行 push 操作？</p></li><li><p>什么时候执行 pop 操作？</p></li></ul><p><strong>练习题 7</strong> ：在一个网络中有 N 台计算机，编号从 1~N，现在给定一些<strong>有向</strong>边，表示计算机之间网络传输使用的时间（ms），请问，从节点编号为k的计算机发出一个信号，需要多久才能让所有的计算机接收到信号。如果不能让所有人接收到信号，请输出 -1。</p><p>输入：N = 2, times = [1, 2, 100], k = 1</p><p>输出：100</p><p><strong>解释</strong>：只有两个计算机 1，和计算机 2。从计算机 1 发送信息到计算机 2 需要 100ms。所以输出 100。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="总结与延伸" tabindex="-1">总结与延伸 <a class="header-anchor" href="#总结与延伸" aria-label="Permalink to &quot;总结与延伸&quot;">​</a></h3><p>至此，我们已经学习了堆的特性与实现。在了解了 push/pop 元素的复杂度为 logn 后，我们还需要知道考点可能出现在以下两个地方：</p><ol><li><p>什么时候 push 元素</p></li><li><p>什么时候 pop 元素</p></li></ol><p>这里我做了一个简单的归纳，并且列举了例题中的条件，你能在实战中补充一些其他有趣的条件吗？</p>`,29),T=p('<p>优先级队列非常有趣，也非常有用，在后面的<strong>广度优先搜索中，还会重拾这个知识，</strong> 帮助你解决更多的疑难问题。</p><h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h3><p>最后我再给你留一道<strong>思考题</strong>：</p><p>来自 <strong>Google</strong> 的面试题。一个机器每隔一秒钟就会输出一个整数，请你写一个查询接口，输出所有已经得到的整数的中位数。中位数就是排序之后位于中间的数。如果数目为偶数，则是中间两个数的平均值。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/03.HeapAndPriorityQueue/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E4%BD%8D%E6%95%B0.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。后会有期，优先级队列！</p><p>下一讲将介绍 04 | 链表：如何利用&quot;假头，新链表，双指针&quot;解决链表题？（上）记得按时来探险。</p>',7);function Q(j,H,w,I,N,O){const s=e("Image");return t(),r("div",null,[E,y,n(s,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB95iADDnqAACK2SKwkGM125.png"}),i,n(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB96aAYBPuAADIgr8zVTQ525.png"}),A,n(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB966AG3lGAADMrGaqmms247.png"}),g,n(s,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB97mANuA0AAEuXuRD7OM444.png"}),F,u,D,h,n(s,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB98KAGCi1AACNPdvPhX0284.png"}),d,n(s,{alt:"1.gif",src:"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB99OAQTpJAAGapaZWoyM328.gif"}),C,n(s,{alt:"2.gif",src:"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB996AJuAmAACoyw2YoTY998.gif"}),B,n(s,{alt:"3.gif",src:"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB9-6AO_sXAAF4Rim8-h4328.gif"}),_,n(s,{alt:"4.gif",src:"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB9_yAMrYIAACvs1tCxn0334.gif"}),b,n(s,{alt:"5.gif",src:"https://s0.lgstatic.com/i/image6/M01/13/49/Cgp9HWBB-CCAHNSQAAiT0tDfClw811.gif"}),k,n(s,{alt:"6.gif",src:"https://s0.lgstatic.com/i/image6/M01/13/46/CioPOWBB-DmADf7pACpCmKnHs-c177.gif"}),m,n(s,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-FeAA31IAADlOdvhaHc020.png"}),f,n(s,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-GWAals1AACz-cwh5A0701.png"}),v,n(s,{alt:"7.gif",src:"https://s0.lgstatic.com/i/image6/M00/13/49/Cgp9HWBB-IeAcgVAABQeZUJ0g7s661.gif"}),P,n(s,{alt:"Drawing 14.png",src:"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-LyAd-I8AACuBAvv24c185.png"}),S,n(s,{alt:"8.gif",src:"https://s0.lgstatic.com/i/image6/M00/13/46/CioPOWBB-NWATbp5ABcZWJEFfns318.gif"}),q,n(s,{alt:"Drawing 16.png",src:"https://s0.lgstatic.com/i/image6/M00/13/4A/Cgp9HWBB-QCAcvk-AADd5wNIZG0008.png"}),T])}const M=o(c,[["render",Q]]);export{x as __pageData,M as default};
