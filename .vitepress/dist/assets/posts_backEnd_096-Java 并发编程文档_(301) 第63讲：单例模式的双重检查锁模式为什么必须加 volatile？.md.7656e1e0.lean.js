import{_ as o,j as e,o as t,g as c,k as a,h as l,Q as p,s}from"./chunks/framework.cfb14fe0.js";const C=JSON.parse('{"title":"第63讲：单例模式的双重检查锁模式为什么必须加volatile？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md"},i=p("",12),E=p("",12),y=s("ul",null,[s("li",null,[s("p",null,"第一步是给 singleton 分配内存空间；")]),s("li",null,[s("p",null,"然后第二步开始调用 Singleton 的构造函数等，来初始化 singleton；")]),s("li",null,[s("p",null,"最后第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。")])],-1),g=s("p",null,"这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。",-1),h=s("p",null,"如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，详细流程如下图所示：",-1),_=p("",7);function u(d,v,A,f,b,F){const n=e("Image");return t(),c("div",null,[i,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/B6/Ciqah16BpV-AG9iPAAAf42nvy5s798.png"}),l(),E,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7E/CC/Cgq2xl6BpWCAMBaVAACFIdffjfM852.png"}),l(),y,g,h,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7E/CC/Cgq2xl6BpWCAB6QQAAEKacFd0CE542.png"}),l(),_])}const k=o(r,[["render",u]]);export{C as __pageData,k as default};
