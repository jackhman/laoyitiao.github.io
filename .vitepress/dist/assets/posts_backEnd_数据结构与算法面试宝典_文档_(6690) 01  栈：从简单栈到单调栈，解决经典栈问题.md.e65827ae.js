import{_ as o,j as t,o as e,g as r,k as a,h as s,Q as l,s as p}from"./chunks/framework.4e7d56ce.js";const X=JSON.parse('{"title":"01栈：从简单栈到单调栈，解决经典栈问题","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6690) 01  栈：从简单栈到单调栈，解决经典栈问题.md","filePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6690) 01  栈：从简单栈到单调栈，解决经典栈问题.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/数据结构与算法面试宝典_文档/(6690) 01  栈：从简单栈到单调栈，解决经典栈问题.md"},E=l(`<h1 id="_01栈-从简单栈到单调栈-解决经典栈问题" tabindex="-1">01栈：从简单栈到单调栈，解决经典栈问题 <a class="header-anchor" href="#_01栈-从简单栈到单调栈-解决经典栈问题" aria-label="Permalink to &quot;01栈：从简单栈到单调栈，解决经典栈问题&quot;">​</a></h1><p>今天我们开始学习一个在工作，以及面试中经常被问到的一个数据结构------<strong>栈</strong>。</p><p>栈这种数据结构，在计算机中有着广泛地运用，比如编程语言中函数的调用、操作系统中从用户态到内核态寄存器的保存、网络消息的处理等都会用到栈。</p><p>今天我们主要介绍面试中经常考察的栈相关的高频题目，主要内容包含两方面：</p><ul><li><p>栈的特性与使用</p></li><li><p>单调栈的解题技巧</p></li></ul><p>针对一道题目，我会深度讲解一种解法，以及其变型，并且带你总结同类问题的解题技巧和规律，从而解决多种相似及变形题目。并且，我会给出 Java/C++/Python 三种代码示例，方便你学习。现在，开始我们的旅程与探险！</p><h3 id="栈的特性与使用" tabindex="-1">栈的特性与使用 <a class="header-anchor" href="#栈的特性与使用" aria-label="Permalink to &quot;栈的特性与使用&quot;">​</a></h3><p>简单栈的特点可以用一句话来概括，<strong>先进后出</strong>（LIFO）顺序。比如 Java 代码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Stack&lt;</span><span style="color:#F97583;">Character</span><span style="color:#E1E4E8;">&gt; t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Stack&lt;</span><span style="color:#F97583;">Character</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;a&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;b&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 这里得到栈顶元素&#39;b&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 这里将栈顶元素&#39;b&#39;弹出</span></span>
<span class="line"><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 此时栈顶元素为&#39;a&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();  </span><span style="color:#6A737D;">// 这里将栈顶元素&#39;a&#39;弹出</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Stack&lt;</span><span style="color:#D73A49;">Character</span><span style="color:#24292E;">&gt; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Stack&lt;</span><span style="color:#D73A49;">Character</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;a&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;b&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 这里得到栈顶元素&#39;b&#39;</span></span>
<span class="line"><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();  </span><span style="color:#6A737D;">// 这里将栈顶元素&#39;b&#39;弹出</span></span>
<span class="line"><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 此时栈顶元素为&#39;a&#39;</span></span>
<span class="line"><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();  </span><span style="color:#6A737D;">// 这里将栈顶元素&#39;a&#39;弹出</span></span></code></pre></div><p>这部分代码片段执行效果如下图所示：</p>`,10),y=p("p",null,[s('那么如何深度利用栈的"'),p("strong",null,"先进后出"),s('"特点来解决实际工作和面试中的问题呢？是否可以总结出什么有用的知识技巧？现在你的大脑里可能已经有了一个栈的"萌芽"，如下图所示：')],-1),i=l('<p>接下来我将通过大厂面试题，带你学习这块重点知识。经过不断地&quot;浇灌&quot;，栈这棵&quot;萌芽&quot;才能抽枝散叶，长得更加茁壮。</p><h4 id="例-1-判断字符串括号是否合法" tabindex="-1">例 1：判断字符串括号是否合法 <a class="header-anchor" href="#例-1-判断字符串括号是否合法" aria-label="Permalink to &quot;例 1：判断字符串括号是否合法&quot;">​</a></h4><p>【<strong>题目</strong>】字符串中只有字符&#39;(&#39;和&#39;)&#39;。合法字符串需要括号可以配对。比如：</p><p>输入：&quot;()&quot;</p><p>输出：true</p><p><strong>解释</strong>：()，()()，(())是合法的。)(，()(，(()是非法的。</p><p>请你实现一个函数，来判断给定的字符串是否合法。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValid</span><span style="color:#E1E4E8;">(String s);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isValid</span><span style="color:#24292E;">(String s);</span></span></code></pre></div><p>【<strong>分析</strong> 】虽然这是一道<strong>简单题</strong> ，但是我们依然可以拿它来<strong>训练深度思考的能力</strong> 。如果你已经知道答案，或者说能够轻松地解决这道题，不妨再跟我一起看看<strong>如何拆解这道题</strong>。</p><p>首先，分析题目的时候，要特别注意以下 4 点，归纳为&quot;<strong>四步分析法</strong>&quot;。</p><ol><li><p><strong>模拟</strong> ：<strong>模拟题目的运行。</strong></p></li><li><p><strong>规律</strong> ：<strong>尝试总结出题目的一般规律和特点。</strong></p></li><li><p><strong>匹配</strong> ：<strong>找到符合这些特点的数据结构与算法。</strong></p></li><li><p><strong>边界</strong> ：<strong>考虑特殊情况。</strong></p></li></ol><p>接下来我们就按照上面的步骤来拆解题目。</p><p><strong>1. 模拟</strong></p><p>首先我们以字符串 s = &quot;()()(())&quot;，进行模拟，如下动图所示：</p>',14),g=l("<p><strong>2. 规律</strong></p><p>我们回顾一下模拟过程，可以总结出以下 3 个特点。</p><p>（1）每个左括号&#39;(&#39;或者右括号&#39;)&#39;都完成<strong>配对</strong>，才是合法的。</p><p>（2）配对可以通过<strong>消除法</strong>来消掉合法的括号，如果最后没有任何字符了，那么就是合法字符串。</p><p>（3）奇数长度的字符串总是非法的。</p><p><strong>3. 匹配</strong></p><p>到这里，我们已经弄清楚题目考核的重点，就是<strong>消除法</strong> 的模拟。如果仔细观察消除法的行为模式，你会发现，在消除的时候，上图中<strong>红色</strong> 的部分和<strong>栈的行为</strong>非常像。因此，可以用栈来进行消除法的模拟。</p><p><strong>4. 边界</strong></p><p>当我们找到问题匹配的算法或者数据结构之后，一定要记住，接下来一步并不是马上写代码，而是要考虑一些边界问题，也就是一些特殊情况：</p><ul><li><p>字符串为空</p></li><li><p>字符串只有 1 个或者奇数个</p></li><li><p>字符串是&quot;(((())))&quot;嵌套很多层的是否可以处理</p></li></ul><p>【<strong>画图</strong>】可以采用画图的方法来判断自己是否已经了解题目，或者是否能灵活运用一个算法。在面试中经常需要在白板或者纸上画图，所以在学习算法时候建议你培养多画图的习惯。</p><ul><li><p>当遇到左括号&#39;(&#39;时，进行压栈操作</p></li><li><p>当遇到右括号&#39;)&#39;时，进行弹栈操作</p></li></ul><p>为了帮助你更好地理解，我将求解过程制作成一张动图，如下所示，注意左边<strong>栈的变化</strong>。</p>",13),A=l(`<p>【<strong>代码</strong>】到这里时，你可以写出以下核心代码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValid</span><span style="color:#E1E4E8;">(String s) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当字符串本来就是空的时候，我们可以快速返回true</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">length</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s.</span><span style="color:#B392F0;">length</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 消除法的主要核心逻辑: </span></span>
<span class="line"><span style="color:#E1E4E8;">  Stack&lt;</span><span style="color:#F97583;">Character</span><span style="color:#E1E4E8;">&gt; t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Stack&lt;</span><span style="color:#F97583;">Character</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">length</span><span style="color:#E1E4E8;">(); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 取出字符</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">charAt</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;(&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果是&#39;(&#39;，那么压栈</span></span>
<span class="line"><span style="color:#E1E4E8;">      t.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(c);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;)&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果是&#39;)&#39;，那么就尝试弹栈</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果弹栈失败，那么返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      t.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isValid</span><span style="color:#24292E;">(String s) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当字符串本来就是空的时候，我们可以快速返回true</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">length</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s.</span><span style="color:#6F42C1;">length</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 消除法的主要核心逻辑: </span></span>
<span class="line"><span style="color:#24292E;">  Stack&lt;</span><span style="color:#D73A49;">Character</span><span style="color:#24292E;">&gt; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Stack&lt;</span><span style="color:#D73A49;">Character</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">length</span><span style="color:#24292E;">(); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 取出字符</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">charAt</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;(&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果是&#39;(&#39;，那么压栈</span></span>
<span class="line"><span style="color:#24292E;">      t.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(c);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;)&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果是&#39;)&#39;，那么就尝试弹栈</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果弹栈失败，那么返回false</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      t.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.Java" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.cpp" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：每个字符只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能会把整个字符串都入栈。</p><p>做完一道题后，我们还需要从两个角度进行深度思考：</p><ul><li><p>深度，比如这种解法还可以怎么优化呢？</p></li><li><p>广度，比如这种解法具有普适性吗？可以推广吗？</p></li></ul><p><strong>1. 深度扩展</strong></p><p>如果仔细观察，你会发现，栈中存放的元素是一样的。全部都是左括号&#39;(&#39;，除此之外，再也没有别的元素，优化方法如下。</p><p><strong>栈中元素都相同时，实际上没有必要使用栈，只需要记录栈中元素个数。</strong> 我们可以通过画图来解决这个问题，如下动图所示：</p>`,9),F=l(`<p>实际上，就是把入栈与出栈变成了 leftBraceNumber 的加减。代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValid</span><span style="color:#E1E4E8;">(String s) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当字符串本来就是空的时候，我们可以快速返回true</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">length</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (s.</span><span style="color:#B392F0;">length</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 消除法的主要核心逻辑:</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> leftBraceNumber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">length</span><span style="color:#E1E4E8;">(); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 取出字符</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">char</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">charAt</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;(&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果是&#39;(&#39;，那么压栈</span></span>
<span class="line"><span style="color:#E1E4E8;">      leftBraceNumber</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (c </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;)&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果是&#39;)&#39;，那么就尝试弹栈</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (leftBraceNumber </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果弹栈失败，那么返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">leftBraceNumber;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> leftBraceNumber </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isValid</span><span style="color:#24292E;">(String s) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当字符串本来就是空的时候，我们可以快速返回true</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">length</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 当字符串长度为奇数的时候，不可能是一个有效的合法字符串</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (s.</span><span style="color:#6F42C1;">length</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 消除法的主要核心逻辑:</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> leftBraceNumber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">length</span><span style="color:#24292E;">(); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 取出字符</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">char</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">charAt</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;(&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果是&#39;(&#39;，那么压栈</span></span>
<span class="line"><span style="color:#24292E;">      leftBraceNumber</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (c </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;)&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果是&#39;)&#39;，那么就尝试弹栈</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (leftBraceNumber </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果弹栈失败，那么返回false</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">leftBraceNumber;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> leftBraceNumber </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.java" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.cpp" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example01_D.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：每个字符只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(1)，因为我们已经只用一个变量来记录栈中的内容。</p><p>【<strong>小结</strong>】经过前面的分析，现在我们可以将题目的特点做一下小结：</p>`,5),h=l('<p><strong>2. 广度扩展</strong></p><p>接下来再来看看如何进行广度扩展。观察题目可以发现，栈中只存放了一个维度的信息：左括号&#39;(&#39;和右括号&#39;)&#39;。如果<strong>栈中的内容变得更加丰富</strong>一点，就可以得到下面这道扩展题。</p><p>【<strong>题目扩展</strong>】给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。有效字符串需满足：</p><ol><li><p>左括号必须用相同类型的右括号闭合</p></li><li><p>左括号必须以正确的顺序闭合</p></li><li><p>注意空字符串可被认为是有效字符串</p></li></ol><p>请实现接口： public boolean isValid(String s)</p><p>对于这道题，我希望你能再走一下：<strong>分析</strong> ，<strong>画图</strong> ，<strong>代码</strong> ，扩<strong>展</strong> ，<strong>小结</strong>的五步曲。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.java" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.cpp" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/20.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>【<strong>小结</strong> 】接下来，我们对拓展题目进行总结，希望你从中<strong>提炼出经验</strong>，以后再遇到相似的题目能够轻松应对。</p><p>对于栈的使用，除了知道&quot;后进先出&quot;这个规律，我们还可以帮它长出一些叶子来，如下图所示：</p>',9),u=l('<p>因此，以后你在看到题目中类似<strong>配对</strong> 、<strong>消除</strong> 之类的动作时，可以采用<strong>栈</strong>来操作。通过这两个方向上的整理和归纳，我们进一步探寻到了题目和解法之间的联系。让我们继续前进。</p><h4 id="例-2-大鱼吃小鱼" tabindex="-1">例 2：大鱼吃小鱼 <a class="header-anchor" href="#例-2-大鱼吃小鱼" aria-label="Permalink to &quot;例 2：大鱼吃小鱼&quot;">​</a></h4><p>【<strong>题目</strong>】在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:</p><ol><li><p>所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；</p></li><li><p>当方向相对时，大鱼会吃掉小鱼；</p></li><li><p>鱼的大小都不一样。</p></li></ol><p>输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]</p><p>输出：3</p><p>请完成以下接口来计算还剩下几条鱼？</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">solution</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] Size, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] Dir);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">solution</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] Size, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] Dir);</span></span></code></pre></div><p>题目的示意图如下所示：</p>',9),D=l('<p>【<strong>分析</strong> 】对于这道题而言，大鱼吃掉小鱼的时候，可以认为是一种<strong>消除</strong>行为。只不过与括号匹配时的行为不一样：</p><ul><li><p>括号匹配是会<strong>同时</strong>把左括号与右括号消除掉；</p></li><li><p>大鱼吃小鱼，<strong>只会把小鱼</strong>消除掉。</p></li></ul><p><strong>1. 模拟</strong></p><p>首先我们以如下示例进行演示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Size </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">], Dir </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Size </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">], Dir </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span></code></pre></div>',5),_=l("<p><em>注意：当鱼的游动方向相同，或者相反时，并不会相遇，此时大鱼不能吃掉小鱼。</em></p><p><strong>2. 规律</strong></p><p>通过模拟，可以发现如下规律:</p><ul><li><p>如果两条鱼<strong>相对而游时，那么较小的鱼会被吃掉；</strong></p></li><li><p><strong>其他情况</strong>没有鱼被吃掉。</p></li></ul><p><strong>3. 匹配</strong></p><p>我们发现，下面活下来的鱼的行为（上图红框部分）就是一个<strong>栈</strong>。每当有新的鱼要进来的时候，就会与栈顶的鱼进行比较。那么我们匹配到的算法就是栈了。</p><p><strong>4. 边界</strong></p><p>在正式开始求解之前，我们还是想一想两种边界：</p><ul><li><p>所有的鱼都朝着一个方向游；</p></li><li><p>一条鱼吃掉了其他的所有鱼。</p></li></ul><p>我们在后面设计算法的时候，这些情况都需要考虑到。</p><p>【<strong>画图</strong> 】<strong>这道题的关键仍然是如何使用栈来模拟鱼的消除行为</strong>。接下来我们用栈画一下图，演示出我们的思路，动图如下：</p>",11),C=l(`<p>【<strong>代码</strong>】根据之前的思考，可以得到如下解法（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">solution</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] fishSize, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] fishDirection) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 首先拿到鱼的数量</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果鱼的数量小于等于1，那么直接返回鱼的数量</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> fishNumber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fishSize.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (fishNumber </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> fishNumber;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 0表示鱼向左游</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 1表示鱼向右游</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  Stack&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Stack</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> fishNumber; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前鱼的情况：1，游动的方向；2，大小</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> curFishDirection </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fishDirection[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> curFishSize </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fishSize[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前的鱼是否被栈中的鱼吃掉了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> hasEat </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果栈中还有鱼，并且栈中鱼向右，当前的鱼向左游，那么就会有相遇的可能性</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> fishDirection[t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">()] </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> right </span><span style="color:#F97583;">&amp;&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">           curFishDirection </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> left) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果栈顶的鱼比较大，那么把新来的吃掉</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (fishSize[t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">()] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> curFishSize) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        hasEat </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果栈中的鱼较小，那么会把栈中的鱼吃掉，栈中的鱼被消除，所以需要弹栈。</span></span>
<span class="line"><span style="color:#E1E4E8;">      t.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果新来的鱼，没有被吃掉，那么压入栈中。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">hasEat) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      t.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> t.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">solution</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] fishSize, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] fishDirection) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 首先拿到鱼的数量</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果鱼的数量小于等于1，那么直接返回鱼的数量</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> fishNumber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fishSize.length;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (fishNumber </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> fishNumber;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 0表示鱼向左游</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 1表示鱼向右游</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  Stack&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Stack</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> fishNumber; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前鱼的情况：1，游动的方向；2，大小</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> curFishDirection </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fishDirection[i];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> curFishSize </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fishSize[i];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前的鱼是否被栈中的鱼吃掉了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> hasEat </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果栈中还有鱼，并且栈中鱼向右，当前的鱼向左游，那么就会有相遇的可能性</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> fishDirection[t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">()] </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> right </span><span style="color:#D73A49;">&amp;&amp;</span></span>
<span class="line"><span style="color:#24292E;">           curFishDirection </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> left) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果栈顶的鱼比较大，那么把新来的吃掉</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (fishSize[t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">()] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> curFishSize) {</span></span>
<span class="line"><span style="color:#24292E;">        hasEat </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果栈中的鱼较小，那么会把栈中的鱼吃掉，栈中的鱼被消除，所以需要弹栈。</span></span>
<span class="line"><span style="color:#24292E;">      t.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果新来的鱼，没有被吃掉，那么压入栈中。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">hasEat) {</span></span>
<span class="line"><span style="color:#24292E;">      t.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> t.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.java" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.cpp" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Fish.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：每只鱼只入栈一次，出栈一次，所以时间复杂度 为 O(N)，而空间复杂度为 O(N)，因为最差情况下可能把所有的鱼都入栈。</p><p>【<strong>小结</strong>】接下来我们一起对这道题做一下归纳。可以发现，与例 1 相比，它们的消除行为有所不同：</p><ul><li><p>在例 1 中，消除行为表现为配对的<strong>两者都会消除；</strong></p></li><li><p>在例 2 中，消除行为表现为配对的两者中<strong>有一个会被消除</strong>。</p></li></ul><p>此外，在与 例 1 的比较中，可以发现，栈中的内容也有所不同：</p><ul><li><p>在例 1 中，栈中的<strong>存放的就是内容本</strong>身；</p></li><li><p>在例 2 中，栈中存<strong>放的只是内容的索引</strong>，可以通过索引得到内容。</p></li></ul><p>再者，我们也发现，在弹栈的时候，不再像以前那样，每次只弹一个元素，而是采用了 while 循环，要一直弹到满足某个条件为止。所以我们总结出，弹栈的时候有两种情况：</p><ul><li><p><strong>弹一个元素</strong>就可以；</p></li><li><p>用 while 语句<strong>一直弹，直到满足某个条件</strong>为止。</p></li></ul><p>因此，这道题的考点我们也挖掘出来了：</p><ul><li><p>是否会<strong>用栈来存放索引</strong>？</p></li><li><p>是否想到在弹栈的时候一定要<strong>满足某个条件才停止弹栈</strong>？</p></li></ul><p>到这里栈的特点更丰富了，通过我们不断地浇灌也让栈这棵&quot;萌芽&quot;长出了更多的叶子，总结如下图所示：</p>`,13),d=l('<h3 id="单调栈的解题技巧" tabindex="-1">单调栈的解题技巧 <a class="header-anchor" href="#单调栈的解题技巧" aria-label="Permalink to &quot;单调栈的解题技巧&quot;">​</a></h3><p>大部分数据结构书上都不太会讲单调栈的知识，但是在面试中却经常考察这一类题，这就非常考验你的知识储备了。</p><p>首先我们看一下<strong>单调栈的定义</strong> ：单调栈就是指栈中的元素<strong>必须</strong> 是按照<strong>升序</strong> 排列的栈，或者是<strong>降序</strong>排列的栈。对于这两种排序方式的栈，还给它们各自取了小名。</p><p>升序排列的栈称为<strong>递增栈</strong>，如下图所示：</p>',4),m=p("p",null,[s("降序排列的栈称为"),p("strong",null,"递减栈"),s("，如下图所示：")],-1),b=p("p",null,[p("em",null,"注意：示意图所展示的这两种栈是横向排列的。栈中元素的值，分别用不同高度的矩形来表示，值越大，矩形越高。")],-1),B=p("p",null,[s('接下来我们介绍一下递增栈的有序性，一句话："'),p("strong",null,"任何时候都需要保证栈的有序性"),s('"。')],-1),f=p("p",null,"递增栈的特性可以演示如下（上方数组是要依次入栈的元素）：",-1),k=p("p",null,"递减栈的特性可以演示如下：",-1),S=p("p",null,"通过这两个动图，我们可以总结出单调栈的特点，如下图所示：",-1),v=l('<p>接下来我们通过一些小题目来对单调栈进行&quot;浇灌&quot;，也让单调栈长出更多的&quot;叶子&quot;。</p><h4 id="例-3-找出数组中右边比我小的元素" tabindex="-1">例 3：找出数组中右边比我小的元素 <a class="header-anchor" href="#例-3-找出数组中右边比我小的元素" aria-label="Permalink to &quot;例 3：找出数组中右边比我小的元素&quot;">​</a></h4><p>【<strong>题目</strong>】一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。</p><p>输入：[5, 2]</p><p>输出：[1, -1]</p><p><strong>解释</strong>：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">接口：</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">findRightSmall</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">接口：</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">findRightSmall</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A);</span></span></code></pre></div><p>【<strong>分析</strong> 】每次开始分析题意时，记得要拿出我们的&quot;<strong>四步分析法&quot;</strong>，通过一步步分析找到题目相应的解法。</p><p><strong>1. 模拟</strong></p><p>在正式开始上手之后，我们先拿两个例子演示一下，看看能不能发现题目中隐藏的一些有趣规律，动图如下所示：</p>',10),T=l("<p><strong>2. 规律</strong></p><p>这里我们是照着题意去寻找一个右边比它小的数的下标。可以发现，A[4] = 4 及 A[5] = 0，这两个数字多次被用到。并且：</p><ul><li><p>A[4] 发现有左边 A[3]，A[3] 就匹配成功；</p></li><li><p>结合 A[5] = 0 的例子，我们发现它会把比它大的数都进行<strong>匹配成功</strong>，但是 A[3] 除外；</p></li><li><p>A[3] 可以认为是匹配成功之后，被 A[4]<strong>消除</strong>了。</p></li></ul><p><strong>这时可以总结出：一个数总是想与左边比它大的数进行匹配，匹配到了之后，小的数会消除掉大的数</strong>。</p><p><strong>3. 匹配</strong></p><p>当你发现要解决的题目有两个特点：</p><ul><li><p>小的数要与大的数<strong>配对</strong></p></li><li><p>小的数会<strong>消除</strong>大的数</p></li></ul><p>你的脑海里应该联想到关于<strong>单调栈</strong>的特性。下面我们看看如何利用单调栈解决这道题目。</p><p>【<strong>画图</strong> 】在这里，依然需要画一个图来描述一下我们的思路及想法，如下图所示：（红色部分表示栈，我们只将<strong>下标绿色值</strong>放到栈中，为了看图方便，把下标对应的值也标在了相应位置。）</p>",9),q=l(`<p>Step 1. 首先将 A[0] = 1 的下标 <strong>0</strong> 入栈。</p><p>Step 2. 将 A[1] = 2 的下标 1 入栈。满足单调栈。</p><p>Step 3. 将 A[2] = 4 的下标 2 入栈。满足单调栈。</p><p>Step 4. 将 A[3] = 9 的下标 3 入栈。满足单调栈。</p><p>Step 5. 将 A[4] = 4 的下标 4 入栈时，不满足单调性，需要将 A[3] = 9 从栈中弹出去。下标 4 将栈中下标 3 弹出栈，记录 A[3] 右边更小的是 index = 4。</p><p>Step 6. 将 A[5] = 0 的下标 5 入栈时，不满足单调性，需要将 A[4] = 4 从栈中弹出去。下标 5 将下标 4 弹出栈，记录 A[4] 右边更小的是 index = 5。A[5] = 0 会将栈中的下标 0, 1, 2 都弹出栈，因此也需要记录相应下标右边比其小的下标为 5，再将 A[5] = 0 的下标 5 放入栈中。</p><p>Step 7. 将 A[6] = 5 的下标 6 放入栈中。满足单调性。</p><p>Step 8. 此时，再也没有元素要入栈了，那么栈中的元素右边没有比其更小的元素。因此设置为 -1.</p><p>【<strong>代码</strong>】到此为止，相信你已经可以根据思路写出代码了，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">findRightSmall</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 结果数组</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[A.length];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 注意，栈中的元素记录的是下标</span></span>
<span class="line"><span style="color:#E1E4E8;">  Stack&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Stack</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> A.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 每个元素都向左遍历栈中的元素完成消除动作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">()] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> x) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 消除的时候，记录一下被谁消除了</span></span>
<span class="line"><span style="color:#E1E4E8;">      ans[t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">()] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 消除时候，值更大的需要从栈中消失</span></span>
<span class="line"><span style="color:#E1E4E8;">      t.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 剩下的入栈</span></span>
<span class="line"><span style="color:#E1E4E8;">    t.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">t.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans[t.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">()] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    t.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">findRightSmall</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 结果数组</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[A.length];</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 注意，栈中的元素记录的是下标</span></span>
<span class="line"><span style="color:#24292E;">  Stack&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Stack</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> A.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 每个元素都向左遍历栈中的元素完成消除动作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">()] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> x) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 消除的时候，记录一下被谁消除了</span></span>
<span class="line"><span style="color:#24292E;">      ans[t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">()] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 消除时候，值更大的需要从栈中消失</span></span>
<span class="line"><span style="color:#24292E;">      t.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 剩下的入栈</span></span>
<span class="line"><span style="color:#24292E;">    t.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 栈中剩下的元素，由于没有人能消除他们，因此，只能将结果设置为-1。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">t.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    ans[t.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">()] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    t.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.java" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.cpp" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example03.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：每个元素只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况可能会把所有的元素都入栈。</p><p>【<strong>小结</strong> 】到这里我们可以得到一个有趣且非常有用的结论：数组中右边<strong>第一个比我小</strong> 的元素的位置，求解用<strong>递增栈</strong>。</p><p>这里给你留几道<strong>练习题</strong>，请你思考如何求解。</p><ol><li>数组中右边第一个比我大的元素的位置</li></ol><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%8F%B3%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><ol start="2"><li>数组中元素左边离我最近且比我小的元素的位置</li></ol><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%B0%8F.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><ol start="3"><li>数组中元素左边离我最近且比我大的元素的位置</li></ol><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E6%88%91%E5%A4%A7.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>如果我们进一步归纳，会发现消除的时候，这里仍然是消除一个元素，保留一个元素。弹栈的时候，仍然是一<strong>直弹栈，直到满足某个条件为止</strong>。只是条件变成了直到元素大于栈顶元素。为了方便你理解，我把内容总结到了一张大图里：</p>`,21),P=l('<h4 id="例-4-字典序最小的-k-个数的子序列" tabindex="-1">例 4：字典序最小的 k 个数的子序列 <a class="header-anchor" href="#例-4-字典序最小的-k-个数的子序列" aria-label="Permalink to &quot;例 4：字典序最小的 k 个数的子序列&quot;">​</a></h4><p>【<strong>题目</strong> 】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. <strong>长度为 k</strong> ；2.<strong>字典序最小</strong>。</p><p>输入：nums = [3,5,2,6], k = 2</p><p>输出：[2,6]</p><p><strong>解释</strong>：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</p><p>所谓字典序就是，给定两个数组：x = [x~1~,x~2~,x~3~,x~4~]，y = [y~1~,y~2~,y~3~,y~4~]，如果 0 ≤ p &lt; i，x~p~ == y~p~ 且 x~i~ &lt; y~i~，那么我们认为 x 的字典序小于 y。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">接口：</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">findSmallSeq</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">接口：</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">findSmallSeq</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k);</span></span></code></pre></div><p>【<strong>分析</strong>】根据&quot;四步分析法&quot;，我们一步一步拆解题目。</p><p><strong>1. 模拟</strong></p><p>首先应该拿例子来模拟一下题目所述的过程，动图如下所示：</p>',10),N=l("<p><strong>2. 规律</strong></p><p>通过模拟，我们发现<strong>一个特点：一旦发现更小的数时，就可以把前面已经放好的数扔掉，然后把这个最小的数放在最前面</strong>。</p><p>如果机智一点，就会发现这里与<strong>例 2 的</strong> &quot;<strong>大鱼吃小鱼</strong> &quot;结果很像。区别在于消除的过程中，大鱼吃小鱼是大鱼留下来了，而这里较小的数和较大的数相遇时，是<strong>较小的数</strong>留下来了。</p><p><strong>3. 匹配</strong></p><p>到这里，我们已经发现了题目的特点------<strong>较小数消除掉较大数</strong> 。根据<strong>例 3</strong> 总结出来的规律，此时就可以用上单调栈。并且，由于是较小的数消除掉较大的数，所以应该使用<strong>递增栈</strong>。</p><p><strong>4. 边界</strong></p><p>不过我们还是需要小心题目的边界。</p><p><strong>Case 1</strong>：假设数组右边有一个最小的数，这个最小的数会把左边的数全部都消掉，然后递增栈里面就只剩下这 1 个数了。这跟题意有点不符合，题意需要的是找到 k = 2 个出来。</p>",8),I=l('<p><strong>解决办法</strong>：不过你可以想一想，是不是可以控制一下消去的数目。当剩下的数字个数与栈中的元素刚好能凑够 k 个数时，就不能再消除了，代码如下 :</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">rightLeftNumber </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> stack.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> k</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">rightLeftNumber </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> stack.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> k</span></span></code></pre></div><p>此时，如果还要进行消除，就不能凑够 k 个数了。这样操作可以保证我们取的序列是最小的 k 个数。</p><p><strong>Case 2</strong>：如果数组是一个升序的数组，那么此时所有的元素都会被压栈。栈中的数目有可能远远超出 k 个。</p>',4),V=p("p",null,[p("strong",null,"解决办法"),s("：只需要把栈中的多出来的数字弹出来即可。")],-1),x=p("p",null,[s("【"),p("strong",null,"画图"),s("】假定输入为[9, 2, 4, 5, 1, 2, 3, 0], k = 3.输出能构成的最小的序列。")],-1),j=l(`<p>Step 1. 首先将 9 加入栈中。</p><p>Step 2. 当 2 要入栈时，不满足单调栈，需要将数字 9 出栈。由于后面还有足够多的元素，可以把 9 弹栈，再将 2 入栈。</p><p>Step 3. 将 4 入栈，满足单调性。</p><p>Step 4. 再将元素 5 入栈，满足单调性。</p><p>Step 5. 将要入栈的元素 1，会弹出栈中所有元素。</p><p>Step 6. 将元素 1 入栈。</p><p>Step 7. 将元素 2 入栈，满足单调性。</p><p>Step 8. 将元素 3 入栈，满足单调性。</p><p>Step 9. 将 0 入栈时，需要将栈顶元素 3 弹出。</p><p>Step 10. 将 0 入栈，不满足单调性。这是因为，如果 0 将前面的元素再弹栈，余下的元素个数就小于 k = 3 个了。所以不能再利用单调性来弹出栈中元素了。</p><p>【<strong>代码</strong>】到这里，相信你已经可以根据思路写出代码了，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">findSmallSeq</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] nums, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[k];</span></span>
<span class="line"><span style="color:#E1E4E8;">  Stack&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Stack</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里生成单调栈</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> nums.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nums.length </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意我们想要提取出k个数，所以注意控制扔掉的数的个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">s.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (s.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> k) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> x) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      s.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    s.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(x);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 如果递增栈里面的数太多，那么我们只需要取出前k个就可以了。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 多余的栈中的元素需要扔掉。</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (s.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> k) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    s.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 把k个元素取出来，注意这里取的顺序!</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> k </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    s.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">findSmallSeq</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] nums, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[k];</span></span>
<span class="line"><span style="color:#24292E;">  Stack&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Stack</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里生成单调栈</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> nums.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums[i];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nums.length </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意我们想要提取出k个数，所以注意控制扔掉的数的个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">s.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (s.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> k) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> x) {</span></span>
<span class="line"><span style="color:#24292E;">      s.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    s.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(x);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 如果递增栈里面的数太多，那么我们只需要取出前k个就可以了。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 多余的栈中的元素需要扔掉。</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (s.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> k) {</span></span>
<span class="line"><span style="color:#24292E;">    s.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 把k个元素取出来，注意这里取的顺序!</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> k </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    ans[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    s.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.java" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.cpp" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/Example04.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：每个元素只入栈一次，出栈一次，所以时间复杂度为 O(N)，而空间复杂度为 O(N)，因为最差情况可能会把所有元素都入栈。</p><p>【<strong>小结</strong>】写完代码之后，我们需要对代码和题目做一个小结：</p><ul><li><p>较小的数<strong>消除</strong> 掉较大的数的时候，使用<strong>递增栈；</strong></p></li><li><p>要注意控制剩下的元素的个数；</p></li></ul><p>如果更进一步推而广之，会发现<strong>从简单栈到单调栈，层层推进的过程中，不停变化就是入栈与出栈的时机</strong>。</p><p>那么，到这里，这个题目的考点也就非常明了了：</p><ul><li><p>递增栈</p></li><li><p>个数控制，我们只需要取 k 个数出来。</p></li></ul><h3 id="总结与延伸" tabindex="-1">总结与延伸 <a class="header-anchor" href="#总结与延伸" aria-label="Permalink to &quot;总结与延伸&quot;">​</a></h3><p>在本讲我带你一起剖析了栈相关的知识和题目，经过我们不断地&quot;浇灌&quot;，栈这棵&quot;萌芽&quot;开始抽枝散叶，终于长成了一棵枝繁叶茂的&quot;大树&quot;。回到知识层面，我把本讲重点介绍、且需要你掌握的内容总结在一张思维导图中，如下图所示：</p>`,21),w=p("p",null,[s('除了带你学习知识本身，我还介绍了题目的变形和演进，希望能够帮助你建立深度分析的能力。在学习算法与数据结构的过程中，作为"刷题过来人"，我非常建议你加强总结和归纳 ，建立自己的'),p("strong",null,"学习方法论"),s("。")],-1),M=p("p",null,"虽然栈很有趣，不过我们的介绍就要到这里了，我对于栈的总结和归纳只是个开头，期待你还能发现更多栈的特点和巧妙用法，并且将它们总结下来。也欢迎在评论区和我交流，期待看到你的奇思妙想。",-1),W=p("h3",{id:"思考题",tabindex:"-1"},[s("思考题 "),p("a",{class:"header-anchor",href:"#思考题","aria-label":'Permalink to "思考题"'},"​")],-1),z=p("p",null,[s("我再给你留一道"),p("strong",null,"思考题"),s(" ：给定一个数组，数组中的元素代表木板的高度。请你求出"),p("strong",null,"相邻木板"),s("能剪出的最大矩形面积。")],-1),O=l('<p>这道题会涉及一个<strong>非常重要且有用</strong> 的单调栈的性质，<strong>希望你能找到它</strong>。你可以把答案写在评论区，我们一起讨论。</p><blockquote><p>解法 1：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.py" target="_blank" rel="noreferrer">Python</a></p><p>解法 2：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/01.Stack/84.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.2.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。让我们继续前进。下一讲将介绍 02 | 队列：FIFO 队列与单调队列的深挖与扩展，记得按时来探险。</p>',3);function R(H,J,Y,L,U,G){const n=t("Image");return e(),r("div",null,[E,a(n,{alt:"1.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/63/Cgp9HWA4jJaAMKH7ADCb3Og8L1Q358.gif"}),s(),y,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M00/0B/64/Cgp9HWA4jLCAYaYWAAAXKWOZhe8052.png"}),s(),i,a(n,{alt:"2.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/61/CioPOWA4jh2AHCJwACmFB7AcuZA768.gif"}),s(),g,a(n,{alt:"3.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/68/Cgp9HWA4kDOANTojAGASkY8p8QQ593.gif"}),s(),A,a(n,{alt:"4.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/65/CioPOWA4kG2AWiD2AAJ2CaCcwJY807.gif"}),s(),F,a(n,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image6/M00/0B/77/Cgp9HWA4ny2ASkpXAABGeRYQOyU298.png"}),s(),h,a(n,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image6/M00/0B/74/CioPOWA4nzyAJYfYAABDA_sAa3Q037.png"}),s(),u,a(n,{alt:"Stack01.大鱼吃小鱼.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/74/CioPOWA4n3uAM9nhAACmI5boRa0503.gif"}),s(),D,a(n,{alt:"5.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/74/CioPOWA4n5yAIhjtAAXAzjrqmCE807.gif"}),s(),_,a(n,{alt:"7.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/74/CioPOWA4n7eAEu-UAAY8UjR-F74828.gif"}),s(),C,a(n,{alt:"Drawing 19.png",src:"https://s0.lgstatic.com/i/image6/M01/0B/77/Cgp9HWA4n9WAA59XAACgLfhWcGY098.png"}),s(),d,a(n,{alt:"8.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/7B/CioPOWA4qWKAWwxXAAClLMMoPFk436.gif"}),s(),m,a(n,{alt:"9.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/7F/Cgp9HWA4qXCAM4-PAADnGTexjMk160.gif"}),s(),b,B,f,a(n,{alt:"13.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/7B/CioPOWA4qXmAUt2VAANQuRNAR14194.gif"}),s(),k,a(n,{alt:"14.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/7B/CioPOWA4qYCABi8aAAUfrNnOGUY452.gif"}),s(),S,a(n,{alt:"Drawing 29.png",src:"https://s0.lgstatic.com/i/image6/M01/0B/7C/CioPOWA4qiiAEfpbAABn_-GStTI565.png"}),s(),v,a(n,{alt:"15.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/7F/Cgp9HWA4qYqASCuDAArtP3-ZB0A448.gif"}),s(),T,a(n,{alt:"16.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/7F/Cgp9HWA4qkaALlpRAHsvPijzTIg101.gif"}),s(),q,a(n,{alt:"Drawing 45.png",src:"https://s0.lgstatic.com/i/image6/M01/0B/7F/Cgp9HWA4qrWAR4cuAADTLTA3i8c099.png"}),s(),P,a(n,{alt:"12.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/80/Cgp9HWA4qsyASrO1AAMU43HNuI4415.gif"}),s(),N,a(n,{alt:"10.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/80/Cgp9HWA4quuAMBDzAALrKCGW33s184.gif"}),s(),I,a(n,{alt:"11.gif",src:"https://s0.lgstatic.com/i/image6/M00/0B/80/Cgp9HWA4qxqAFbVgAAH8B7oHgJo512.gif"}),s(),V,x,a(n,{alt:"17.gif",src:"https://s0.lgstatic.com/i/image6/M01/0B/81/Cgp9HWA4qzaAHEjwAGccHgMTVOU699.gif"}),s(),j,a(n,{alt:"Drawing 65.png",src:"https://s0.lgstatic.com/i/image6/M01/0B/7F/CioPOWA4q6qASB-UAADhj7uzOwg933.png"}),s(),w,M,W,z,a(n,{alt:"尾图.png",src:"https://s0.lgstatic.com/i/image6/M00/0B/83/Cgp9HWA4q--AZmcbAABdc5tNqDI318.png"}),s(),O])}const K=o(c,[["render",R]]);export{X as __pageData,K as default};
