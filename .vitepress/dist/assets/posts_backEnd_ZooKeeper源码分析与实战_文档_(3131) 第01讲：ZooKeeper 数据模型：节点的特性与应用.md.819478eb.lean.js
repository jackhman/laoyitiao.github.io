import{_ as t,j as n,o as l,h as r,k as a,f as s,Q as p,s as e}from"./chunks/framework.d3daa342.js";const I=JSON.parse('{"title":"第01讲：ZooKeeper数据模型：节点的特性与应用","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/ZooKeeper源码分析与实战_文档/(3131) 第01讲：ZooKeeper 数据模型：节点的特性与应用.md","filePath":"posts/backEnd/ZooKeeper源码分析与实战_文档/(3131) 第01讲：ZooKeeper 数据模型：节点的特性与应用.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/ZooKeeper源码分析与实战_文档/(3131) 第01讲：ZooKeeper 数据模型：节点的特性与应用.md"},i=p("",19),d=e("p",null,'ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。ZooKeeper 的数据模型也具有一个固定的根节点（/），我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。ZooKeeper 树中的每一层级用斜杠（/）分隔开，且只能用绝对路径（如"get /work/task1"）的方式查询 ZooKeeper 节点，而不能使用相对路径。具体的结构你可以看看下面这张图：',-1),_=p("",7),h=e("h4",{id:"_3、有序节点",tabindex:"-1"},[s("3、有序节点 "),e("a",{class:"header-anchor",href:"#_3、有序节点","aria-label":'Permalink to "3、有序节点"'},"​")],-1),y=e("p",null,"最后我们再说一下有序节点，其实有序节点并不算是一种单独种类的节点，而是在之前提到的持久节点和临时节点特性的基础上，增加了一个节点有序的性质。所谓节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。例如一个客户端创建了一个路径为 works/task- 的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为 works/task-1。通过这种方式我们可以直观的查看到节点的创建顺序。",-1),g=e("p",null,"到目前为止我们知道在 ZooKeeper 服务器上存储数据的基本信息，知道了 ZooKeeper 中的数据节点种类有持久节点和临时节点等。上述这几种数据节点虽然类型不同，但 ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组（byte data[]），用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。",-1),E=e("p",null,"下面我们详细说明节点的状态信息。",-1),u=e("h3",{id:"节点的状态结构",tabindex:"-1"},[s("节点的状态结构 "),e("a",{class:"header-anchor",href:"#节点的状态结构","aria-label":'Permalink to "节点的状态结构"'},"​")],-1),k=e("p",null,"每个节点都有属于自己的状态信息，这就很像我们每个人的身份信息一样，我们打开之前的客户端，执行 stat /zk_test，可以看到控制台输出了一些信息，这些就是节点状态信息。",-1),A=e("p",null,"每一个节点都有一个自己的状态属性，记录了节点本身的一些信息，这些属性包括的内容我列在了下面这个表格里：",-1),K=p("",10),Z=e("p",null,'这时进程 b 也要访问临界区资源，于是进程 b 也尝试创建"/locks"节点来获取锁，因为之前进程 a 已经创建该节点，所以进程 b 创建节点失败无法获得锁。',-1),m=e("p",null,"这样就实现了一个简单的悲观锁，不过这也有一个隐含的问题，就是当进程 a 因为异常中断导致 /locks 节点始终存在，其他线程因为无法再次创建节点而无法获取锁，这就产生了一个死锁问题。针对这种情况我们可以通过将节点设置为临时节点的方式避免。并通过在服务器端添加监听事件来通知其他进程重新获取锁。",-1),b=e("p",null,[e("strong",null,"乐观锁")],-1),v=e("p",null,"乐观锁认为，进程对临界区资源的竞争不会总是出现，所以相对悲观锁而言。加锁方式没有那么激烈，不会全程的锁定资源，而是在数据进行提交更新的时候，对数据的冲突与否进行检测，如果发现冲突了，则拒绝操作。",-1),C=e("p",null,"**乐观锁基本可以分为读取、校验、写入三个步骤。**CAS（Compare-And-Swap），即比较并替换，就是一个乐观锁的实现。CAS 有 3 个操作数，内存值 V，旧的预期值 A，要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。",-1),q=e("p",null,'在 ZooKeeper 中的 version 属性就是用来实现乐观锁机制中的"校验"的，ZooKeeper 每个节点都有数据版本的概念，在调用更新操作的时候，假如有一个客户端试图进行更新操作，它会携带上次获取到的 version 值进行更新。而如果在这段时间内，ZooKeeper 服务器上该节点的数值恰好已经被其他客户端更新了，那么其数据版本一定也会发生变化，因此肯定与客户端携带的 version 无法匹配，便无法成功更新，因此可以有效地避免一些分布式更新的并发问题。',-1),D=e("p",null,"在 ZooKeeper 的底层实现中，当服务端处理 setDataRequest 请求时，首先会调用 checkAndIncVersion 方法进行数据版本校验。ZooKeeper 会从 setDataRequest 请求中获取当前请求的版本 version，同时通过 getRecordForPath 方法获取服务器数据记录 nodeRecord， 从中得到当前服务器上的版本信息 currentversion。如果 version 为 -1，表示该请求操作不使用乐观锁，可以忽略版本对比；如果 version 不是 -1，那么就对比 version 和 currentversion，如果相等，则进行更新操作，否则就会抛出 BadVersionException 异常中断操作。",-1),F=p("",5);function T(P,f,S,B,z,V){const o=n("Image");return l(),r("div",null,[i,a(o,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/Ciqc1F6yL9OAUUguAAAtBwGI74E989.png"}),s(),d,a(o,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/CgqCHl6yL9uAbpHYAABF_GHyGNc950.png"}),s(),_,a(o,{alt:"image (7).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/CgqCHl6yL-SAb0zaAABQBLohKvo019.png"}),s(),h,y,g,E,u,k,a(o,{alt:"image (8).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/Ciqc1F6yL-yAKn9QAABsJSpQkFI688.png"}),s(),A,a(o,{alt:"表.png",src:"https://s0.lgstatic.com/i/image/M00/03/C1/Ciqc1F6zbwWAVkt5AAC_yMQVCFo712.png"}),s(),K,a(o,{alt:"image (9).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/CgqCHl6yL_WAAnymAAB32xbrhxQ973.png"}),s(),Z,a(o,{alt:"image (10).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/CgqCHl6yL_6AOIONAAB3daUjikw147.png"}),s(),m,b,v,C,q,D,a(o,{alt:"image (11).png",src:"https://s0.lgstatic.com/i/image/M00/02/DA/CgqCHl6yMBKAZzwGAABPrrtajyI575.png"}),s(),F])}const M=t(c,[["render",T]]);export{I as __pageData,M as default};
