import{_ as o,j as e,o as t,g as c,k as l,h as a,Q as p,s}from"./chunks/framework.4e7d56ce.js";const is=JSON.parse('{"title":"第03讲：字节码层面分析cla类文件结构","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1857) 第03讲：字节码层面分析 cla 类文件结构.md","filePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1857) 第03讲：字节码层面分析 cla 类文件结构.md","lastUpdated":1696682708000}'),i={name:"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1857) 第03讲：字节码层面分析 cla 类文件结构.md"},r=p("",8),E=p("",4),_=p("",4),y=s("p",null,"当 JVM 加载某个 class 文件时，JVM 就是根据上图中的结构去解析 class 文件，加载 class 文件到内存中，并在内存中分配相应的空间。具体某一种结构需要占用大多空间，可以参考下图：",-1),d=p("",5),g=s("p",null,"上图中都是一些 16 进制数字，每两个字符代表一个字节。乍看一下各个字符之间毫无规律，但是在 JVM 的视角里这些 16 进制字符是按照严格的规律排列的。接下来就一步一步看下 JVM 是如何解析它们的。",-1),u=s("h3",{id:"魔数-magic-number",tabindex:"-1"},[a("魔数 magic number "),s("a",{class:"header-anchor",href:"#魔数-magic-number","aria-label":'Permalink to "魔数 magic number"'},"​")],-1),h=s("p",null,"如上图所示，在 class 文件开头的四个字节是 class 文件的魔数，它是一个固定的值--0XCAFEBABE。魔数是 class 文件的标志，也就是说它是判断一个文件是不是 class 格式文件的标准， 如果开头四个字节不是 0XCAFEBABE， 那么就说明它不是 class 文件， 不能被 JVM 识别或加载。",-1),A=s("h3",{id:"版本号",tabindex:"-1"},[a("版本号 "),s("a",{class:"header-anchor",href:"#版本号","aria-label":'Permalink to "版本号"'},"​")],-1),C=s("p",null,[a("紧跟在魔数后面的四个字节代表当前 class 文件的版本号。前两个字节 "),s("strong",null,"0000"),a(" 代表次版本号（minor_version），后两个字节 "),s("strong",null,"0034"),a(" 是主版本号（major_version），对应的十进制值为 52，也就是说当前 class 文件的主版本号为 52，次版本号为 0。所以综合版本号是 52.0，也就是 "),s("strong",null,"jdk1.8.0")],-1),T=s("h3",{id:"常量池-重点",tabindex:"-1"},[a("常量池（重点） "),s("a",{class:"header-anchor",href:"#常量池-重点","aria-label":'Permalink to "常量池（重点）"'},"​")],-1),m=s("p",null,"紧跟在版本号之后的是一个叫作常量池的表（cp_info）。在常量池中保存了类的各种相关信息，比如类的名称、父类的名称、类中的方法名、参数名称、参数类型等，这些信息都是以各种表的形式保存在常量池中的。",-1),b=s("p",null,[s("strong",null,"常量池中的每一项都是一个表，其项目类型共有 14 种，如下表所示：")],-1),v=p("",11),f=s("p",null,"理解了常量池内部的数据结构之后，接下来就看一下实例代码的解析过程。因为开发者平时定义的 Java 类各式各样，类中的方法与参数也不尽相同。所以常量池的元素数量也就无法固定，因此 class 文件在常量池的前面使用 2 个字节的容量计数器，用来代表当前类中常量池的大小。如下图所示：",-1),N=s("p",null,[a("红色框中的 "),s("strong",null,"001d"),a(" 转化为十进制就是 29，也就是说常量计数器的值为 29。其中下标为 0 的常量被 JVM 留作其他特殊用途，因此 Test.class 中实际的常量池大小为这个计数器的值减 1，也就是 28个。")],-1),S=s("p",null,"第一个常量，如下所示：",-1),q=p("",5),D=p("",7),F=p("",3),k=s("p",null,"仔细解析层层引用，最后我们可以看出，Test.class 文件中常量池的第 1 个常量保存的是 Object 中的默认构造器方法。",-1),x=s("h3",{id:"访问标志-access-flags",tabindex:"-1"},[a("访问标志（access_flags） "),s("a",{class:"header-anchor",href:"#访问标志-access-flags","aria-label":'Permalink to "访问标志（access_flags）"'},"​")],-1),V=s("p",null,"紧跟在常量池之后的常量是访问标志，占用两个字节，如下图所示：",-1),P=s("p",null,"访问标志代表类或者接口的访问信息，比如：该 class 文件是类还是接口，是否被定义成 public，是否是 abstract，如果是类，是否被声明成 final 等等。各种访问标志如下所示：",-1),M=p("",3),j=s("p",null,"可以看出类索引指向常量池中的第 5 个常量，父类索引指向常量池中的第 6 个常量，并且实现的接口个数为 2 个。再回顾下常量池中的数据：",-1),O=p("",6),I=p("",4),B=s("h3",{id:"字段访问标志",tabindex:"-1"},[a("字段访问标志 "),s("a",{class:"header-anchor",href:"#字段访问标志","aria-label":'Permalink to "字段访问标志"'},"​")],-1),J=s("p",null,"对于 Java 类中的变量，也可以使用 public、private、final、static 等标识符进行标识。因此解析字段时，需要先判断它的访问标志，字段的访问标志如下所示：",-1),R=s("p",null,'字段表结构图中的访问标志的值为 0002，代表它是 private 类型。变量名索引指向常量池中的第 9 个常量，变量名类型索引指向常量池中第 10 个常量。第 9 和第 10 个常量分别为"num"和"I"，如下所示：',-1),X=s("p",null,"因此可以得知类中有一个名为 num，类型为 int 类型的变量。对于第 2 个变量的解析过程也是一样，就不再过多介绍。",-1),W=s("p",null,"注意事项：",-1),w=s("ol",null,[s("li",null,[s("p",null,"字段表集合中不会列出从父类或者父接口中继承而来的字段。")]),s("li",null,[s("p",null,"内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。")])],-1),U=s("p",null,"对于以上两种情况，建议你可以自行定义一个类查看并手动分析一下。",-1),z=s("h3",{id:"方法表",tabindex:"-1"},[a("方法表 "),s("a",{class:"header-anchor",href:"#方法表","aria-label":'Permalink to "方法表"'},"​")],-1),Y=s("p",null,"字段表之后跟着的就是方法表常量。相信你应该也能猜到了，方法表常量应该也是以一个计数器开始的，因为一个类中的方法数量是不固定的，如图所示：",-1),Q=p("",4),G=s("p",null,"我们主要来看下 add 方法，具体如下：",-1),H=p("",9),K=s("p",null,[a('可以看到，在方法类型索引之后跟着的就是"add"方法的属性。'),s("strong",null,"0X0001"),a(" 是属性计数器，代表只有一个属性。"),s("strong",null,"0X000f"),a(" 是属性表类型索引，通过查看常量池可以看出它是一个 Code 属性表，如下所示：")],-1),L=s("p",null,"Code 属性表中，最主要的就是一些列的字节码。通过 javap -v Test.class 之后，可以看到方法的字节码，如下图显示的是 add 方法的字节码指令：",-1),Z=s("p",null,"JVM 执行 add 方法时，就通过这一系列指令来做相应的操作。",-1),$=s("h3",{id:"总结",tabindex:"-1"},[a("总结： "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结："'},"​")],-1),ss=s("p",null,"本课时我们主要了解了一个 class 文件内容的数据结构到底长什么样子，并通过 Test.class 来模拟演示Java虚拟机解析字节码文件的过程。其中 class 常量池部分是重点内容，它就相当于是 class 文件中的资源仓库，其他的几种结构或多或少都会最终指向到这个资源仓库中。实际上平时我们不太会直接用一个 16 进制编辑器去打开一个 .class 文件。我们可以使用 javap 等命令或者是其他工具，来帮助我们查看 class 内部的数据结构。只不过自己亲手操作一遍是很有助于理解 JVM 的解析过程，并加深对 class 文件结构的记忆。",-1);function as(ns,ls,ps,os,es,ts){const n=e("Image");return t(),c("div",null,[r,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV2AOOPvAAB-G25Eh54563.png"}),a(),E,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/BF/Cgq2xl6DCV2AZUxwAAA_iliDrpk482.png"}),a(),_,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/86/B2/Cgq2xl6Qc1OACWWHAADJjiKcHuI014.png"}),a(),y,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/BF/Cgq2xl6DCV2AehqNAAD5VToVKKE770.png"}),a(),d,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV2AUCDGAACPVltgw7U787.png"}),a(),g,u,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/BF/Cgq2xl6DCV2Afn7BAAAXOY5BQb4173.png"}),a(),h,A,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV6AYt6iAAAXNBPDSYI774.png"}),a(),C,T,m,b,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/BF/Cgq2xl6DCV6AcrLKAAIl1RRQwuM068.png"}),a(),v,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCV6AXxB3AABLqovPP_U830.png"}),a(),f,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV6AAgxqAAAXSMEd2RY264.png"}),a(),N,S,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCV6APx_SAAAbADvvw9s632.png"}),a(),q,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV6ATNz8AAAk0yVkN3w194.png"}),a(),D,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCV6AY16CAAOpMl4BX8o212.png"}),a(),F,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV-Ab50PAAFzorn_6lE082.png"}),a(),k,x,V,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCV-AAxmAAABWyueVdYk372.png"}),a(),P,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV-ANSgGAAFbz25EF8Y890.png"}),a(),M,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCV-ANNTLAAHqaoQnlE8139.png"}),a(),j,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCV-APkRPAAC9RAY2gMo106.png"}),a(),O,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCV-AWc3lAAAQCjcjhaQ999.png"}),a(),I,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCWCAb5EeAAEXyXlvezk194.png"}),a(),B,J,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCWCAe5MBAAEjBXwl4wA351.png"}),a(),R,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCWCAOTRgAAD1A786a0w663.png"}),a(),X,W,w,U,z,Y,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCWCAZxp2AAARuAI8Xbw177.png"}),a(),Q,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCWCAAdkIAAFVaPL8OfA302.png"}),a(),G,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCWCAK8l0AAAU6SkPGdo841.png"}),a(),H,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCWCAfy2rAAAXX7yc2Ik873.png"}),a(),K,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/C0/Cgq2xl6DCWGAPQD-AAE5_E_ZIRI717.png"}),a(),L,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/06/A9/Ciqah16DCWGAad0jAABXMTjeCSU916.png"}),a(),Z,$,ss])}const rs=o(i,[["render",as]]);export{is as __pageData,rs as default};
