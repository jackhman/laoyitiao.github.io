import{_ as o,j as p,o as r,g as s,k as n,h as e,s as a,Q as i}from"./chunks/framework.4e7d56ce.js";const x=JSON.parse('{"title":"第35讲：经典问题：先更新数据库，还是先更新缓存？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/分布式技术原理与实战45讲_文档/(1938) 第35讲：经典问题：先更新数据库，还是先更新缓存？.md","filePath":"posts/backEnd/分布式技术原理与实战45讲_文档/(1938) 第35讲：经典问题：先更新数据库，还是先更新缓存？.md","lastUpdated":1696417798000}'),l={name:"posts/backEnd/分布式技术原理与实战45讲_文档/(1938) 第35讲：经典问题：先更新数据库，还是先更新缓存？.md"},_=a("h1",{id:"第35讲-经典问题-先更新数据库-还是先更新缓存",tabindex:"-1"},[e("第35讲：经典问题：先更新数据库，还是先更新缓存？ "),a("a",{class:"header-anchor",href:"#第35讲-经典问题-先更新数据库-还是先更新缓存","aria-label":'Permalink to "第35讲：经典问题：先更新数据库，还是先更新缓存？"'},"​")],-1),h=a("p",null,"上一课时分享了缓存使用中的几个问题场景：缓存穿透、缓存击穿和缓存雪崩，这几个问题聚焦的是缓存本身的稳定性，包括缓存集群和缓存的数据，除了这些，缓存应用中，缓存和上下游系统的数据同步也很重要。这一课时，我们来学习缓存应用中的另一个高频问题：应用缓存以后，缓存和数据库何时同步。",-1),d=a("h3",{id:"数据不一致问题",tabindex:"-1"},[e("数据不一致问题 "),a("a",{class:"header-anchor",href:"#数据不一致问题","aria-label":'Permalink to "数据不一致问题"'},"​")],-1),c=a("p",null,"我们知道，除了少部分配置信息类缓存，比如业务中的黑白名单信息、页面展示配置等，大部分缓存应用一般是作为前端请求和持久化存储的中间层，承担前端的海量请求。",-1),u=i("",38);function m(b,q,g,f,k,A){const t=p("Image");return r(),s("div",null,[_,h,d,c,n(t,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image/M00/3D/2B/Ciqc1F8pMf6AIyYqAAAp1R6rHNs353.png"}),e(),u])}const C=o(l,[["render",m]]);export{x as __pageData,C as default};
