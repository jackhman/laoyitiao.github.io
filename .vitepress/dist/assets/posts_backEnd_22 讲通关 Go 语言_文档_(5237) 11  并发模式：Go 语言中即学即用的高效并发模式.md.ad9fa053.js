import{_ as o,j as e,o as c,g as t,k as l,h as n,Q as p,s}from"./chunks/framework.b3d8e22e.js";const q=JSON.parse('{"title":"for select 循环模式 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/22 讲通关 Go 语言_文档/(5237) 11  并发模式：Go 语言中即学即用的高效并发模式.md","filePath":"posts/backEnd/22 讲通关 Go 语言_文档/(5237) 11  并发模式：Go 语言中即学即用的高效并发模式.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/22 讲通关 Go 语言_文档/(5237) 11  并发模式：Go 语言中即学即用的高效并发模式.md"},E=p(`<p>上节课我为你讲解了如何通过 Context 更好地控制多个协程，课程最后的思考题是：如何通过 Context 实现日志跟踪？</p><p>要想跟踪一个用户的请求，必须有一个唯一的 ID 来标识这次请求调用了哪些函数、执行了哪些代码，然后通过这个唯一的 ID 把日志信息串联起来。这样就形成了一个日志轨迹，也就实现了用户的跟踪，于是思路就有了。</p><ol><li><p>在用户请求的入口点生成 TraceID。</p></li><li><p>通过 context.WithValue 保存 TraceID。</p></li><li><p>然后这个保存着 TraceID 的 Context 就可以作为参数在各个协程或者函数间传递。</p></li><li><p>在需要记录日志的地方，通过 Context 的 Value 方法获取保存的 TraceID，然后把它和其他日志信息记录下来。</p></li><li><p>这样具备同样 TraceID 的日志就可以被串联起来，达到日志跟踪的目的。</p></li></ol><p>以上思路实现的核心是 Context 的传值功能。</p><p>目前我们已熟练掌握了 goroutine、channel、sync 包的同步原语，这些都是并发编程比较基础的元素。而这节课要介绍的是如何用这些基础元素组成并发模式，帮助我们更好地编写并发程序。</p><h3 id="for-select-循环模式" tabindex="-1">for select 循环模式 <a class="header-anchor" href="#for-select-循环模式" aria-label="Permalink to &quot;for select 循环模式&quot;">​</a></h3><p>for select 循环模式非常常见，在前面的课程中也使用过，它一般和 channel 组合完成任务，代码格式如下：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">//for无限循环，或者for range循环</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//通过一个channel控制</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">//for无限循环，或者for range循环</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通过一个channel控制</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这是一种 for 循环 +select 多路复用的并发模式，哪个 case 满足就执行哪个，直到满足一定的条件退出 for 循环（比如发送退出信号）。</p><p>从具体实现上讲，for select 循环有两种模式，一种是上节课监控狗例子中的无限循环模式，只有收到终止指令才会退出，如下所示：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">done:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">//执行具体的任务</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">done:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">default</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">//执行具体的任务</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span></code></pre></div><p>这种模式会一直执行 default 语句中的任务，直到 done 这个 channel 被关闭为止。</p><p>第二种模式是 for range select 有限循环，一般用于把可以迭代的内容发送到 channel 上，如下所示：</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> _,s</span><span style="color:#F97583;">:=range</span><span style="color:#E1E4E8;"> []</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">{}{</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">done:</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> resultCh </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> s:</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> _,s</span><span style="color:#D73A49;">:=range</span><span style="color:#24292E;"> []</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">{}{</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">done:</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> resultCh </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> s:</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这种模式也会有一个 done channel，用于退出当前的 for 循环，而另外一个 resultCh channel 用于接收 for range 循环的值，这些值通过 resultCh 可以传送给其他的调用者。</p><h3 id="select-timeout-模式" tabindex="-1">select timeout 模式 <a class="header-anchor" href="#select-timeout-模式" aria-label="Permalink to &quot;select timeout 模式&quot;">​</a></h3><p>假如需要访问服务器获取数据，因为网络的不同响应时间不一样，为保证程序的质量，不可能一直等待网络返回，所以需要设置一个超时时间，这时候就可以使用 select timeout 模式，如下所示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">   result </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">//模拟网络访问</span></span>
<span class="line"><span style="color:#E1E4E8;">      time.</span><span style="color:#79B8FF;">Sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> time.Second)</span></span>
<span class="line"><span style="color:#E1E4E8;">      result </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;服务端结果&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">select</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> v </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">result:</span></span>
<span class="line"><span style="color:#E1E4E8;">      fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(v)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">time.</span><span style="color:#79B8FF;">After</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> time.Second):</span></span>
<span class="line"><span style="color:#E1E4E8;">      fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;网络访问超时了&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">   result </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">//模拟网络访问</span></span>
<span class="line"><span style="color:#24292E;">      time.</span><span style="color:#005CC5;">Sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">8</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> time.Second)</span></span>
<span class="line"><span style="color:#24292E;">      result </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;服务端结果&quot;</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">select</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> v </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">result:</span></span>
<span class="line"><span style="color:#24292E;">      fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(v)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">time.</span><span style="color:#005CC5;">After</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> time.Second):</span></span>
<span class="line"><span style="color:#24292E;">      fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;网络访问超时了&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>select timeout 模式的核心在于通过 time.After 函数设置一个超时时间，防止因为异常造成 select 语句的无限等待。</p><blockquote><p>小提示：如果可以使用 Context 的 WithTimeout 函数超时取消，要优先使用。</p></blockquote><h3 id="pipeline-模式" tabindex="-1">Pipeline 模式 <a class="header-anchor" href="#pipeline-模式" aria-label="Permalink to &quot;Pipeline 模式&quot;">​</a></h3><p>Pipeline 模式也称为流水线模式，模拟的就是现实世界中的流水线生产。以手机组装为例，整条生产流水线可能有成百上千道工序，每道工序只负责自己的事情，最终经过一道道工序组装，就完成了一部手机的生产。</p><p>从技术上看，每一道工序的输出，就是下一道工序的输入，在工序之间传递的东西就是数据，这种模式称为流水线模式，而传递的数据称为数据流。</p>`,24),y=s("p",null,"（流水线模式）",-1),i=s("p",null,"通过以上流水线模式示意图，可以看到从最开始的生产，经过工序 1、2、3、4 到最终成品，这就是一条比较形象的流水线，也就是 Pipeline。",-1),F=s("p",null,[n("现在我以组装手机为例，讲解流水线模式的使用。假设一条组装手机的流水线有 3 道工序，分别是"),s("strong",null,"配件采购"),n(" 、"),s("strong",null,"配件组装"),n(" 、"),s("strong",null,"打包成品"),n("，如图所示：")],-1),u=p(`<p>(手机组装流水线)</p><p>从以上示意图中可以看到，采购的配件通过 channel 传递给工序 2 进行组装，然后再通过 channel 传递给工序 3 打包成品。相对工序 2 来说，工序 1 是生产者，工序 3 是消费者。相对工序 1 来说，工序 2 是消费者。相对工序 3 来说，工序 2 是生产者。</p><p>我用下面的几组代码进行演示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//工序1采购</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buy</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   out </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">defer</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">close</span><span style="color:#E1E4E8;">(out)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> n; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">         out </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> fmt.</span><span style="color:#79B8FF;">Sprint</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;配件&quot;</span><span style="color:#E1E4E8;">, i)</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> out</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//工序1采购</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buy</span><span style="color:#24292E;">(n </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   out </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">defer</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">close</span><span style="color:#24292E;">(out)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> n; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">         out </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> fmt.</span><span style="color:#005CC5;">Sprint</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;配件&quot;</span><span style="color:#24292E;">, i)</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> out</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>首先我们定义一个采购函数 buy，它有一个参数 n，可以设置要采购多少套配件。采购代码的实现逻辑是通过 for 循环产生配件，然后放到 channel 类型的变量 out 里，最后返回这个 out，调用者就可以从 out 中获得配件。</p><p>有了采购好的配件，就可以开始组装了，如下面的代码所示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//工序2组装</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">(in </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   out </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">defer</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">close</span><span style="color:#E1E4E8;">(out)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">range</span><span style="color:#E1E4E8;"> in {</span></span>
<span class="line"><span style="color:#E1E4E8;">         out </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;组装(&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;)&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> out</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//工序2组装</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">(in </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   out </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">defer</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">close</span><span style="color:#24292E;">(out)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">range</span><span style="color:#24292E;"> in {</span></span>
<span class="line"><span style="color:#24292E;">         out </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;组装(&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;)&quot;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> out</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>组装函数 build 有一个 channel 类型的参数 in，用于接收配件进行组装，组装后的手机放到 channel 类型的变量 out 中返回。</p><p>有了组装好的手机，就可以放在精美的包装盒中售卖了，而包装的操作是工序 3 完成的，对应的函数是 pack，如下所示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//工序3打包</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">pack</span><span style="color:#E1E4E8;">(in </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   out </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">defer</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">close</span><span style="color:#E1E4E8;">(out)</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">range</span><span style="color:#E1E4E8;"> in {</span></span>
<span class="line"><span style="color:#E1E4E8;">         out </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;打包(&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;)&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> out</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//工序3打包</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">pack</span><span style="color:#24292E;">(in </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   out </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">defer</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">close</span><span style="color:#24292E;">(out)</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">range</span><span style="color:#24292E;"> in {</span></span>
<span class="line"><span style="color:#24292E;">         out </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;打包(&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;)&quot;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> out</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>函数 pack 的代码实现和组装函数 build 基本相同，这里不再赘述。</p><p>流水线上的三道工序都完成后，就可以通过一个组织者把三道工序组织在一起，形成一条完整的手机组装流水线，这个组织者可以是我们常用的 main 函数，如下面的代码所示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">   coms </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buy</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">)    </span><span style="color:#6A737D;">//采购10套配件</span></span>
<span class="line"><span style="color:#E1E4E8;">   phones </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">build</span><span style="color:#E1E4E8;">(coms) </span><span style="color:#6A737D;">//组装10部手机</span></span>
<span class="line"><span style="color:#E1E4E8;">   packs </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">pack</span><span style="color:#E1E4E8;">(phones) </span><span style="color:#6A737D;">//打包它们以便售卖</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//输出测试，看看效果</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">range</span><span style="color:#E1E4E8;"> packs {</span></span>
<span class="line"><span style="color:#E1E4E8;">      fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(p)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">   coms </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buy</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">)    </span><span style="color:#6A737D;">//采购10套配件</span></span>
<span class="line"><span style="color:#24292E;">   phones </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">build</span><span style="color:#24292E;">(coms) </span><span style="color:#6A737D;">//组装10部手机</span></span>
<span class="line"><span style="color:#24292E;">   packs </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">pack</span><span style="color:#24292E;">(phones) </span><span style="color:#6A737D;">//打包它们以便售卖</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//输出测试，看看效果</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">range</span><span style="color:#24292E;"> packs {</span></span>
<span class="line"><span style="color:#24292E;">      fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(p)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>按照流水线工序进行调用，最终把手机打包以便售卖，过程如下所示：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">打包(组装(配件1))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件2))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件3))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件4))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件5))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件6))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件7))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件8))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件9))</span></span>
<span class="line"><span style="color:#E1E4E8;">打包(组装(配件10))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">打包(组装(配件1))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件2))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件3))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件4))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件5))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件6))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件7))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件8))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件9))</span></span>
<span class="line"><span style="color:#24292E;">打包(组装(配件10))</span></span></code></pre></div><p>从上述例子中，我们可以总结出一个流水线模式的构成：</p><ol><li><p>流水线由一道道工序构成，每道工序通过 channel 把数据传递到下一个工序；</p></li><li><p>每道工序一般会对应一个函数，函数里有协程和 channel，协程一般用于处理数据并把它放入 channel 中，整个函数会返回这个 channel 以供下一道工序使用；</p></li><li><p>最终要有一个组织者（示例中的 main 函数）把这些工序串起来，这样就形成了一个完整的流水线，对于数据来说就是数据流。</p></li></ol><h3 id="扇出和扇入模式" tabindex="-1">扇出和扇入模式 <a class="header-anchor" href="#扇出和扇入模式" aria-label="Permalink to &quot;扇出和扇入模式&quot;">​</a></h3><p>手机流水线经过一段时间的运转，组织者发现产能提不上去，经过调研分析，发现瓶颈在工序 2 配件组装。工序 2 过慢，导致上游工序 1 配件采购速度不得不降下来，下游工序 3 没太多事情做，不得不闲下来，这就是整条流水线产能低下的原因。</p><p>为了提升手机产能，组织者决定对工序 2 增加两班人手。人手增加后，整条流水线的示意图如下所示：</p>`,24),g=p(`<p>（改进后的流水线）</p><p>从改造后的流水线示意图可以看到，工序 2 共有工序 2-1、工序 2-2、工序 2-3 三班人手，工序 1 采购的配件会被工序 2 的三班人手同时组装，这三班人手组装好的手机会同时传给<strong>merge 组件</strong> 汇聚，然后再传给工序 3 打包成品。在这个流程中，会产生两种模式：<strong>扇出和扇入</strong>。</p><ul><li><p>示意图中红色的部分是<strong>扇出</strong>，对于工序 1 来说，它同时为工序 2 的三班人手传递数据（采购配件）。以工序 1 为中点，三条传递数据的线发散出去，就像一把打开的扇子一样，所以叫扇出。</p></li><li><p>示意图中蓝色的部分是<strong>扇入</strong>，对于 merge 组件来说，它同时接收工序 2 三班人手传递的数据（组装的手机）进行汇聚，然后传给工序 3。以 merge 组件为中点，三条传递数据的线汇聚到 merge 组件，也像一把打开的扇子一样，所以叫扇入。</p></li></ul><blockquote><p>小提示：扇出和扇入都像一把打开的扇子，因为数据传递的方向不同，所以叫法也不一样，扇出的数据流向是发散传递出去，是输出流；扇入的数据流向是汇聚进来，是输入流。</p></blockquote><p>已经理解了扇出扇入的原理，就可以开始改造流水线了。这次改造中，三道工序的实现函数 buy、build、pack 都保持不变，只需要增加一个 merge 函数即可，如下面的代码所示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//扇入函数（组件），把多个chanel中的数据发送到一个channel中</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">merge</span><span style="color:#E1E4E8;">(ins </span><span style="color:#F97583;">...&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> wg sync.WaitGroup</span></span>
<span class="line"><span style="color:#E1E4E8;">   out </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//把一个channel中的数据发送到out中</span></span>
<span class="line"><span style="color:#E1E4E8;">   p</span><span style="color:#F97583;">:=func</span><span style="color:#E1E4E8;">(in </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">defer</span><span style="color:#E1E4E8;"> wg.</span><span style="color:#79B8FF;">Done</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">range</span><span style="color:#E1E4E8;"> in {</span></span>
<span class="line"><span style="color:#E1E4E8;">         out </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> c</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">   wg.</span><span style="color:#79B8FF;">Add</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">len</span><span style="color:#E1E4E8;">(ins))</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//扇入，需要启动多个goroutine用于处于多个channel中的数据</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> _,cs</span><span style="color:#F97583;">:=range</span><span style="color:#E1E4E8;"> ins{</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">p</span><span style="color:#E1E4E8;">(cs)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//等待所有输入的数据ins处理完，再关闭输出out</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      wg.</span><span style="color:#79B8FF;">Wait</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#79B8FF;">close</span><span style="color:#E1E4E8;">(out)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> out</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//扇入函数（组件），把多个chanel中的数据发送到一个channel中</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">merge</span><span style="color:#24292E;">(ins </span><span style="color:#D73A49;">...&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> wg sync.WaitGroup</span></span>
<span class="line"><span style="color:#24292E;">   out </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//把一个channel中的数据发送到out中</span></span>
<span class="line"><span style="color:#24292E;">   p</span><span style="color:#D73A49;">:=func</span><span style="color:#24292E;">(in </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">defer</span><span style="color:#24292E;"> wg.</span><span style="color:#005CC5;">Done</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">range</span><span style="color:#24292E;"> in {</span></span>
<span class="line"><span style="color:#24292E;">         out </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> c</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">   wg.</span><span style="color:#005CC5;">Add</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">len</span><span style="color:#24292E;">(ins))</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//扇入，需要启动多个goroutine用于处于多个channel中的数据</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> _,cs</span><span style="color:#D73A49;">:=range</span><span style="color:#24292E;"> ins{</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">p</span><span style="color:#24292E;">(cs)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//等待所有输入的数据ins处理完，再关闭输出out</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      wg.</span><span style="color:#005CC5;">Wait</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">close</span><span style="color:#24292E;">(out)</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> out</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>新增的 merge 函数的核心逻辑就是对输入的每个 channel 使用单独的协程处理，并将每个协程处理的结果都发送到变量 out 中，达到扇入的目的。总结起来就是通过多个协程并发，把多个 channel 合成一个。</p><p>在整条手机组装流水线中，merge 函数非常小，而且和业务无关，不能当作一道工序，所以我把它叫作<strong>组件</strong>。该 merge 组件是可以复用的，流水线中的任何工序需要扇入的时候，都可以使用 merge 组件。</p><blockquote><p>小提示：这次的改造新增了 merge 函数，其他函数保持不变，符合开闭原则。开闭原则规定&quot;软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的&quot;。</p></blockquote><p>有了可以复用的 merge 组件，现在来看流水线的组织者 main 函数是如何使用扇出和扇入并发模式的，如下所示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">   coms </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">buy</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">)    </span><span style="color:#6A737D;">//采购100套配件</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//三班人同时组装100部手机</span></span>
<span class="line"><span style="color:#E1E4E8;">   phones1 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">build</span><span style="color:#E1E4E8;">(coms)</span></span>
<span class="line"><span style="color:#E1E4E8;">   phones2 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">build</span><span style="color:#E1E4E8;">(coms)</span></span>
<span class="line"><span style="color:#E1E4E8;">   phones3 </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">build</span><span style="color:#E1E4E8;">(coms)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//汇聚三个channel成一个</span></span>
<span class="line"><span style="color:#E1E4E8;">   phones </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">merge</span><span style="color:#E1E4E8;">(phones1,phones2,phones3)</span></span>
<span class="line"><span style="color:#E1E4E8;">   packs </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">pack</span><span style="color:#E1E4E8;">(phones) </span><span style="color:#6A737D;">//打包它们以便售卖</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//输出测试，看看效果</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">range</span><span style="color:#E1E4E8;"> packs {</span></span>
<span class="line"><span style="color:#E1E4E8;">      fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(p)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">   coms </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">buy</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">100</span><span style="color:#24292E;">)    </span><span style="color:#6A737D;">//采购100套配件</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//三班人同时组装100部手机</span></span>
<span class="line"><span style="color:#24292E;">   phones1 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">build</span><span style="color:#24292E;">(coms)</span></span>
<span class="line"><span style="color:#24292E;">   phones2 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">build</span><span style="color:#24292E;">(coms)</span></span>
<span class="line"><span style="color:#24292E;">   phones3 </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">build</span><span style="color:#24292E;">(coms)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//汇聚三个channel成一个</span></span>
<span class="line"><span style="color:#24292E;">   phones </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">merge</span><span style="color:#24292E;">(phones1,phones2,phones3)</span></span>
<span class="line"><span style="color:#24292E;">   packs </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">pack</span><span style="color:#24292E;">(phones) </span><span style="color:#6A737D;">//打包它们以便售卖</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//输出测试，看看效果</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">range</span><span style="color:#24292E;"> packs {</span></span>
<span class="line"><span style="color:#24292E;">      fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(p)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这个示例采购了 100 套配件，也就是开始增加产能了。于是同时调用三次 build 函数，也就是为工序 2 增加人手，这里是三班人手同时组装配件，然后通过 merge 函数这个可复用的组件将三个 channel 汇聚为一个，然后传给 pack 函数打包。</p><p>这样通过扇出和扇入模式，整条流水线就被扩充好了，大大提升了生产效率。因为已经有了通用的扇入组件 merge，所以整条流水中任何需要扇出、扇入提高性能的工序，都可以复用 merge 组件做扇入，并且不用做任何修改。</p><h3 id="futures-模式" tabindex="-1">Futures 模式 <a class="header-anchor" href="#futures-模式" aria-label="Permalink to &quot;Futures 模式&quot;">​</a></h3><p>Pipeline 流水线模式中的工序是相互依赖的，上一道工序做完，下一道工序才能开始。但是在我们的实际需求中，也有大量的任务之间相互独立、没有依赖，所以为了提高性能，这些独立的任务就可以并发执行。</p><p>举个例子，比如我打算自己做顿火锅吃，那么就需要洗菜、烧水。洗菜、烧水这两个步骤相互之间没有依赖关系，是独立的，那么就可以同时做，但是最后做火锅这个步骤就需要洗好菜、烧好水之后才能进行。这个做火锅的场景就适用 Futures 模式。</p><p>Futures 模式可以理解为未来模式，主协程不用等待子协程返回的结果，可以先去做其他事情，等未来需要子协程结果的时候再来取，如果子协程还没有返回结果，就一直等待。我用下面的代码进行演示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//洗菜</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">washVegetables</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   vegetables </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      time.</span><span style="color:#79B8FF;">Sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> time.Second)</span></span>
<span class="line"><span style="color:#E1E4E8;">      vegetables </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;洗好的菜&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> vegetables</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">//烧水</span></span>
<span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">boilWater</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;-chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   water </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">make</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">chan</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">string</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">go</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">func</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      time.</span><span style="color:#79B8FF;">Sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> time.Second)</span></span>
<span class="line"><span style="color:#E1E4E8;">      water </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;烧开的水&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">   }()</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> water</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//洗菜</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">washVegetables</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   vegetables </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      time.</span><span style="color:#005CC5;">Sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> time.Second)</span></span>
<span class="line"><span style="color:#24292E;">      vegetables </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;洗好的菜&quot;</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> vegetables</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">//烧水</span></span>
<span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">boilWater</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;-chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   water </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">make</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">chan</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">string</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">go</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">func</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      time.</span><span style="color:#005CC5;">Sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> time.Second)</span></span>
<span class="line"><span style="color:#24292E;">      water </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;烧开的水&quot;</span></span>
<span class="line"><span style="color:#24292E;">   }()</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> water</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>洗菜和烧水这两个相互独立的任务可以一起做，所以示例中通过开启协程的方式，实现同时做的功能。当任务完成后，结果会通过 channel 返回。</p><blockquote><p>小提示：示例中的等待 5 秒用来描述洗菜和烧火的耗时。</p></blockquote><p>在启动两个子协程同时去洗菜和烧水的时候，主协程就可以去干点其他事情（示例中是眯一会），等睡醒了，要做火锅的时候，就需要洗好的菜和烧好的水这两个结果了。我用下面的代码进行演示：</p><p><em><strong>ch11/main.go</strong></em></p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">   vegetablesCh </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">washVegetables</span><span style="color:#E1E4E8;">() </span><span style="color:#6A737D;">//洗菜</span></span>
<span class="line"><span style="color:#E1E4E8;">   waterCh </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">boilWater</span><span style="color:#E1E4E8;">()           </span><span style="color:#6A737D;">//烧水</span></span>
<span class="line"><span style="color:#E1E4E8;">   fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;已经安排洗菜和烧水了，我先眯一会&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   time.</span><span style="color:#79B8FF;">Sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> time.Second)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">   fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;要做火锅了，看看菜和水好了吗&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">   vegetables </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">vegetablesCh</span></span>
<span class="line"><span style="color:#E1E4E8;">   water </span><span style="color:#F97583;">:=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;-</span><span style="color:#E1E4E8;">waterCh</span></span>
<span class="line"><span style="color:#E1E4E8;">   fmt.</span><span style="color:#79B8FF;">Println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;准备好了，可以做火锅了:&quot;</span><span style="color:#E1E4E8;">,vegetables,water)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">func</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">   vegetablesCh </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">washVegetables</span><span style="color:#24292E;">() </span><span style="color:#6A737D;">//洗菜</span></span>
<span class="line"><span style="color:#24292E;">   waterCh </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">boilWater</span><span style="color:#24292E;">()           </span><span style="color:#6A737D;">//烧水</span></span>
<span class="line"><span style="color:#24292E;">   fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;已经安排洗菜和烧水了，我先眯一会&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   time.</span><span style="color:#005CC5;">Sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> time.Second)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">   fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;要做火锅了，看看菜和水好了吗&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">   vegetables </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">vegetablesCh</span></span>
<span class="line"><span style="color:#24292E;">   water </span><span style="color:#D73A49;">:=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;-</span><span style="color:#24292E;">waterCh</span></span>
<span class="line"><span style="color:#24292E;">   fmt.</span><span style="color:#005CC5;">Println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;准备好了，可以做火锅了:&quot;</span><span style="color:#24292E;">,vegetables,water)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Futures 模式下的协程和普通协程最大的区别是可以返回结果，而这个结果会在未来的某个时间点使用。所以在未来获取这个结果的操作必须是一个阻塞的操作，要一直等到获取结果为止。</p><p>如果你的大任务可以拆解为一个个独立并发执行的小任务，并且可以通过这些小任务的结果得出最终大任务的结果，就可以使用 Futures 模式。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>并发模式和设计模式很相似，都是对现实场景的抽象封装，以便提供一个统一的解决方案。但和设计模式不同的是，并发模式更专注于异步和并发。</p>`,30),h=s("p",null,"你会在很多项目的源代码中一遍遍地看到本节课提到的并发模式，虽然解决的问题不一样，但它们的思路是相似的，所以你也可以把它们进一步抽象，这样在项目开发中就可以直接复用。",-1),d=s("p",null,"并发模式不限于这节课讲的这些，在项目中和并发、异步有关并且可以被抽象复用的解决方案都可以总结为并发模式。所以发挥自己的想象吧，这节课的思考题就是：你还能总结出哪些并发模式呢？",-1),A=s("p",null,'下节课开始，我们将进入本专栏的第三个模块"Go 语言深入理解"，所以一定要好好复习前面的课程，下节课开始就会比较深入了。',-1);function D(C,m,f,b,k,_){const a=e("Image");return c(),t("div",null,[E,l(a,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image/M00/75/53/CgqCHl_HcfiAH8GxAAEpQcyhlLg927.png"}),n(),y,i,F,l(a,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image/M00/75/48/Ciqc1F_HcfGAWb6pAABvGsG8s_o830.png"}),n(),u,l(a,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image/M00/75/53/CgqCHl_HcgOAJjFKAAFXf-gaoW4824.png"}),n(),g,l(a,{alt:"11金句.png",src:"https://s0.lgstatic.com/i/image/M00/75/48/Ciqc1F_Hcg-AXnkiAAVaWJnRE0s191.png"}),h,d,A])}const B=o(r,[["render",D]]);export{q as __pageData,B as default};
