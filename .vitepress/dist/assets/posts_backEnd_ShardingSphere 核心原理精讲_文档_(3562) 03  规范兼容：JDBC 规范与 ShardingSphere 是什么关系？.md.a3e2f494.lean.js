import{_ as l,j as e,o as t,g as c,k as a,h as o,Q as p,s}from"./chunks/framework.e0c66c3f.js";const P=JSON.parse('{"title":"JDBC 规范简介 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3562) 03  规范兼容：JDBC 规范与 ShardingSphere 是什么关系？.md","filePath":"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3562) 03  规范兼容：JDBC 规范与 ShardingSphere 是什么关系？.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/ShardingSphere 核心原理精讲_文档/(3562) 03  规范兼容：JDBC 规范与 ShardingSphere 是什么关系？.md"},E=p("",5),y=p("",8),i=s("p",null,"其中，DataSource 是官方定义的获取 Connection 的基础接口，ConnectionPoolDataSource 是从连接池 ConnectionPool 中获取的 Connection 接口。而 XADataSource 则用来实现在分布式事务环境下获取 Connection，我们在讨论 ShardingSphere 的分布式事务时会接触到这个接口。",-1),d=s("p",null,[s("strong",null,"请注意，DataSource 接口同时还继承了一个 Wrapper 接口"),o("。从接口的命名上看，可以判断该接口应该起到一种包装器的作用，事实上，由于很多数据库供应商提供了超越标准 JDBC API 的扩展功能，所以，Wrapper 接口可以把一个由第三方供应商提供的、非 JDBC 标准的接口包装成标准接口。以 DataSource 接口为例，如果我们想要实现自己的数据源 MyDataSource，就可以提供一个实现了 Wrapper 接口的 MyDataSourceWrapper 类来完成包装和适配：")],-1),h=p("",9),u=s("p",null,"ShardingSphere 提供了与 JDBC 规范完全兼容的 API。也就是说，开发人员可以基于这个开发流程和 JDBC 中的核心接口完成分片引擎、数据脱敏等操作，我们来看一下。",-1),C=s("h3",{id:"基于适配器模式的-jdbc-重写实现方案",tabindex:"-1"},[o("基于适配器模式的 JDBC 重写实现方案 "),s("a",{class:"header-anchor",href:"#基于适配器模式的-jdbc-重写实现方案","aria-label":'Permalink to "基于适配器模式的 JDBC 重写实现方案"'},"​")],-1),S=s("p",null,[o("在 ShardingSphere 中，实现与 JDBC 规范兼容性的基本策略就是采用了设计模式中的适配器模式（Adapter Pattern）。"),s("strong",null,"适配器模式通常被用作连接两个不兼容接口之间的桥梁，涉及为某一个接口加入独立的或不兼容的功能。")],-1),F=s("p",null,"作为一套适配 JDBC 规范的实现方案，ShardingSphere 需要对上面介绍的 JDBC API 中的 DataSource、Connection、Statement 及 ResultSet 等核心对象都完成重写。虽然这些对象承载着不同功能，但重写机制应该是共通的，否则就需要对不同对象都实现定制化开发，显然，这不符合我们的设计原则。为此，ShardingSphere 抽象并开发了一套基于适配器模式的实现方案，整体结构是这样的，如下图所示：",-1),g=s("p",null,"首先，我们看到这里有一个 JdbcObject 接口，这个接口泛指 JDBC API 中的 DataSource、Connection、Statement 等核心接口。前面提到，这些接口都继承自包装器 Wrapper 接口。ShardingSphere 为这个 Wrapper 接口提供了一个实现类 WrapperAdapter，这点在图中得到了展示。在 ShardingSphere 代码工程 sharding-jdbc-core 的 org.apache.shardingsphere.shardingjdbc.jdbc.adapter 包中包含了所有与 Adapter 相关的实现类：",-1),D=s("p",null,"在 ShardingSphere 基于适配器模式的实现方案图的底部，有一个 ShardingJdbcObject 类的定义。这个类也是一种泛指，代表 ShardingSphere 中用于分片的 ShardingDataSource、ShardingConnection、ShardingStatement 等对象。",-1),A=s("p",null,"最后发现 ShardingJdbcObject 继承自一个 AbstractJdbcObjectAdapter，而 AbstractJdbcObjectAdapter 又继承自 AbstractUnsupportedOperationJdbcObject，这两个类都是抽象类，而且也都泛指一组类。两者的区别在于，AbstractJdbcObjectAdapter 只提供了针对 JdbcObject 接口的一部分实现方法，这些方法是我们完成分片操作所需要的。而对于那些我们不需要的方法实现，则全部交由 AbstractUnsupportedOperationJdbcObject 进行实现，这两个类的所有方法的合集，就是原有 JdbcObject 接口的所有方法定义。",-1),b=s("p",null,"这样，我们大致了解了 ShardingSphere 对 JDBC 规范中核心接口的重写机制。这个重写机制非常重要，在 ShardingSphere 中应用也很广泛，我们可以通过示例对这一机制做进一步理解。",-1),m=s("h3",{id:"shardingsphere-重写-jdbc-规范示例-shardingconnection",tabindex:"-1"},[o("ShardingSphere 重写 JDBC 规范示例：ShardingConnection "),s("a",{class:"header-anchor",href:"#shardingsphere-重写-jdbc-规范示例-shardingconnection","aria-label":'Permalink to "ShardingSphere 重写 JDBC 规范示例：ShardingConnection"'},"​")],-1),v=s("p",null,"通过前面的介绍，我们知道 ShardingSphere 的分片引擎中提供了一系列 ShardingJdbcObject 来支持分片操作，包括 ShardingDataSource、ShardingConnection、ShardingStatement、ShardingPreparedStament 等。这里以最具代表性的 ShardingConnection 为例，来讲解它的实现过程。请注意，今天我们关注的还是重写机制，不会对 ShardingConnection 中的具体功能以及与其他类之间的交互过程做过多展开讲解。",-1),B=s("h4",{id:"shardingconnection-类层结构",tabindex:"-1"},[o("ShardingConnection 类层结构 "),s("a",{class:"header-anchor",href:"#shardingconnection-类层结构","aria-label":'Permalink to "ShardingConnection 类层结构"'},"​")],-1),_=s("p",null,"ShardingConnection 是对 JDBC 中 Connection 的适配和包装，所以它需要提供 Connection 接口中定义的方法，包括 createConnection、getMetaData、各种重载的 prepareStatement 和 createStatement 以及针对事务的 setAutoCommit、commit 和 rollback 方法等。ShardingConnection 对这些方法都进行了重写，如下图所示：",-1),f=s("p",null,"ShardingConnection 中的方法列表图",-1),J=s("p",null,"ShardingConnection 类的一条类层结构支线就是适配器模式的具体应用，这部分内容的类层结构与前面介绍的重写机制的类层结构是完全一致的，如下图所示：",-1),q=p("",27);function M(k,w,j,x,O,I){const n=e("Image");return t(),c("div",null,[E,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/26/42/CgqCHl7xtaiASay6AAB0vuO1kAA457.png"}),y,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/26/42/CgqCHl7xtbuALDZqAABj4c2IofU664.png"}),i,d,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/26/42/CgqCHl7xtdOAZEGNAABnV-ZtNrk288.png"}),h,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/26/36/Ciqc1F7xteqAQsj5AAB1bj_eu10085.png"}),u,C,S,F,a(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/26/36/Ciqc1F7xtfeAIlV7AABhpWkSy7c199.png"}),g,a(n,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/26/36/Ciqc1F7xtgWAb3PaAAAW8D9SY1w475.png"}),D,A,b,m,v,B,_,a(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/26/42/CgqCHl7xthSAHp4DAACJDJsvmyk879.png"}),o(),f,J,a(n,{alt:"111.jpeg",src:"https://s0.lgstatic.com/i/image/M00/48/93/CgqCHl9MudqAOb9wAAEeGv0YTn807.jpeg"}),q])}const N=l(r,[["render",M]]);export{P as __pageData,N as default};
