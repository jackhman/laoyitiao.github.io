import{_ as a,j as p,o as l,h as o,k as e,f as t,Q as s}from"./chunks/framework.d3daa342.js";const A=JSON.parse('{"title":"07计算属性：计算属性比普通函数好在哪里？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Vue.js 3.0 核心源码内参_文档/(7632) 07  计算属性：计算属性比普通函数好在哪里？.md","filePath":"posts/frontEnd/Vue.js 3.0 核心源码内参_文档/(7632) 07  计算属性：计算属性比普通函数好在哪里？.md","lastUpdated":1696682708000}'),c={name:"posts/frontEnd/Vue.js 3.0 核心源码内参_文档/(7632) 07  计算属性：计算属性比普通函数好在哪里？.md"},r=s(`<h1 id="_07计算属性-计算属性比普通函数好在哪里" tabindex="-1">07计算属性：计算属性比普通函数好在哪里？ <a class="header-anchor" href="#_07计算属性-计算属性比普通函数好在哪里" aria-label="Permalink to &quot;07计算属性：计算属性比普通函数好在哪里？&quot;">​</a></h1><p>上一节课，我们学习了响应式的实现原理，这节课我们将学习一个非常常用的响应式 API------<strong>计算属性</strong>。</p><p>计算属性是 Vue.js 开发中一个非常实用的 API ，它允许用户定义一个计算方法，然后根据一些依赖的响应式数据计算出新值并返回。当依赖发生变化时，计算属性可以自动重新计算获取新值，所以使用起来非常方便。</p><p>在 Vue.js 2.x 中，相信你对计算属性的应用已经如数家珍了，我们可以在组件对象中定义 computed 属性。到了 Vue.js 3.0 ，虽然也可以在组件中沿用 Vue.js 2.x 的使用方式，但是我们也可以单独使用计算属性 API。</p><p>计算属性本质上还是对依赖的计算，那么为什么我们不直接用函数呢？在 Vue.js 3.0 中计算属性的 API 又是如何实现呢？接下来，就请你带着这些疑问，随我一起深入其实现原理的学习吧。</p><h3 id="计算属性-api-computed" tabindex="-1">计算属性 API： computed <a class="header-anchor" href="#计算属性-api-computed" aria-label="Permalink to &quot;计算属性 API： computed&quot;">​</a></h3><p>Vue.js 3.0 提供了一个 computed 函数作为计算属性 API，我们先来看看它是如何使用的。</p><p>我们举个简单的例子：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> plusOne </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(plusOne.value) </span><span style="color:#6A737D;">// 2 </span></span>
<span class="line"><span style="color:#E1E4E8;">plusOne.value</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// error </span></span>
<span class="line"><span style="color:#E1E4E8;">count.value</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(plusOne.value) </span><span style="color:#6A737D;">// 3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> plusOne </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> count.value </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(plusOne.value) </span><span style="color:#6A737D;">// 2 </span></span>
<span class="line"><span style="color:#24292E;">plusOne.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// error </span></span>
<span class="line"><span style="color:#24292E;">count.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(plusOne.value) </span><span style="color:#6A737D;">// 3</span></span></code></pre></div><p>从代码中可以看到，我们先使用 ref API 创建了一个响应式对象 count，然后使用 computed API 创建了另一个响应式对象 plusOne，它的值是 count.value + 1，当我们修改 count.value 的时候， plusOne.value 就会自动发生变化。</p><p>注意，这里我们直接修改 plusOne.value 会报一个错误，这是因为如果我们传递给 computed 的是一个函数，那么这就是一个 getter 函数，我们只能获取它的值，而不能直接修改它。</p><p>在 getter 函数中，我们会根据响应式对象重新计算出新的值，这也就是它被叫做计算属性的原因，而这个响应式对象，就是计算属性的依赖。</p><p>当然，有时候我们也希望能够直接修改 computed 的返回值，那么我们可以给 computed 传入一个对象：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> plusOne </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">({ </span></span>
<span class="line"><span style="color:#E1E4E8;">  get</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">  set</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> val </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    count.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">}) </span></span>
<span class="line"><span style="color:#E1E4E8;">plusOne.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(count.value) </span><span style="color:#6A737D;">// 0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> plusOne </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">({ </span></span>
<span class="line"><span style="color:#24292E;">  get</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> count.value </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">  set</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> val </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    count.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> val </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">}) </span></span>
<span class="line"><span style="color:#24292E;">plusOne.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(count.value) </span><span style="color:#6A737D;">// 0</span></span></code></pre></div><p>在这个例子中，结合上述代码可以看到，我们给 computed 函数传入了一个拥有 getter 函数和 setter 函数的对象，getter 函数和之前一样，还是返回 count.value + 1；而 setter 函数，请注意，这里我们修改 plusOne.value 的值就会触发 setter 函数，其实 setter 函数内部实际上会根据传入的参数修改计算属性的依赖值 count.value，因为一旦依赖的值被修改了，我们再去获取计算属性就会重新执行一遍 getter，所以这样获取的值也就发生了变化。</p><p>好了，我们现在已经知道了 computed API 的两种使用方式了，接下来就看看它是怎样实现的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">(getterOrOptions) { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// getter 函数 </span></span>
<span class="line"><span style="color:#E1E4E8;">  let getter </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// setter 函数 </span></span>
<span class="line"><span style="color:#E1E4E8;">  let setter </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 标准化参数 </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isFunction</span><span style="color:#E1E4E8;">(getterOrOptions)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 表面传入的是 getter 函数，不能修改计算属性的值 </span></span>
<span class="line"><span style="color:#E1E4E8;">    getter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> getterOrOptions </span></span>
<span class="line"><span style="color:#E1E4E8;">    setter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (p<wbr>rocess.env.NODE_ENV </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;production&#39;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">warn</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Write operation failed: computed value is readonly&#39;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> NOOP </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    getter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> getterOrOptions.get </span></span>
<span class="line"><span style="color:#E1E4E8;">    setter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> getterOrOptions.set </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 数据是否脏的 </span></span>
<span class="line"><span style="color:#E1E4E8;">  let dirty </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 计算结果 </span></span>
<span class="line"><span style="color:#E1E4E8;">  let value </span></span>
<span class="line"><span style="color:#E1E4E8;">  let computed </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 创建副作用函数 </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> runner </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">effect</span><span style="color:#E1E4E8;">(getter, { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 延时执行 </span></span>
<span class="line"><span style="color:#E1E4E8;">    lazy</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 </span></span>
<span class="line"><span style="color:#E1E4E8;">    computed</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调度执行的实现 </span></span>
<span class="line"><span style="color:#E1E4E8;">    scheduler</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">dirty) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        dirty </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">trigger</span><span style="color:#E1E4E8;">(computed, </span><span style="color:#9ECBFF;">&quot;set&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">/* SET */</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;value&#39;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">  }) </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 创建 computed 对象 </span></span>
<span class="line"><span style="color:#E1E4E8;">  computed </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    __v_isRef</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 暴露 effect 对象以便计算属性可以停止计算 </span></span>
<span class="line"><span style="color:#E1E4E8;">    effect</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> runner, </span></span>
<span class="line"><span style="color:#E1E4E8;">    get </span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">() { </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 计算属性的 getter </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (dirty) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 只有数据为脏的时候才会重新计算 </span></span>
<span class="line"><span style="color:#E1E4E8;">        value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runner</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">        dirty </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">track</span><span style="color:#E1E4E8;">(computed, </span><span style="color:#9ECBFF;">&quot;get&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">/* GET */</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;value&#39;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> value </span></span>
<span class="line"><span style="color:#E1E4E8;">    }, </span></span>
<span class="line"><span style="color:#E1E4E8;">    set </span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">(newValue) { </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 计算属性的 setter </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">setter</span><span style="color:#E1E4E8;">(newValue) </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> computed </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">(getterOrOptions) { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// getter 函数 </span></span>
<span class="line"><span style="color:#24292E;">  let getter </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// setter 函数 </span></span>
<span class="line"><span style="color:#24292E;">  let setter </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 标准化参数 </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isFunction</span><span style="color:#24292E;">(getterOrOptions)) { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 表面传入的是 getter 函数，不能修改计算属性的值 </span></span>
<span class="line"><span style="color:#24292E;">    getter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> getterOrOptions </span></span>
<span class="line"><span style="color:#24292E;">    setter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (p<wbr>rocess.env.NODE_ENV </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;production&#39;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">        console.</span><span style="color:#6F42C1;">warn</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;Write operation failed: computed value is readonly&#39;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> NOOP </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    getter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> getterOrOptions.get </span></span>
<span class="line"><span style="color:#24292E;">    setter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> getterOrOptions.set </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 数据是否脏的 </span></span>
<span class="line"><span style="color:#24292E;">  let dirty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 计算结果 </span></span>
<span class="line"><span style="color:#24292E;">  let value </span></span>
<span class="line"><span style="color:#24292E;">  let computed </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 创建副作用函数 </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> runner </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">effect</span><span style="color:#24292E;">(getter, { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 延时执行 </span></span>
<span class="line"><span style="color:#24292E;">    lazy</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 标记这是一个 computed effect 用于在 trigger 阶段的优先级排序 </span></span>
<span class="line"><span style="color:#24292E;">    computed</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调度执行的实现 </span></span>
<span class="line"><span style="color:#24292E;">    scheduler</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">dirty) { </span></span>
<span class="line"><span style="color:#24292E;">        dirty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">trigger</span><span style="color:#24292E;">(computed, </span><span style="color:#032F62;">&quot;set&quot;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">/* SET */</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;value&#39;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">  }) </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 创建 computed 对象 </span></span>
<span class="line"><span style="color:#24292E;">  computed </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    __v_isRef</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 暴露 effect 对象以便计算属性可以停止计算 </span></span>
<span class="line"><span style="color:#24292E;">    effect</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> runner, </span></span>
<span class="line"><span style="color:#24292E;">    get </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">() { </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 计算属性的 getter </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (dirty) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 只有数据为脏的时候才会重新计算 </span></span>
<span class="line"><span style="color:#24292E;">        value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runner</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">        dirty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">track</span><span style="color:#24292E;">(computed, </span><span style="color:#032F62;">&quot;get&quot;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">/* GET */</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;value&#39;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> value </span></span>
<span class="line"><span style="color:#24292E;">    }, </span></span>
<span class="line"><span style="color:#24292E;">    set </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">(newValue) { </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 计算属性的 setter </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">setter</span><span style="color:#24292E;">(newValue) </span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> computed </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>从代码中可以看到，computed 函数的流程主要做了三件事情：标准化参数，创建副作用函数和创建 computed 对象。我们来详细分析一下这几个步骤。</p><p>首先是<strong>标准化参数</strong>。computed 函数接受两种类型的参数，一个是 getter 函数，一个是拥有 getter 和 setter 函数的对象，通过判断参数的类型，我们初始化了函数内部定义的 getter 和 setter 函数。</p><p>接着是<strong>创建副作用函数 runner</strong>。computed 内部通过 effect 创建了一个副作用函数，它是对 getter 函数做的一层封装，另外我们这里要注意第二个参数，也就是 effect 函数的配置对象。其中 lazy 为 true 表示 effect 函数返回的 runner 并不会立即执行；computed 为 true 用于表示这是一个 computed effect，用于 trigger 阶段的优先级排序，我们稍后会分析；scheduler 表示它的调度运行的方式，我们也稍后分析。</p><p>最后是<strong>创建 computed 对象并返回</strong>，这个对象也拥有 getter 和 setter 函数。当 computed 对象被访问的时候会触发 getter，然后会判断是否 dirty，如果是就执行 runner，然后做依赖收集；当我们直接设置 computed 对象时会触发 setter，即执行 computed 函数内部定义的 setter 函数。</p><h4 id="计算属性的运行机制" tabindex="-1">计算属性的运行机制 <a class="header-anchor" href="#计算属性的运行机制" aria-label="Permalink to &quot;计算属性的运行机制&quot;">​</a></h4><p>computed 函数的逻辑会有一点绕，不过不要紧，我们可以结合一个应用 computed 计算属性的例子，来理解整个计算属性的运行机制。分析之前我们需要记住 computed 内部两个重要的变量，第一个 dirty 表示一个计算属性的值是否是&quot;脏的&quot;，用来判断需不需要重新计算，第二个 value 表示计算属性每次计算后的结果。</p><p>现在，我们来看这个示例：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">    { { plusOne }} </span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> </span><span style="color:#FDAEB7;font-style:italic;">@click=&quot;plus&quot;&gt;plus&lt;/button&gt;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">&lt;/template&gt;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">&lt;script&gt;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">import</span><span style="color:#E1E4E8;"> { ref, computed } </span><span style="color:#B392F0;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;vue&#39;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">default</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setup</span><span style="color:#E1E4E8;">() { </span></span>
<span class="line"><span style="color:#E1E4E8;">      const count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">      const plusOne </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">      }) </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">      function </span><span style="color:#B392F0;">plus</span><span style="color:#E1E4E8;">() { </span></span>
<span class="line"><span style="color:#E1E4E8;">        count.value</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">      return { </span></span>
<span class="line"><span style="color:#E1E4E8;">        plusOne, </span></span>
<span class="line"><span style="color:#E1E4E8;">        plus </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">&lt;/script&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">    { { plusOne }} </span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> </span><span style="color:#B31D28;font-style:italic;">@click=&quot;plus&quot;&gt;plus&lt;/button&gt;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">&lt;/template&gt;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">&lt;script&gt;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">import</span><span style="color:#24292E;"> { ref, computed } </span><span style="color:#6F42C1;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;vue&#39;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">export</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">default</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setup</span><span style="color:#24292E;">() { </span></span>
<span class="line"><span style="color:#24292E;">      const count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">      const plusOne </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> count.value </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">      }) </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">      function </span><span style="color:#6F42C1;">plus</span><span style="color:#24292E;">() { </span></span>
<span class="line"><span style="color:#24292E;">        count.value</span><span style="color:#D73A49;">++</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">      return { </span></span>
<span class="line"><span style="color:#24292E;">        plusOne, </span></span>
<span class="line"><span style="color:#24292E;">        plus </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">&lt;/script&gt;</span></span></code></pre></div><p>可以看到，在这个例子中我们利用 computed API 创建了计算属性对象 plusOne，它传入的是一个 getter 函数，为了和后面计算属性对象的 getter 函数区分，我们把它称作 computed getter。另外，组件模板中引用了 plusOne 变量和 plus 函数。</p><p>组件渲染阶段会访问 plusOne，也就触发了 plusOne 对象的 getter 函数：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">get </span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">() { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 计算属性的 getter </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (dirty) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 只有数据为脏的时候才会重新计算 </span></span>
<span class="line"><span style="color:#E1E4E8;">    value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">runner</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">    dirty </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">track</span><span style="color:#E1E4E8;">(computed, </span><span style="color:#9ECBFF;">&quot;get&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">/* GET */</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;value&#39;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> value </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">get </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">() { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 计算属性的 getter </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (dirty) { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 只有数据为脏的时候才会重新计算 </span></span>
<span class="line"><span style="color:#24292E;">    value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">runner</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">    dirty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 依赖收集，收集运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">track</span><span style="color:#24292E;">(computed, </span><span style="color:#032F62;">&quot;get&quot;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">/* GET */</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;value&#39;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> value </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>由于默认 dirty 是 true，所以这个时候会执行 runner 函数，并进一步执行 computed getter，也就是 count.value + 1，因为访问了 count 的值，并且由于 count 也是一个响应式对象，所以就会触发 count 对象的依赖收集过程。</p><p>请注意，由于是在 runner 执行的时候访问 count，所以这个时候的 activeEffect 是 runner 函数。runner 函数执行完毕，会把 dirty 设置为 false，并进一步执行 track（computed,&quot;get&quot;,&#39;value&#39;) 函数做依赖收集，这个时候 runner 已经执行完了，所以 activeEffect 是组件副作用渲染函数。</p><p>所以你要特别注意这是两个依赖收集过程：对于 plusOne 来说，它收集的依赖是组件副作用渲染函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p><p>然后当我们点击按钮的时候，会执行 plus 函数，函数内部通过 count.value++ 修改 count 的值，并派发通知。请注意，这里不是直接调用 runner 函数，而是把 runner 作为参数去执行 scheduler 函数。我们来回顾一下 trigger 函数内部对于 effect 函数的执行方式:</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> run </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (effect) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 调度执行 </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (effect.options.scheduler) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    effect.options.</span><span style="color:#B392F0;">scheduler</span><span style="color:#E1E4E8;">(effect) </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 直接运行 </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">effect</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> run </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (effect) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 调度执行 </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (effect.options.scheduler) { </span></span>
<span class="line"><span style="color:#24292E;">    effect.options.</span><span style="color:#6F42C1;">scheduler</span><span style="color:#24292E;">(effect) </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 直接运行 </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">effect</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>computed API 内部创建副作用函数时，已经配置了 scheduler 函数，如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">scheduler</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">dirty) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    dirty </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">trigger</span><span style="color:#E1E4E8;">(computed, </span><span style="color:#9ECBFF;">&quot;set&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">/* SET */</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;value&#39;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">scheduler</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">dirty) { </span></span>
<span class="line"><span style="color:#24292E;">    dirty </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 派发通知，通知运行访问该计算属性的 activeEffect </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">trigger</span><span style="color:#24292E;">(computed, </span><span style="color:#032F62;">&quot;set&quot;</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">/* SET */</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;value&#39;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>它并没有对计算属性求新值，而仅仅是把 dirty 设置为 true，再执行 trigger(computed, &quot;set&quot; , &#39;value&#39;)，去通知执行 plusOne 依赖的组件渲染副作用函数，即触发组件的重新渲染。</p><p>在组件重新渲染的时候，会再次访问 plusOne，我们发现这个时候 dirty 为 true，然后会再次执行 computed getter，此时才会执行 count.value + 1 求得新值。这就是虽然组件没有直接访问 count，但是当我们修改 count 的值的时候，组件仍然会重新渲染的原因。</p><p>为了更加直观展示上述过程，我画了一张图：</p>`,38),E=s(`<p>通过以上分析，我们可以看出 computed 计算属性有两个特点：</p><ol><li><p><strong>延时计算</strong>，只有当我们访问计算属性的时候，它才会真正运行 computed getter 函数计算；</p></li><li><p><strong>缓存</strong>，它的内部会缓存上次的计算结果 value，而且只有 dirty 为 true 时才会重新计算。如果访问计算属性时 dirty 为 false，那么直接返回这个 value。</p></li></ol><p>现在，我们就可以回答开头提的问题了。和单纯使用普通函数相比，计算属性的优势是：<strong>只要依赖不变化</strong> ，<strong>就可以使用缓存的 value 而不用每次在渲染组件的时候都执行函数去计算</strong>，这是典型的空间换时间的优化思想。</p><h4 id="嵌套计算属性" tabindex="-1">嵌套计算属性 <a class="header-anchor" href="#嵌套计算属性" aria-label="Permalink to &quot;嵌套计算属性&quot;">​</a></h4><p>计算属性也支持嵌套，我们可以针对上述例子做个小修改，即不在渲染函数中访问 plusOne，而在另一个计算属性中访问：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> count </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> plusOne </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> count.value </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">}) </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> plusTwo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> plusOne.value </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">}) </span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(plusTwo.value)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> count </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> plusOne </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> count.value </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">}) </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> plusTwo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> plusOne.value </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">}) </span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(plusTwo.value)</span></span></code></pre></div><p>从代码中可以看到，当我们访问 plusTwo 的时候，过程和前面都差不多，同样也是两个依赖收集的过程。对于 plusOne 来说，它收集的依赖是 plusTwo 内部的 runner 函数；对于 count 来说，它收集的依赖是 plusOne 内部的 runner 函数。</p><p>接着当我们修改 count 的值时，它会派发通知，先运行 plusOne 内部的 scheduler 函数，把 plusOne 内部的 dirty 变为 true，然后执行 trigger 函数再次派发通知，接着运行 plusTwo 内部的 scheduler 函数，把 plusTwo 内部的 dirty 设置为 true。</p><p>然后当我们再次访问 plusTwo 的值时，发现 dirty 为 true，就会执行 plusTwo 的 computed getter 函数去执行 plusOne.value + 1，进而执行 plusOne 的 computed gette 即 count.value + 1 + 1，求得最终新值 2。</p><p>得益于 computed 这种巧妙的设计，无论嵌套多少层计算属性都可以正常工作。</p><h4 id="计算属性的执行顺序" tabindex="-1">计算属性的执行顺序 <a class="header-anchor" href="#计算属性的执行顺序" aria-label="Permalink to &quot;计算属性的执行顺序&quot;">​</a></h4><p>我们曾提到计算属性内部创建副作用函数的时候会配置 computed 为 true，标识这是一个 computed effect，用于在 trigger 阶段的优先级排序。我们来回顾一下 trigger 函数执行 effects 的过程：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> add </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (effectsToAdd) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (effectsToAdd) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    effectsToAdd.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(effect </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (effect </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> activeEffect </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">shouldTrack) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (effect.options.computed) { </span></span>
<span class="line"><span style="color:#E1E4E8;">          computedRunners.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(effect) </span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">          effects.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(effect) </span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span></span>
<span class="line"><span style="color:#E1E4E8;">    }) </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">} </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> run </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (effect) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (effect.options.scheduler) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    effect.options.</span><span style="color:#B392F0;">scheduler</span><span style="color:#E1E4E8;">(effect) </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">effect</span><span style="color:#E1E4E8;">() </span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span></span>
<span class="line"><span style="color:#E1E4E8;">} </span></span>
<span class="line"><span style="color:#E1E4E8;">computedRunners.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(run) </span></span>
<span class="line"><span style="color:#E1E4E8;">effects.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(run)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> add </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (effectsToAdd) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (effectsToAdd) { </span></span>
<span class="line"><span style="color:#24292E;">    effectsToAdd.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(effect </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (effect </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> activeEffect </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">shouldTrack) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (effect.options.computed) { </span></span>
<span class="line"><span style="color:#24292E;">          computedRunners.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(effect) </span></span>
<span class="line"><span style="color:#24292E;">        } </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">          effects.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(effect) </span></span>
<span class="line"><span style="color:#24292E;">        } </span></span>
<span class="line"><span style="color:#24292E;">      } </span></span>
<span class="line"><span style="color:#24292E;">    }) </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">} </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> run </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (effect) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (effect.options.scheduler) { </span></span>
<span class="line"><span style="color:#24292E;">    effect.options.</span><span style="color:#6F42C1;">scheduler</span><span style="color:#24292E;">(effect) </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">effect</span><span style="color:#24292E;">() </span></span>
<span class="line"><span style="color:#24292E;">  } </span></span>
<span class="line"><span style="color:#24292E;">} </span></span>
<span class="line"><span style="color:#24292E;">computedRunners.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(run) </span></span>
<span class="line"><span style="color:#24292E;">effects.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(run)</span></span></code></pre></div><p>在上一节课分析 trigger 函数的时候，为了方便你理解主干逻辑，我省略了 computedRunners 的分支逻辑。实际上，在添加待运行的 effects 的时候，我们会判断每一个 effect 是不是一个 computed effect，如果是的话会添加到 computedRunners 中，在后面运行的时候会优先执行 computedRunners，然后再执行普通的 effects。</p><p>那么为什么要这么设计呢？其实是考虑到了一些特殊场景，我们通过一个示例来说明：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { ref, computed } from &#39;vue&#39; </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">import</span><span style="color:#E1E4E8;"> { effect } from &#39;@vue/reactivity&#39; </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> count = ref(</span><span style="color:#FDAEB7;font-style:italic;">0</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> plusOne = computed(() =&gt; { </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#FDAEB7;font-style:italic;">return</span><span style="color:#E1E4E8;"> count.value + </span><span style="color:#FDAEB7;font-style:italic;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">}) </span></span>
<span class="line"><span style="color:#E1E4E8;">effect(() =&gt; { </span></span>
<span class="line"><span style="color:#E1E4E8;">  console.log(plusOne.value + count.value) </span></span>
<span class="line"><span style="color:#E1E4E8;">}) </span></span>
<span class="line"><span style="color:#E1E4E8;">function plus() { </span></span>
<span class="line"><span style="color:#E1E4E8;">  count.value++ </span></span>
<span class="line"><span style="color:#E1E4E8;">} </span></span>
<span class="line"><span style="color:#E1E4E8;">plus()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { ref, computed } from &#39;vue&#39; </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">import</span><span style="color:#24292E;"> { effect } from &#39;@vue/reactivity&#39; </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> count = ref(</span><span style="color:#B31D28;font-style:italic;">0</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> plusOne = computed(() =&gt; { </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#B31D28;font-style:italic;">return</span><span style="color:#24292E;"> count.value + </span><span style="color:#B31D28;font-style:italic;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">}) </span></span>
<span class="line"><span style="color:#24292E;">effect(() =&gt; { </span></span>
<span class="line"><span style="color:#24292E;">  console.log(plusOne.value + count.value) </span></span>
<span class="line"><span style="color:#24292E;">}) </span></span>
<span class="line"><span style="color:#24292E;">function plus() { </span></span>
<span class="line"><span style="color:#24292E;">  count.value++ </span></span>
<span class="line"><span style="color:#24292E;">} </span></span>
<span class="line"><span style="color:#24292E;">plus()</span></span></code></pre></div><p>这个示例运行后的结果输出：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#79B8FF;">3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#005CC5;">3</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#005CC5;">3</span></span></code></pre></div><p>在执行 effect 函数时运行 console.log(plusOne.value + count.value)，所以第一次输出 1，此时 count.value 是 0，plusOne.value 是 1。</p><p>后面连续输出两次 3 是因为， plusOne 和 count 的依赖都是这个 effect 函数，所以当我们执行 plus 函数修改 count 的值时，会触发并执行这个 effect 函数，因为 plusOne 的 runner 也是 count 的依赖，count 值修改也会执行 plusOne 的 runner，也就会再次执行 plusOne 的依赖即 effect 函数，因此会输出两次。</p><p>那么为什么两次都输出 3 呢？这就跟先执行 computed runner 有关。首先，由于 plusOne 的 runner 和 effect 都是 count 的依赖，当我们修改 count 值的时候， plusOne 的 runner 和 effect 都会执行，那么此时执行顺序就很重要了。</p><p>这里先执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value。这个时候，由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了新值 2， 再加上 1 就得到 3。执行完 plusOne 的 runner 以及依赖更新之后，再去执行 count 的普通effect 依赖，从而去执行 plusOne.value + count.value，这个时候 plusOne dirty 为 false， 直接返回上次的计算结果 2，然后再加 1 就又得到 3。</p><p>如果我们把 computed runner 和 effect 的执行顺序换一下会怎样呢？我来告诉你，会输出如下结果：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#79B8FF;">3</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#005CC5;">3</span></span></code></pre></div><p>第一次输出 1 很好理解，因为流程是一样的。第二次为什么会输出 2 呢？我们来分析一下，当我们执行 plus 函数修改 count 的值时，会触发 plusOne 的 runner 和 effect 的执行，这一次我们先让 effect 执行 plusOne.value + count.value，那么就会访问 plusOne.value，但由于 plusOne 的 runner 还没执行，所以此时 dirty 为 false，得到的值还是上一次的计算结果 1，然后再加 1 得到 2。</p><p>接着再执行 plusOne 的 runner，把 plusOne 的 dirty 设置为 true，然后通知它的依赖 effect 执行 plusOne.value + count.value，这个时候由于 dirty 为 true，就会再次执行 plusOne 的 getter 计算新值，拿到了 2，然后再加上 1 就得到 3。</p><p>知道原因后，我们再回过头看例子。因为 effect 函数依赖了 plusOne 和 count，所以 plusOne 先计算会更合理，这就是为什么我们需要让 computed runner 的执行优先于普通的 effect 函数。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>好的，到这里我们这一节的学习就结束啦，我希望通过学习，你能理解计算属性的工作机制，能搞明白计算属性嵌套场景代码的执行顺序，知道计算属性的两个特点------延时计算和缓存，也希望你能够在组件的开发中合理使用计算属性。</p><p>最后，给你留一道思考题目，computed 函数返回的对象实际上劫持的是 value 属性的 getter 和 setter，但为什么我们在组件的模板中访问一个计算属性变量，不用手动在后面加 .value 呢？欢迎你在留言区与我分享。</p><blockquote><p><strong>本节课的相关代码在源代码中的位置如下：</strong></p><p>packages/reactivity/src/computed.ts</p></blockquote>`,31);function y(i,u,d,f,F,g){const n=p("Image");return l(),o("div",null,[r,e(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/3C/6A/Ciqc1F8nv6SAMiYhAAJ4vcrA7pg591.png"}),t(),E])}const D=a(c,[["render",y]]);export{A as __pageData,D as default};
