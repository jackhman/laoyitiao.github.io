import{_ as o,j as e,o as t,g as c,k as a,s,h as l,Q as p}from"./chunks/framework.e0c66c3f.js";const U=JSON.parse('{"title":"队列是什么 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学数据结构与算法_文档/(3344) 06  队列：先进先出的线性表，如何实现增删查？.md","filePath":"posts/backEnd/重学数据结构与算法_文档/(3344) 06  队列：先进先出的线性表，如何实现增删查？.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/重学数据结构与算法_文档/(3344) 06  队列：先进先出的线性表，如何实现增删查？.md"},E=s("p",null,"通过前面课时的学习，你学会了数据结构中可以灵活增删数据的线性表。在需要严格遵守数据处理顺序的场景下，我们对线性表予以限制，那么就得到了后进先出的数据结构，栈。与之对应的还有一种限制的线性表，它遵循先进先出的性质，这就是队列。这一课时我们就来学习队列的增删查。",-1),i=s("h3",{id:"队列是什么",tabindex:"-1"},[l("队列是什么 "),s("a",{class:"header-anchor",href:"#队列是什么","aria-label":'Permalink to "队列是什么"'},"​")],-1),y=s("p",null,"与栈相似，队列也是一种特殊的线性表，与线性表的不同之处也是体现在对数据的增和删的操作上。",-1),_=s("p",null,"队列的特点是先进先出：",-1),d=s("ul",null,[s("li",null,[s("p",null,"先进，表示队列的数据新增操作只能在末端进行，不允许在队列的中间某个结点后新增数据;")]),s("li",null,[s("p",null,"先出，队列的数据删除操作只能在始端进行，不允许在队列的中间某个结点后删除数据。也就是说队列的增和删的操作只能分别在这个队列的队尾和队头进行，如下图所示：")])],-1),F=s("p",null,"与线性表、栈一样，队列也存在这两种存储方式，即顺序队列和链式队列：",-1),A=s("ul",null,[s("li",null,[s("p",null,"顺序队列，依赖数组来实现，其中的数据在内存中也是顺序存储。")]),s("li",null,[s("p",null,"而链式队列，则依赖链表来实现，其中的数据依赖每个结点的指针互联，在内存中并不是顺序存储。链式队列，实际上就是只能尾进头出的线性表的单链表。")])],-1),h=s("p",null,"如下图所示，我们将队头指针指向链队列的头结点，队尾指针指向终端结点。不管是哪种实现方式，一个队列都依赖队头（front）和队尾（rear）两个指针进行唯一确定。",-1),g=s("p",null,"当队列为空时，front 和 rear 都指向头结点，如下图所示：",-1),m=s("h3",{id:"队列对于数据的增删查处理",tabindex:"-1"},[l("队列对于数据的增删查处理 "),s("a",{class:"header-anchor",href:"#队列对于数据的增删查处理","aria-label":'Permalink to "队列对于数据的增删查处理"'},"​")],-1),u=s("p",null,"队列从队头（front）删除元素，从队尾（rear）插入元素。对于一个顺序队列的数组来说，会设置一个 front 指针来指向队头，并设置另一个 rear 指针指向队尾。当我们不断进行插入删除操作时，头尾两个指针都会不断向后移动。",-1),C=s("p",null,"为了实现一个有 k 个元素的顺序存储的队列，我们需要建立一个长度比 k 大的数组，以便把所有的队列元素存储在数组中。队列新增数据的操作，就是利用 rear 指针在队尾新增一个数据元素。这个过程不会影响其他数据，时间复杂度为 O(1)，状态如下图所示：",-1),D=s("p",null,"队列删除数据的操作与栈不同。队列元素出口在队列头部，即下标为 0 的位置。当利用 front 指针删除一个数据时，队列中剩余的元素都需要向前移动一个位置，以保证队列头部下标为 0 的位置不为空，此时时间复杂度就变成 O(n) 了，状态如下图所示：",-1),f=s("p",null,"我们看到，front 指针删除数据的操作引发了时间复杂度过高的问题，那么我们该如何解决呢？我们可以通过移动指针的方式来删除数据，这样就不需要移动剩余的数据了。但是，这样的操作，也可能会产生数组越界的问题。接下来，我们来详细讨论一下。",-1),q=s("p",null,"我们一起来看一个利用顺序队列，持续新增数据和删除数据的例子。",-1),k=s("p",null,"初始时，定义了长度为 5 的数组，front 指针和 rear 指针相等，且都指向下标为 0 的位置，队列为空队列。如下图所示：",-1),B=s("p",null,"当 A、B、C、D 四条数据加入队列后，front 依然指向下标为 0 的位置，而 rear 则指向下标为 4 的位置。",-1),b=s("p",null,"当 A 出队列时，front 指针指向下标为 1 的位置，rear 保持不变。其后 E 加入队列，front 保持不变，rear 则移动到了数组以外，如下图所示：",-1),T=p("",8),x=s("p",null,"如果这时再新增了 F 进入队列，就可以放入在下标为 0 的位置，rear 指针指向下标为 1 的位置。这时的 rear 和 front 指针就会重合，指向下标为 1 的位置，如下图所示：",-1),P=s("p",null,"此时，又会产生新的问题，即当队列为空时，有 front 指针和 rear 指针相等。而现在的队列是满的，同样有 front 指针和 rear 指针相等。那么怎样判断队列到底是空还是满呢？常用的方法是，设置一个标志变量 flag 来区别队列是空还是满。",-1),v=s("h4",{id:"链式队列的数据操作",tabindex:"-1"},[l("链式队列的数据操作 "),s("a",{class:"header-anchor",href:"#链式队列的数据操作","aria-label":'Permalink to "链式队列的数据操作"'},"​")],-1),I=s("p",null,"我们再看一下链式队列的数据操作。链式队列就是一个单链表，同时增加了 front 指针和 rear 指针。链式队列和单链表一样，通常会增加一个头结点，并另 front 指针指向头结点。头结点不存储数据，只是用来辅助标识。",-1),M=s("p",null,"链式队列进行新增数据操作时，将拥有数值 X 的新结点 s 赋值给原队尾结点的后继，即 rear.next。然后把当前的 s 设置为队尾结点，指针 rear 指向 s。如下图所示：",-1),S=s("p",null,"当链式队列进行删除数据操作时，实际删除的是头结点的后继结点。这是因为头结点仅仅用来标识队列，并不存储数据。因此，出队列的操作，就需要找到头结点的后继，这就是要删除的结点。接着，让头结点指向要删除结点的后继。",-1),X=s("p",null,"特别值得一提的是，如果这个链表除去头结点外只剩一个元素，那么删除仅剩的一个元素后，rear 指针就变成野指针了。这时候，需要让 rear 指针指向头结点。也许你前面会对头结点存在的意义产生怀疑，似乎没有它也不影响增删的操作。那么为何队列还特被强调要有头结点呢？",-1),V=s("p",null,"这主要是为了防止删除最后一个有效数据结点后， front 指针和 rear 指针变成野指针，导致队列没有意义了。有了头结点后，哪怕队列为空，头结点依然存在，能让 front 指针和 rear 指针依然有意义。",-1),O=p("",6),L=p("",6);function N(H,Y,j,w,z,K){const n=e("Image");return t(),c("div",null,[E,i,y,_,d,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/D1/Ciqc1F7XiWKAYQ6uAABDmk0Wx98597.png"}),F,A,h,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/D1/Ciqc1F7XiWqAdDfGAABpdzpnaic772.png"}),g,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/DD/CgqCHl7XiXGADFxLAAAzCTHg63s024.png"}),m,u,C,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/D1/Ciqc1F7XiX2AcswVAAB59JjuOyQ221.png"}),D,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/D1/Ciqc1F7XiYOAdl0WAACJFu_x0pg197.png"}),f,q,k,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/DD/CgqCHl7XiYqAaxUUAACPoQw5EYI800.png"}),B,b,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/D1/Ciqc1F7XiZCAQFJlAACnK-UehMk790.png"}),T,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/D1/Ciqc1F7XiZiAPVGUAABIBxBMZIk624.png"}),x,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/DD/CgqCHl7XiZ6AYibiAABIpfFet7k826.png"}),P,v,I,M,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/DE/CgqCHl7XixGAeHPTAABaaMqb6YY421.png"}),S,X,V,a(n,{alt:"001.png",src:"https://s0.lgstatic.com/i/image/M00/28/28/Ciqc1F74TT6AKxhrAADpi9uXKjg928.png"}),O,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/17/DE/CgqCHl7Xiv-AKgAeAEgzBtcbFjk481.gif"}),L])}const G=o(r,[["render",N]]);export{U as __pageData,G as default};
