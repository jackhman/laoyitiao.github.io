import{_ as o,j as e,o as t,g as r,k as l,Q as p,s,h as n}from"./chunks/framework.e0c66c3f.js";const ks=JSON.parse('{"title":"前序遍历 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6695) 06  树：如何深度运用树的遍历？.md","filePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6695) 06  树：如何深度运用树的遍历？.md","lastUpdated":null}'),c={name:"posts/backEnd/数据结构与算法面试宝典_文档/(6695) 06  树：如何深度运用树的遍历？.md"},E=p(`<p>树在我们的应用程序中非常常见，大部分语言的 Map 数据结构，大多是基于树来实现的。此外还经常会遇到很多其他树结构的变种，比如 MySQL 会使用 B+ 树、MongoDB 会使用 B- 树。其中二叉树是各种树的基础，相关的题目也是变化多样，因此，各大公司都喜欢通过二叉树，考察面试者对语言底层数据结构的理解。</p><p>二叉树的结点定义较为简单，一般采用如下方式来定义：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    TreeNode right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">() {}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">TreeNode</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) { </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val; }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    TreeNode right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">() {}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">TreeNode</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">val</span><span style="color:#24292E;">) { </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> val; }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>一个树的结点里面分别存放着：</p><ul><li><p>值：用 val 表示</p></li><li><p>左子结点：用 left 指针表示</p></li><li><p>右子结点：用 right 指针表示</p></li></ul><p>在我学习二叉树的过程中，发现很多问题实际上都可以通过二叉树的遍历进行求解。 二叉树的遍历可以分为以下 4 种：</p><ul><li><p>前序遍历</p></li><li><p>中序遍历</p></li><li><p>后序遍历</p></li><li><p>层次遍历</p></li></ul><p>在&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">第 02 讲</a>&quot;我们已经介绍了层次遍历，因此，本讲会重点介绍前 3 种遍历以及它们的深度运用。<strong>由于二叉树关联的面试题目考察的重点都是在各种遍历上</strong> ，所以在讲解时，我会采用更加<strong>单刀直入</strong>的方式，带你开启一段&quot;爬树&quot;的旅程。</p><h3 id="前序遍历" tabindex="-1">前序遍历 <a class="header-anchor" href="#前序遍历" aria-label="Permalink to &quot;前序遍历&quot;">​</a></h3><p>前序遍历的顺序为：</p><ol><li><p>遍历根结点</p></li><li><p>左子树</p></li><li><p>右子树</p></li></ol><p>这里我们不再按照课本上一步一步演示的方式。将采用<strong>整体概括处理的方式</strong>，比如把左子树或者右子树作为一个整体来处理，如下图所示：</p>`,12),y=p(`<ul><li><p>Step 1. 首先遍历根结点，然后<strong>遍历左子树的时候，就把左子树放到相应的位置；遍历右子树的时候，就把右子树放到相应的位置</strong>。</p></li><li><p>Step 2. 接着再把左子树展开，放到相应位置。</p></li><li><p>Step 3. 最后再把右子树展开，放到相应位置。此时就得到了最终前序遍历的结果。</p></li></ul><p>不过你在处理根结点或者子树的时候，需要注意空树的情况。避免访问空指针！</p><h4 id="递归前序遍历" tabindex="-1">递归前序遍历 <a class="header-anchor" href="#递归前序遍历" aria-label="Permalink to &quot;递归前序遍历&quot;">​</a></h4><p>基于以上思路，可以写出递归的前序遍历的代码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(TreeNode root, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Integer</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> ans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 边界处理：如果树为空，那么不需要处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 先访问根结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 再分别访问左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.left, ans);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 再访问右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.right, ans);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(TreeNode root, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Integer</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> ans) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 边界处理：如果树为空，那么不需要处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 先访问根结点</span></span>
<span class="line"><span style="color:#24292E;">        ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 再分别访问左子树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.left, ans);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 再访问右子树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.right, ans);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/05.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>接下来我们看一下算法的复杂度，在面试中经常有人将时间复杂度与空间复杂度混淆，这里很<strong>容易出错</strong>，你需要格外注意。</p><ul><li><p><strong>时间复杂度</strong>，由于树上的每个结点都只访问一次，并且每次访问都只有一次压栈弹栈操作，所以复杂度为 O(N)。</p></li><li><p><strong>空间复杂度</strong>，由于函数调用栈的深度与树的高度有关系，所以使用的空间为 O(H)。H 表示树的高度。（注意：一般而言，输出结果存放的 List 并不算在空间复杂度里面）。</p></li></ul><p><strong>提示</strong>：在面试时候，你需要问清楚面试官：访问每个结点的时候，是需要 Print 出来，还是放到一个 List 里面返回。搞清楚需求再开始写代码！</p><h4 id="使用栈完成前序遍历" tabindex="-1">使用栈完成前序遍历 <a class="header-anchor" href="#使用栈完成前序遍历" aria-label="Permalink to &quot;使用栈完成前序遍历&quot;">​</a></h4><p>接下来，我们看一下如何将递归的前序代码改成非递归的前序代码，如下所示（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">preorderTraversal</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 用来进行递归的栈</span></span>
<span class="line"><span style="color:#E1E4E8;">        Stack&lt;</span><span style="color:#F97583;">TreeNode</span><span style="color:#E1E4E8;">&gt; s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 用来存放遍历的结果，不算在空间复杂度里面 </span></span>
<span class="line"><span style="color:#E1E4E8;">        List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 开始利用栈来进行遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">s.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 模拟递归的压栈过程</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                s.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(root);</span></span>
<span class="line"><span style="color:#E1E4E8;">                ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">                root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 当无法压栈的时候，将root.right进行压栈</span></span>
<span class="line"><span style="color:#E1E4E8;">            root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            s.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">preorderTraversal</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 用来进行递归的栈</span></span>
<span class="line"><span style="color:#24292E;">        Stack&lt;</span><span style="color:#D73A49;">TreeNode</span><span style="color:#24292E;">&gt; s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 用来存放遍历的结果，不算在空间复杂度里面 </span></span>
<span class="line"><span style="color:#24292E;">        List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 开始利用栈来进行遍历</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">s.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 模拟递归的压栈过程</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                s.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(root);</span></span>
<span class="line"><span style="color:#24292E;">                ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">                root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.left;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 当无法压栈的时候，将root.right进行压栈</span></span>
<span class="line"><span style="color:#24292E;">            root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            s.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.right;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>算法复杂度</strong>：每个结点都入栈出栈一次，遍历整棵树的时间复杂度为 O(N)，空间复杂度就是栈的最大使用空间，而这个空间是由树的高度决定的，所以空间复杂度就是 O(H)。</p><p><strong>备注</strong>：虽然面试的时候极难考到 Morris 遍历，如果你有时间，可以看看 Morris 遍历，这种算法的优点是只需要使用 O(1) 的空间（没有函数递归）。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>下面我们通过几道题目还原一下面试场景，看看面试官都给你埋了哪些雷。</p><h4 id="例-1-验证二叉搜索树" tabindex="-1">例 1：验证二叉搜索树 <a class="header-anchor" href="#例-1-验证二叉搜索树" aria-label="Permalink to &quot;例 1：验证二叉搜索树&quot;">​</a></h4><p>【<strong>题目</strong>】二叉搜索树有以下特点：</p><ul><li><p>根结点的值大于所有的左子树结点的值</p></li><li><p>根结点的值小于所有的右子树结点的值</p></li><li><p>左右子树也必须满足以上特性</p></li></ul><p>现给定一棵二叉树，判断是否是二叉搜索树。</p><p>输入:</p>`,22),i=s("p",null,"输出: true",-1),A=s("p",null,[n("【"),s("strong",null,"分析"),n(" 】二叉搜索树的定义，"),s("strong",null,"本质上就是一个前序遍历"),n("。因此，可以利用前序遍历的思路来解决这道题。")],-1),g=p("<p>【<strong>模拟</strong>】首先我们在这棵树上进行模拟，效果如下 （用 INT64_MIN 表示负无穷大，INT64_MAX 表示正无穷大）：</p><p>Step 1. 我们假设<strong>根结点总是对的</strong>。如果总是对的，那么可以认为结点的值总是：处在区间(INT64_MIN, INT64_MAX)以内。由于二叉树结点的值是 int，如果用 int64 总是可以保证一定在范围里面。</p><p>Step 2. 根据二叉搜索树的定义，左子树总是小于根结点 5，那么左子树的范围就应该设置为(INT64_MIN, 5)。</p><p>Step 3. 根据二叉搜索树的定久，右子树总是大于根结点 5，那么右子树的范围就应该设置为 (5, INT64_MAX)。</p><p>Step 4. 然后再看结点 7 的左子树，范围应该是 (5, 7)。</p><p>【<strong>规律</strong>】经过运行的模拟，我们可以总结出以下特点：</p><ul><li><p>通过原本给出的那棵二叉树，实际上能够构造出一棵&quot;影子&quot;<strong>区间二叉树</strong>，只不过这个二叉树上的结点是一个区间；</p></li><li><p>原二叉树上的值，需要掉在新二叉树的区间范围里面。</p></li></ul>",7),u=p(`<p>因此，<strong>解题的思路</strong>就是：</p><ul><li><p>如何有效利用右边的&quot;区间&quot;二叉树验证左边二叉树的有效性？</p></li><li><p>当右边的&quot;区间&quot;二叉树不能成功构建，原二叉树就是一棵无效的二叉搜索树。</p></li></ul><p><em>注：我们不是真的要构建&quot;影子&quot;二叉树，这样做的目的是方便思考。</em></p><p>&quot;影子&quot;二叉树是通过原二叉树生成的。树上结点就是不停地将区间进行拆分，比如：</p><ul><li><p>(INT64_MIN, INT64_MAX) -&gt; (INT64_MIN, 5) , (5, INT64_MAX)</p></li><li><p>(5, INT64_MAX) -&gt; (5, 7), (7, INT64_MAX)</p></li></ul><p>【<strong>匹配</strong>】我们就利用二叉树的前序遍历，同时遍历这两棵二叉树。注意，其中&quot;影子&quot;二叉树是动态生成的，并且我们也不保存其数据结构。</p><p>【<strong>边界</strong>】关于二叉树的边界，我们需要考虑一种情况：</p><ul><li><p>一棵空二叉树；</p></li><li><p>题目的定义采用的&quot;小于&quot;，&quot;大于&quot;；</p></li><li><p>当任何一个位置不满足二叉树的定义，就可以不用再遍历下去了。因此，我们要注意快速返回。</p></li></ul><p><strong>【代码】</strong> 有了思路，也有了运行图，此时就可以写出以下核心代码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, Long </span><span style="color:#FFAB70;">l</span><span style="color:#E1E4E8;">, Long </span><span style="color:#FFAB70;">r</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 1. 如果为空树</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 2. 如果已经有结点不满足BST的要求了</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">ans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 检查当前结点是不是在影子二叉树的区间里面</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里相当于在检查两棵二叉树相同位置的结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(l </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> root.val </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> root.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> r)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里同时遍历左子树，(l, root.val)就是影子二叉树的左子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.left, l, Long.</span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;">(root.val));</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里同时遍历右子树，(root.val, r)就是影子二叉树的右子结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.right, Long.</span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;">(root.val), r);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root, Long.MIN_VALUE, Long.MAX_VALUE);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">, Long </span><span style="color:#E36209;">l</span><span style="color:#24292E;">, Long </span><span style="color:#E36209;">r</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 1. 如果为空树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 2. 如果已经有结点不满足BST的要求了</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">ans) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 检查当前结点是不是在影子二叉树的区间里面</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里相当于在检查两棵二叉树相同位置的结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(l </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> root.val </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> root.val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> r)) {</span></span>
<span class="line"><span style="color:#24292E;">            ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里同时遍历左子树，(l, root.val)就是影子二叉树的左子结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.left, l, Long.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">(root.val));</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里同时遍历右子树，(root.val, r)就是影子二叉树的右子结点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.right, Long.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">(root.val), r);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isValidBST</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root, Long.MIN_VALUE, Long.MAX_VALUE);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.1.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>【<strong>小结</strong> 】我们在传统经验的前序遍历基础上，进行了一点扩展，需要创建一棵&quot;影子&quot;二叉树才能进行前序遍历。因此这道题的<strong>考点</strong> 就是：<strong>找到隐藏的&quot;影子&quot;二叉树</strong>。</p><p>此外，遍历二叉树的时候，如果可以用递归，那么应该也可以用栈，或者 Morris 遍历。作为一道思考题，你能用栈来完成&quot;验证二叉搜索树&quot;这道题目吗？</p><blockquote><p>代码：<a href="https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/JiYou/LaGouAlgo/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>为了巩固我们前面所讲的知识，下面我再给你留两道练习题。</p><p><strong>练习题 1</strong> ：&quot;影子&quot;二叉树还可以解决&quot;<strong>是否相同的树</strong>&quot;的问题。比如给定两棵二叉树，要求判断这两棵二叉树是不是一样的？思考的时候，再想一下，&quot;影子&quot;二叉树是怎么样的呢？</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>,<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/100.%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>当然，有时候出题人还会将一些考点进行组合，比如将&quot;相同的子树&quot;与&quot;前序遍历&quot;进行组合，就可以得到一道新的题目。</p><p><strong>练习题 2</strong> ：当我们写出&quot;判断是否相同的树&quot;的代码之后，可以开始思考另外一个问题------如何判断<strong>一棵树是不是另外一棵树的子树</strong>？</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/572.%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>你可以把答案或者思考的过程写在评论区，我们一起讨论。</p><p>到这里，我们可以总结一下解题时用到的知识点和收获。为了方便你理解和复习，我把关于&quot;树的遍历&quot;的考点整理在一张大图里，如下图所示：</p>`,22),F=s("p",null,'然后，我们收获了一种思路------"影子"二叉树；一个模板------如何判断相同的树。',-1),d=s("h4",{id:"例-2-目标和的所有路径",tabindex:"-1"},[n("例 2：目标和的所有路径 "),s("a",{class:"header-anchor",href:"#例-2-目标和的所有路径","aria-label":'Permalink to "例 2：目标和的所有路径"'},"​")],-1),h=s("p",null,[n("【"),s("strong",null,"题目"),n("】给定一棵二叉树，一个目标值。请输出所有路径，需要满足根结点至叶子结点之和等于给定的目标值。")],-1),D=s("p",null,"输入：target = 9",-1),C=s("p",null,"输出：[[5,4], [5,3,1]]",-1),b=s("p",null,[s("strong",null,"解释"),n("：从根结点到叶子结点形成的路径有 3 条：[5, 4], [5, 3, 1], [5, 3, 2]，其中只有 [5, 4], [5, 3, 1] 形成的和为 9。")],-1),B=s("p",null,[n("【"),s("strong",null,"分析"),n(" 】这是一道来自"),s("strong",null,"头条"),n("的面试题目。首先题目要求从根结点出发，最后到达叶子结点。因此，从遍历的顺序上来说，符合前序遍历。")],-1),_=s("p",null,[n("【"),s("strong",null,"模拟"),n("】那么接下来我们进行一轮模拟，过程如下所示：")],-1),m=p(`<p>Step 1. 首先从结点 5 出发，此时形成的并不完整的路径为 [5]。</p><p>Step 2. 接着走向左子结点 4，形成一个有效路径 [5, 4]。</p><p>Step 3. 接下来在换一条路之前，需要把 4 扔掉。</p><p>Step 4. 按照前序遍历顺序访问 3，形成并不完整的路径 [5, 3]。</p><p>Step 5. 接下来访问结点 1，形成完整的有效路径 [5, 3, 1]。</p><p>Step 6. 当结点 1 遍历完之后，需要从路径中扔掉。</p><p>Step 7. 接下来遍历结点 2，形成路径 [5, 3, 2]。总和为 10，并不是一个有效解。</p><p>因此，我们一共找到两个有效解 [5, 4], [5, 3, 1]。</p><p>【<strong>规律</strong>】经过模拟的过程，可以发现了以下特点：</p><ul><li><p>遇到新结点，路径总是从尾部添加结点；</p></li><li><p>遍历完结点，路径就把它从尾部扔掉；</p></li></ul><p>路径里面的元素刚好与递归时压栈的元素完全一样。因此，我们需要在递归结束时，把路径里面的元素像&quot;弹栈&quot;一样扔掉。</p><p>【<strong>匹配</strong> 】基于二叉树而言，这里的考点当然是前序遍历。但是我们发现：还需要另外一个信息&quot;<strong>路径</strong>&quot;：随着参数的压栈、弹栈而变化。</p><p>【<strong>边界</strong>】按照题意，这里需要注意两点：</p><ul><li><p>题目一定要根结点到叶子结点</p></li><li><p>注意代码要支持空树</p></li></ul><p>【<strong>代码</strong>】此时，我们已经可以写一写代码了（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> List&lt;List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;&gt; ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">backtrace</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">      List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">path</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">sum</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果已经是空树，那么没有必要看</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 前序遍历，加上累计的和</span></span>
<span class="line"><span style="color:#E1E4E8;">        sum </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> root.val;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将结点添加到路径中，相当于压栈一样</span></span>
<span class="line"><span style="color:#E1E4E8;">        path.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root.left </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> root.right </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果已经形成了一个有效路径!</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sum </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 添加到ans中</span></span>
<span class="line"><span style="color:#E1E4E8;">                ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;(path));</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 回溯，分别再看子情况。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">backtrace</span><span style="color:#E1E4E8;">(root.left, path, sum, target);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">backtrace</span><span style="color:#E1E4E8;">(root.right, path, sum, target);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 函数结束的时候弹栈，也要把结点从路径最后扔掉!</span></span>
<span class="line"><span style="color:#E1E4E8;">        path.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(path.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List&lt;List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt;&gt; </span><span style="color:#B392F0;">pathSum</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">sum</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 路径</span></span>
<span class="line"><span style="color:#E1E4E8;">        List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; path </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">backtrace</span><span style="color:#E1E4E8;">(root, path, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, sum);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> List&lt;List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;&gt; ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">backtrace</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">      List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">path</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">sum</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">target</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果已经是空树，那么没有必要看</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 前序遍历，加上累计的和</span></span>
<span class="line"><span style="color:#24292E;">        sum </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> root.val;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将结点添加到路径中，相当于压栈一样</span></span>
<span class="line"><span style="color:#24292E;">        path.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root.left </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> root.right </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果已经形成了一个有效路径!</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sum </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> target) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 添加到ans中</span></span>
<span class="line"><span style="color:#24292E;">                ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;(path));</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 回溯，分别再看子情况。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">backtrace</span><span style="color:#24292E;">(root.left, path, sum, target);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">backtrace</span><span style="color:#24292E;">(root.right, path, sum, target);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 函数结束的时候弹栈，也要把结点从路径最后扔掉!</span></span>
<span class="line"><span style="color:#24292E;">        path.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(path.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List&lt;List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt;&gt; </span><span style="color:#6F42C1;">pathSum</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">sum</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 路径</span></span>
<span class="line"><span style="color:#24292E;">        List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; path </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">backtrace</span><span style="color:#24292E;">(root, path, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, sum);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/113.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：首先遍历每个结点，复杂度肯定是 O(N)。但是最大的复杂度在于复制有效路径。假设有一棵满二叉树，最下面一层结点都符合要求。那么一共需要复制 N/2 次。而每次需要复制路径深度为 log(N)。因此，复杂度为 N/2 * log(N)，即 NlgN。</p><p>【<strong>小结</strong> 】本质上，这道题的考点就是：<strong>回溯</strong> ，只不过借用了二叉树这个皮。反过来，在<strong>二叉树上进行回溯的代码模板，你也需要熟练掌握</strong>。</p><p>如果我们把题目中&quot;路径之和等于 target&quot;这个条件去掉，那么题目就变成了需要输出二叉树到叶子结点的所有路径。想必这道题目你也能够解决了吧？</p><p>到这里，我们又可以进一步丰富了前面总结出的关于&quot;二叉树的前序遍历&quot;的思维导图了，如下图所示：</p>`,21),f=p('<p>在这里，我们收获了：二叉树上的<strong>回溯模板</strong>。</p><p>前序遍历的变种还有很多，结合不同的考点，还会有新的题型出现，但是只要我们能分析出题目的考点，有效地掌握一些代码模板进行相互组合，一定能克服这些新鲜的题目。</p><h3 id="中序遍历" tabindex="-1">中序遍历 <a class="header-anchor" href="#中序遍历" aria-label="Permalink to &quot;中序遍历&quot;">​</a></h3><p>接下来我们看一下中序遍历。中序遍历的顺序：</p><ol><li><p>左子树</p></li><li><p>根结点</p></li><li><p>右子树</p></li></ol><p>这里不再按照课本上一步一步演示的方式，同样可以采用一种概括处理的思路，如下所示：</p>',6),T=s("ul",null,[s("li",null,[s("p",null,"Step 1. 左子树作为一个整体放到左边；然后把根结点放到中间；最后把右子树作为一个整体放右边。")]),s("li",null,[s("p",null,"Step 2. 接着再把左子树展开。")]),s("li",null,[s("p",null,"Step 3. 最后再把右子树展开，此时我们就得到了最终中序遍历的结果。")])],-1),v=s("p",null,"经过上述过程的拆解和分析，有助于帮助你理解中序遍历。但是仍然要注意输出结点的顺序，结点真正输出顺序如下图所示：",-1),k=p(`<h4 id="递归中序遍历" tabindex="-1">递归中序遍历 <a class="header-anchor" href="#递归中序遍历" aria-label="Permalink to &quot;递归中序遍历&quot;">​</a></h4><p>基于以上思路，我们可以写出递归的中序遍历的代码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(TreeNode root, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Integer</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> ans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 先遍历左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.left, ans);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 然后遍历中间的根结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 最后遍历右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">preOrder</span><span style="color:#E1E4E8;">(root.right, ans);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(TreeNode root, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Integer</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> ans) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 先遍历左子树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.left, ans);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 然后遍历中间的根结点</span></span>
<span class="line"><span style="color:#24292E;">        ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 最后遍历右子树</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">preOrder</span><span style="color:#24292E;">(root.right, ans);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度为 O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1) 复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。</p><h4 id="使用栈完成中序遍历" tabindex="-1">使用栈完成中序遍历 <a class="header-anchor" href="#使用栈完成中序遍历" aria-label="Permalink to &quot;使用栈完成中序遍历&quot;">​</a></h4><p>接下来，我们看一下如何将递归的中序代码，改成<strong>非递归的中序代码</strong>（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">inorderTraversal</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Stack&lt;</span><span style="color:#F97583;">TreeNode</span><span style="color:#E1E4E8;">&gt; s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 注意这里的判断条件，需要root或stack非空</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">s.</span><span style="color:#B392F0;">empty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 往左边走，连续入栈，直到不能再走为止</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                s.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(root);</span></span>
<span class="line"><span style="color:#E1E4E8;">                root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 到达了最左边，把结点弹出来，进行遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">            root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            s.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 转向右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">            root </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 返回遍历的结果</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">inorderTraversal</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        Stack&lt;</span><span style="color:#D73A49;">TreeNode</span><span style="color:#24292E;">&gt; s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 注意这里的判断条件，需要root或stack非空</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">s.</span><span style="color:#6F42C1;">empty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 往左边走，连续入栈，直到不能再走为止</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                s.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(root);</span></span>
<span class="line"><span style="color:#24292E;">                root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.left;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 到达了最左边，把结点弹出来，进行遍历</span></span>
<span class="line"><span style="color:#24292E;">            root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            s.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 转向右子树</span></span>
<span class="line"><span style="color:#24292E;">            root </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.right;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 返回遍历的结果</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度为 O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1) 复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。</p><p><strong>备注</strong>：虽然面试的时候极难考到 Morris，但如果你想多掌握一种解题方法，可以尝试用 Morris 遍历，其优点是只需要使用 O(1) 的空间复杂度。这里我先给出完整实现代码，如有你有疑问可以写在留言区，我们一起讨论。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><h4 id="例-3-验证二叉搜索树" tabindex="-1">例 3：验证二叉搜索树 <a class="header-anchor" href="#例-3-验证二叉搜索树" aria-label="Permalink to &quot;例 3：验证二叉搜索树&quot;">​</a></h4><p>【<strong>题目</strong>】（与例 1 一样）给定一棵二叉树，要求验证是不是一棵二叉搜索树。</p><p>【<strong>分析</strong> 】根据<strong>二叉搜索树</strong> 的特性，可以知道。<strong>中序遍历一定有序</strong>。因此，可以利用这个特性进行验证。如果从这个角度来切入，那么题目的考点就可以总结如下：</p>`,15),q=p(`<p>接下来我们就尝试用中序遍历解决这道题目，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    Long preValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Long.MIN_VALUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">midOrder</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">ans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">midOrder</span><span style="color:#E1E4E8;">(root.left);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 只需要在中序遍历的时候，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 与前面的值进行一下比较就可以了。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (preValue </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> root.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 比较完成之后，更新一下前面结点的值</span></span>
<span class="line"><span style="color:#E1E4E8;">            preValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Long.</span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">midOrder</span><span style="color:#E1E4E8;">(root.right);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 注意，为了防止root.val取到最小值INT_MIN</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里需要初始化为64位的最小值。</span></span>
<span class="line"><span style="color:#E1E4E8;">        preValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Long.MIN_VALUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">midOrder</span><span style="color:#E1E4E8;">(root);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    Long preValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Long.MIN_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">midOrder</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">ans) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">midOrder</span><span style="color:#24292E;">(root.left);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 只需要在中序遍历的时候，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 与前面的值进行一下比较就可以了。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (preValue </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> root.val) {</span></span>
<span class="line"><span style="color:#24292E;">                ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 比较完成之后，更新一下前面结点的值</span></span>
<span class="line"><span style="color:#24292E;">            preValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Long.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">midOrder</span><span style="color:#24292E;">(root.right);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isValidBST</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 注意，为了防止root.val取到最小值INT_MIN</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里需要初始化为64位的最小值。</span></span>
<span class="line"><span style="color:#24292E;">        preValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Long.MIN_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">midOrder</span><span style="color:#24292E;">(root);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E4%B8%AD%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度 O(N)，每个结点只遍历一次，并且每个结点访问只需要 O(1) 时间复杂度。空间复杂度为 O(H)，其中 H 为树的高度。</p><p>【<strong>小结</strong>】平时练习的时候，你不妨将同类型的二叉树题目串起来进行比较，也许会发现题目真正的考点。比如将&quot;二叉树的中序遍历&quot;与&quot;验证二叉搜索树&quot;这两类题目放在一起思考，就会发现，考点是将中序遍历访问结点时候的处理做了一点小小的变化。</p><p>另外，在处理二叉搜索树的时候，还需要利用有序性。中序遍历二叉搜索树的时候，可以把它<strong>看成一个有序的数组，在此基础上展开思路。</strong></p><p><strong>练习题 3</strong>：找出二叉搜索树里面出现次数最多的数。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>我们还可以做进一步思考。经典的中序遍历只访问了一个结点，<strong>关心一个结点的性质</strong> 。而&quot;验证二叉搜索树&quot;需要访问两个结点，用<strong>两个结点的信息</strong>做决策。</p><p>因此，从&quot;需要用的<strong>结点个数</strong>&quot;角度出发，也可以衍生出一些题目。这里给你留两道练习题，帮助你巩固前面所讲的知识，希望你可以在课下完成它。</p><p><strong>练习题 4</strong>：找出二叉搜索树任意两结点之间绝对值的最小值</p><blockquote><p>代码：<a href="http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.java" target="_blank" rel="noreferrer">Java</a>/<a href="http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="http://agoueducol/Algorithm-Dryad/blob/main/06.Tree/783.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 5</strong>：一棵二叉搜索树的两个结点被交换了，恢复这棵二叉搜索树</p><blockquote><p>解法 1（递归）：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.py" target="_blank" rel="noreferrer">Python</a></p><p>解法 2（栈）：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.2.py" target="_blank" rel="noreferrer">Python</a></p><p>解法 3（Morris）：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.java" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.cpp" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/99.%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.3.py" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>至此，我们已经挖掘了中序遍历可能的考点，如下图所示：</p>`,15),x=p(`<p>讲完二叉搜索树（BST），我们再来看看&quot;如何删除二叉搜索树的结点&quot;，这也是面试中很重要的一个考点。</p><h4 id="例-4-删除二叉搜索树的结点" tabindex="-1">例 4：删除二叉搜索树的结点 <a class="header-anchor" href="#例-4-删除二叉搜索树的结点" aria-label="Permalink to &quot;例 4：删除二叉搜索树的结点&quot;">​</a></h4><p>【<strong>题目</strong>】删除二叉搜索树的指定结点。返回删除之后的根结点。接口如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">TreeNode </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(TreeNode root, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> value);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">TreeNode </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(TreeNode root, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> value);</span></span></code></pre></div><p>【<strong>分析</strong> 】这是一道来自<strong>微软</strong>的面试题。它的难点在于需要考虑各种情况。因此，针对这道题的题目特点，我们把重点放在分析各种 Case。</p><p>Case 1：空树。如果树是空树，那么只需要返回 null 即可。</p><p>Case 2：如果 value 比根结点小，那么去左子树里面删除相应结点，执行：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (value </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> root.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    root.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.left, value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (value </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> root.val) {</span></span>
<span class="line"><span style="color:#24292E;">    root.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.left, value);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里只有一行核心代码，但却<strong>非常有意思</strong>。因为这行代码统一处理了以下几种情况。</p><p>a）当结点 1 删除之后，左子树为空，需要设置 root.left = null。如下图所示：</p>`,10),N=s("p",null,"b）当结点 1 删除之后，左子树的根结点为 2，需要设置 root.left 指向结点 2。如下图所示：",-1),S=s("p",null,"c）当结点 1 删除之后，左子树根结点变成 2，需要设置 root.left 指向结点 2。如下图所示：",-1),V=p(`<p>因此，删除结点时，需要：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">root.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.left, value);</span></span>
<span class="line"><span style="color:#E1E4E8;">或</span></span>
<span class="line"><span style="color:#E1E4E8;">root.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.right, value);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">root.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.left, value);</span></span>
<span class="line"><span style="color:#24292E;">或</span></span>
<span class="line"><span style="color:#24292E;">root.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.right, value);</span></span></code></pre></div><p>虽然看起来 b）没有重新赋值的必要，但是利用这一句话，却把a）、b）、c）三情况都统一起来了。我们再思考时，就不需要考虑更多的情况了。</p><p>Case 3：如果 value 比根结点大，那么需要执行：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (value </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> root.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    root.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.right, value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (value </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> root.val) {</span></span>
<span class="line"><span style="color:#24292E;">    root.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.right, value);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Case 4：如果 value 与根结点的值相等，那么需要再分四种情况考虑。</p><p>a）此时只有一个结点。比如：</p>`,7),R=s("p",null,"在删除 1 之后，都需要返回 null。",-1),j=s("p",null,[n("b）如果被删除的结点有左子树。那么需要从"),s("strong",null,"左子树中找到最大值"),n(" ，然后与当前结点进行值"),s("strong",null,"交换"),n(" 。最后"),s("strong",null,"再在左子树中删除 value"),n("。步骤如下：")],-1),O=p("<p>Step 1. 找到要删除的结点 1，发现它还有左子树。并不能直接删除。</p><p>Step 2. 找到左子树里面的最大值 -1。</p><p>Step 3. 将值 -1 与 1 的值进行交换。注意：我们只是交换 node.val，而不是交换 node。</p><p>Step 4. 交换之后，接着在左子树中删除结点 1。</p><p>Step 5. 最终得到的仍然是一棵二叉搜索树。</p><p>c）如果要删除的结点只有右子树。那么需要从<strong>右子树中找到最小值</strong> ，然后与当前结点进行值<strong>交换</strong> 。然后<strong>再在右子树中删除 value</strong>。步骤如下：</p>",6),P=p(`<p>Step 1. 找到要删除的结点 1，发现它还有右子树。</p><p>Step 2. 在右子树中找到最小的值 2。</p><p>Step 3. 交换值。注意：是交换值，不是结点交换。</p><p>Step 4. 继续在右子树中删除结点 1。</p><p>Step 5. 最终我们得到一棵删除结点 1 之后的二叉搜索树。</p><p>d）被删除的结点既有左子树，也有右子树。这时，假设它只有左子树，或者假设它只有右子树，这两种假设你可以任选一个进行删除即可。</p><p>不过这里我要给你留道<strong>思考题</strong>：如果我们想要删除结点之后，想让二叉搜索树尽量保持平衡，有什么办法呢？提示：可以增加一些结点信息。</p><p>【<strong>代码</strong> 】至此，我们把<strong>删除二叉搜索树的结点</strong>涉及的所有情况都分析清楚了，接下来就可以直接写代码了（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">swapValue</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, TreeNode </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a.val;</span></span>
<span class="line"><span style="color:#E1E4E8;">        a.val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> b.val;</span></span>
<span class="line"><span style="color:#E1E4E8;">        b.val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> TreeNode </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// case 1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// case 2</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> root.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            root.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.left, key);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (key </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> root.val) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// case 3</span></span>
<span class="line"><span style="color:#E1E4E8;">            root.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.right, key);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// case 4. case4又分为4种小情况，最后一种可以被合并掉。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 所以这里只处理了三种。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 当前树只有一个结点，那么直接返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root.left </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> root.right </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root.left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 当前结点还有左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 那么需要从左子树中找个较大的值。</span></span>
<span class="line"><span style="color:#E1E4E8;">                TreeNode large </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (large.right </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    large </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> large.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 交换再删除</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">swapValue</span><span style="color:#E1E4E8;">(root, large);</span></span>
<span class="line"><span style="color:#E1E4E8;">                root.left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.left, key);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root.right </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 当前结点还有右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">                TreeNode small </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 那么需要从右子树中找个较小的值</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (small.left </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    small </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> small.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 交换再删除</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">swapValue</span><span style="color:#E1E4E8;">(root, small);</span></span>
<span class="line"><span style="color:#E1E4E8;">                root.right </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">deleteNode</span><span style="color:#E1E4E8;">(root.right, key);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">swapValue</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">a</span><span style="color:#24292E;">, TreeNode </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a.val;</span></span>
<span class="line"><span style="color:#24292E;">        a.val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> b.val;</span></span>
<span class="line"><span style="color:#24292E;">        b.val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> TreeNode </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">key</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// case 1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// case 2</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> root.val) {</span></span>
<span class="line"><span style="color:#24292E;">            root.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.left, key);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (key </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> root.val) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// case 3</span></span>
<span class="line"><span style="color:#24292E;">            root.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.right, key);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// case 4. case4又分为4种小情况，最后一种可以被合并掉。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 所以这里只处理了三种。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 当前树只有一个结点，那么直接返回null</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root.left </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> root.right </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root.left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 当前结点还有左子树</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 那么需要从左子树中找个较大的值。</span></span>
<span class="line"><span style="color:#24292E;">                TreeNode large </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.left;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (large.right </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    large </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> large.right;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 交换再删除</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">swapValue</span><span style="color:#24292E;">(root, large);</span></span>
<span class="line"><span style="color:#24292E;">                root.left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.left, key);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root.right </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 当前结点还有右子树</span></span>
<span class="line"><span style="color:#24292E;">                TreeNode small </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root.right;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 那么需要从右子树中找个较小的值</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (small.left </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    small </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> small.left;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 交换再删除</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">swapValue</span><span style="color:#24292E;">(root, small);</span></span>
<span class="line"><span style="color:#24292E;">                root.right </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">deleteNode</span><span style="color:#24292E;">(root.right, key);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> root;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：如果是一棵平衡的二叉搜索树，那么时间复杂度为 O(lgn)，否则时间复杂度为 O(N)。</p><p>【<strong>小结</strong> 】我们对&quot;二叉搜索树的删除结点&quot;的考点做一下小结。一方面是利用<strong>有序性</strong> ，另一方面就是<strong>考察应聘者的分析能力</strong>。因此，这道题的重点是清晰分析出其中涉及的四种情况。面试的时候，面试官会要求你：</p><ul><li><p>能清晰地讲出每种情况的处理办法</p></li><li><p>能清晰简洁地实现代码</p></li></ul><p>既然我们已经学习了二叉搜索树删除结点操作，那么另外两种操作想必你可以拿来练练手了。</p><p><strong>练习题 6</strong>: 二叉搜索树插入一个新结点</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.jcpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 7</strong>：二叉搜索树查找结点</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>此时我们就可以将<strong>二叉搜索树的中序遍历</strong> 、<strong>查找</strong> 、<strong>插入</strong> ，<strong>以及删除</strong>加入我们的知识树里面了，如下图所示：</p>`,19),I=s("h3",{id:"后序遍历",tabindex:"-1"},[n("后序遍历 "),s("a",{class:"header-anchor",href:"#后序遍历","aria-label":'Permalink to "后序遍历"'},"​")],-1),H=s("p",null,"接下来我们看一下后序遍历。后序遍历的顺序：",-1),L=s("ol",null,[s("li",null,[s("p",null,"左子树")]),s("li",null,[s("p",null,"右子树")]),s("li",null,[s("p",null,"根结点")])],-1),X=s("p",null,"这里我们同样采用一种**概括处理的思路，**不再按照课本上一步一步演示的方式。下图是我们处理的步骤：",-1),M=s("ul",null,[s("li",null,[s("p",null,"Step 1. 左子树作为一个整体放到左边，右子树作为一个整体放右边。")]),s("li",null,[s("p",null,"Step 2. 再把左子树展开。")]),s("li",null,[s("p",null,"Step 3. 接着把右子树展开。")]),s("li",null,[s("p",null,"Step 4. 最后放上根结点。")])],-1),G=s("p",null,[n("这样有助于帮助你理解后序遍历。但是仍然要"),s("strong",null,"注意输出结点的顺序"),n("。结点真正输出顺序如下图所示（红色表示顺序）：")],-1),K=p(`<h4 id="递归后序遍历" tabindex="-1">递归后序遍历 <a class="header-anchor" href="#递归后序遍历" aria-label="Permalink to &quot;递归后序遍历&quot;">​</a></h4><p>基于以上思路，我们可以写出递归的后序遍历代码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(TreeNode root, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Integer</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> ans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 先遍历左子树</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.left, ans);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 最后遍历右子树</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.right, ans);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 然后遍历中间的根结点</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(root.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(TreeNode root, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Integer</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> ans) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 先遍历左子树</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.left, ans);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 最后遍历右子树</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.right, ans);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 然后遍历中间的根结点</span></span>
<span class="line"><span style="color:#24292E;">    ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(root.val);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/94.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86.1.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度为 O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1) 复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。</p><h4 id="使用栈完成后序遍历" tabindex="-1">使用栈完成后序遍历 <a class="header-anchor" href="#使用栈完成后序遍历" aria-label="Permalink to &quot;使用栈完成后序遍历&quot;">​</a></h4><p>接下来，我们看一下如何将递归的后序代码，改成<strong>非递归的后序代码</strong>（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">postorderTraversal</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 存放遍历的结果</span></span>
<span class="line"><span style="color:#E1E4E8;">        List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// pre表示遍历时前面一个已经遍历过的结点</span></span>
<span class="line"><span style="color:#E1E4E8;">        TreeNode pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        Stack&lt;</span><span style="color:#F97583;">TreeNode</span><span style="color:#E1E4E8;">&gt; s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果栈中还有元素，或者当前结点t非空</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">s.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 顺着左子树走，并且将所有的元素压入栈中</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                s.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(t);</span></span>
<span class="line"><span style="color:#E1E4E8;">                t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t.left;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 当没有任何元素可以压栈的时候</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 拿栈顶元素，注意这里并不将栈顶元素弹出</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 因为在迭代时，根结点需要遍历两次，这里需要判断一下</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 右子树是否遍历完毕</span></span>
<span class="line"><span style="color:#E1E4E8;">            t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> s.</span><span style="color:#B392F0;">peek</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果要遍历当前结点，需要确保右子树已经遍历完毕</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 1. 如果当前结点右子树为空，那么右子树没有遍历的必要</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 需要将当前结点放到ans中</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 2. 当t.right == pre时，说明右子树已经被打印过了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 那么此时需要将当前结点放到ans中</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t.right </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> t.right </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> pre) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 右子树已经遍历完毕，放到ans中。</span></span>
<span class="line"><span style="color:#E1E4E8;">                ans.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(t.val);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 弹栈</span></span>
<span class="line"><span style="color:#E1E4E8;">                s.</span><span style="color:#B392F0;">pop</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 因为已经遍历了当前结点，所以需要更新pre结点</span></span>
<span class="line"><span style="color:#E1E4E8;">                pre </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 已经打印完毕。需要设置为空，否则下一轮循环</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 还会遍历t的左子树。</span></span>
<span class="line"><span style="color:#E1E4E8;">                t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 需要将t结点的右子树遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">                t </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> t.right;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">postorderTraversal</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 存放遍历的结果</span></span>
<span class="line"><span style="color:#24292E;">        List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// pre表示遍历时前面一个已经遍历过的结点</span></span>
<span class="line"><span style="color:#24292E;">        TreeNode pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        Stack&lt;</span><span style="color:#D73A49;">TreeNode</span><span style="color:#24292E;">&gt; s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Stack&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果栈中还有元素，或者当前结点t非空</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">s.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 顺着左子树走，并且将所有的元素压入栈中</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                s.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(t);</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.left;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 当没有任何元素可以压栈的时候</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 拿栈顶元素，注意这里并不将栈顶元素弹出</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 因为在迭代时，根结点需要遍历两次，这里需要判断一下</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 右子树是否遍历完毕</span></span>
<span class="line"><span style="color:#24292E;">            t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> s.</span><span style="color:#6F42C1;">peek</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果要遍历当前结点，需要确保右子树已经遍历完毕</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 1. 如果当前结点右子树为空，那么右子树没有遍历的必要</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 需要将当前结点放到ans中</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 2. 当t.right == pre时，说明右子树已经被打印过了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 那么此时需要将当前结点放到ans中</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t.right </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> t.right </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> pre) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 右子树已经遍历完毕，放到ans中。</span></span>
<span class="line"><span style="color:#24292E;">                ans.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(t.val);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 弹栈</span></span>
<span class="line"><span style="color:#24292E;">                s.</span><span style="color:#6F42C1;">pop</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 因为已经遍历了当前结点，所以需要更新pre结点</span></span>
<span class="line"><span style="color:#24292E;">                pre </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 已经打印完毕。需要设置为空，否则下一轮循环</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 还会遍历t的左子树。</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 第一次走到t结点，不能放到ans中，因为t的右子树还没有遍历。</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 需要将t结点的右子树遍历</span></span>
<span class="line"><span style="color:#24292E;">                t </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> t.right;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.stack.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度 O(N)，每个结点都只遍历一次，并且每个结点访问只需要 O(1) 复杂度的时间。空间复杂度为 O(H)，其中 H 为树的高度。</p><p>迭代写法的<strong>考点</strong>：判断当前结点是不是应该放到 ans 中。 这里我们用了两个条件进行判断：</p><ul><li><p>是否有右子树</p></li><li><p>pre 指针是不是指向当前结点的右子树</p></li></ul><p><strong>备注</strong>：虽然面试的时候极难考到 Morris，但如果你有时间我还是建议你看看 Morris 后序遍历，其优点是只需要使用 O(1) 的空间复杂度。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/145.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86.morris.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>相比前序遍历、中序遍历，后序遍历出题形式变化更多样。接下来我们看一下如何用后序遍历处理例 1。</p><h4 id="例-5-验证二叉搜索树" tabindex="-1">例 5：验证二叉搜索树 <a class="header-anchor" href="#例-5-验证二叉搜索树" aria-label="Permalink to &quot;例 5：验证二叉搜索树&quot;">​</a></h4><p>【<strong>题目</strong>】（与例 1一样）给定一棵二叉树，要求验证是不是一棵二叉搜索树。</p><p>【<strong>分析</strong>】这里要利用后序遍历来求解这道题目。回到二叉搜索树的定义：左子树所有值都比根结点小，右子树所有值都比根结点大。</p><p>如果我们能够拿到左右子树的信息，根结点就可以利用这些信息判断是否满足二叉搜索树的要求。</p>`,19),Q=s("p",null,[n("如上图所示：如果满足 lmax < x 并且 x < rmin，那么可以认为这棵树是二叉搜索树。注意，"),s("strong",null,"我们是先拿到了左子树与右子树的信息，然后再利用这个信息做出判断"),n("。这样的操作符合后序遍历的要求。")],-1),w=s("p",null,[n("【"),s("strong",null,"画图"),n("】这里我们拿一棵二叉搜索树来画图演示步骤，动图如下：")],-1),W=s("p",null,"Step 1. 想要判断根结点是否大于左子树，小于右子树。但是此时还没有拿到左右子树的信息，于是分别去拿左子树/右子树的信息。",-1),J=s("p",null,"Step 2. 观察左子树.可以发现 1 < 2， 并且 2 < 3，左子树是一棵二叉搜索树，此外我们还得到了左子树的范围 [1, 3]。",-1),U=s("p",null,"Step 3. 然后再看右子树，可以发现 5 < 6 并且 6 < 7，右子树是一棵二叉搜索树，此外我们还得到了右子树的范围 [5, 7]。",-1),Y=s("p",null,"Step 4. 分别得到左右子树的信息之后，我们将这个信息替换掉原来的子树，然后再比较 lmax = 3 < 4 并且 4 < rmin = 5，因此这棵树是一棵有效的二叉搜索树。",-1),Z=s("p",null,[n("【"),s("strong",null,"技巧"),n("】在利用后序遍历处理这道题目的时候，还需要考虑空结点带来的麻烦，如下图所示：")],-1),z=s("p",null,"我们在处理结点 4 的时候，右子树的范围比较容易确定 [5, 5]。但是左子树是一棵空树，返回什么范围给结点 4 合适呢？有什么办法可以比较好地避免用 if/else 去判断空结点呢？",-1),$=s("p",null,[n("这里给你介绍一个"),s("strong",null,"技巧：用 [Long.MAX_VALUE, Long.MIN_VALUE]表示一个空区间"),n(" ，也就是"),s("strong",null,"下界是一个最大的数，上界是一个最小的数"),n("。")],-1),ss=s("p",null,"下面我们利用动图演示一下为什么在这种情况下可以工作（画图时分别用 -inf 取代最小值，用inf 取代最大值）：",-1),ns=p(`<p>Step 1. 根据后序遍历的要求，首先应该去查看左子树和右子树的信息。</p><p>Step 2. 左子树是一棵空树，那么得到的区间就是 <strong>[inf, -inf]</strong>。注意这里表示空区间的方式。</p><p>Step 3. 右子树只有一个结点 5，其左右子树也是空树，因此结点 5 的左右区间分别为 [inf, -inf] 和 [inf, -inf]。<strong>接下来进行比较，lmax = -inf &lt; 5 并且 5 &lt; rmin = inf</strong>。</p><p>Step 4. 然后我们需要总结右子树的区间范围。这个区间就可以这样取了：[<strong>min(lmin=inf, 5)</strong> ,<strong>max(5, rmax=-inf)</strong>]，也就是 [5, 5]。</p><p>Step 5. 接下来利用左子树的信息和右子树的信息，首先判断范围，lmax = -inf &lt; 4并且4 &lt; rmin = 5，再得到整棵树的范围[<strong>min(lmin=inf, 4)</strong> ,<strong>max(5, rmax=5)</strong>]，也就是 [4, 5]。</p><p>【<strong>代码</strong>】到这里，我们已经可以开始写一下代码了（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 用来存放一棵树里面数值的区间</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Range</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Long min </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Long.MAX_VALUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Long max </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Long.MIN_VALUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Range</span><span style="color:#E1E4E8;">() {}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Range</span><span style="color:#E1E4E8;">(Long </span><span style="color:#FFAB70;">l</span><span style="color:#E1E4E8;">, Long </span><span style="color:#FFAB70;">r</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      min </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> l;</span></span>
<span class="line"><span style="color:#E1E4E8;">      max </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> r;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Range emptyRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Range</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Range </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果是空树，或者已经判断不是一棵二叉搜索树了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 那么就不需要再继续遍历了。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">ans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> emptyRange;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    Range l </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.left);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Range r </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.right);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">(l.max </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> root.val </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> root.val </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> r.min)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 当不符合的时候，返回任意区间都是可以的</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> emptyRange;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 需要取左子树最小值与当前结点的最小值。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 需要取右子树最大值与当前结点的最大值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Range</span><span style="color:#E1E4E8;">(Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(l.min, root.val),</span></span>
<span class="line"><span style="color:#E1E4E8;">                    Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(r.max, root.val));</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isValidBST</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 用来存放一棵树里面数值的区间</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Range</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Long min </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Long.MAX_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Long max </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Long.MIN_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Range</span><span style="color:#24292E;">() {}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Range</span><span style="color:#24292E;">(Long </span><span style="color:#E36209;">l</span><span style="color:#24292E;">, Long </span><span style="color:#E36209;">r</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      min </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> l;</span></span>
<span class="line"><span style="color:#24292E;">      max </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> r;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Range emptyRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Range</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Range </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果是空树，或者已经判断不是一棵二叉搜索树了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 那么就不需要再继续遍历了。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">ans) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> emptyRange;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    Range l </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.left);</span></span>
<span class="line"><span style="color:#24292E;">    Range r </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.right);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">(l.max </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> root.val </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> root.val </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> r.min)) {</span></span>
<span class="line"><span style="color:#24292E;">      ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 当不符合的时候，返回任意区间都是可以的</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> emptyRange;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 需要取左子树最小值与当前结点的最小值。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 需要取右子树最大值与当前结点的最大值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Range</span><span style="color:#24292E;">(Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(l.min, root.val),</span></span>
<span class="line"><span style="color:#24292E;">                    Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(r.max, root.val));</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isValidBST</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/98.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.%E5%90%8E%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度为 O(n)，空间复杂度为 O(H)，其中 H 表示树的高度。</p><p>【<strong>小结</strong>】写完代码之后，我们来看一下这道题的考点：</p><ul><li><p>拿到子树的区间</p></li><li><p>利用子树的区间，整合出整棵树的区间</p></li><li><p>如何处理空结点</p></li></ul><p>我们可以把这些知识点浓缩一下，方便我们以后复习，如下图所示：</p>`,12),as=s("p",null,[n("如果我们再深入思考一下，就会发现，后序遍历的时候有个"),s("strong",null,"特点"),n(" ："),s("strong",null,"想要验证"),n(" 一棵树是否是二叉搜索树，后序遍历的"),s("strong",null,"返回值"),n("却是整棵树的信息。")],-1),ls=s("p",null,"这里画图来表示一下：",-1),ps=s("p",null,[n('有点"'),s("strong",null,"项庄舞剑，意在沛公"),n('"的味道。那么我们再对后序遍历做一个小结，如下图所示：')],-1),os=s("p",null,"完成总结后，我们再通过一道题目，加深对这个考点的理解。",-1),es=s("h4",{id:"例-6-最低公共祖先",tabindex:"-1"},[n("例 6：最低公共祖先 "),s("a",{class:"header-anchor",href:"#例-6-最低公共祖先","aria-label":'Permalink to "例 6：最低公共祖先"'},"​")],-1),ts=s("p",null,[n("【"),s("strong",null,"题目"),n("】给定一棵二叉树，和两个在树上的结点，返回这两个结点的最低公共祖先。比如 [5,3] 两个结点的最低公共祖先是结点 6。")],-1),rs=p("<p>【<strong>分析</strong> 】这是一道来自<strong>微软</strong> 的面试题。在面试时，注意面试官要求的是两个结点的<strong>最低</strong>公共祖先。</p><p>一个结点 x 如果是 p，q 的最低公共祖先，那么以结点 x 为根的树，必然包含了 p，q 这<strong>2</strong>个结点。并且只可能下面 2 种 Case。</p><p><strong>Case 1</strong>：两个结点 p，q 分别在 x 的左边和右边。此时左子树会找到 1 个结点，右子树会找到 1 个结点。如下图所示：</p>",3),cs=s("p",null,"Case 2：根结点为 q，另外一个结点 p 在子树里，反之亦然。如下图所示：",-1),Es=s("p",null,[n("这里你可能会想，如果"),s("strong",null,"左子树"),n("找到 2 个结点怎么办？比如下图展示的情况：")],-1),ys=p("<p>绿色结点发现左子树计数有两个结点，那么绿色结点肯定不是最低公共祖先，最低公共祖先应该是左子树，比如红色结点。说明在处理左子树时，已经找到了最低公共祖先。这种情况不需要做什么处理。</p><p>我们再提取一下分析思路里的<strong>关键信息</strong>。</p><ul><li><p>最终想要的结论（<strong>沛公</strong>）：找到二叉树里面的最低公共祖先。</p></li><li><p>函数的返回值（<strong>项庄</strong> ）：在当前子树中，<strong>统计</strong>结点为 p，q 的个数。</p></li></ul><p>此时，我们已经有了&quot;<strong>沛公，项庄</strong>&quot;，就可以展开&quot;鸿门宴&quot;了。</p><p>【<strong>画图</strong>】接下来通过一个实例先在一棵树上进行模拟，动图演示如下：</p>",5),is=p(`<p>Step 1. 给定一棵二叉树，需要找到结点 5, 3 的最低公共祖先。<strong>后序遍历时，从最下层的结点开始逐层往上归纳信息</strong>。</p><p>Step 2. 最下层的结点为 3，统计数目为 1。</p><p>Step 3. 接着处理倒数第二层，统计出当前子树里面结点为 [5, 3] 的个数。</p><p>Step 4. 处理倒数第 3 层，分别统计出结点 7, 9 里面结点为 [5, 3] 的个数，[7, 9] 得到的统计值都为 1。</p><p>Step 5. 处理结点 6，此时左结点统计值为 1，右子树统计值为 1，那么最低公共祖先为结点 6。</p><p>Step 6. 处理结点 11，此时统计值为 2，但是由于右子树统计值已经是 2 了，那么结点 11 不是最低公共祖先。</p><p>【<strong>代码</strong>】至此，我们已经定义好了函数的返回值，也知道了利用子树的统计值处理前面提到的两种 Case，进而得到真正的答案。代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> TreeNode ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">, TreeNode </span><span style="color:#FFAB70;">p</span><span style="color:#E1E4E8;">, TreeNode </span><span style="color:#FFAB70;">q</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 查看子结点的梳计个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> lcnt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.left, p, q);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> rcnt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root.right, p, q);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 利用子结点返回的信息来进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果左边有一个，右边有一个，那么当前root就是最低公共祖先</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (lcnt </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> rcnt </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (lcnt </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> rcnt </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果左边找到一个，或者右边找到一个</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 并且我等于其中某一个结点p|q</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 那么当前root就是最低公共祖先</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> q) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回值为以root为根的子树, 统计里面的p,q结点的个数。</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> lcnt </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> rcnt </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> ((root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> p </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> root </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> q) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> TreeNode </span><span style="color:#B392F0;">lowestCommonAncestor</span><span style="color:#E1E4E8;">(TreeNode </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                              TreeNode </span><span style="color:#FFAB70;">p</span><span style="color:#E1E4E8;">, TreeNode </span><span style="color:#FFAB70;">q</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">postOrder</span><span style="color:#E1E4E8;">(root, p, q);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> TreeNode ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">, TreeNode </span><span style="color:#E36209;">p</span><span style="color:#24292E;">, TreeNode </span><span style="color:#E36209;">q</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 查看子结点的梳计个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> lcnt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.left, p, q);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> rcnt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root.right, p, q);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 利用子结点返回的信息来进行处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果左边有一个，右边有一个，那么当前root就是最低公共祖先</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (lcnt </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> rcnt </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (lcnt </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> rcnt </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果左边找到一个，或者右边找到一个</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 并且我等于其中某一个结点p|q</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 那么当前root就是最低公共祖先</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> q) {</span></span>
<span class="line"><span style="color:#24292E;">        ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回值为以root为根的子树, 统计里面的p,q结点的个数。</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> lcnt </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> rcnt </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> ((root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> p </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> root </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> q) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> TreeNode </span><span style="color:#6F42C1;">lowestCommonAncestor</span><span style="color:#24292E;">(TreeNode </span><span style="color:#E36209;">root</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                              TreeNode </span><span style="color:#E36209;">p</span><span style="color:#24292E;">, TreeNode </span><span style="color:#E36209;">q</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">postOrder</span><span style="color:#24292E;">(root, p, q);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%90%8E%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度为 O(N)，空间复杂度为 O(H)，H 为树的高度。</p><p>【<strong>小结</strong>】就这道题来说，考点为：</p><ul><li><p>定义函数的返回值为统计结点 p，q 的个数;</p></li><li><p>利用子树返回的结点个数，得到想要的最低公共祖先。</p></li></ul><p>如果仔细思考一下，这道题还可以用前序遍历的方法来解决。你能思考一下吗？</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.%E5%89%8D%E5%BA%8F.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>思考题</strong>：我们再把这道题从广度和深度上进行展开：</p>`,15),As=s("p",null,"虽然我们只介绍了两个结点的后序遍历解法，但你也可以开阔思路来试一下多叉树的题目。",-1),gs=s("p",null,[n("我们再归纳一下"),s("strong",null,"后序遍历的思路"),n(" ，可以"),s("strong",null,'总结为 8 个字"项庄舞剑，意在沛公"'),n("，如下图所示：")],-1),us=s("ul",null,[s("li",null,[s("p",null,'子树的信息：即如何定义函数的返回值。可以巧妙记为"项庄是谁？"。')]),s("li",null,[s("p",null,'信息的处理：如何利用子树返回的信息，得到我们最终想要的结论，可以巧妙地记为"如何得到沛公？"。')])],-1),Fs=s("h3",{id:"总结与延伸",tabindex:"-1"},[n("总结与延伸 "),s("a",{class:"header-anchor",href:"#总结与延伸","aria-label":'Permalink to "总结与延伸"'},"​")],-1),ds=s("p",null,"经过前面几讲的学习，我们马上就要和二叉树说再见了，回到知识层面，我再把本讲重点介绍，且需要你掌握的内容总结在一张思维导图中，如下图所示：",-1),hs=s("p",null,"除去知识的扩展，你还要学会浓缩和简化，抓住三种遍历的核心。我同样为你总结了一张思维导图：",-1),Ds=p('<p>除去介绍知识本身，这里我重点介绍了&quot;我是如何通过三种遍历搞定所有的二叉树的题目&quot;。由于篇幅的限制，关于&quot;树&quot;的介绍就要到这里。今天所讲的内容只是一引子，期待你还能发现更多树的特点和巧妙用法。欢迎在评论区和我交流，期待看到大家的奇思妙想。</p><h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h3><p>我再给你留一道<strong>思考题</strong>：给定一个二叉树的前序遍历和中序遍历，请构建出这棵二叉树。</p><p>输入：pre = [2,1,3], mid = [1, 2, 3]</p><p>输出：返回二叉树根结点 [2]，左子结点为 1，右子结点为3.</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/06.Tree/105.%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。你可以把答案写在评论区，我们一起讨论。接下来请和我一起踏上更加奇妙的算法与数据结构的旅程。下一讲将介绍 0<strong>7 | 并查集，如何利用两行代码完成并查集的解题技巧</strong>？让我们一起前进。</p>',7);function Cs(bs,Bs,_s,ms,fs,Ts){const a=e("Image");return t(),r("div",null,[E,l(a,{alt:"1.gif",src:"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtI-AItMYAAjasV3sa24039.gif"}),y,l(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/42/Cgp9HWBRtKeAYSGpAACZpTIXfU0084.png"}),i,A,l(a,{alt:"11.gif",src:"https://s0.lgstatic.com/i/image6/M01/21/38/CioPOWBUIueAOJfcAAdhS5BAUGo971.gif"}),g,l(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtNGAeo22AACebFDJtSc681.png"}),u,l(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtOmAcCa2AADXoM_tlx4996.png"}),F,d,h,D,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/3F/CioPOWBRtPWAR1otAACA-Iu2vmU954.png"}),C,b,B,_,l(a,{alt:"3.gif",src:"https://s0.lgstatic.com/i/image6/M01/1F/42/Cgp9HWBRtQqAeOlzAA3wDEKa3P4970.gif"}),m,l(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtRmAU_NjAAEAKqKMPsY246.png"}),f,l(a,{alt:"4.gif",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtSuAPkajAAkCntnG56c613.gif"}),T,v,l(a,{alt:"2021319-12844.png",src:"https://s0.lgstatic.com/i/image6/M00/21/3A/CioPOWBUI-qAV1MZAACWlNh4bls274.png"}),k,l(a,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtUiAJEr9AAC21ET_Iqs675.png"}),q,l(a,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtVWASUJoAAD2XJCLLgQ425.png"}),x,l(a,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtWWAIxSJAABkVgPnF_o374.png"}),N,l(a,{alt:"Drawing 13.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtW2AARGtAAB29vC847A588.png"}),S,l(a,{alt:"Drawing 14.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtXaALQrkAAB3-_72MrY558.png"}),V,l(a,{alt:"Drawing 15.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtYOAaCxfAABz2q7dEO8442.png"}),R,j,l(a,{alt:"5.gif",src:"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtZiAEkBKAAanEhq-SYE408.gif"}),O,l(a,{alt:"6.gif",src:"https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtbCAEv1OAAXuSoTT_wY014.gif"}),P,l(a,{alt:"Drawing 18.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/40/CioPOWBRtcGAHdsVAAD8g3mqZEQ373.png"}),I,H,L,X,l(a,{alt:"7.gif",src:"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtc6AUcUpAAoB4AbuqCg073.gif"}),M,G,l(a,{alt:"Drawing 20.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRtdmAVCQTAACWpvqFKDQ011.png"}),K,l(a,{alt:"Drawing 21.png",src:"https://s0.lgstatic.com/i/image6/M00/1F/43/Cgp9HWBRte6AGgSSAANZYCc0W0I359.png"}),Q,w,l(a,{alt:"12.gif",src:"https://s0.lgstatic.com/i/image6/M01/21/38/CioPOWBUIwGAAv3NAAp9VZSO5a4731.gif"}),W,J,U,Y,Z,l(a,{alt:"Drawing 23.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtgKAIBrtAABQgHb3MVg861.png"}),z,$,ss,l(a,{alt:"9.gif",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtheAAqTpAAqrC7nn9cs642.gif"}),ns,l(a,{alt:"Drawing 25.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtiyAGHC7AACr9Dp8WWE577.png"}),as,ls,l(a,{alt:"Drawing 26.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtjaACs7TAABq6h1DLRQ985.png"}),ps,l(a,{alt:"Drawing 27.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtj6AF94_AAC54hdOUJs668.png"}),os,es,ts,l(a,{alt:"Drawing 28.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtkaAE0QsAADAh6zPbnk294.png"}),rs,l(a,{alt:"Drawing 29.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtlCAbdR9AARsIH_iZJY236.png"}),cs,l(a,{alt:"Drawing 30.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/43/Cgp9HWBRtlmAcMP0AAJsaaiXrk4163.png"}),Es,l(a,{alt:"Drawing 31.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/44/Cgp9HWBRtmKADj4gAAKGC_G6FjM242.png"}),ys,l(a,{alt:"10.gif",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtm-AabKNAAto4bxyLyY509.gif"}),is,l(a,{alt:"Drawing 33.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtoqAPZ6tAADozszBVY4858.png"}),As,gs,l(a,{alt:"Drawing 34.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtpGAUxzZAADV23ElNds459.png"}),us,Fs,ds,l(a,{alt:"Drawing 35.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtp2ACQ-ZAAKKPaNyzjs632.png"}),hs,l(a,{alt:"Drawing 36.png",src:"https://s0.lgstatic.com/i/image6/M01/1F/40/CioPOWBRtqWAL6DXAADFeBomwio444.png"}),Ds])}const qs=o(c,[["render",Cs]]);export{ks as __pageData,qs as default};
