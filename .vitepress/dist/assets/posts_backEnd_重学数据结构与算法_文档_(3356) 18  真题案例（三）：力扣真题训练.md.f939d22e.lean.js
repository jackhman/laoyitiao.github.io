import{_ as o,j as e,o as t,g as c,k as p,h as n,Q as l,s}from"./chunks/framework.a0d18f64.js";const S=JSON.parse('{"title":"18真题案例（三）：力扣真题训练","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学数据结构与算法_文档/(3356) 18  真题案例（三）：力扣真题训练.md","filePath":"posts/backEnd/重学数据结构与算法_文档/(3356) 18  真题案例（三）：力扣真题训练.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/重学数据结构与算法_文档/(3356) 18  真题案例（三）：力扣真题训练.md"},E=l("",17),y=l("",16),i=s("p",null,"经过切分后，两个数组分别被拆分为 3 个部分，合在一起是 6 个部分。二分查找的思路是，需要从这 6 个部分中，剔除掉一些，让查找的范围缩小。那么，我们来思考一个问题，在这 6 个部分中，目标中位数一定不会发生在哪几个部分呢？",-1),F=s("p",null,[s("strong",null,"中位数有一个重要的特质，那就是比中位数小的数字个数，和比中位数大的数字个数，是相等的"),n("。围绕这个性质来看，中位数就一定不会发生在 C 和 D 的区间。")],-1),b=s("p",null,"如果中位数在 C 部分，那么在 nums1 中，比中位数小的数字就会更多一些。因为 4 < 5（nums2 的中位数小于 nums1 的中位数），所以在 nums2 中，比中位数小的数字也会更多一些（最不济也就是一样多）。因此，整体来看，中位数不可能在 C 部分。同理，中位数也不会发生在 D 部分。",-1),g=s("p",null,'接下来，我们就可以在查找范围内，剔除掉 C 部分（永远比中位数大的数字）和 D 部分（永远比中位数小的数字），这样我们就成功地完成了一次二分动作，缩小了查找范围。然而这样并没结束。剔除掉了 C 和 D 之后，中位数有可能发生改变。这是因为，C 部分的数字个数和 D 部分数字的个数是不相等的。剔除不相等数量的"小数"和"大数"后，会造成中位数的改变。',-1),m=s("p",null,"为了解决这个问题，我们需要对剔除的策略进行修改。一个可行的方法是，如果 C 部分数字更少为 p 个，则剔除 C 部分；并只剔除 D 部分中的 p 个数字。这样就能保证，经过一次二分后，剔除之后的数组的中位数不变。",-1),A=l("",11),D=l("",16);function d(u,C,_,h,B,f){const a=e("Image");return t(),c("div",null,[E,p(a,{alt:"1.gif",src:"https://s0.lgstatic.com/i/image/M00/32/E8/CgqCHl8O4AaAIRWPAATuBR6nG1c878.gif"}),n(),y,p(a,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/32/DD/Ciqc1F8O4BWAJgOUAABMJW6Ihfk508.png"}),n(),i,F,b,g,m,p(a,{alt:"3.png",src:"https://s0.lgstatic.com/i/image/M00/32/E8/CgqCHl8O4CKAd3GfAAA88tCPFHQ522.png"}),n(),A,p(a,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image/M00/32/6C/Ciqc1F8Odd-AdDghAAAd2xZYP1g802.png"}),n(),D])}const v=o(r,[["render",d]]);export{S as __pageData,v as default};
