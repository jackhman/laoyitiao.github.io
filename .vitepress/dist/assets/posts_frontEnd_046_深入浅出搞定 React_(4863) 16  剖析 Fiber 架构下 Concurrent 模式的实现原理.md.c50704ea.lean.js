import{_ as o,D as e,o as t,g as r,J as l,h as n,Q as p,m as s}from"./chunks/framework.f67d7268.js";const As=JSON.parse('{"title":"16剖析Fiber架构下Concurrent模式的实现原理","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(4863) 16  剖析 Fiber 架构下 Concurrent 模式的实现原理.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(4863) 16  剖析 Fiber 架构下 Concurrent 模式的实现原理.md","lastUpdated":1696682708000}'),c={name:"posts/frontEnd/046_深入浅出搞定 React/(4863) 16  剖析 Fiber 架构下 Concurrent 模式的实现原理.md"},E=p("",21),y=s("p",null,"每点击数字 0 一下，它的值就会 +1，这就是我们的更新动作。",-1),i=s("h5",{id:"挂载后的-fiber-树",tabindex:"-1"},[n("挂载后的 Fiber 树 "),s("a",{class:"header-anchor",href:"#挂载后的-fiber-树","aria-label":'Permalink to "挂载后的 Fiber 树"'},"​")],-1),u=s("p",null,"关于 Fiber 树的构建过程，前面已经详细讲解过，这里不再重复。下面我直接为你展示挂载时的 render 阶段结束后，commit 执行前，两棵 Fiber 树的形态，如下图所示：",-1),d=s("p",null,"待 commit 阶段完成后，右侧的 workInProgress 树对应的 DOM 树就被真正渲染到了页面上，此时 current 指针会指向 workInProgress 树：",-1),g=s("p",null,'由于挂载是一个从无到有的过程，在这个过程中我们是在不断地创建新节点，因此还谈不上什么"节点复用"。节点复用要到更新过程中去看。',-1),A=s("h5",{id:"第一次更新",tabindex:"-1"},[n("第一次更新 "),s("a",{class:"header-anchor",href:"#第一次更新","aria-label":'Permalink to "第一次更新"'},"​")],-1),F=s("p",null,"现在我点击数字 0，触发一次更新。这次更新中，下图高亮的 rootFiber 节点就会被复用：",-1),h=s("p",null,"这段复用的逻辑在 beginWork 调用链路中的 createWorkInProgress 方法里。这里我为你截取了 createWorkInProgress 方法里面一段非常关键的逻辑，请看下图：",-1),m=s("p",null,"在 createWorkInProgress 方法中，会先取当前节点的 alternate 属性，将其记为 workInProgress 节点。对于 rootFiber 节点来说，它的 alternate 属性，其实就是上一棵 current 树的 rootFiber，如下图高亮部分所示：",-1),k=s("p",null,[s("strong",null,"当检查到上一棵 current 树的 rootFiber 存在时，React 会直接复用这个节点，让它作为下一棵 workInProgress 的节点存在下去"),n("，也就是说会走进 createWorkInProgress 的 else 逻辑里去。如果它和目标的 workInProgress 节点之间存在差异，直接在该节点上修改属性、使其与目标节点一致即可，而不必再创建新的 Fiber 节点。")],-1),_=s("p",null,"至于剩下的 App、div、p 等节点，由于没有对应的 alternate 节点存在，因此它们的 createWorkInProgress 调用会走进下图高亮处的逻辑中：",-1),D=s("p",null,"在这段逻辑里，将调用 createFiber 来新建一个 FiberNode。",-1),C=s("p",null,"第一次更新结束后，我们会得到一棵新的 workInProgress Fiber 树，current 指针最后将会指向这棵新的 workInProgress Fiber 树，如下图所示：",-1),b=s("h5",{id:"第二次更新",tabindex:"-1"},[n("第二次更新 "),s("a",{class:"header-anchor",href:"#第二次更新","aria-label":'Permalink to "第二次更新"'},"​")],-1),T=s("p",null,"接下来我们再次点击数字 1，触发 state 的第二次更新。",-1),q=s("p",null,"在这次更新中，current 树中的每一个 alternate 属性都不为空（如上图所示）。因此每次通过 beginWork 触发 createWorkInProgress 调用时，都会一致地走入 else 里面的逻辑，也就是直接复用现成的节点。",-1),I=s("p",null,'以上便是 current 树和 work 树相互"打配合"，实现节点复用的过程。',-1),f=s("h3",{id:"更新链路要素拆解",tabindex:"-1"},[n("更新链路要素拆解 "),s("a",{class:"header-anchor",href:"#更新链路要素拆解","aria-label":'Permalink to "更新链路要素拆解"'},"​")],-1),w=s("p",null,"在上一讲，我们已经学习了挂载阶段的渲染链路。同步模式下的更新链路与挂载链路的 render 阶段基本是一致的，都是通过 performSyncWorkOnRoot 来触发包括 beginWork、completeWork 在内的深度优先搜索过程。这里我为你展示一个更新过程的调用栈，请看下图：",-1),v=s("p",null,[n("你会发现还是熟悉的配方，还是原来的味道。"),s("strong",null,"其实，挂载可以理解为一种特殊的更新，ReactDOM.render 和 setState 一样，也是一种触发更新的姿势"),n(' 。在 React 中，ReactDOM.render、setState、useState 等方法都是可以触发更新的，这些方法发起的调用链路很相似，是因为它们最后"殊途同归"，'),s("strong",null,"都会通过创建 update 对象来进入同一套更新工作流"),n("。")],-1),B=s("h4",{id:"update-的创建",tabindex:"-1"},[n("update 的创建 "),s("a",{class:"header-anchor",href:"#update-的创建","aria-label":'Permalink to "update 的创建"'},"​")],-1),P=s("p",null,"接下来我继续以开篇的 Demo 为例，为你拆解更新链路中的要素。在点击数字后，点击相关的回调被执行，它首先触发的是 dispatchAction 这个方法，如下图所示：",-1),Q=s("p",null,"请你关注图中两处标红的函数调用，你会看到 dispatchAction 方法在 performSyncWorkOnRoot 的左边。也就是说整体的更新链路应该是这样的：",-1),S=s("p",null,"dispatchAction 中，会完成 update 对象的创建，如下图标红处所示：",-1),R=s("h4",{id:"从-update-对象到-scheduleupdateonfiber",tabindex:"-1"},[n("从 update 对象到 scheduleUpdateOnFiber "),s("a",{class:"header-anchor",href:"#从-update-对象到-scheduleupdateonfiber","aria-label":'Permalink to "从 update 对象到 scheduleUpdateOnFiber"'},"​")],-1),x=s("p",null,"等等，这段逻辑你是否觉得似曾相识？如果你对 ReactDOM.render 系列的第一课时还有印象的话，我希望你能回忆起 updateContainer 这个方法。在 updateContainer 中，React 曾经有过性质一模一样的行为，这里我为你截取了 updateContainer 函数中的相关逻辑：",-1),O=p("",2),M=s("p",null,"现在我们再回过头来看 dispatchAction 的逻辑，你会发现 dispatchAction 里面同样有对这三个动作的处理。上面我对 dispatchAction 的局部截图，包含了对 update 对象的创建和入队处理。dispatchAction 的更新调度动作，在函数的末尾，如下图所示：",-1),W=s("p",null,[n("这里有一个点需要提示一下：dispatchAction 中，"),s("strong",null,"调度的是当前触发更新的节点"),n(" ，这一点和挂载过程需要区分开来。在挂载过程中，updateContainer 会直接调度根节点。其实，对于更新这种场景来说，"),s("strong",null,"大部分的更新动作确实都不是由根节点触发的"),n("，而 render 阶段的起点则是根节点。因此在 scheduleUpdateOnFiber 中，有这样一个方法，见下图标红处：")],-1),L=s("p",null,"markUpdateLaneFromFiberToRoot 将会从当前 Fiber 节点开始，向上遍历直至根节点，并将根节点返回。",-1),H=s("h4",{id:"scheduleupdateonfiber-如何区分同步还是异步",tabindex:"-1"},[n("scheduleUpdateOnFiber 如何区分同步还是异步？ "),s("a",{class:"header-anchor",href:"#scheduleupdateonfiber-如何区分同步还是异步","aria-label":'Permalink to "scheduleUpdateOnFiber 如何区分同步还是异步？"'},"​")],-1),N=s("p",null,"如果你对之前学过的同步渲染链路分析还有印象，相信你对下面这段逻辑不会陌生：",-1),U=p("",8),G=p("",6),Y=s("p",null,"当我使用 ReactDOM.render 来渲染这个长列表时，它的调用栈如下图所示：",-1),j=s("p",null,[n('在这张图中，你就不必再重复去关注 beginWork、completeWork 之流了，请把目光放在调用栈的上层，也就是图中标红的地方------一个不间断的灰色"Task"长条，对浏览器来说就意味着是一个'),s("strong",null,"不可中断"),n("的任务。")],-1),V=s("p",null,[n("在我的浏览器上，这个 Task 的执行时长在 130ms 以上（将鼠标悬浮在 Task 长条上就可以查看执行时长）。而"),s("strong",null,"浏览器的刷新频率为 60Hz，也就是说每 16.6ms 就会刷新一次"),n(" 。在这 16.6ms 里，除了 JS 线程外，渲染线程也是有工作要处理的，"),s("strong",null,"但超长的 Task 显然会挤占渲染线程的工作时间"),n(' ，引起"掉帧"，进而带来卡顿的风险，这也正是第 12 讲中所提到的"'),s("strong",null,"JS 对主线程的超时占用"),n('"问题。')],-1),J=s("p",null,"若将 ReactDOM.render 调用改为 createRoot 调用（即开启 Concurrent 模式），调用栈就会变成下面这样：",-1),K=s("p",null,"请继续将你的注意力放在顶层的 Task 长条上。",-1),$=s("p",null,'你会发现那一个不间断的 Task 长条（大任务），如今像是被"切"过了一样，已经变成了多个断断续续的 Task "短条"（小任务），单个短 Task 的执行时长在我的浏览器中是 5ms 左右。这些短 Task 的工作量加起来，和之前长 Task 工作量是一样的。但短 Task 之间留出的时间缝隙，却给了浏览器喘息的机会，这就是所谓的"时间切片"效果。',-1),z=s("h4",{id:"时间切片是如何实现的",tabindex:"-1"},[n("时间切片是如何实现的？ "),s("a",{class:"header-anchor",href:"#时间切片是如何实现的","aria-label":'Permalink to "时间切片是如何实现的？"'},"​")],-1),X=s("p",null,[n("在同步渲染中，循环创建 Fiber 节点、构建 Fiber 树的过程是由 "),s("strong",null,"workLoopSync"),n(" 函数来触发的。这里我们来复习一下 workLoopSync 的源码，请看下图：")],-1),Z=s("p",null,"在 workLoopSync 中，只要 workInProgress 不为空，while 循环就不会结束，它所触发的是一个同步的 performUnitOfWork 循环调用过程。",-1),ss=s("p",null,[n("而在异步渲染模式下，这个循环是由 "),s("strong",null,"workLoopConcurrent"),n(" 来开启的。workLoopConcurrent 的工作内容和 workLoopSync 非常相似，仅仅在循环判断上有一处不同，请注意下图源码中标红部分：")],-1),ns=p("",4),as=s("p",null,[n('其中 unstable_now 这里实际取的就是 performance.now() 的值，即"'),s("strong",null,"当前时间"),n(' "。那么 deadline 又是什么呢？它可以被理解为'),s("strong",null,"当前时间切片的到期时间"),n("，它的计算过程在 Scheduler 包中的 performWorkUntilDeadline 方法里可以找到，也就是下图的标红部分：")],-1),ls=p("",25),ps=s("p",null,"这张大图需要结合楼上的文字解析一起消化，如果你是跳读至此，还请回到文章中细嚼慢咽~^_^",-1),os=s("h3",{id:"总结",tabindex:"-1"},[n("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),es=s("p",null,'这一讲我们首先认识了"双缓存"模式在 Fiber 架构下的实现，接着对更新链路的种种要素进行了拆解，理解了挂载 / 更新等动作的本质。最后，我们结合源码对 Scheduler（调度器）的核心能力，也就是"时间切片"和"优先级调度"两个方面进行了剖析，最终揭开了 Fiber 架构异步渲染的神秘面纱，理解了 Concurrent 模式背后的实现逻辑。',-1),ts=s("p",null,'到这里，关于 Fiber 架构的探讨，就要告一段落了。下一讲将讲解"特别的事件系统：React 事件与 DOM 事件有何不同"，到时见~',-1);function rs(cs,Es,ys,is,us,ds){const a=e("Image");return t(),r("div",null,[E,l(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GIlaAHn_FAAAchawzt4s009.png"}),n(),y,i,u,l(a,{alt:"图片14.png",src:"https://s0.lgstatic.com/i/image/M00/73/AD/Ciqc1F_GK5KAPsNRAADXbk-KIQg893.png"}),n(),d,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GImqABNjLAACxddF2jhY942.png"}),n(),g,A,F,l(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GInGAAhaiAADrvJFiOdA159.png"}),n(),h,l(a,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/73/AB/CgqCHl_GIneAPBZcAAKQF1HrIv0329.png"}),n(),m,l(a,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/73/A0/Ciqc1F_GIn2AK_7QAADrvJFiOdA218.png"}),n(),k,_,l(a,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image/M00/73/A0/Ciqc1F_GIoSAIIE5AAJG_0ANgrg415.png"}),n(),D,C,l(a,{alt:"Drawing 13.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIouAVjKDAAEwJVqKwHY353.png"}),n(),b,T,q,I,f,w,l(a,{alt:"Drawing 14.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIpSAfb9qAACwnR8L9Po005.png"}),n(),v,B,P,l(a,{alt:"Drawing 15.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIpqAFVQWAAE4Rdg6o0g228.png"}),n(),Q,l(a,{alt:"Drawing 16.png",src:"https://s0.lgstatic.com/i/image/M00/73/A1/Ciqc1F_GIqKAP_3fAABp3EtlwDk160.png"}),n(),S,l(a,{alt:"Drawing 17.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIqiAOf4aAAQVWAWjjt0722.png"}),n(),R,x,l(a,{alt:"Drawing 18.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIrCAJiUaAACZL_H8ts8659.png"}),n(),O,l(a,{alt:"Drawing 19.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIrmAO5UJAABDaDLvIyM528.png"}),n(),M,l(a,{alt:"Drawing 20.png",src:"https://s0.lgstatic.com/i/image/M00/73/AC/CgqCHl_GIsGADUaBAAAYE3Ps56g927.png"}),n(),W,l(a,{alt:"Drawing 21.png",src:"https://s0.lgstatic.com/i/image/M00/73/A1/Ciqc1F_GIseASLuzAAVy6vkOrOA579.png"}),n(),L,H,N,l(a,{alt:"Drawing 22.png",src:"https://s0.lgstatic.com/i/image/M00/73/A1/Ciqc1F_GItCAerpyAAQXnhAd3k4018.png"}),n(),U,l(a,{alt:"Drawing 23.png",src:"https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIt-AVQdjAAEHWIrq_Po945.png"}),n(),G,l(a,{alt:"Drawing 24.png",src:"https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIuyABtYCAABNHJ0zT3I546.png"}),n(),Y,l(a,{alt:"Drawing 25.png",src:"https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIvOALbOqAAOn8pi1lpw155.png"}),n(),j,V,J,l(a,{alt:"Drawing 26.png",src:"https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIvuATEYcAALRQfAuBFI173.png"}),n(),K,$,z,X,l(a,{alt:"Drawing 27.png",src:"https://s0.lgstatic.com/i/image/M00/73/AD/CgqCHl_GIwKAHTjDAACgXrFd5c0290.png"}),n(),Z,ss,l(a,{alt:"Drawing 28.png",src:"https://s0.lgstatic.com/i/image/M00/73/AD/CgqCHl_GIwiAAsOJAADS76o4FHc058.png"}),n(),ns,l(a,{alt:"Drawing 29.png",src:"https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIxeAJas8AAEiY1Hfbsw871.png"}),n(),as,l(a,{alt:"Drawing 30.png",src:"https://s0.lgstatic.com/i/image/M00/73/A2/Ciqc1F_GIx-AL94QAAHs2HJQXfA804.png"}),n(),ls,l(a,{alt:"Drawing 32.png",src:"https://s0.lgstatic.com/i/image/M00/73/AE/CgqCHl_GIzeAHilIAAFT8rmskL8314.png"}),n(),ps,os,es,ts])}const Fs=o(c,[["render",rs]]);export{As as __pageData,Fs as default};
