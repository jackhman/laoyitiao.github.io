import{_ as l,j as p,o as t,g as s,k as i,h as o,Q as a}from"./chunks/framework.cfb14fe0.js";const m=JSON.parse('{"title":"第01讲：工作累积的最常用Shell命令合集及使用技巧","description":"","frontmatter":{},"headers":[],"relativePath":"posts/devops/111-运维高手的36项修炼文档/(1546) 第01讲：工作累积的最常用 Shell 命令合集及使用技巧.md","filePath":"posts/devops/111-运维高手的36项修炼文档/(1546) 第01讲：工作累积的最常用 Shell 命令合集及使用技巧.md","lastUpdated":1696682708000}'),r={name:"posts/devops/111-运维高手的36项修炼文档/(1546) 第01讲：工作累积的最常用 Shell 命令合集及使用技巧.md"},n=a('<h1 id="第01讲-工作累积的最常用shell命令合集及使用技巧" tabindex="-1">第01讲：工作累积的最常用Shell命令合集及使用技巧 <a class="header-anchor" href="#第01讲-工作累积的最常用shell命令合集及使用技巧" aria-label="Permalink to &quot;第01讲：工作累积的最常用Shell命令合集及使用技巧&quot;">​</a></h1><p>在本课时我们主要讲解 Shell 命令合集，以及对控制台的使用技巧。在正式学习这个课时之前你需要掌握如下三部分的知识内容：</p><ul><li><p>需要熟悉掌握 Linux；</p></li><li><p>需要了解一些 Shell 基础，课时中会介绍一些常见的 Shell 命令合集；</p></li><li><p>需要了解 TCP 三次握手原理，这个课时的 Shell 命令合集包含对计算机进行网络分析。</p></li></ul><h2 id="控制台使用技巧" tabindex="-1">控制台使用技巧 <a class="header-anchor" href="#控制台使用技巧" aria-label="Permalink to &quot;控制台使用技巧&quot;">​</a></h2><p>首先，我们来学习控制台的使用技巧，学习掌握控制台的使用技巧后可以帮助我们熟练快速地操作控制台，提高工作效率；还可以通过快捷键方式避免大量的命令输入，减少出错产生的概率。</p><br><p>那么都有哪些快捷键供我们使用呢，基于我的运维工作经验给你汇总如下：</p><ul><li><p>操作快捷键</p><ul><li><p>Ctrl + r：可以快速查找历史命令；</p></li><li><p>Ctrl + l：可以清理控制台屏幕；</p></li><li><p>Ctrl + a \\ Ctrl + e：移动光标到命令行首\\行尾；</p></li><li><p>Ctrl + w \\ Ctrl + k：删除光标之前\\之后的内容。</p></li></ul></li><li><p>VIM文件编辑快捷键</p><ul><li>快捷键ZZ：文件保存并退出。</li></ul></li><li><p>进程操作快捷键</p><ul><li><p>Ctrl + c：强制终止程序的执行；</p></li><li><p>Ctrl + z：挂起一个进程；</p></li><li><p>Ctrl + d：终端中输入 exit 后回车。</p></li></ul></li><li><p>linux命令中快捷键（top）</p><ul><li><p>Shift + p：根据 CPU 使用率排序；</p></li><li><p>Shift + m：根据内存占用排序。</p></li></ul></li></ul><h2 id="shell-命令合集" tabindex="-1">Shell 命令合集 <a class="header-anchor" href="#shell-命令合集" aria-label="Permalink to &quot;Shell 命令合集&quot;">​</a></h2><p>熟练掌握相关快捷键后，我们便进入 Shell 命令合集的学习，在这一部分需要你根据课时中所讲的知识在课后进行相关操作的练习，练习过程中希望你可以应用上面所讲的控制台使用技巧。</p><br><p>需要注意的是这里的 Shell 命令合集不是简单的单一命令使用，而是讲解 Shell 命令组合的使用，它们的适用场景虽然平时可能很少用到，但通过本课时的学习你能够在遇到此类场景时能够得心应手，而不必临时查找或根据经验拼凑，同时期望通过这些组合命令的学习后你对对基础命令的理解可以得到进一步的提升。</p><br><p>首先，我们需要对 Shell 命令合集做一个分类。</p><ul><li><p>空间分析</p><ul><li><p>场景1：磁盘空间不足，需快速定位日志目录；</p></li><li><p>场景2：系统产生很多碎片文件，导致 inode 资源不足。</p></li></ul></li><li><p>指定文件操作</p><ul><li><p>场景1：批量查找文件作内容替换；</p></li><li><p>场景2：批量查找文件作拷贝打包。</p></li></ul></li><li><p>链接状态分析</p><ul><li>场景：想了解用户请求所建立的网络连接状态分析。</li></ul></li><li><p>IP 信息提取</p><ul><li>场景：shell 脚本中希望快速提取到本机 IP。</li></ul></li></ul><h3 id="空间分析-场景1" tabindex="-1">空间分析-场景1 <a class="header-anchor" href="#空间分析-场景1" aria-label="Permalink to &quot;空间分析-场景1&quot;">​</a></h3><p>该场景主要应用于当磁盘空间不足，需要快速定位或者对文件使用率进行排序，需要查看哪一些文件目录或者文件占用的空间比较多，就需要如下组合命令。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">du -x --max-depth=1 / |sort -k1 -nr</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">du -x --max-depth=1 / |sort -k1 -nr</span></span></code></pre></div><br><p>我们可以看到这一个命令组合由两个 Shell 命令组成，前面的 du 命令进行磁盘统计，第二个 sort 命令对统计后的数据进行排序，中间通过 | 管道符来传递数据。管道符 | 的作用是将前一个命令的输出传递到下一个命令的输入。</p><br><p>du 命令中 -x 参数表示跳过其他文件系统，也就是只分析本文件系统里的文件，它可以帮助我们排除一些非本文件系统的统计信息，这样执行速度会更快也不容易出现一些额外的干扰项。--max-depth 参数设置为 1，这样就可以统计出根目录下第一级目录中的所有文件的大小。第二个命令sort中 -k 参数指明具体按照哪一列进行排序，-n 参数表示只对数值进行排序，而 -r 参数表示反向排序，那整体分析sort 这一段命令的意思就是指定第一列并按照数据大小做反序排序。</p><h3 id="空间分析-场景2" tabindex="-1">空间分析-场景2 <a class="header-anchor" href="#空间分析-场景2" aria-label="Permalink to &quot;空间分析-场景2&quot;">​</a></h3><p>场景 2 适用于系统上产生很多碎片文件时，随之产生大量的 Inode ， Inode 用于存放着文件系统中文件的源数据，Inode过渡的使用会导致系统 Inode 资源不足。这种情况是不正常的，这个时候分析如果通过du 命令指能具体展示出磁盘空间的使用情况，但并不能分析出具体目录下产生了多少碎片文件，我们就需要如下的命令组合来对文件进行统计分析。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">find -type f|awk -F/-v OFS=/&#39;{$NF=&quot;&quot;;dir[$0]++}END{for(i in dir)print dir[i]&quot;&quot;i}&#39;|sort -k1 -nr|head</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">find -type f|awk -F/-v OFS=/&#39;{$NF=&quot;&quot;;dir[$0]++}END{for(i in dir)print dir[i]&quot;&quot;i}&#39;|sort -k1 -nr|head</span></span></code></pre></div><br><p>基于管道可以将这个命令组合切割成四部分，分别是 find、awk、sort、head 命令。</p><br><p>其中 find 命令通过 -type -f 参数查找指定文件类型的文件，然后将查找结果通过管道传递给 awk，它可以把文本内容按行进行格式化输出并展示，-F / 指定处理文件时字符串之间以 / 进行分割，-v OFS=/ 表示文件显示结果时以 / 进行分割展示。对于awk命令整体规则而言有一个 {} END {} 格式，前面的 {} 表示行处理操作，END{} 表示行处理后需要进行整体结果出。在行处理操作逻辑中，设置$NF 为空表示将每一行的文件名信息去除，从而只保留目录路径，dir 是一个自增数组，用于统计结果。最后通过 for 循环进行遍历输出dir关联数组中所有行信息。</p><br><p>因为这个命令组合比较复杂，我们在控制台中来看具体的演示，首先在控制台中输入这一串命令组合。</p>',33),c=a('<p>你可以看到在当前目录路径通过执行命令，结果中已经把每一个产生文件的路径都展示出来了，并且前面还会显示在每一个路径下一共包含了多少文件，如果我们系统 提示inode 使用率问题，需要分析出哪个路径下的文件数最多，这时就可以通过 这个组合命令来进行分析。</p><h3 id="文件操作-场景1" tabindex="-1">文件操作-场景1 <a class="header-anchor" href="#文件操作-场景1" aria-label="Permalink to &quot;文件操作-场景1&quot;">​</a></h3><p>文件操作的场景主要有两个，第一个场是批量文件内容需要进行替换，也就是当我们在一个文件目录下面有多级子目录，并且子目录中有大量的文件，而我们需要对目录下的某一个名称的文件批量的查找替换内容。面对这种场景我们可以使用如下的组合命令：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">find ./-type f -name consumer.xml -exec sed -i&quot;s/aaaaaa/bbbbbb/g&quot;{}\\;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">find ./-type f -name consumer.xml -exec sed -i&quot;s/aaaaaa/bbbbbb/g&quot;{}\\;</span></span></code></pre></div><br><p>我们通过 find + 路径 的方式查找需要批量修改的指定的文件名，比如命令中的 consumer.xml 文件，查找到文件后通过 find 自带的参数 exec 将结果传递给另外一条命令 sed 来进行下一步命令的处理。</p><br><p>find 命令中，-name 参数指定查找的文件名，-exec 参数将查找到的内容传递给下一个命令去继续执行相关逻辑，sed 命令主要对文件内容进行替换，这里会将 consumer 文件中的 aaaaaa 替换成 bbbbbb，这就是一个批量查找替换的操作。</p><h3 id="文件操作-场景2" tabindex="-1">文件操作-场景2 <a class="header-anchor" href="#文件操作-场景2" aria-label="Permalink to &quot;文件操作-场景2&quot;">​</a></h3><p>文件操作的第二种场景是我们需要对文件进行批量的打包、拷贝，你可以看到下面这样的一个组合命令：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">(find . -name &quot;*.txt&quot;|xargs tar -cvf test.tar) &amp;&amp; cp -f test.tar /home/.</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">(find . -name &quot;*.txt&quot;|xargs tar -cvf test.tar) &amp;&amp; cp -f test.tar /home/.</span></span></code></pre></div><br><p>首先我们来看下括号中的部分，括号中包含两条命令，它们使用管道符进行连接，括号外通过&quot;&amp;&amp;&quot;符号与第三条命令进行连接，也就是我们首先需要执行括号中的组合命令，先查找所有 .txt 文件，然后将结果传递给 xargs 命令进行打包，如果打包成功后才将压缩包传递给 cp 命令进行拷贝。</p><h3 id="网络连接状态分析" tabindex="-1">网络连接状态分析 <a class="header-anchor" href="#网络连接状态分析" aria-label="Permalink to &quot;网络连接状态分析&quot;">​</a></h3><p>对于网络连接状态分析是运维工程师经常需要做的事情，因为我们经常需要了解系统对外提供的网络服务是否正常，并了解它们的连接状态，这时就可以通过如下的命令组合进行操作：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</span></span></code></pre></div><br><p>我们先来分析下这个命令组合的构成，整体上来说它由两个命令构成，第一个命令是 netstat -n，这个命令负责查看主机上的所有 TCP、UDP 连接信息，而 awk 命令则负责对这些信息进行进一步的处理，awk 后有一个用两个 &quot;斜杠&quot; 括起来的正则表达式，主要用来匹配以 tcp 开头的每一行信息，所以这里的正则表达式起到了一个过滤的作用（只分析tcp的连接），后面则是对信息过滤后进行具体的统计和输出。</p><h3 id="ip信息提取" tabindex="-1">IP信息提取 <a class="header-anchor" href="#ip信息提取" aria-label="Permalink to &quot;IP信息提取&quot;">​</a></h3><p>而另外一个场景就是提取主机上的 IP 信息，这里推荐使用如下的命令组合：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">ip a|grep &quot;global&quot;|awk&#39;{print $2}&#39;|awk -F/&#39;{print $1}&#39;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">ip a|grep &quot;global&quot;|awk&#39;{print $2}&#39;|awk -F/&#39;{print $1}&#39;</span></span></code></pre></div><br><p>可以看到它的结构组成也比较简单，分别是由四个命令组合而成，前面的 ip a 负责查看主机上所有网卡的信息，然后通过 grep 进行条件过滤，再通过 awk 实现第二列内容输出，最后通过 awk 以指定 / 作为分隔符来打印第一列的信息。</p><h2 id="常见问题答疑" tabindex="-1">常见问题答疑 <a class="header-anchor" href="#常见问题答疑" aria-label="Permalink to &quot;常见问题答疑&quot;">​</a></h2><p>最后，分享一下 对Shell 常有的几个疑问。</p><br><p>问题一：Shell 适不适合作多并发任务？</p><br><p>答案：不适合，在 Shell 中一般需要通过 nohup 方式将需要并发执行的命令放入后台，但这样操作存在一些问题，包括：</p><ul><li><p>进程的状态不好控制；</p></li><li><p>进程间信息共享一般以文件方式。</p></li></ul><p>等等，所以，我们当需要进行大的自动化工程任务需要作并发任务时，建议选择 Python、Go、PHP 等语言。</p><br><p>问题二：Shell 的远程执行命令方式是什么？</p><br><p>答案：当 Shell 进行远程执行命令时，通常通过 ssh <a href="mailto:xx@xxx.xxx.xxx.xxx" target="_blank" rel="noreferrer">xx@xxx.xxx.xxx.xxx</a> /home/ieson/imoocc.sh 参数的方式，但如果是批量主机任务，建议选择 ansible、saltstack 这样成熟且专业的工具实现。</p><br><p>问题三：Shell 适合用在什么场景中？</p><br><p>答案：Shell 适合用在追求运维高效（非性能高效）要求的简单场景中，如日志切割、进程分析、系统初始化等。</p><br><p>本专栏课中的所有案例配置及源代码，可以课后通过<a href="http://www.jesonc.com/jeson/2020/02/07/ywgs36/" target="_blank" rel="noreferrer">http://www.jesonc.com/jeson/2020/02/07/ywgs36/</a>自己下载，密码为 mukelaoshi。</p>',45);function d(h,u,b,_,g,x){const e=p("Image");return t(),s("div",null,[n,i(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/65/4A/CgpOIF5BIhKADtFGAANv__aeR0g437.png"}),o(),c])}const f=l(r,[["render",d]]);export{m as __pageData,f as default};
