import{_ as l,j as t,o as e,g as r,k as o,h as s,Q as p,s as n}from"./chunks/framework.b3d8e22e.js";const B=JSON.parse('{"title":"实现无主架构的任务 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6140) 15  数据库与缓存的扩展升级与扣减返还.md","filePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6140) 15  数据库与缓存的扩展升级与扣减返还.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/23讲搞定后台架构实战_文档/(6140) 15  数据库与缓存的扩展升级与扣减返还.md"},E=p("",5),y=p("",6),i=p("",7),_=p("",26),d=n("p",null,"图 4：超返还的场景",-1),u=n("p",null,[n("strong",null,"对于上述潜在的风险，可以在返还前，对返还所属的扣减 ID 进行加锁来保证串行化操作，规避超卖的风险"),s("，架构如下图 5 所示：")],-1),g=n("p",null,"图 5：加锁串行的架构",-1),F=n("p",null,'在扣减 ID 上加锁，会导致该扣减 ID 下的所有返还都串行执行，有一定的性能损耗。但从业务上看，同一个扣减 ID 并发产生返还的场景极低且返还的调用次数也相对较少，从"架构是技术与业务场景的取舍"这个角度来看，暂不需要花费太大的人力去构建一个更加复杂的加锁架构。',-1),m=n("p",null,[n("strong",null,"原则四：返还要保证幂等")],-1),k=n("p",null,[s("最后，设计的返还接口需要支持幂等性。比如外部系统调用返还接口超时后，因为外部系统不知道是否调用成功，就会再一次重试。如果返还接口不满足幂等性要求，且上次超时实际是执行成功的，则会导致同一个返还号产生两次数据的返还。处理这个问题最简单的做法是："),n("strong",null,"在返还接口增加返还编号（上述表结构中的 return_uuid）字段并由外部系统传入，通过数据库唯一索引来防重，进而实现幂等性"),s("，大致的架构如下图 6 所示：")],-1),A=p("",7);function h(D,b,W,C,I,T){const a=t("Image");return e(),r("div",null,[E,o(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M01/09/8F/Cgp9HWA2Hv-AengkAAFbqrm50e0510.png"}),s(),y,o(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M01/09/8F/Cgp9HWA2HxeAByWyAAG_vLMo_ro146.png"}),s(),i,o(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image6/M01/09/8F/Cgp9HWA2HyuAXQFcAAGDTC7m15w249.png"}),s(),_,o(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image6/M01/09/8B/CioPOWA2H0SAMz2jAAC7KdMVEvk472.png"}),s(),d,u,o(a,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image6/M01/09/8B/CioPOWA2H0yAKRa9AADfr4I_Js8310.png"}),s(),g,F,m,k,o(a,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image6/M00/09/8F/Cgp9HWA2H1iALPaJAAC9S3IhS1w174.png"}),s(),A])}const v=l(c,[["render",h]]);export{B as __pageData,v as default};
