import{_ as t,j as p,o,g as r,k as l,h as a,Q as e,s}from"./chunks/framework.4e7d56ce.js";const H=JSON.parse('{"title":"第14讲：预警与解决：深入浅出GC监控与调优","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1038) 第14讲：预警与解决：深入浅出 GC 监控与调优.md","filePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1038) 第14讲：预警与解决：深入浅出 GC 监控与调优.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1038) 第14讲：预警与解决：深入浅出 GC 监控与调优.md"},i=e(`<h1 id="第14讲-预警与解决-深入浅出gc监控与调优" tabindex="-1">第14讲：预警与解决：深入浅出GC监控与调优 <a class="header-anchor" href="#第14讲-预警与解决-深入浅出gc监控与调优" aria-label="Permalink to &quot;第14讲：预警与解决：深入浅出GC监控与调优&quot;">​</a></h1><p>本课时我们主要讲解深入浅出 GC 监控与调优。</p><br><p>在前面的课时中不止一次谈到了监控，但除了 GC Log，大多数都是一些&quot;瞬时监控&quot;工具，也就是看到的问题，基本是当前发生的。</p><br><p>你可能见过在地铁上抱着电脑处理故障的照片，由此可见，大部分程序员都是随身携带电脑的，它体现了两个问题：第一，自动化应急处理机制并不完善；第二，缺乏能够跟踪定位问题的工具，只能靠&quot;苦力&quot;去解决。</p><br><p>我们在前面第 11 课时中提到的一系列命令，就是一个被分解的典型脚本，这个脚本能够在问题发生的时候，自动触发并保存顺时态的现场。除了这些工具，我们还需要有一个与时间序列相关的监控系统。<strong>这就是监控工具的必要性</strong>。</p><br><p>我们来盘点一下对于问题的排查，现在都有哪些资源：</p><ul><li><p>GC 日志，能够反映每次 GC 的具体状况，可根据这些信息调整一些参数及容量；</p></li><li><p>问题发生点的堆快照，能够在线下找到具体内存泄漏的原因；</p></li><li><p>问题发生点的堆栈信息，能够定位到当前正在运行的业务，以及一些死锁问题；</p></li><li><p>操作系统监控，比如 CPU 资源、内存、网络、I/O 等，能够看到问题发生前后整个操作系统的资源状况；</p></li><li><p>服务监控，比如服务的访问量、响应时间等，可以评估故障堆服务的影响面，或者找到一些突增的流量来源；</p></li><li><p>JVM 各个区的内存变化、GC 变化、耗时等监控，能够帮我们了解到 JVM 在整个故障周期的时间跨度上，到底发生了什么。</p></li></ul><br><p>在实践课时中，我们也不止一次提到，优化和问题排查是一个综合的过程。故障相关信息越多越好，哪怕是同事不经意间透露的一次压测信息，都能够帮助你快速找到问题的根本。</p><br><p>本课时将以一个实际的监控解决方案，来看一下监控数据是怎么收集和分析的。使用的工具主要集中在 Telegraf、InfluxDB 和 Grafana 上，如果你在用其他的监控工具，思路也是类似的。</p><h2 id="监控指标" tabindex="-1">监控指标 <a class="header-anchor" href="#监控指标" aria-label="Permalink to &quot;监控指标&quot;">​</a></h2><p>在前面的一些示例代码中，会看到如下的 JMX 代码片段：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">static void memPrint() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        for (MemoryPoolMXBean memoryPoolMXBean : ManagementFactory.getMemoryPoolMXBeans()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            System.out.println(memoryPoolMXBean.getName() +</span></span>
<span class="line"><span style="color:#E1E4E8;">                    &quot;  committed:&quot; + memoryPoolMXBean.getUsage().getCommitted() +</span></span>
<span class="line"><span style="color:#E1E4E8;">                    &quot;  used:&quot; + memoryPoolMXBean.getUsage().getUsed());</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">static void memPrint() {</span></span>
<span class="line"><span style="color:#24292E;">        for (MemoryPoolMXBean memoryPoolMXBean : ManagementFactory.getMemoryPoolMXBeans()) {</span></span>
<span class="line"><span style="color:#24292E;">            System.out.println(memoryPoolMXBean.getName() +</span></span>
<span class="line"><span style="color:#24292E;">                    &quot;  committed:&quot; + memoryPoolMXBean.getUsage().getCommitted() +</span></span>
<span class="line"><span style="color:#24292E;">                    &quot;  used:&quot; + memoryPoolMXBean.getUsage().getUsed());</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div><br><p>这就是 JMX 的作用。除了使用代码，通过 <strong>jmc</strong>工具也可以简单地看一下它们的值（前面提到的 VisualVM 通过安装插件，也可以看到这些信息）。</p><br><p>新版本的 JDK 不再包含 jmc 这个工具，<a href="https://jdk.java.net/jmc/" target="_blank" rel="noreferrer">可点击这里自行下载</a>。</p><br><p>如下图所示，可以看到一个 Java 进程的资源概览，包括内存、CPU、线程等。</p>`,25),d=s("br",null,null,-1),g=s("p",null,"下图是切换到 MBean 选项卡之后的截图，可以看到图中展示的 Metaspace 详细信息。",-1),m=s("br",null,null,-1),E=s("br",null,null,-1),u=s("p",null,[a("jmc 还是一个性能分析平台，可以录制、收集正在运行的 Java 程序的诊断数据和概要分析数据，感兴趣的可以自行探索。但还是那句话，线上环境可能没有条件让我们使用一些图形化分析工具，相对比 "),s("strong",null,"Arthas"),a("这样的命令行工具就比较吃香。")],-1),y=s("br",null,null,-1),h=s("p",null,"比如，下图就是一个典型的互联网架构图，真正的服务器可能是一群 docker 实例，如果自己的机器想要访问 JVM 的宿主机器，则需要配置一些复杂的安全策略和权限开通。图像化的工具在平常的工作中**不是非常有用，**而且，由于性能损耗和安全性的考虑，也不会让研发主动去通过 JMX 连接这些机器。",-1),_=s("br",null,null,-1),b=s("p",null,"所以面试的时候如果你一直在提一些图形化工具，面试官只能无奈的笑笑，这个话题也无法进行下去了。",-1),f=s("br",null,null,-1),v=e(`<br><p>在必要的情况下，JMX 还可以通过加上一些参数，进行远程访问。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">-Djava.rmi.server.hostname=127.0.0.1</span></span>
<span class="line"><span style="color:#E1E4E8;">-Dcom.sun.management.jmxremote </span></span>
<span class="line"><span style="color:#E1E4E8;">-Dcom.sun.management.jmxremote.port=14000 </span></span>
<span class="line"><span style="color:#E1E4E8;">-Dcom.sun.management.jmxremote.ssl=false </span></span>
<span class="line"><span style="color:#E1E4E8;">-Dcom.sun.management.jmxremote.authenticate=false</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">-Djava.rmi.server.hostname=127.0.0.1</span></span>
<span class="line"><span style="color:#24292E;">-Dcom.sun.management.jmxremote </span></span>
<span class="line"><span style="color:#24292E;">-Dcom.sun.management.jmxremote.port=14000 </span></span>
<span class="line"><span style="color:#24292E;">-Dcom.sun.management.jmxremote.ssl=false </span></span>
<span class="line"><span style="color:#24292E;">-Dcom.sun.management.jmxremote.authenticate=false</span></span></code></pre></div><br><p>无论是哪种方式，我们发现每个内存区域，都有四个值：init、used、committed 和 max，下图展示了它们之间的大小关系。</p><br>`,7),k=e('<br><p>以堆内存大小来说：</p><ul><li><p>-Xmx 就是 max</p></li><li><p>-Xms 就是 init</p></li><li><p>committed 指的是当前可用的内存大小，它的大小包括已经使用的内存</p></li><li><p>used 指的是实际被使用的内存大小，它的值总是小于 committed</p></li></ul><br><p>如果在启动的时候，指定了 -Xmx = -Xms，也就是初始值和最大值是一样的，可以看到这四个值，只有 used 是变动的。</p><h2 id="jolokia" tabindex="-1">Jolokia <a class="header-anchor" href="#jolokia" aria-label="Permalink to &quot;Jolokia&quot;">​</a></h2><p>单独看这些 JMX 的瞬时监控值，是没有什么用的，需要使用程序收集起来并进行分析。</p><br><p>但是 JMX 的客户端 API 使用起来非常的不方便，Jolokia 就是一个将 JMX 转换成 HTTP 的适配器，方便了 JMX 的使用。</p><br>',10),C=s("br",null,null,-1),x=s("p",null,"Jokokia 可以通过 jar 包和 agent 的方式启动，在一些框架中，比如 Spring Boot 中，很容易进行集成。",-1),A=s("br",null,null,-1),M=s("p",null,[a("访问 "),s("a",{href:"http://start.spring.io",target:"_blank",rel:"noreferrer"},[s("strong",null,"http://start.spring.io")]),a("，生成一个普通的 Spring Boot 项目。")],-1),j=s("br",null,null,-1),T=e(`<br><p>直接在 pom 文件里加入 jolokia 的依赖。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#FDAEB7;font-style:italic;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#FDAEB7;font-style:italic;">groupId</span><span style="color:#E1E4E8;">&gt;org.springframework.boot&lt;/</span><span style="color:#FDAEB7;font-style:italic;">groupId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#FDAEB7;font-style:italic;">artifactId</span><span style="color:#E1E4E8;">&gt;spring-boot-starter-actuator&lt;/</span><span style="color:#FDAEB7;font-style:italic;">artifactId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#FDAEB7;font-style:italic;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#FDAEB7;font-style:italic;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#FDAEB7;font-style:italic;">groupId</span><span style="color:#E1E4E8;">&gt;org.jolokia&lt;/</span><span style="color:#FDAEB7;font-style:italic;">groupId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        &lt;</span><span style="color:#FDAEB7;font-style:italic;">artifactId</span><span style="color:#E1E4E8;">&gt;jolokia-core&lt;/</span><span style="color:#FDAEB7;font-style:italic;">artifactId</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#FDAEB7;font-style:italic;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#B31D28;font-style:italic;">dependency</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        &lt;</span><span style="color:#B31D28;font-style:italic;">groupId</span><span style="color:#24292E;">&gt;org.springframework.boot&lt;/</span><span style="color:#B31D28;font-style:italic;">groupId</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        &lt;</span><span style="color:#B31D28;font-style:italic;">artifactId</span><span style="color:#24292E;">&gt;spring-boot-starter-actuator&lt;/</span><span style="color:#B31D28;font-style:italic;">artifactId</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#B31D28;font-style:italic;">dependency</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#B31D28;font-style:italic;">dependency</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        &lt;</span><span style="color:#B31D28;font-style:italic;">groupId</span><span style="color:#24292E;">&gt;org.jolokia&lt;/</span><span style="color:#B31D28;font-style:italic;">groupId</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        &lt;</span><span style="color:#B31D28;font-style:italic;">artifactId</span><span style="color:#24292E;">&gt;jolokia-core&lt;/</span><span style="color:#B31D28;font-style:italic;">artifactId</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#B31D28;font-style:italic;">dependency</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><br><p>在 <strong>application.yml</strong>中简单地加入一点配置，就可以通过 HTTP 接口访问 JMX 的内容了。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">management:</span></span>
<span class="line"><span style="color:#E1E4E8;">  endpoints:</span></span>
<span class="line"><span style="color:#E1E4E8;">    web:</span></span>
<span class="line"><span style="color:#E1E4E8;">      exposure:</span></span>
<span class="line"><span style="color:#E1E4E8;">        include: jolokia</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">management:</span></span>
<span class="line"><span style="color:#24292E;">  endpoints:</span></span>
<span class="line"><span style="color:#24292E;">    web:</span></span>
<span class="line"><span style="color:#24292E;">      exposure:</span></span>
<span class="line"><span style="color:#24292E;">        include: jolokia</span></span></code></pre></div><br><p>你也可以直接下载仓库中的 <strong>monitor-demo</strong>项目，启动后访问 8084 端口，即可获取 JMX 的 json 数据。访问链接 /demo 之后，会使用 guava 持续产生内存缓存。</p><br><p>接下来，我们将收集这个项目的 JMX 数据。</p><br>`,13),X=e('<br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">http://localhost:8084/actuator/jolokia/list</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">http://localhost:8084/actuator/jolokia/list</span></span></code></pre></div><br><p>附上仓库地址：<a href="https://gitee.com/xjjdog/jvm-lagou-res" target="_blank" rel="noreferrer">https://gitee.com/xjjdog/jvm-lagou-res</a>。</p><h2 id="jvm-监控搭建" tabindex="-1">JVM 监控搭建 <a class="header-anchor" href="#jvm-监控搭建" aria-label="Permalink to &quot;JVM 监控搭建&quot;">​</a></h2><p>我们先简单看一下 JVM 监控的整体架构图：</p>',6),P=e(`<br><p>JVM 的各种内存信息，会通过 JMX 接口进行暴露；Jolokia 组件负责把 JMX 信息翻译成容易读取的 HTTP 请求。</p><br><p>telegraf 组件作为一个通用的监控 agent，和 JVM 进程部署在同一台机器上，通过访问转化后的 HTTP 接口，以固定的频率拉取监控信息；然后把这些信息存放到 influxdb 时序数据库中；最后，通过高颜值的 Grafana 展示组件，设计 JVM 监控图表。</p><br><p>整个监控组件是可以热拔插的，并不会影响原有服务。监控部分也是可以复用的，比如 telegraf 就可以很容易的进行操作系统监控。</p><h3 id="influxdb" tabindex="-1">influxdb <a class="header-anchor" href="#influxdb" aria-label="Permalink to &quot;influxdb&quot;">​</a></h3><p>influxdb 是一个性能和压缩比非常高的时序数据库，在中小型公司非常流行，<a href="https://www.influxdata.com/get-influxdb/" target="_blank" rel="noreferrer">点击这里可获取 influxdb</a>。</p><br><p>在 CentOS 环境中，可以使用下面的命令下载。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">wget -c https://dl.influxdata.com/influxdb/releases/influxdb-1.7.9_linux_amd64.tar.gz</span></span>
<span class="line"><span style="color:#E1E4E8;">tar xvfz influxdb-1.7.9_linux_amd64.tar.gz</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">wget -c https://dl.influxdata.com/influxdb/releases/influxdb-1.7.9_linux_amd64.tar.gz</span></span>
<span class="line"><span style="color:#24292E;">tar xvfz influxdb-1.7.9_linux_amd64.tar.gz</span></span></code></pre></div><br><p>解压后，然后使用 nohup 进行启动。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">nohup ./influxd &amp;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">nohup ./influxd &amp;</span></span></code></pre></div><br><p>InfluxDB 将在 8086 端口进行监听。</p><h3 id="telegraf" tabindex="-1">Telegraf <a class="header-anchor" href="#telegraf" aria-label="Permalink to &quot;Telegraf&quot;">​</a></h3><p>Telegraf 是一个监控数据收集工具，支持非常丰富的监控类型，其中就包含内置的 Jolokia 收集器。</p><br><p>接下来，下载并安装 Telegraf：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">wget -c https://dl.influxdata.com/telegraf/releases/telegraf-1.13.1-1.x86_64.rpm</span></span>
<span class="line"><span style="color:#E1E4E8;">sudo yum localinstall telegraf-1.13.1-1.x86_64.rpm</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">wget -c https://dl.influxdata.com/telegraf/releases/telegraf-1.13.1-1.x86_64.rpm</span></span>
<span class="line"><span style="color:#24292E;">sudo yum localinstall telegraf-1.13.1-1.x86_64.rpm</span></span></code></pre></div><p>Telegraf 通过 jolokia 配置收集数据相对简单，比如下面就是收集堆内存使用状况的一段配置。</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">[[inputs.jolokia2_agent.metric]]</span></span>
<span class="line"><span style="color:#E1E4E8;">    name  = &quot;jvm&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    field_prefix = &quot;Memory_&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    mbean = &quot;java.lang:type=Memory&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">    paths = [&quot;HeapMemoryUsage&quot;, &quot;NonHeapMemoryUsage&quot;, &quot;ObjectPendingFinalizationCount&quot;]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">[[inputs.jolokia2_agent.metric]]</span></span>
<span class="line"><span style="color:#24292E;">    name  = &quot;jvm&quot;</span></span>
<span class="line"><span style="color:#24292E;">    field_prefix = &quot;Memory_&quot;</span></span>
<span class="line"><span style="color:#24292E;">    mbean = &quot;java.lang:type=Memory&quot;</span></span>
<span class="line"><span style="color:#24292E;">    paths = [&quot;HeapMemoryUsage&quot;, &quot;NonHeapMemoryUsage&quot;, &quot;ObjectPendingFinalizationCount&quot;]</span></span></code></pre></div><p>设计这个配置文件的主要难点在于对 JVM 各个内存分区的理解。由于配置文件比较长，可以参考仓库中的 jvm.conf 和 sys.conf，你可以把这两个文件，复制到 **/etc/telegraf/telegraf.d/**目录下面，然后执行 systemctl restart telegraf 重启 telegraf。</p><h3 id="grafana" tabindex="-1">grafana <a class="header-anchor" href="#grafana" aria-label="Permalink to &quot;grafana&quot;">​</a></h3><p>grafana 是一个颜值非常高的监控展示组件，支持非常多的数据源类型，对 influxdb 的集成度也比较高，可通过以下地址进行下载：<a href="https://grafana.com/grafana/download" target="_blank" rel="noreferrer">https://grafana.com/grafana/download</a></p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">wget -c https://dl.grafana.com/oss/release/grafana-6.5.3.linux-amd64.tar.gz</span></span>
<span class="line"><span style="color:#E1E4E8;">tar -zxvf grafana-6.5.3.linux-amd64.tar.gz</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">wget -c https://dl.grafana.com/oss/release/grafana-6.5.3.linux-amd64.tar.gz</span></span>
<span class="line"><span style="color:#24292E;">tar -zxvf grafana-6.5.3.linux-amd64.tar.gz</span></span></code></pre></div><br><p>下面是我已经做好的一张针对于 CMS 垃圾回收器的监控图，你可以导入 grafana-jvm-influxdb.json 文件进行测试。</p><br>`,35),q=s("br",null,null,-1),D=s("p",null,"在导入之前，还需要创建一个数据源，选择 influxdb，填入 db 的地址即可。",-1),B=s("br",null,null,-1),J=e(`<h3 id="集成" tabindex="-1">集成 <a class="header-anchor" href="#集成" aria-label="Permalink to &quot;集成&quot;">​</a></h3><p>把我们的 Spring Boot 项目打包（见仓库），然后上传到服务器上去执行。</p><br><p>打包方式：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">mvn package -Dmaven.tesk.skip=true</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">mvn package -Dmaven.tesk.skip=true</span></span></code></pre></div><br><p>执行方式（自行替换日志方面配置）：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">mkdir /tmp/logs</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">nohup  java   -XX:+UseConcMarkSweepGC -Xmx512M -Xms512M -Djava.rmi.server.hos</span></span>
<span class="line"><span style="color:#E1E4E8;">tname=192.168.99.101 -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmx</span></span>
<span class="line"><span style="color:#E1E4E8;">remote.port=14000  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.manage</span></span>
<span class="line"><span style="color:#E1E4E8;">ment.jmxremote.authenticate=false -verbose:gc -XX:+PrintGCDetails -XX:+PrintG</span></span>
<span class="line"><span style="color:#E1E4E8;">CDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintTenuringDistributio</span></span>
<span class="line"><span style="color:#E1E4E8;">n -Xloggc:/tmp/logs/gc_%p.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPat</span></span>
<span class="line"><span style="color:#E1E4E8;">h=/tmp/logs -XX:ErrorFile=/tmp/logs/hs_error_pid%p.log -XX:-OmitStackTraceInF</span></span>
<span class="line"><span style="color:#E1E4E8;">astThrow  -jar monitor-demo-0.0.1-SNAPSHOT.jar  2&gt;&amp;1  &amp;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">mkdir /tmp/logs</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">nohup  java   -XX:+UseConcMarkSweepGC -Xmx512M -Xms512M -Djava.rmi.server.hos</span></span>
<span class="line"><span style="color:#24292E;">tname=192.168.99.101 -Dcom.sun.management.jmxremote  -Dcom.sun.management.jmx</span></span>
<span class="line"><span style="color:#24292E;">remote.port=14000  -Dcom.sun.management.jmxremote.ssl=false  -Dcom.sun.manage</span></span>
<span class="line"><span style="color:#24292E;">ment.jmxremote.authenticate=false -verbose:gc -XX:+PrintGCDetails -XX:+PrintG</span></span>
<span class="line"><span style="color:#24292E;">CDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintTenuringDistributio</span></span>
<span class="line"><span style="color:#24292E;">n -Xloggc:/tmp/logs/gc_%p.log -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPat</span></span>
<span class="line"><span style="color:#24292E;">h=/tmp/logs -XX:ErrorFile=/tmp/logs/hs_error_pid%p.log -XX:-OmitStackTraceInF</span></span>
<span class="line"><span style="color:#24292E;">astThrow  -jar monitor-demo-0.0.1-SNAPSHOT.jar  2&gt;&amp;1  &amp;</span></span></code></pre></div><br><p>请将 IP 地址改成自己服务器的实际 IP 地址，这样就可以使用 jmc 或者 VisualVM 等工具进行连接了。</p><br><p>确保 Telegraf、InfluxDB、Grafana 已经启动，这样，Java 进程的 JVM 相关数据，将会以 10 秒一次的频率进行收集，我们可以选择 Grafana 的时间轴，来查看实时的或者历史的监控曲线。</p><br><p>这类监控信息，可以保存长达 1 ~ 2 年，也就是说非常久远的问题，也依然能够被追溯到。如果你想要对 JVM 尽可能地进行调优，就要时刻关注这些监控图。</p><br><p>举一个例子：我们发现有一个线上服务，运行一段时间以后，CPU 升高、程序执行变慢，登录相应的服务器进行分析，发现 C2 编译线程一直处在高耗 CPU 的情况。</p><br><p>但是我们无法解决这个问题，一度以为是 JVM 的 Bug。</p><br><p>通过分析 CPU 的监控图和 JVM 每个内存分区的曲线，发现 CodeCache 相应的曲线，在增加到 32MB 之后，就变成了一条直线，同时 CPU 的使用也开始增加。</p><br><p>通过检查启动参数和其他配置，最终发现一个开发环境的 JVM 参数被一位想要练手的同学给修改了，他本意是想要通过参数 &quot;-XX:ReservedCodeCacheSize&quot; 来限制 CodeCache 的大小，这个参数被误推送到了线上环境。</p><br><p>JVM 通过 JIT 编译器来增加程序的执行效率，JIT 编译后的代码，都会放在 CodeCache 里。如果这个空间不足，JIT 则无法继续编译，编译执行会变成解释执行，性能会降低一个数量级。同时，JIT 编译器会一直尝试去优化代码，造成了 CPU 的占用上升。</p><br><p>由于我们收集了这些分区的监控信息，所以很容易就发现了问题的相关性，这些判断也会反向支持我们的分析，而不仅仅是靠猜测。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>本课时简要介绍了基于 JMX 的 JVM 监控，并了解了一系列观测这些数据的工具。但通常，使用 JMX 的 API 还是稍显复杂一些，Jolokia 可以把这些信息转化成 HTTP 的 json 信息。</p><br><p>还介绍了一个可用的监控体系，来收集这些暴露的数据，这也是有点规模的公司采用的正统思路。收集的一些 GC 数据，和前面介绍的 GC 日志是有一些重合的，但我们的监控更突出的是实时性，以及追踪一些可能比较久远的问题数据。</p><br><p>附录：代码清单</p><ul><li><p><strong>sys.conf</strong> 操作系统监控数据收集配置文件，Telegraf 使用。</p></li><li><p><strong>jvm.conf</strong> JVM 监控配置文件，Telegraf 使用。</p></li><li><p><strong>grafana-jvm-influxdb.json</strong> JVM 监控面板，Grafana 使用。</p></li><li><p><strong>monitor-demo</strong> 被收集的 Spring Boot 项目。</p></li></ul>`,35);function I(S,V,G,O,F,U){const n=p("Image");return o(),r("div",null,[i,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/CgpOIF5WOcmANUJIAAHH0v-SqIg611.jpg"}),a(),d,g,m,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/Cgq2xl5WOcmAWhmjAAF-W24OEt8285.jpg"}),a(),E,u,y,h,_,b,f,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/CgpOIF5WOcmAE7A8AAB-w3pvGdE946.jpg"}),a(),v,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/Cgq2xl5WOcmAF9JCAAAsbftRAtQ610.jpg"}),a(),k,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/CgpOIF5WOcqAAC5eAABHCB0CHX4011.jpg"}),a(),C,x,A,M,j,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/Cgq2xl5WOcqAR8R3AABiB-i16nc579.jpg"}),a(),T,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/CgpOIF5WOcqALmlRAAB7q-dV9p4253.jpg"}),a(),X,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/Cgq2xl5WOcqAILdGAAAwT9weUCE428.jpg"}),a(),P,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/CgpOIF5WOcqAcWX7AAbu9u8lzaU635.png"}),a(),q,D,B,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/6A/E1/Cgq2xl5WOcuAGVb5AABRBG7h0-4332.jpg"}),a(),J])}const N=t(c,[["render",I]]);export{H as __pageData,N as default};
