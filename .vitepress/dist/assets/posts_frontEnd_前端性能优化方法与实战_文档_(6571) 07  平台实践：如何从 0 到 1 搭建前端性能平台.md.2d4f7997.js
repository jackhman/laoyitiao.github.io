import{_ as a,j as s,o as i,g as n,k as o,h as t,s as p,Q as l}from"./chunks/framework.4e7d56ce.js";const b=JSON.parse('{"title":"性能数据处理后台 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/前端性能优化方法与实战_文档/(6571) 07  平台实践：如何从 0 到 1 搭建前端性能平台.md","filePath":"posts/frontEnd/前端性能优化方法与实战_文档/(6571) 07  平台实践：如何从 0 到 1 搭建前端性能平台.md","lastUpdated":1696417798000}'),_={name:"posts/frontEnd/前端性能优化方法与实战_文档/(6571) 07  平台实践：如何从 0 到 1 搭建前端性能平台.md"},r=p("p",null,"前几讲，我已经介绍了首屏时间、白屏、卡顿等性能指标采集和上报，按照性能优化体系的流程，接下来就该对性能 SDK 上报数据的处理了。那具体该怎么做呢？这就需要用到我们这一讲介绍的前端性能平台了。",-1),c=p("p",null,"还记得我之前提到的奥林匹亚项目吗？当时我们用的是一个开源的监控平台，只能够满足首屏时间和白屏时间等性能关键指标的展示需求，具体到一些个性化细分的性能数据，比如秒开率，数据瀑布流等，并无法满足。再加上业务开始对性能重视起来，不再想再亡羊补牢，还希望能未雨绸缪，提前发现故障，快速定位问题。于是，前端性能平台的自研需求就应运而生了。",-1),d=p("p",null,"如果你或者你所在的团队也想进一步提高前端性能，那么这一讲就要认真看了哦，前端性能平台可是性能优化体系当中不可缺少的一环。",-1),u=p("p",null,"什么是前端性能平台呢？",-1),h=p("p",null,[t("单从名字来看，它仿佛是一个后台系统，类似报表统计后台之类的。其实不然，前端性能平台是一个 Web 系统，主要包括"),p("strong",null,"后台的性能数据处理和前台的可视化展示"),t("两部分。")],-1),g=p("p",null,"其中，数据处理后台主要是对 SDK 上报后的性能指标进行处理和运算，具体包括数据入库、数据清洗、数据计算，做完这些后，前台会对结果进行可视化展现，我们借助它就可以实时监督前端的性能情况。下图是性能平台大盘页的效果，主要对当前用户关注的性能模块进行展示，内容包括首屏时间、秒开率和采样PV。",-1),S=p("p",null,"性能平台大盘页",-1),A=p("p",null,"那么，我们该如何搭建这样一个性能平台呢？",-1),m=l('<p>性能平台技术架构图</p><p>这是具体的技术架构图，从底层到前台大致情况如下：</p><ul><li><p>数据接入层，主要是接收 SDK上报的性能数据，做数据处理后入库，包含的技术有 Node.js、Node-sechdule、Node-mailer；</p></li><li><p>数据计算层，会对性能数据做计算处理，需要的技术有 Kafka、Spark、Hive、HDFS；</p></li><li><p>存储层，包括 MySQL + MongoDB ，性能平台需要的数据会来这里；</p></li><li><p>平台层，也就是展示给用户的部分，需要的技术有 React、Ant design、Antv、Less。</p></li></ul><p>接下来我就将结合技术架构图来为你详细介绍下，如何一步步搭建性能平台。</p><h3 id="性能数据处理后台" tabindex="-1">性能数据处理后台 <a class="header-anchor" href="#性能数据处理后台" aria-label="Permalink to &quot;性能数据处理后台&quot;">​</a></h3><p>想要搭建性能平台，我们先来看它的性能处理后台情况。一般性能 SDK 上报数据的处理过程是这样的：</p><ol><li><p>客户端借助 SDK 上报性能数据指标，数据接入层（图中绿色部分）接收相应数据，并做协议转换等简单处理后，作为生产者向 Kafka 写入数据；</p></li><li><p>数据计算层（图中橙色部分）作为消费者，从 Kafka 读数据存入 Hive（Hadoop平台的存储表），Hadoop 平台借助 Spark 做数据分析计算；</p></li><li><p>借助 Hive 提供的接口，数据计算层使用 SQL 语句从 Hive 拉取计算后的数据到数据库平台（MongoDB），平台层取出数据，准备数据可视化展现的数据。</p></li></ol><p>上述数据流程，对应的性能数据后台的搭建过程如下：</p><p>第一步是入库，客户端借助 SDK 上报性能数据指标后，需要后端服务层的处理，这里我们选取的是 NodeJS 做后端，利用 Controller 层对数据做处理。</p><p>为了避免数据库出现&quot;脏数据&quot;（如空数据、异常数据），影响后续数据处理，我们将 SDK 上报的数据通过 URL 解析成 key-value 格式的数据，对数据进行空数据删除，异常数据舍弃等操作。然后我们让数据写进消息队列 Kafka。</p><p>为什么不是直接存入 Hive 呢？</p><p>因为客户端上报的性能数据量和用户规模有关。如果直接入库到 Hive，遇到高并发的时候，会因为服务器扛不住而导致数据丢失。与此同时，因为数据下游（数据的使用方，如数据清洗计算平台，性能预警模块）会有多个数据接收端，直接入库的话也会造成数据重复。</p><p>所以最好我们选择 Kafka，先让数据写进消息队列。Kafka 能通过缓存，慢慢接收这些数据，降低流量洪峰压力。同时，消息队列还有接收数据后将其删除的特点，可以避免数据重复的问题。</p><p>第二步，对 Kafka 中的数据，做数据清洗和数据计算。</p><p>数据清洗，是指针对性能上报单条数据进行核对校验的过程。所清洗的数据包括：</p><ul><li><p>对重复数据的处理，即同一个用户网络出错时，多次重试导致上传了好几条首屏时间相关的数据；</p></li><li><p>对缺失数据的处理，虽然上报了首屏时间，但白屏时间或者卡顿时间计算时没能给出；</p></li><li><p>对错误数据的处理，即数据超出正常范围，出现负值或者超出极大值的情况。</p></li></ul><p>这几种类型数据问题如果不处理，最终会影响计算结果的准确性。那么该怎么处理呢？</p><ul><li><p>遇到重复数据，直接去重删除即可。</p></li><li><p>遇到缺失数据，我们在 Spark 平台上，先根据上报的 Performance 数据进行计算补全，如果无法补全的，就直接舍弃掉，不然会出现后续无法入库的情况。</p></li><li><p>遇到超出正常范围的数据，如负值或者超过 10 秒以上的数据，把它当作无效数据，直接舍弃掉。</p></li></ul><p>做完数据清洗之后，我们还需要使用 Spark 做数据计算，为可视化展现准备数据。具体需要做以下数据计算：</p><ul><li><p>首屏时间分布的计算，1s ～ 2s 占比多少，2s ～ 4s 占比多少；</p></li><li><p>秒开率的计算，首屏时间小于等于 1 秒的数据占比；</p></li><li><p>页面瀑布流时间的计算。</p></li></ul><p>其中，页面瀑布流时间是对首屏时间的细分，包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间。这些细分时间点，是我们根据 SDK 上报的 Performance 接口数据指标计算出来的，前端工程师根据页面瀑布流时间，可以快速定位性能瓶颈点出现在哪个环节。</p><p>第三步，准备性能前台所需的可视化数据。</p><p>为了完成前台展现，性能平台需要登录功能，还需要做一些用户关注的模块信息，比如前端开发者添加关注的业务模块。我们可以用关系数据库去存储这些数据，具体可以选择 MySQL完成账号权限系统和关注业务模块对应的数据表。</p><p>而性能数据，因为都是单条性能信息，相互之间并没有什么关系，可以用 MongoDB 做存储。具体来说，我们可以用 NodeJS 提供的定时脚本（Node-sechdule）从 Spark 取到数据导入到 MongoDB 中。</p><h3 id="前端数据可视化展示前台" tabindex="-1">前端数据可视化展示前台 <a class="header-anchor" href="#前端数据可视化展示前台" aria-label="Permalink to &quot;前端数据可视化展示前台&quot;">​</a></h3><p>前端数据可视化展现前台，整体上只有两个页面，大盘页和详情页。</p><p>大盘页包括一个个业务的性能简图。每一个性能简图包括首屏时间、秒开率、采样 PV 数据。点击性能简图上的&quot;进入详情&quot;链接，就可以进入详情页。初次进入大盘页的时候，需要你登录并关注相关的业务，然后就可以在大盘首页看到相关的性能情况。</p><p>详情页的设计的初衷是为了对性能简图做进一步的补充，除了展示对应性能简图的秒开率、性能均值细节、白屏均值细节之外，还会展示终端信息，比如多少比例在IOS端，多少比例在Android端，以方便用户根据不同场景去做优化。</p>',28),D=p("p",null,"详情页性能均值",-1),P=p("p",null,"详情页终端类型",-1),k=p("p",null,"同时，为了解秒开率不达标原因或者首屏时间变慢的细节在哪里，我们会给出页面加载瀑布流，前面数据处理阶段已经提到可以使用的数据（包括 DNS 查询、TCP链接、请求耗时、内容传输、资源解析、DOM 解析和资源加载的时间），套用 AntV （阿里巴巴集团的数据可视化方案）的瀑布流模板即可完成数据展现。",-1),f=l('<p>页面加载瀑布流</p><p>那么，大盘页和详情页如何实现的呢？</p><p>首先是前端展示技术栈的选择，对应技术架构图中的淡黄色部分，因为这两个页面都属于 PC 端后台页面，主要给公司前端开发者使用，功能上更多是数据可视化展示，非常适合用 React 技术栈做开发。</p><p>为了更好实现首屏时间、秒开率和采用 PV 的功能效果，我们使用 AntdPro 的模板，相关的配套的数据可视化方案，我推荐 Antv，因为它能够满足我们在首屏时间、秒开率等性能指标的展示需求，用起来比较简单（开箱即用），功能灵活且扩展性强（比如秒开率部分，要自定义一些图形，能够较好满足）。</p><p>大盘页和详情页的数据展示效果比较丰富多样，相应的 CSS 代码逻辑就比较复杂，为了让 CSS代码更容易维护和扩展，CSS 方面可以选用 Less 框架。</p><p>接下来是前后端交互方面，为了让前后台更独立，大盘页、详情页与后端的通信通过 HTTP 接口来实现，使用 nginx 作为 Web Server。为了让传输更高效，我们采用 compression 对 HTTP 传输内容进行 GZip 压缩处理。</p><p>最后是后台服务部分，为了让性能平台开发过程更简单，效率更高，同时平台本身的性能体验更流畅，后台服务方面可以选用 Egg.js（基于 NodeJS 的开发框架）做开发，进行数据处理和存储服务。</p><p>为了解决监控预警的问题，我们借助 Node-schedule 做调度和定时任务的处理，通过 node-mailer 进行邮件报警。有关预警部分的实现细节，我会在下一讲展开介绍。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3>',9),C=p("p",null,"好了以上就是性能监控平台的核心实现，如果公司没有类似的埋点平台，那么这一讲非常适合你，如果已经有了，性能上报直接走埋点平台处理就好，基本上性能上报处理就不需要自己做了，可以专注于第二部分前端可视化交互。",-1),T=p("p",null,"另外性能指标里有很多内容，比如 Dom ready 指标，完全加载时间指标，这些通过Performance 接口也能取到，但根据我过往的经验，最有用的性能指标还是秒开率、首屏时间、白屏时间、卡断指标。",-1),N=p("p",null,"好了，性能平台实践的内容就到这里了。在这里给你留一个小问题：",-1),K=p("blockquote",null,[p("p",null,"业界在统计首屏时间时，都会统计一下是否首次访问，这个是怎么实现的呢？")],-1),v=p("p",null,"欢迎在评论区留言和我沟通，下一讲我会详细介绍下如何进行效果评估、监控预警及问题诊断。",-1);function M(B,H,L,V,q,O){const e=s("Image");return i(),n("div",null,[r,c,d,u,h,g,o(e,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M00/1A/35/CioPOWBLG3mAVYkkAAHApv2u7qk043.png"}),t(),S,A,o(e,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M00/1A/38/Cgp9HWBLG4yAU8hkAACsiIzC-Zs386.png"}),t(),m,o(e,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image6/M00/1A/35/CioPOWBLG6aASuNtAAURvlMLkr8118.png"}),t(),D,o(e,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image6/M00/1A/35/CioPOWBLG66AKPw6AADWZ9u93AE631.png"}),t(),P,k,o(e,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image6/M00/1A/38/Cgp9HWBLG8CAOosDAAGIeWOW8_Y611.png"}),t(),f,o(e,{alt:"溪风的思维导图07.png",src:"https://s0.lgstatic.com/i/image6/M00/1A/53/CioPOWBLOe6AGanvAAJKTg2Y6Bw296.png"}),C,T,N,K,v])}const I=a(_,[["render",M]]);export{b as __pageData,I as default};
