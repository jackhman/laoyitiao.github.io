import{_ as t,D as l,o as r,g as o,J as a,h as s,Q as p,m as e}from"./chunks/framework.f67d7268.js";const k=JSON.parse('{"title":"第13讲：剖析Trace在SkyWalking中的落地实现方案（下）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2033) 第13讲：剖析 Trace 在 SkyWalking 中的落地实现方案（下）.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2033) 第13讲：剖析 Trace 在 SkyWalking 中的落地实现方案（下）.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2033) 第13讲：剖析 Trace 在 SkyWalking 中的落地实现方案（下）.md"},i=p("",12),E=p("",10),S=e("br",null,null,-1),g=e("p",null,"当请求经过 Tomcat 插件时会创建 EntrySpan（调用 start() 方法）并入栈到 activeSpanStack 中；请求经过 Spring MVC 插件时不会创建新的 EntrySpan，只会重新调用 start() 方法。接下来在调用 first() 方法时会创建相应的 LocalSpan 并入栈，first() 方法调用结束之后会将该 LocalSpan 出栈；调用 second() 方法时与 Span 出入栈逻辑相同；最后在通过 Dubbo 远程调用 HelloService.say() 方法的时候，会创建相应的 ExitSpan 并入栈，结束 Dubbo 调用之后其相应的 ExitSpan 会出栈，此时整个 activeSpanStack 栈空了，TraceSegment 也就结束了。整个过程如下图所示：",-1),y=e("br",null,null,-1),d=p("",17),u=p("",13);function m(C,h,x,T,_,I){const n=l("Image");return r(),o("div",null,[i,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/89/94/Cgq2xl6X_6-ATLgTAAApyYi2z4g447.png"}),s(),E,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/03/50/CgoCgV6X_7CAIrmBAABEHpBozXI630.png"}),s(),S,g,y,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/10/7E/Ciqah16X_7CADwCpAAQ3K_wSU4k128.png"}),s(),d,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/89/95/Cgq2xl6X_7CATU_aAAFxCpVbciQ707.png"}),s(),u])}const v=t(c,[["render",m]]);export{k as __pageData,v as default};
