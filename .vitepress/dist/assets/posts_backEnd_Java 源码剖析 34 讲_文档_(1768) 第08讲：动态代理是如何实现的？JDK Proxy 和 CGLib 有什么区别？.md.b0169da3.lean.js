import{_ as p,j as o,o as e,g as t,k as a,Q as l,s}from"./chunks/framework.b3d8e22e.js";const x=JSON.parse('{"title":"典型回答 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md","filePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md"},r=l("",36),E=s("p",null,"接下来讲讲 Lombok 的原理。",-1),y=s("p",null,"Lombok 的实现和反射没有任何关系，前面我们说了反射是程序在运行期的一种自省（introspect）能力，而 Lombok 的实现是在编译期就完成了，为什么这么说呢？",-1),i=s("p",null,"回到我们刚才 Setter/Getter 的方法，当我们打开 Person 的编译类就会发现，使用了 Lombok 的 @Data 注解后的源码竟然是这样的：",-1),F=s("p",null,"可以看出 Lombok 是在编译期就为我们生成了对应的字节码。",-1),g=s("p",null,"其实 Lombok 是基于 Java 1.6 实现的 JSR 269: Pluggable Annotation Processing API 来实现的，也就是通过编译期自定义注解处理器来实现的，它的执行步骤如下：",-1),D=l("",8);function d(A,b,u,h,C,v){const n=o("Image");return e(),t("div",null,[r,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/05/Ciqah16HCB6AcjsPAAIhVz8yo1o620.png"}),E,y,i,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/1B/Cgq2xl6HCB6AXaC5AAHG477g0yQ093.png"}),F,g,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/1B/Cgq2xl6HCB-AAsAKAACfTHorgDA111.png"}),D])}const B=p(c,[["render",d]]);export{x as __pageData,B as default};
