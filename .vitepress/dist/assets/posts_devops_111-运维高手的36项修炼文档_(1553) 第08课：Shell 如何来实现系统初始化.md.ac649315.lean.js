import{_ as s,j as l,o,g as r,k as t,Q as i,s as e,h as n}from"./chunks/framework.e0c66c3f.js";const B=JSON.parse('{"title":"Close selinux services","description":"","frontmatter":{},"headers":[],"relativePath":"posts/devops/111-运维高手的36项修炼文档/(1553) 第08课：Shell 如何来实现系统初始化.md","filePath":"posts/devops/111-运维高手的36项修炼文档/(1553) 第08课：Shell 如何来实现系统初始化.md","lastUpdated":1696338709000}'),p={name:"posts/devops/111-运维高手的36项修炼文档/(1553) 第08课：Shell 如何来实现系统初始化.md"},c=i("",17),h=e("br",null,null,-1),u=e("p",null,"首先，我们来看一下 Jinit.sh 脚本的整体结构。如果你了解 Shell 会发现，这是一种最基础的编写方式，Shell 会由上到下，依次执行每一段优化项。如果你想将脚本写得更好，建议你把优化项封装成函数，这样维护性更高。另外你也可以选择优先调用执行顺序.",-1),d=e("h3",{id:"学习基础",tabindex:"-1"},[n("学习基础 "),e("a",{class:"header-anchor",href:"#学习基础","aria-label":'Permalink to "学习基础"'},"​")],-1),_=e("p",null,"学习这个脚本之前，你需要有一定的 Linux 操作基础，同时需要了解基础的操作系统原理，接下来，给你画了一张思维导图。",-1),b=e("br",null,null,-1),m=i("",27),f=e("br",null,null,-1),g=e("p",null,"如果我把 Timestamps 设为 1，当客户端往服务端发包的时候，它会判断源 IP 在上次通讯时的时间戳值会不会大于本次。如果不大于的话，也就是当时间戳比本地的时间戳更加小的时候，这时就会直接 drop 到这个包。这样会有一些影响，所以这个时候我们直接把它设为 0，就可以避这样的问题。",-1),q=e("br",null,null,-1),x=e("p",null,"另外就是操作系统内核的优化，除了文件句柄等我们常知道的优化内容以外，经常需要考虑网络的底层去优化。说到网络底层优化，你就需要先了解 TCP 的 3 次握手和 4 次挥手，这个是非常重要的，别看是非常简单的一个概念，这里我们来回顾一下这张图。",-1),k=e("br",null,null,-1),P=e("br",null,null,-1),S=e("p",null,"客户端主动连接，我们会看到 3 次握手时，客户端和服务端分别进入一个新的状态；同样，当客户端对服务端进行 4 次挥手断开这些连接时，客户端和服务端每次的状态也相应发生改变。",-1),y=e("br",null,null,-1),A=e("p",null,"为什么 3 次握手和 4 次挥手需要重点关注呢？因为我们在做操作系统内核优化时，很多的优化参数都是优化服务端的网卡队列相关信息，比如我们刚刚看到的客户端和服务端建立起 3 次握手，当客户端发送 SYN 包到服务端以后，服务端会进入到一个 SYN_RCVD 状态，这个状态里面的数值就需要保存在服务端的网卡队列中。",-1),I=e("br",null,null,-1),C=e("p",null,"那么网卡队列的长度设置为多少合适呢？如果你是一个高并发的服务，这个时候就需要优化本地的网卡队列的长度。所以对于网卡操作系统队列，我们需要优化一些参数：",-1),v=e("br",null,null,-1),T=e("p",null,"一个是本地设备的网卡队列的请求长度，这个我们可以适当的调大。另外一个，就是刚讲到的SYN 队列长度，默认为 1024，这里我们把它调到更大。还有一些 TIME_WAIT 的网卡队列的长度，我们也可以适当地调大，经验来看短连接服务往往在本地会产生大量的 TIME_WAIT，所以就需要把 TIME_WAIT 的 buff 值调得更高，这样的话就会减少 TIME_WAIT 报错信息。",-1),w=e("br",null,null,-1),N=e("p",null,"以上就是刚刚讲到的所有关于网卡队列的长度大小的优化。单独摘出来的一个参数配置，需要注意的就是 ip_local_port_range。这个参数表示从本地最多可以使用多少个 IP 和端口连接同一个目标 IP 及端口，所以这个值也可以适当的调整，在我的脚本里也会做优化。",-1),E=e("br",null,null,-1),O=i("",143);function J(M,U,L,D,Y,j){const a=l("Image");return o(),r("div",null,[c,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/73/7A/Cgq2xl5qC1-AJZ-eAAOMT2A6vD8550.png"}),h,u,d,_,b,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/73/7A/CgpOIF5qC1-ATg7VAALizw8mvh4653.png"}),m,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/73/7A/Cgq2xl5qC1-ABdFAAALgbr--nNA834.png"}),f,g,q,x,k,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/73/7A/CgpOIF5qC1-AVlH_AAORTXwTB0A492.png"}),P,S,y,A,I,C,v,T,w,N,E,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/73/7A/Cgq2xl5qC1-ARQjxAAHQtHHl1RA689.png"}),O])}const R=s(p,[["render",J]]);export{B as __pageData,R as default};
