import{_ as l,j as t,o as e,g as c,k as o,h as a,Q as p,s}from"./chunks/framework.4e7d56ce.js";const D=JSON.parse('{"title":"微服务 CPU 被打满如何排查 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6143) 18  如何设计微服务才能防止宕机？.md","filePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6143) 18  如何设计微服务才能防止宕机？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/23讲搞定后台架构实战_文档/(6143) 18  如何设计微服务才能防止宕机？.md"},i=p("",13),E=s("p",null,"图 1：双机房部署架构图",-1),y=s("p",null,"上述部署里，同一个微服务分别在两个机房各部署了两台机器。在存储上，数据库的主从分别部署在两个机房里。当出现机房级别的故障，如网络不通时，可以直接将故障机房的机器从微服务的注册中心摘除。其次，如果故障发生在主库所在机房，就需要 DBA 进行协助，对主从数据库的数据对比、订正并进行数据库的主从切换。",-1),g=s("p",null,"双机房部署使得微服务具备了机房级别的容灾能力，当机房出现故障时，可以快速地进行切换，而不用耗费几个小时甚至更久的时间，在一个新的机房进行微服务和数据库的重新部署。但上述的部署里，数据库其实是单机房部署的。因为在实际运行时，只有主库承载读写流量，从库只是跨机房进行数据复制，作为灾备使用。",-1),d=s("p",null,[a("当真正出现机房故障时，整个微服务仍需停服一定时间，用来等待 DBA 进行主从切换，原则上只在秒级或者分钟级别。这在绝大部分场景里均可满足业务的需要，但有些用户使用高频的场景，如打车、即时通信等软件，需要业务尽可能 7*24 运行，减少或保障不出现业务停服的场景。对于此类需求，可以采用"),s("strong",null,"存储按机房多地部署、且每个机房的存储均支持部分用户的数据读写的方案"),a(" 进行升级，此方式在业界有个特有名词，叫作"),s("strong",null,"单元化部署的架构"),a("，具体架构如下图 2 所示：")],-1),_=s("p",null,"图 2：单元化架构图",-1),u=s("p",null,"在单元化架构里，两个机房里的数据库均为主库，它们都承载读写流量。此外，对于用户的请求流量，在网关层进行了转发，一部分转发至机房 A，另外一部分转发至机房 B。假设当机房 A 出现故障时，机房 B 所承载的流量是完全不受影响的，即路由至机房 B 的用户对于故障无感知。",-1),h=s("p",null,"而对于机房 A 里的用户，则可以在网关层进行前置再路由，将所有的请求全部转发至未故障的机房 B。在上图 2 中，有一条两个机房里的数据库主库互相同步的标识线，它是单元化里需要构建的数据同步模块。作用是发生故障时，减少机房 A 里的用户切换到机房 B 的时间。因为机房 A 里的用户可以切换到机房 B 的前置条件是，机房 A 里的数据已经全部同步至机房 B 里，实时的数据同步可以减少故障后 DBA 进行数据同步、对比和校准的时间。",-1),C=s("p",null,"可以看到，单元化架构并不是机房故障后，对于业务完全无损，而是保障一部分用户完全无损来提高高可用能力。",-1),v=s("p",null,[s("strong",null,"其次，机房内至少部署两台及以上机器。"),a(" 这里再多啰唆一句，上述第一条要求至少双机房部署，并不是两个机房各部署一台机器即可，而是要在同一个机房里至少部署两台机器，保障机房内机器互相灾备。此方式可以防止当某一台机器故障后，出现整个机房全部失联，进而将调用方的所有的流量都打至另外一个机房，引起请求的性能和稳定性下降，因为跨机房的请求的网络传输时间更长。单机房部署单容器故障时导致的跨机房调用的架构如下图 3 所示，可以看到故障后，调用方的所有流量全部都路由至被调用方的单个机房里。")],-1),b=s("p",null,"图 3：机器故障导致的跨机房架构图",-1),F=s("p",null,[s("strong",null,"再者，不同类型的接口需要单独部署。"),a(" 在模块二和模块三里介绍过读服务和写服务的特点，这里再复习一下。读服务的特点是调用次数特别大，对于性能要求高。而写服务则是对于稳定性要求特别高，调用次数相比读服务会低很多。假设你在微服务拆分时，没有在垂直拆分时按读写分离的方式将读和写服务拆分开，而是将代码编写在同一个工程里。那么部署的时候，建议将二者的接口拆开部署，拆开后的结构如下图 4 所示：")],-1),m=s("p",null,"图 4：读写分离的部署架构",-1),k=s("p",null,"隔离开单独部署主要有以下几点考虑。",-1),A=s("ol",null,[s("li",null,[s("p",null,"写服务对于稳定性要求较高。隔离后，读服务里因为代码 Bug 等因素导致的机器 CPU 飙升、内存占满等问题不会影响到写服务的性能和稳定性。")]),s("li",null,[s("p",null,"其次，读服务调用量较高，对于机器 CPU、内存、网络等占用也较高。隔离后，写服务将独享机器资源，性能和稳定性也较好。")]),s("li",null,[s("p",null,"最后，微服务的执行线程是根据机器的 CPU 提前设置好的，大小是固定的。读写混合部署时，读请求很容易将微服务框架的执行线程沾满，导致线程枯竭，进而导致写请求得不到执行。此时，通过隔离部署也可以解决此问题。")])],-1),B=s("p",null,[s("strong",null,"最后，至少要线程池隔离。"),a(" 在某些时候，可能读服务的调用次数并不是特别大或机器资源有限，实现不了上述的纯机器隔离。此时，可以实现一个简版的隔离，即微服务框架的执行线程池隔离。现在主流的微服务框架都支持对于接口单独配置一个执行线程，这样在执行时，就可以做到线程池资源隔离，互不影响，具体架构见如下图 5 所示。在某些无法完成机器隔离的场景里，可以使用此方式实现一定程度的资源隔离。")],-1),j=p("",23);function S(P,f,I,q,U,J){const n=t("Image");return e(),c("div",null,[i,o(n,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image6/M01/13/61/Cgp9HWBCEGOAY71-AAGWcwIKajo733.png"}),a(),E,y,g,d,o(n,{alt:"202139-175217.png",src:"https://s0.lgstatic.com/i/image6/M01/17/23/Cgp9HWBHRkGAdikBAAGJLuwtcSo932.png"}),a(),_,u,h,C,v,o(n,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image6/M01/13/61/Cgp9HWBCEHqALpQPAAGoVAJNnZE659.png"}),a(),b,F,o(n,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image6/M01/13/61/Cgp9HWBCEIaAD7M_AAC8tIXD8Kw065.png"}),a(),m,k,A,B,o(n,{alt:"图片5.png",src:"https://s0.lgstatic.com/i/image6/M01/13/5E/CioPOWBCEJCAGNKjAAEKuamCvRg498.png"}),a(),j])}const N=l(r,[["render",S]]);export{D as __pageData,N as default};
