import{_ as o,j as l,o as c,g as e,k as a,s,h as p,Q as t}from"./chunks/framework.4e7d56ce.js";const C=JSON.parse('{"title":"相同点 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(260) 第22讲：ynchronized 和 Lock 孰优孰劣，如何选择？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(260) 第22讲：ynchronized 和 Lock 孰优孰劣，如何选择？.md","lastUpdated":1696417798000}'),i={name:"posts/backEnd/096-Java 并发编程文档/(260) 第22讲：ynchronized 和 Lock 孰优孰劣，如何选择？.md"},r=s("p",null,"本课时我们主要学习 synchronized 和 Lock 的异同点，以及该如何选择。",-1),d=s("h3",{id:"相同点",tabindex:"-1"},[p("相同点 "),s("a",{class:"header-anchor",href:"#相同点","aria-label":'Permalink to "相同点"'},"​")],-1),y=s("p",null,"synchronized 和 Lock 的相同点非常多，我们这里重点讲解 3 个比较大的相同点。",-1),h=s("ul",null,[s("li",null,"synchronized 和 Lock 都是用来保护资源线程安全的。")],-1),k=s("p",null,"这一点毋庸置疑，这是它们的基本作用。",-1),E=s("ul",null,[s("li",null,"都可以保证可见性。")],-1),_=s("p",null,"对于 synchronized 而言，线程 A 在进入 synchronized 块之前或在 synchronized 块内进行操作，对于后续的获得同一个 monitor 锁的线程 B 是可见的，也就是线程 B 是可以看到线程 A 之前的操作的，这也体现了 happens-before 针对 synchronized 的一个原则。",-1),u=s("p",null,"而对于 Lock 而言，它和 synchronized 是一样，都可以保证可见性，如图所示，在解锁之前的所有操作对加锁之后的所有操作都是可见的。",-1),z=t("",28);function L(v,b,g,m,f,j){const n=l("Image");return c(),e("div",null,[r,d,y,h,k,E,_,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5B/48/Cgq2xl4EG32AOox-AADNKxopmhk051.png"}),u,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/5B/47/CgpOIF4EG4WAML9mAACrPzwbiwo300.png"}),z])}const J=o(i,[["render",L]]);export{C as __pageData,J as default};
