import{_ as l,j as o,o as c,g as s,k as t,s as e,h as p,Q as i}from"./chunks/framework.e0c66c3f.js";const Z=JSON.parse('{"title":"工作过程简介 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/102-Webpack原理与实践文档/(2265) 第05讲：探索 Webpack 运行机制与核心工作原理.md","filePath":"posts/frontEnd/102-Webpack原理与实践文档/(2265) 第05讲：探索 Webpack 运行机制与核心工作原理.md","lastUpdated":1696338709000}'),n={name:"posts/frontEnd/102-Webpack原理与实践文档/(2265) 第05讲：探索 Webpack 运行机制与核心工作原理.md"},r=e("p",null,"在前面的课时中我们已经对 Webpack 两个最重要的特性：Loader 和插件机制有了深入的了解，今天我们再来解读一下 Webpack 的运行机制和核心工作原理。",-1),_=e("h3",{id:"工作过程简介",tabindex:"-1"},[p("工作过程简介 "),e("a",{class:"header-anchor",href:"#工作过程简介","aria-label":'Permalink to "工作过程简介"'},"​")],-1),m=e("p",null,"其实 Webpack 官网首屏的英雄区就已经很清楚地描述了它的工作原理，如下图所示：",-1),g=e("p",null,"那这里我们先来快速理解一下 Webpack 打包的核心工作过程。我们以一个普通的前端项目为例，项目中一般都会散落着各种各样的代码及资源文件，如下图所示：",-1),d=e("p",null,"比如 JS、CSS、图片、字体等，这些文件在 Webpack 的思想中都属于当前项目中的一个模块。Webpack 可以通过打包，将它们最终聚集到一起。Webpack 在整个打包的过程中：",-1),h=e("ul",null,[e("li",null,"通过 Loader 处理特殊类型资源的加载，例如加载样式、图片；"),e("li",null,"通过 Plugin 实现各种自动化的构建任务，例如自动压缩、自动发布。")],-1),b=e("p",null,"具体来看打包的过程，Webpack 启动后，会根据我们的配置，找到项目中的某个指定文件（一般这个文件都会是一个 JS 文件）作为入口。然后顺着入口文件中的代码，根据代码中出现的 import（ES Modules）或者是 require（CommonJS）之类的语句，解析推断出来这个文件所依赖的资源模块，然后再分别去解析每个资源模块的依赖，周而复始，最后形成整个项目中所有用到的文件之间的依赖关系树，下面这个动画生动的演示了这个过程：",-1),k=e("p",null,"有了这个依赖关系树过后， Webpack 会遍历（递归）这个依赖树，找到每个节点对应的资源文件，然后根据配置选项中的 Loader 配置，交给对应的 Loader 去加载这个模块，最后将加载的结果放入 bundle.js（打包结果）中，从而实现整个项目的打包，具体操作可以参考下面的动画：",-1),u=i("",19),C=e("p",null,"紧接着后面，调用了 bin/utils/convert-argv.js 模块，将得到的命令行参数转换为 Webpack 的配置选项对象，具体操作如下：",-1),A=e("p",null,"在 convert-argv.js 工作过程中，首先为传递过来的命令行参数设置了默认值，然后判断了命令行参数中是否指定了一个具体的配置文件路径，如果指定了就加载指定配置文件，反之则需要根据默认配置文件加载规则找到配置文件，具体代码如下：",-1),W=e("p",null,"找到配置文件过后，将配置文件中的配置和 CLI 参数中的配置合并，如果出现重复的情况，会优先使用 CLI 参数，最终得到一个完整的配置选项。",-1),q=e("p",null,"有了配置选项过后，开始载入 Webpack 核心模块，传入配置选项，创建 Compiler 对象，这个 Compiler 对象就是整个 Webpack 工作过程中最核心的对象了，负责完成整个项目的构建工作。",-1),T=e("h4",{id:"二、创建-compiler-对象",tabindex:"-1"},[p("二、创建 Compiler 对象 "),e("a",{class:"header-anchor",href:"#二、创建-compiler-对象","aria-label":'Permalink to "二、创建 Compiler 对象"'},"​")],-1),f=e("p",null,[p("随着 Webpack CLI 载入 Webpack 核心模块，整个执行过程就到了 Webpack 模块中，所以这一部分的代码需要回到 Webpack 模块中，我这里分析的是 v4.43.0 版本的 Webpack，可参考这个版本的"),e("a",{href:"https://github.com/webpack/webpack/tree/v4.43.0",target:"_blank",rel:"noreferrer"},"源代码的固定链接"),p("。")],-1),S=e("p",null,"同样，这里我们需要找到这个模块的入口文件，也就是 lib/webpack.js 文件。这个文件导出的是一个用于创建 Compiler 的函数，具体如下：",-1),M=e("p",null,"在这个函数中，首先校验了外部传递过来的 options 参数是否符合要求，紧接着判断了 options 的类型。",-1),L=e("p",null,"根据这个函数中的代码，我们发现 options 不仅仅可以是一个对象，还可以是一个数组。如果我们传入的是一个数组，那么 Webpack 内部创建的就是一个 MultiCompiler，也就是说 Webpack 应该支持同时开启多路打包，配置数组中的每一个成员就是一个独立的配置选项。而如果我们传入的是普通的对象，就会按照我们最熟悉的方式创建一个 Compiler 对象，进行单线打包。",-1),w=e("p",null,"我们顺着主线接着往下看，如下图所示：在创建了 Compiler 对象过后，Webpack 就开始注册我们配置中的每一个插件了，因为再往后 Webpack 工作过程的生命周期就要开始了，所以必须先注册，这样才能确保插件中的每一个钩子都能被命中。",-1),E=e("h4",{id:"三、开始构建",tabindex:"-1"},[p("三、开始构建 "),e("a",{class:"header-anchor",href:"#三、开始构建","aria-label":'Permalink to "三、开始构建"'},"​")],-1),I=e("p",null,"完成 Compiler 对象的创建过后，紧接着这里的代码开始判断配置选项中是否启用了监视模式，具体操作如下：",-1),P=e("ul",null,[e("li",null,"如果是监视模式就调用 Compiler 对象的 watch 方法，以监视模式启动构建，但这不是我们主要关心的主线。"),e("li",null,"如果不是监视模式就调用 Compiler 对象的 run 方法，开始构建整个应用。")],-1),F=e("p",null,"这个 run 方法定义在 Compiler 类型中，具体文件在 webpack 模块下的 lib/Compiler.js 中，代码位置如下：",-1),x=e("p",null,"这个方法内部就是先触发了beforeRun 和 run 两个钩子，然后最关键的是调用了当前对象的 compile 方法，真正开始编译整个项目，具体代码位置如下：",-1),B=e("p",null,'compile 方法内部主要就是创建了一个 Compilation 对象，这个对象我们在 04 课时中有提到，Compilation 字面意思是"合集"，实际上，你就可以理解为一次构建过程中的上下文对象，里面包含了这次构建中全部的资源和信息。',-1),V=e("p",null,"创建完 Compilation 对象过后，紧接着触发了一个叫作 make 的钩子，进入整个构建过程最核心的 make 阶段。",-1),v=e("h4",{id:"四、make-阶段",tabindex:"-1"},[p("四、make 阶段 "),e("a",{class:"header-anchor",href:"#四、make-阶段","aria-label":'Permalink to "四、make 阶段"'},"​")],-1),j=e("p",null,"make 阶段主体的目标就是：根据 entry 配置找到入口模块，开始依次递归出所有依赖，形成依赖关系树，然后将递归到的每个模块交给不同的 Loader 处理。",-1),y=e("p",null,"由于这个阶段的调用过程并不像之前一样，直接调用某个对象的某个方法，而是采用事件触发机制，让外部监听这个 make 事件的地方开始执行，所以从这里往后的代码可能找起来会费点劲儿。",-1),D=e("p",null,"这里我简单提示一下：想要知道这个事件触发后，哪些地方会开始执行，前提是得知道哪里注册了这个叫作 make 的事件。",-1),H=e("p",null,"Webpack 的插件系统是基于官方自己的 Tapable 库实现的，我们想要知道在哪里注册了某个事件，必须要知道如何注册的事件。Tapable 的注册方式具体如下：",-1),O=e("p",null,"所以，我们只需要通过开发工具搜索源代码中的 make.tap，就应该能够找到事件注册的位置，具体操作如下：",-1),J=e("p",null,"这里搜索到了六个插件中都注册了 make 事件，这些插件实际上是前面创建 Compiler 对象的时候创建的，刚刚因为没有影响，所以我们就忽略了：",-1),G=e("p",null,"因为我们默认使用的就是单一入口打包的方式，所以这里最终会执行其中的 SingleEntryPlugin。",-1),N=i("",12);function X(z,U,Y,K,Q,R){const a=o("Image");return c(),s("div",null,[r,_,m,t(a,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/00/4E/CgqCHl6pSFmAC5UzAAEwx63IBwE024.png"}),g,t(a,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/00/4E/Ciqc1F6pSGGAc9qLAAAkYGOB6fY837.png"}),d,h,b,t(a,{alt:"3.gif",src:"https://s0.lgstatic.com/i/image/M00/00/4E/Ciqc1F6pSHiAbuTBACPS6wVVqZw547.gif"}),k,t(a,{alt:"4小.gif",src:"https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pUBeAfHWtAG70TcGBhSM152.gif"}),u,t(a,{alt:"5.png",src:"https://s0.lgstatic.com/i/image/M00/00/51/Ciqc1F6pS9iAE-dtAAOjZcVPPzw330.png"}),C,t(a,{alt:"image.png",src:"https://s0.lgstatic.com/i/image/M00/00/53/CgqCHl6pTd-ASt6BAADU-S6qhDo690.png"}),A,t(a,{alt:"image (1).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTeaAedzEAAS80vohmio167.png"}),W,q,t(a,{alt:"image (2).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/CgqCHl6pTe6AKEyAAAFWM1c2jo4379.png"}),T,f,S,t(a,{alt:"image (3).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/CgqCHl6pThGAYBSpAAOrHJC19zY284.png"}),M,L,t(a,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pThqAB_XKAAPEsCITm7Q145.png"}),w,t(a,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTiKAHHyCAAJMG1UWDSA408.png"}),E,I,t(a,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTl6AIg5uAAJLEZQnnTE844.png"}),P,F,t(a,{alt:"image (7).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTmmAT8OjAALe_UlnYVs734.png"}),x,t(a,{alt:"image (8).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTnCAIOwcAAO9SzOiSUg967.png"}),B,t(a,{alt:"image (9).png",src:"https://s0.lgstatic.com/i/image/M00/00/53/Ciqc1F6pTniAHnnDAAHoLTnzs9A306.png"}),V,v,j,t(a,{alt:"image (10).png",src:"https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pTzWABOtoAAEXDnF67ow274.png"}),y,D,H,t(a,{alt:"image (11).png",src:"https://s0.lgstatic.com/i/image/M00/00/54/CgqCHl6pT0SAQu2BAAD1mVx6IOM261.png"}),O,t(a,{alt:"image (12).png",src:"https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pT06AdneyAARyPGKqWLw664.png"}),J,t(a,{alt:"image (13).png",src:"https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pT1aAfcDBAANqf-qyrV8871.png"}),G,t(a,{alt:"image (14).png",src:"https://s0.lgstatic.com/i/image/M00/00/54/Ciqc1F6pT12AfmmEAAF7uDrm_DY692.png"}),N])}const ee=l(n,[["render",X]]);export{Z as __pageData,ee as default};
