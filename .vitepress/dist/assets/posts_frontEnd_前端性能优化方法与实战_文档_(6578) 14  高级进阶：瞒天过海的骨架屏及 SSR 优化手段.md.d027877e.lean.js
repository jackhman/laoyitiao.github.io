import{_ as n,j as p,o,g as l,k as e,h as t,Q as c,s}from"./chunks/framework.cfb14fe0.js";const C=JSON.parse('{"title":"14高级进阶：瞒天过海的骨架屏及SSR优化手段","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/前端性能优化方法与实战_文档/(6578) 14  高级进阶：瞒天过海的骨架屏及 SSR 优化手段.md","filePath":"posts/frontEnd/前端性能优化方法与实战_文档/(6578) 14  高级进阶：瞒天过海的骨架屏及 SSR 优化手段.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/前端性能优化方法与实战_文档/(6578) 14  高级进阶：瞒天过海的骨架屏及 SSR 优化手段.md"},i=c("",52),E=s("p",null,"好了，以上就是骨架屏和 SSR 性能优化方案。在实际当中，你可能会问了：SSR 说了这么多优点，为什么没全量普及，替代掉 CSR？",-1),y=s("p",null,"这是因为， SSR 需要你对后端知识，尤其是 Node.js 知识有很好地把握，且具备一定的数据接口设计规划和设计能力，但许多前端工程师很容易忽视这方面的学习。还有，SSR 渲染进行的页面，一些事件还在绑定中，有可能会出现操作没反应的情形；一些环境变量（如 window、document ）获取不到，稍不注意也会遇到内存泄漏的问题。",-1),d=s("p",null,"当然，这些对于白屏 100ms 的效果实现，都是非常值得的，而且前者可以通过提前安排Node.js 服务端开发相关培训来解决，后者可以通过整理一份 SSR 开发规范，将一步步蹚过的坑和宝贵经验沉淀下来。",-1),u=s("p",null,"下面给你留一个思考题：",-1),h=s("blockquote",null,[s("p",null,"SSR 方案和前面提到离线化方案有什么区别？")],-1),S=s("p",null,"可以写到下面的留言区哦。接下来我们将进入下一讲 ------ WebView 层及代码架构层面优化。",-1);function m(_,q,F,g,R,v){const a=p("Image");return o(),l("div",null,[i,e(a,{alt:"溪风的思维导图14.png",src:"https://s0.lgstatic.com/i/image6/M00/32/C2/Cgp9HWBuXziAAA4DAAI6QH-dulY404.png"}),t(),E,y,d,u,h,S])}const x=n(r,[["render",m]]);export{C as __pageData,x as default};
