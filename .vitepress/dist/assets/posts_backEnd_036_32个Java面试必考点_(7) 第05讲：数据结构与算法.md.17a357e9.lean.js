import{_ as t,D as e,o as _,g as r,J as p,h as i,Q as o,m as l}from"./chunks/framework.f67d7268.js";const z=JSON.parse('{"title":"第05讲：数据结构与算法","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/036_32个Java面试必考点/(7) 第05讲：数据结构与算法.md","filePath":"posts/backEnd/036_32个Java面试必考点/(7) 第05讲：数据结构与算法.md","lastUpdated":1696682708000}'),s={name:"posts/backEnd/036_32个Java面试必考点/(7) 第05讲：数据结构与算法.md"},n=o("",6),h=o("",5),c=o("",6),d=l("p",null,"二叉树的查询时间复杂度是 log(N)，但是随着不断的插入、删除节点，二叉树的树高可能会不断变大，当一个二叉搜索树所有节点都只有左子树或者都只有右子树时，其查找性能就退化成线性的了。",-1),u=l("h6",{id:"平衡二叉树",tabindex:"-1"},[i("平衡二叉树 "),l("a",{class:"header-anchor",href:"#平衡二叉树","aria-label":'Permalink to "平衡二叉树"'},"​")],-1),b=l("p",null,"平衡二叉树可以解决上面这个问题，平衡二叉树保证每个节点左右子树的高度差的绝对值不超过 1，例如 AVL 树。AVL 树是严格的平衡二叉树，插入或删除数据时可能经常需要旋转来保持平衡，比较适合插入、删除比较少的场景。",-1),A=l("h6",{id:"红黑树",tabindex:"-1"},[i("红黑树 "),l("a",{class:"header-anchor",href:"#红黑树","aria-label":'Permalink to "红黑树"'},"​")],-1),T=l("p",null,"红黑树是一种更加实用的非严格的平衡二叉树。红黑树更关注局部平衡而非整体平衡，确保没有一条路径会比其他路径长出 2 倍，所以是接近平衡的，但减少了许多不必要的旋转操作，更加实用。前面提到过，Java 8 的 HashMap 中就应用了红黑树来解决散列冲突时的查找问题。TreeMap 也是通过红黑树来保证有序性的。",-1),m=l("p",null,"红黑树除了拥有二叉搜索树的特点外，还有以下规则，如下图所示。",-1),g=l("br",null,null,-1),B=l("br",null,null,-1),P=o("",5),q=o("",11),k=o("",18),C=o("",20),f=l("br",null,null,-1),S=l("p",null,"这个算法的时间复杂度是 N*logK。算法的优点是不用在内存中读入全部的元素，能够适用于非常大的数据集。",-1),V=l("h6",{id:"topk-变种问题",tabindex:"-1"},[i("TopK 变种问题 "),l("a",{class:"header-anchor",href:"#topk-变种问题","aria-label":'Permalink to "TopK 变种问题"'},"​")],-1),x=l("p",null,"TopK 变种的问题，就是从 N 个有序队列中，找到最小或者最大的 K 个值。这个问题的不同点在于，是对多个数据集进行排序。由于初始的数据集是有序的，因此不需要遍历完 N 个队列中所有的元素。因此，解题思路是如何减少要遍历的元素。",-1),K=l("p",null,"解题思路如下图所示。",-1),E=l("br",null,null,-1),I=o("",11),M=o("",16),N=o("",20),O=l("ul",null,[l("li",null,[l("p",null,"第 1、2 题都是基础算法，必须要牢牢掌握，一些题目要记住递归与非递归的实现，例如树的遍历、快速排序等；")]),l("li",null,[l("p",null,"类似第 5 题这样的对使用内存进行限制的题目，要考虑使用分治思想进行分解处理；")]),l("li",null,[l("p",null,"第 6 题数组去重，可以有排序和 Hash 两种思路。")])],-1),R=l("br",null,null,-1),D=l("br",null,null,-1),v=l("p",null,"第二部分真题总结如下。",-1),J=l("br",null,null,-1),H=l("ul",null,[l("li",null,[l("p",null,"第 9 题成语接龙，可以考虑使用深度优先搜索解决；")]),l("li",null,[l("p",null,"第 10 题寻找两节点公共祖先，可以考虑通过递归与非递归两种方式实现。")])],-1),U=l("p",null,"本课时完成了基础知识的学习模块，下一课时会开始讲解应用知识模块，下一课时的主题常用工具集。",-1),w=l("br",null,null,-1);function y(L,Q,$,F,j,G){const a=e("Image");return _(),r("div",null,[n,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT6AJUiFAACk7j7acPA736.png"}),i(),h,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C1/CgoB5l14oT6ARislAAIosv-_rkU883.png"}),i(),c,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT6AIEwmAAAW0UV9vPM694.png"}),i(),d,u,b,A,T,m,g,B,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C2/CgoB5l14oT6AeAxdAAAmJsTBAww115.png"}),i(),P,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT6APZerAAAkJXd9qEE912.png"}),i(),q,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C2/CgoB5l14oT6AUR7GAAAe0Dk9-gg936.png"}),i(),k,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT-Afn5rAABqVBMkMoQ782.png"}),i(),C,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C2/CgoB5l14oT-AOE1HAABBgmRTvsw099.png"}),i(),f,S,V,x,K,E,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT-AWAq1AABdS2B7K4w210.png"}),i(),I,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C2/CgoB5l14oT-AOl2vAABkMCakhSg069.png"}),i(),M,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oT-AP4CcAABsEmtOf8k652.png"}),i(),N,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C2/CgoB5l14oT-ARd_4AABHIOKApao309.png"}),i(),O,R,D,v,J,p(a,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/E1/CgotOV14oUCAaYpcAABG4nzjpc4378.png"}),i(),H,U,w])}const X=t(s,[["render",y]]);export{z as __pageData,X as default};
