import{_ as o,j as s,o as a,g as d,k as t,Q as l,s as e}from"./chunks/framework.4e7d56ce.js";const g=JSON.parse('{"title":"淘汰原理 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(203) 第23讲：Redi是如何淘汰key的？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(203) 第23讲：Redi是如何淘汰key的？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(203) 第23讲：Redi是如何淘汰key的？.md"},y=l("",16),k=e("p",null,"Redis 提供了 8 种淘汰策略对 key 进行管理，而且还引入基于样本的 eviction pool，来提升剔除的准确性，确保 在保持最大性能 的前提下，剔除最不活跃的 key。eviction pool 主要对 LRU、LFU，以及过期 dict ttl 内存管理策略 生效。处理流程为，当 Redis 内存占用超过阀值后，按策略从主 dict 或者带过期时间的 expire dict 中随机选择 N 个 key，N 默认是 5，计算每个 key 的 idle 值，按 idle 值从小到大的顺序插入 evictionPool 中，然后选择 idle 最大的那个 key，进行淘汰。",-1),c=l("",13),p=e("p",null,"第七种策略是 allkeys-lfu，它也是针对所有 key 采用最近最不经常使用的算法来淘汰。这种策略与 volatile-lfu 类似，都是在随机选择的 key 中，选择访问频率最小的 key 进行淘汰。区别在于，volatile-flu从expire dict 过期字典中选择 key，而 allkeys-lfu 是从主 dict 中选择 key。这种策略适合的场景是，需要从所有的 key 中进行淘汰，但数据有冷热区分，且越热的数据访问频率越高。",-1),n=e("br",null,null,-1),_=e("p",null,"最后一种策略是 allkeys-random，它是针对所有 key 进行随机算法进行淘汰。它也是从主 dict 中随机选择 key，然后进行删除回收。如果需要从所有的 key 中进行淘汰，并且 key 的访问没有明显热点，被随机访问，即可采用这种策略。",-1),m=e("br",null,null,-1),u=e("p",null,'OK，这节课就讲到这里啦，下一课时我将分享"Redis 持久化"，记得按时来听课哈。好，下节课见，拜拜！',-1),R=e("br",null,null,-1);function h(v,b,x,f,B,D){const i=s("Image");return a(),d("div",null,[y,t(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A6/10/CgotOV3FFsuAUbuEAACf0iVa4D4899.png"}),k,t(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A5/F0/CgoB5l3FFsuAWSfWAABSzZJO_zQ633.png"}),c,t(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/A6/10/CgotOV3FFsyARUTKAABT9Pk3F9A583.png"}),p,n,_,m,u,R])}const I=o(r,[["render",h]]);export{g as __pageData,I as default};
