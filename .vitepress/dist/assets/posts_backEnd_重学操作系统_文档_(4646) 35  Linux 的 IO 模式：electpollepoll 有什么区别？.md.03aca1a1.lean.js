import{_ as o,j as e,o as t,g as c,k as l,h as n,Q as p,s}from"./chunks/framework.cfb14fe0.js";const O=JSON.parse('{"title":"35Linux的IO模式：electpollepoll有什么区别？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学操作系统_文档/(4646) 35  Linux 的 IO 模式：electpollepoll 有什么区别？.md","filePath":"posts/backEnd/重学操作系统_文档/(4646) 35  Linux 的 IO 模式：electpollepoll 有什么区别？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/重学操作系统_文档/(4646) 35  Linux 的 IO 模式：electpollepoll 有什么区别？.md"},E=p("",8),y=p("",8),i=s("p",null,[n("如上图所示，Socket 连接了应用和协议，如果应用层的程序想要传输数据，就创建一个 Socket。应用向 Socket 中写入数据，相当于将数据发送给了另一个应用。应用从 Socket 中读取数据，相当于接收另一个应用发送的数据。而具体的操作就是由 Socket 进行封装。具体来说，"),s("strong",null,"对于 UNIX 系的操作系统，是利用 Socket 文件系统，Socket 是一种特殊的文件------每个都是一个双向的管道。一端是应用，一端是缓冲"),n("区。")],-1),F=s("p",null,"那么作为一个服务端的应用，如何知道有哪些 Socket 呢？也就是，哪些客户端连接过来了呢？这是就需要一种特殊类型的 Socket，也就是服务端 Socket 文件。",-1),d=s("p",null,"如上图所示，当有客户端连接服务端时，服务端 Socket 文件中会写入这个客户端 Socket 的文件描述符。进程可以通过 accept() 方法，从服务端 Socket 文件中读出客户端的 Socket 文件描述符，从而拿到客户端的 Socket 文件。",-1),_=s("p",null,"程序员实现一个网络服务器的时候，会先手动去创建一个服务端 Socket 文件。服务端的 Socket 文件依然会存在操作系统内核之中，并且会绑定到某个 IP 地址和端口上。以后凡是发送到这台机器、目标 IP 地址和端口号的连接请求，在形成了客户端 Socket 文件之后，文件的文件描述符都会被写入到服务端的 Socket 文件中。应用只要调用 accept 方法，就可以拿到这些客户端的 Socket 文件描述符，这样服务端的应用就可以方便地知道有哪些客户端连接了进来。",-1),A=s("p",null,"而每个客户端对这个应用而言，都是一个文件描述符。如果需要读取某个客户端的数据，就读取这个客户端对应的 Socket 文件。如果要向某个特定的客户端发送数据，就写入这个客户端的 Socket 文件。",-1),D=s("p",null,"以上就是 Socket 的编程模型。",-1),f=s("h3",{id:"i-o-多路复用",tabindex:"-1"},[n("I/O 多路复用 "),s("a",{class:"header-anchor",href:"#i-o-多路复用","aria-label":'Permalink to "I/O 多路复用"'},"​")],-1),u=s("p",null,[n("在上面的讨论当中，进程拿到了它关注的所有 Socket，也称作关注的集合（Intersting Set）。如下图所示，这种过程相当于进程从所有的 Socket 中，筛选出了自己关注的一个子集，但是这时还有一个问题没有解决："),s("strong",null,"进程如何监听关注集合的状态变化，比如说在有数据进来，如何通知到这个进程"),n("？")],-1),C=s("p",null,[n("其实更准确地说，一个线程需要处理所有关注的 Socket 产生的变化，或者说消息。实际上一个线程要处理很多个文件的 I/O。"),s("strong",null,"所有关注的 Socket 状态发生了变化，都由一个线程去处理，构成了 I/O 的多路复用问题"),n("。如下图所示：")],-1),g=s("p",null,"处理 I/O 多路复用的问题，需要操作系统提供内核级别的支持。Linux 下有三种提供 I/O 多路复用的 API，分别是：",-1),B=s("ul",null,[s("li",null,[s("p",null,"select")]),s("li",null,[s("p",null,"poll")]),s("li",null,[s("p",null,"epoll")])],-1),h=s("p",null,"如下图所示，内核了解网络的状态。因此不难知道具体发生了什么消息，比如内核知道某个 Socket 文件状态发生了变化。但是内核如何知道该把哪个消息给哪个进程呢？",-1),k=p("",44);function S(v,L,m,b,I,w){const a=e("Image");return t(),c("div",null,[E,l(a,{alt:"1111.png",src:"https://s0.lgstatic.com/i/image2/M01/05/F3/Cip5yGABb8uAECMGAAERrnFoSrI090.png"}),n(),y,l(a,{alt:"Lark20210115-150702.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABP3OAHezqAABndlGAu9c457.png"}),n(),i,F,l(a,{alt:"Lark20210115-150706.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABP3qADKbBAAB564sk120429.png"}),n(),d,_,A,D,f,u,l(a,{alt:"Lark20210115-150708.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABP4OAdKBcAACAbVkbI0g191.png"}),n(),C,l(a,{alt:"Lark20210115-150711.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABP4uAW8-dAAB_SubmZ4Q301.png"}),n(),g,B,h,l(a,{alt:"Lark20210115-150654.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABP5KAVSWVAAFSurtl2bU931.png"}),n(),k])}const T=o(r,[["render",S]]);export{O as __pageData,T as default};
