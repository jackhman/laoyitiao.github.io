import{_ as o,j as e,o as t,h as r,k as l,f as s,Q as p,s as n}from"./chunks/framework.d3daa342.js";const _=JSON.parse('{"title":"23如何在CompletableFuture异步线程中正确使用JPA？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Spring Data JPA 原理与实战_文档/(4723) 23  如何在 CompletableFuture 异步线程中正确使用 JPA？.md","filePath":"posts/backEnd/Spring Data JPA 原理与实战_文档/(4723) 23  如何在 CompletableFuture 异步线程中正确使用 JPA？.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/Spring Data JPA 原理与实战_文档/(4723) 23  如何在 CompletableFuture 异步线程中正确使用 JPA？.md"},E=p("",34),y=n("p",null,"先看一下上半部分，通过日志我们可以看到，首先执行这个方法的时候开启了两个事务，分别做如下解释。",-1),i=n("p",null,[n("strong",null,"线程 1"),s("：[nio-8087-exec-1] 开启了 UserInfoController.testSaveUser 方法上面的事务，也就是 http 的请求线程，开启了一个 Controller 请求事务。这是因为我们在 testSaveUser 的方法上面加了 @Transaction 的注解，所以开启了一个事务。")],-1),u=n("p",null,"而通过日志我们也可以发现，事务 1 里面什么都没有做，随后就进行了 Commit 操作，所以我们可以看得出来，默认不做任何处理的情况下，事务是不能跨线程的。每个线程里面的事务相互隔离、互不影响。",-1),F=n("p",null,[n("strong",null,"线程 2"),s("：[ task-1]，通过异步线程池开启了 SimpleJpaRepository.findById 方法上面的只读事务。这是因为默认的 SimpleJpaRepository 类上面加了 @Transaction(readOnly=true) 产生的结果。而我们通过 MySQL 的日志也可以看得出来，此次事务里面只做了和我们代码相关的 select user_info 的操作。")],-1),d=n("p",null,"我们再看一下后半部分的日志，如图所示。",-1),A=p("",10),C=p("",16),D=p("",6),g=p("",14);function m(v,b,h,f,B,I){const a=e("Image");return t(),r("div",null,[E,l(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/72/11/Ciqc1F_As0GAa7gmAAQU-sy_Y6s946.png"}),s(),y,i,u,F,d,l(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/72/1C/CgqCHl_As2KAPPhLAAVgCANdWbo463.png"}),s(),A,l(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/72/1C/CgqCHl_As2uAXKFdAAOga2Jcfio735.png"}),s(),C,l(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/72/11/Ciqc1F_As3uAcvehAAG5ahJbL1Y740.png"}),s(),D,l(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/72/11/Ciqc1F_As4SATk88AAEnxfK1BOo296.png"}),s(),g])}const k=o(c,[["render",m]]);export{_ as __pageData,k as default};
