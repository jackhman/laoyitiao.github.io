import{_ as p,j as t,o as e,g as r,k as n,Q as o,s,h as l}from"./chunks/framework.4e7d56ce.js";const Y=JSON.parse('{"title":"1.1 程序计数器（Program Counter Register） ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1855) 第01讲：程序运行时，内存到底是如何进行分配的？.md","filePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1855) 第01讲：程序运行时，内存到底是如何进行分配的？.md","lastUpdated":1696417798000}'),c={name:"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1855) 第01讲：程序运行时，内存到底是如何进行分配的？.md"},i=o("",4),E=s("h3",{id:"_1-1-程序计数器-program-counter-register",tabindex:"-1"},[l("1.1 程序计数器（Program Counter Register） "),s("a",{class:"header-anchor",href:"#_1-1-程序计数器-program-counter-register","aria-label":'Permalink to "1.1 程序计数器（Program Counter Register）"'},"​")],-1),y=s("p",null,[l("Java 程序是多线程的，CPU 可以在多个线程中分配执行时间片段。当某一个线程被 CPU 挂起时，需要记录代码已经执行到的位置，方便 CPU 重新执行此线程时，知道从哪行指令开始执行。这就是"),s("strong",null,"程序计数器"),l("的作用。")],-1),d=s("p",null,'"程序计数器"是虚拟机中一块较小的内存空间，主要用于记录当前线程执行的位置。',-1),_=s("p",null,"如下图所示：每个线程都会记录一个当前方法执行到的位置，当 CPU 切换回某一个线程上时，则根据程序计数器记录的数字，继续向下执行指令。",-1),g=o("",12),h=o("",30),F=s("p",null,"icons_1 把常量 1 压入操作数栈顶，结果如下：",-1),C=s("p",null,"istore_1 把操作数栈顶的元素出栈并放入局部变量表下标为 1 的位置，结果如下：",-1),A=s("p",null,[s("strong",null,"可以看出此时操作数栈重新变为空，并将出栈的元素 1 保存在局部变量表中。")],-1),u=s("p",null,"iconst_2 把常量 2 压入操作数栈顶，结果如下：",-1),m=s("p",null,"istore_2 把操作数栈顶的元素出栈并放入局部变量表下标为 2 的位置，结果如下：",-1),D=s("p",null,"接下来是两步 iload 操作，分别是 iload_1 和 iload_2。分别代表的是将局部变量表中下标为 1 和下标为 2 的元素重新压入操作数栈中，结果如下：",-1),v=s("p",null,"接下来进行 iadd 操作，这个操作会将栈顶最上方的两个元素（也就是 1、2）进行加法操作，然后将结果重新压入到栈顶，执行完之后的结果如下：",-1),q=s("p",null,"istor_3 将操作数栈顶的元素出栈，并保存在局部变量表下标为 3 的位置。结果如下：",-1),B=s("p",null,"iload_3 将局部变量表中下标为 3 的元素重新压入到操作数栈顶，结果如下：",-1),b=s("p",null,"bipush 10 将常量 10 压入到操作数栈中，结果如下：",-1),k=s("p",null,"再次执行 iadd 操作，注意此时栈顶最上方的两个元素为 3 和 10，所以执行完结果如下：",-1),f=o("",6),M=o("",10),J=s("p",null,"在method方法中，递归调用了自身，并且没有设置递归结束条件。运行上述代码时，则会产生StackOverflowError。",-1),P=s("p",null,"原因就是每调用一次method方法时，都会在虚拟机栈中创建出一个栈帧。因为是递归调用，method方法并不会退出，也不会将栈帧销毁，所以必然会导致StackOverflowError。因此当需要使用递归时，需要格外谨慎。",-1),S=s("h4",{id:"outofmemoryerror-内存溢出异常",tabindex:"-1"},[l("OutOfMemoryError 内存溢出异常 "),s("a",{class:"header-anchor",href:"#outofmemoryerror-内存溢出异常","aria-label":'Permalink to "OutOfMemoryError 内存溢出异常"'},"​")],-1),T=s("p",null,"理论上，虚拟机栈、堆、方法区都有发生OutOfMemoryError的可能。但是实际项目中，大多发生于堆当中。比如以下代码：",-1),x=s("p",null,"在一个无限循环中，动态的向ArrayList中添加新的HeapError对象。这会不断的占用堆中的内存，当堆内存不够时，必然会产生OutOfMemoryError，也就是内存溢出异常。",-1),V=s("p",null,"上图中的Xms和Xmx是虚拟机运行参数，将会在下一节垃圾回收中详细介绍。",-1),O=s("h3",{id:"总结",tabindex:"-1"},[l("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),j=s("p",null,[l('对于 JVM 运行时内存布局，我们需要始终记住一点：上面介绍的这 5 块内容都是在 Java 虚拟机规范中定义的规则，这些规则只是描述了各个区域是负责做什么事情、存储什么样的数据、如何处理异常、是否允许线程间共享等。千万不要将它们理解为虚拟机的"'),s("strong",null,"具体实现"),l('"，虚拟机的具体实现有很多，比如 Sun 公司的 HotSpot、JRocket、IBM J9、以及我们非常熟悉的 Android Dalvik 和 ART 等。这些具体实现在符合上面 5 种运行时数据区的前提下，又各自有不同的实现方式。')],-1),I=s("p",null,"最后我们借助一张图来概括一下本课时所介绍的内容：",-1),H=s("p",null,'总结来说，JVM 的运行时内存结构中一共有两个"栈"和一个"堆"，分别是：Java 虚拟机栈和本地方法栈，以及"GC堆"和方法区。除此之外还有一个程序计数器，但是我们开发者几乎不会用到这一部分，所以并不是重点学习内容。 JVM 内存中只有堆和方法区是线程共享的数据区域，其它区域都是线程私有的。并且程序计数器是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。',-1);function N(U,w,L,W,R,z){const a=t("Image");return e(),r("div",null,[i,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/03/38/Ciqah158SbeAQdCSAAEEJ1oi53Y731.png"}),E,y,d,_,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/02/5F/Ciqah1568qOAbdSwAACfAFxEuk8310.png"}),g,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/02/8C/Ciqah157F6SAJiwFAACto3B4htg907.png"}),h,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/F6/Ciqah16B6TaAf1-0AAAysGLvaNA217.png"}),F,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0C/Cgq2xl6B6UiAVDhgAAAz1ETy_zw863.png"}),C,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/F6/Ciqah16B6WWAQaemAAAzA5dFKek577.png"}),A,u,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/F6/Ciqah16B6XWAB-KtAAA1E4L0-z4184.png"}),m,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0D/Cgq2xl6B6YCAN_XlAAA0TOko7wE207.png"}),D,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/F7/Ciqah16B6ZOAezePAAA3FSLJoEQ663.png"}),v,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0D/Cgq2xl6B6aSAYhxEAAA2GX0vtbs275.png"}),q,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0D/Cgq2xl6B6beAcZjxAAA1yUigm-I994.png"}),B,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0D/Cgq2xl6B6dSAFVW3AAA4HqFzta4068.png"}),b,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0D/Cgq2xl6B6eOACfCXAAA7AQP5ezo044.png"}),k,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7F/0D/Cgq2xl6B6fWAHG84AAA40zwhtMc116.png"}),f,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7B/A3/Cgq2xl57GDCAVkHYAABVMCBYUEE302.png"}),M,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/02/5F/Ciqah1568qWAdPyHAADRtq7PYeU036.png"}),J,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7B/76/Cgq2xl568qWAMaBbAAAkXac4E1U378.png"}),P,S,T,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/02/5F/Ciqah1568qaAbiVsAAB-bnJ26yU637.png"}),x,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7B/76/Cgq2xl568qaATF_fAADLwH6bQoU914.png"}),V,O,j,I,n(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/02/8D/Ciqah157GD2AYLFtAADxheNgCA0454.png"}),H])}const X=p(c,[["render",N]]);export{Y as __pageData,X as default};
