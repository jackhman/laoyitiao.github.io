import{_ as i,j as o,o as r,h as s,k as t,f as a,Q as h,s as e}from"./chunks/framework.d3daa342.js";const E=JSON.parse('{"title":"第02讲：如何根据业务来选择缓存模式和组件？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(161) 第02讲：如何根据业务来选择缓存模式和组件？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(161) 第02讲：如何根据业务来选择缓存模式和组件？.md","lastUpdated":1696682708000}'),l={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(161) 第02讲：如何根据业务来选择缓存模式和组件？.md"},n=h("",5),_=e("h6",{id:"cache-aside",tabindex:"-1"},[a("Cache Aside "),e("a",{class:"header-anchor",href:"#cache-aside","aria-label":'Permalink to "Cache Aside"'},"​")],-1),d=e("br",null,null,-1),p=e("p",null,"如上图所示，Cache Aside 模式中，业务应用方对于写，是更新 DB 后，直接将 key 从 cache 中删除，然后由 DB 驱动缓存数据的更新；而对于读，是先读 cache，如果 cache 没有，则读 DB，同时将从 DB 中读取的数据回写到 cache。",-1),u=e("p",null,"这种模式的特点是，业务端处理所有数据访问细节，同时利用 Lazy 计算的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率。",-1),g=e("p",null,"如果没有专门的存储服务，同时是对数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务，这些情况都比较适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式，这些缓存数据需要通过多个原始数据进行计算后设置。在部分数据变更后，直接删除缓存。同时，使用一个 Trigger 组件，实时读取 DB 的变更日志，然后重新计算并更新缓存。如果读缓存的时候，Trigger 还没写入 cache，则由调用方自行到 DB 加载计算并写入 cache。",-1),B=e("h6",{id:"read-write-through",tabindex:"-1"},[a("Read/Write Through "),e("a",{class:"header-anchor",href:"#read-write-through","aria-label":'Permalink to "Read/Write Through"'},"​")],-1),C=e("h6",{id:"",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#","aria-label":'Permalink to ""'},"​")],-1),b=e("br",null,null,-1),m=e("br",null,null,-1),D=e("p",null,"如上图，对于 Cache Aside 模式，业务应用需要同时维护 cache 和 DB 两个数据存储方，过于繁琐，于是就有了 Read/Write Through 模式。在这种模式下，业务应用只关注一个存储服务即可，业务方的读写 cache 和 DB 的操作，都由存储服务代理。存储服务收到业务应用的写请求时，会首先查 cache，如果数据在 cache 中不存在，则只更新 DB，如果数据在 cache 中存在，则先更新 cache，然后更新 DB。而存储服务收到读请求时，如果命中 cache 直接返回，否则先从 DB 加载，回种到 cache 后返回响应。",-1),k=e("p",null,"这种模式的特点是，存储服务封装了所有的数据处理细节，业务应用端代码只用关注业务逻辑本身，系统的隔离性更佳。另外，进行写操作时，如果 cache 中没有数据则不更新，有缓存数据才更新，内存效率更高。",-1),A=e("p",null,"微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。",-1),f=e("h6",{id:"write-behind-caching",tabindex:"-1"},[a("Write Behind Caching "),e("a",{class:"header-anchor",href:"#write-behind-caching","aria-label":'Permalink to "Write Behind Caching"'},"​")],-1),T=h("",17);function x(P,S,R,q,V,F){const c=o("Image");return r(),s("div",null,[n,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/8F/CgotOV2kRdSARL_yAABgmkQ_X6k170.png"}),a(),_,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/6F/CgoB5l2kRdSAE8I4AAFjGcx_DP4974.png"}),a(),d,p,u,g,B,C,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/8F/CgotOV2kRdSAGi0EAAFFkVZArO4978.png"}),a(),b,m,D,k,A,f,t(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/6F/CgoB5l2kRdSAKsw-AAFBxhGDxBU820.png"}),a(),T])}const I=i(l,[["render",x]]);export{E as __pageData,I as default};
