import{_ as o,j as h,o as i,g as s,k as t,s as a,Q as l,h as r}from"./chunks/framework.b3d8e22e.js";const I=JSON.parse('{"title":"缓存失效 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(163) 第04讲：缓存失效、穿透和雪崩问题怎么处理？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(163) 第04讲：缓存失效、穿透和雪崩问题怎么处理？.md","lastUpdated":1696417798000}'),n={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(163) 第04讲：缓存失效、穿透和雪崩问题怎么处理？.md"},_=a("p",null,'你好，我是你的缓存老师陈波，欢迎进入第 4 课时"缓存访问相关的经典问题"。',-1),c=a("p",null,"前面讲解了缓存的原理、引入，以及设计架构，总结了缓存在使用及设计架构过程中的很多套路和关键考量点。实际上，在缓存系统的设计架构中，还有很多坑，很多的明枪暗箭，如果设计不当会导致很多严重的后果。设计不当，轻则请求变慢、性能降低，重则会数据不一致、系统可用性降低，甚至会导致缓存雪崩，整个系统无法对外提供服务。",-1),d=a("p",null,"接下来将对缓存设计中的 7 大经典问题，如下图，进行问题描述、原因分析，并给出日常研发中，可能会出现该问题的业务场景，最后给出这些经典问题的解决方案。本课时首先学习缓存失效、缓存穿透与缓存雪崩。",-1),p=l("",10),k=l("",11),u=a("p",null,"不过这两种方案在设计时仍然有一些要注意的坑。",-1),m=a("ul",null,[a("li",null,[a("p",null,"对于方案一，如果特殊访客持续访问大量的不存在的 key，这些 key 即便只存一个简单的默认值，也会占用大量的缓存空间，导致正常 key 的命中率下降。所以进一步的改进措施是，对这些不存在的 key 只存较短的时间，让它们尽快过期；或者将这些不存在的 key 存在一个独立的公共缓存，从缓存查找时，先查正常的缓存组件，如果 miss，则查一下公共的非法 key 的缓存，如果后者命中，直接返回，否则穿透 DB，如果查出来是空，则回种到非法 key 缓存，否则回种到正常缓存。")]),a("li",null,[a("p",null,"对于方案二，BloomFilter 要缓存全量的 key，这就要求全量的 key 数量不大，10亿 条数据以内最佳，因为 10亿 条数据大概要占用 1.2GB 的内存。也可以用 BloomFilter 缓存非法 key，每次发现一个 key 是不存在的非法 key，就记录到 BloomFilter 中，这种记录方案，会导致 BloomFilter 存储的 key 持续高速增长，为了避免记录 key 太多而导致误判率增大，需要定期清零处理。")])],-1),B=a("h6",{id:"bloomfilter",tabindex:"-1"},[r("BloomFilter "),a("a",{class:"header-anchor",href:"#bloomfilter","aria-label":'Permalink to "BloomFilter"'},"​")],-1),b=a("p",null,"BloomFilter 是一个非常有意思的数据结构，不仅仅可以挡住非法 key 攻击，还可以低成本、高性能地对海量数据进行判断，比如一个系统有数亿用户和百亿级新闻 feed，就可以用 BloomFilter 来判断某个用户是否阅读某条新闻 feed。下面来对 BloomFilter 数据结构做一个分析，如下图所示。",-1),y=l("",17),D=a("ul",null,[a("li",null,[a("p",null,"方案二，对缓存增加多个副本，缓存异常或请求 miss 后，再读取其他缓存副本，而且多个缓存副本尽量部署在不同机架，从而确保在任何情况下，缓存系统都会正常对外提供服务。")]),a("li",null,[a("p",null,"方案三，对缓存体系进行实时监控，当请求访问的慢速比超过阀值时，及时报警，通过机器替换、服务替换进行及时恢复；也可以通过各种自动故障转移策略，自动关闭异常接口、停止边缘服务、停止部分非核心功能措施，确保在极端场景下，核心功能的正常运行。")])],-1),q=a("p",null,"实际上，微博平台系统，这三种方案都采用了，通过三管齐下，规避缓存雪崩的发生。",-1),f=a("br",null,null,-1),T=a("p",null,'OK，这节课就讲到这里，下一课时我会分享"缓存数据相关的经典问题"，记得按时来听课哈。好，下节课见，拜拜！',-1);function g(A,P,x,C,F,H){const e=h("Image");return i(),s("div",null,[_,c,d,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/94/CgotOV2kTKKAVD94AAIOd1w5wy8841.png"}),p,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/74/CgoB5l2kTKKAVkTnAAFhcJtdQl0573.png"}),k,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/94/CgotOV2kTKOAZcRHAAIFuQZE-no463.png"}),u,m,B,b,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/74/CgoB5l2kTKOABkQdAAFikFQHrgc863.png"}),y,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/94/CgotOV2kTKOAX4H_AACZ92HqRoY447.png"}),D,q,f,T])}const S=o(n,[["render",g]]);export{I as __pageData,S as default};
