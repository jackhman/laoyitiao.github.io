import{_ as o,j as e,o as t,g as r,k as l,h as n,s,Q as p}from"./chunks/framework.4e7d56ce.js";const P=JSON.parse('{"title":"35负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(5363) 35  负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(5363) 35  负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Dubbo源码解读与实战_文档/(5363) 35  负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）.md"},E=s("h1",{id:"_35负载均衡-公平公正物尽其用的负载均衡策略-这里都有-上",tabindex:"-1"},[n("35负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上） "),s("a",{class:"header-anchor",href:"#_35负载均衡-公平公正物尽其用的负载均衡策略-这里都有-上","aria-label":'Permalink to "35负载均衡：公平公正物尽其用的负载均衡策略，这里都有（上）"'},"​")],-1),y=s("p",null,"在前面的课时中，我们已经详细介绍了 dubbo-cluster 模块中的 Directory 和 Router 两个核心接口以及核心实现，同时也介绍了这两个接口相关的周边知识。本课时我们继续按照下图的顺序介绍 LoadBalance 的相关内容。",-1),i=p('<p>LoadBalance 核心接口图</p><p><strong>LoadBalance（负载均衡）的职责是将网络请求或者其他形式的负载&quot;均摊&quot;到不同的服务节点上，从而避免服务集群中部分节点压力过大、资源紧张，而另一部分节点比较空闲的情况。</strong></p><p>通过合理的负载均衡算法，我们希望可以让每个服务节点获取到适合自己处理能力的负载，<strong>实现处理能力和流量的合理分配</strong> 。常用的负载均衡可分为<strong>软件负载均衡</strong> （比如，日常工作中使用的 Nginx）和<strong>硬件负载均衡</strong>（主要有 F5、Array、NetScaler 等，不过开发工程师在实践中很少直接接触到）。</p><p>常见的 RPC 框架中都有负载均衡的概念和相应的实现，Dubbo 也不例外。Dubbo 需要对 Consumer 的调用请求进行分配，避免少数 Provider 节点负载过大，而剩余的其他 Provider 节点处于空闲的状态。因为当 Provider 负载过大时，就会导致一部分请求超时、丢失等一系列问题发生，造成线上故障。</p><p>Dubbo 提供了 5 种负载均衡实现，分别是：</p><ul><li><p>基于 Hash 一致性的 ConsistentHashLoadBalance；</p></li><li><p>基于权重随机算法的 RandomLoadBalance；</p></li><li><p>基于最少活跃调用数算法的 LeastActiveLoadBalance；</p></li><li><p>基于加权轮询算法的 RoundRobinLoadBalance；</p></li><li><p>基于最短响应时间的 ShortestResponseLoadBalance 。</p></li></ul><h3 id="loadbalance-接口" tabindex="-1">LoadBalance 接口 <a class="header-anchor" href="#loadbalance-接口" aria-label="Permalink to &quot;LoadBalance 接口&quot;">​</a></h3><p>上述 Dubbo 提供的负载均衡实现，都是 LoadBalance 接口的实现类，如下图所示：</p>',8),F=p(`<p>LoadBalance 继承关系图</p><p><strong>LoadBalance 是一个扩展接口，默认使用的扩展实现是 RandomLoadBalance</strong>，其定义如下所示，其中的 @Adaptive 注解参数为 loadbalance，即动态生成的适配器会按照 URL 中的 loadbalance 参数值选择扩展实现类。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span><span style="color:#E1E4E8;">(RandomLoadBalance.NAME)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LoadBalance</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;loadbalance&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(List&lt;Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;&gt; </span><span style="color:#FFAB70;">invokers</span><span style="color:#E1E4E8;">, URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span><span style="color:#24292E;">(RandomLoadBalance.NAME)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LoadBalance</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;loadbalance&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(List&lt;Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;&gt; </span><span style="color:#E36209;">invokers</span><span style="color:#24292E;">, URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>LoadBalance 接口中 select() 方法的核心功能是根据传入的 URL 和 Invocation，以及自身的负载均衡算法，从 Invoker 集合中选择一个 Invoker 返回。</p><p>AbstractLoadBalance 抽象类并没有真正实现 select() 方法，只是对 Invoker 集合为空或是只包含一个 Invoker 对象的特殊情况进行了处理，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, URL url, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CollectionUtils.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(invokers)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// Invoker集合为空，直接返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// Invoker集合只包含一个Invoker，则直接返回该Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Invoker集合包含多个Invoker对象时，交给doSelect()方法处理，这是个抽象方法，留给子类具体实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSelect</span><span style="color:#E1E4E8;">(invokers, url, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, URL url, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CollectionUtils.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(invokers)) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// Invoker集合为空，直接返回null</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// Invoker集合只包含一个Invoker，则直接返回该Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Invoker集合包含多个Invoker对象时，交给doSelect()方法处理，这是个抽象方法，留给子类具体实现</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSelect</span><span style="color:#24292E;">(invokers, url, invocation);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>另外，AbstractLoadBalance 还提供了一个 getWeight() 方法，该方法用于计算 Provider 权重，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getWeight</span><span style="color:#E1E4E8;">(Invoker</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> invoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> weight;</span></span>
<span class="line"><span style="color:#E1E4E8;">    URL url </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (REGISTRY_SERVICE_REFERENCE_PATH.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(url.</span><span style="color:#B392F0;">getServiceInterface</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果是RegistryService接口的话，直接获取权重即可</span></span>
<span class="line"><span style="color:#E1E4E8;">        weight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(REGISTRY_KEY </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;.&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> WEIGHT_KEY, DEFAULT_WEIGHT);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        weight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getMethodParameter</span><span style="color:#E1E4E8;">(invocation.</span><span style="color:#B392F0;">getMethodName</span><span style="color:#E1E4E8;">(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (weight </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 获取服务提供者的启动时间戳</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> timestamp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(TIMESTAMP_KEY, </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (timestamp </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0L</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 计算Provider运行时长</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> uptime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> timestamp;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (uptime </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 计算Provider预热时长</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> warmup </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(WARMUP_KEY, DEFAULT_WARMUP);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果Provider运行时间小于预热时间，则该Provider节点可能还在预热阶段，需要重新计算服务权重(降低其权重)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (uptime </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> uptime </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> warmup) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    weight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">calculateWarmupWeight</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)uptime, warmup, weight);</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(weight, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getWeight</span><span style="color:#24292E;">(Invoker</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> invoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> weight;</span></span>
<span class="line"><span style="color:#24292E;">    URL url </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (REGISTRY_SERVICE_REFERENCE_PATH.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(url.</span><span style="color:#6F42C1;">getServiceInterface</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果是RegistryService接口的话，直接获取权重即可</span></span>
<span class="line"><span style="color:#24292E;">        weight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(REGISTRY_KEY </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;.&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> WEIGHT_KEY, DEFAULT_WEIGHT);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        weight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getMethodParameter</span><span style="color:#24292E;">(invocation.</span><span style="color:#6F42C1;">getMethodName</span><span style="color:#24292E;">(), WEIGHT_KEY, DEFAULT_WEIGHT);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (weight </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 获取服务提供者的启动时间戳</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> timestamp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(TIMESTAMP_KEY, </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (timestamp </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0L</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 计算Provider运行时长</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> uptime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> timestamp;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (uptime </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 计算Provider预热时长</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> warmup </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(WARMUP_KEY, DEFAULT_WARMUP);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果Provider运行时间小于预热时间，则该Provider节点可能还在预热阶段，需要重新计算服务权重(降低其权重)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (uptime </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> uptime </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> warmup) {</span></span>
<span class="line"><span style="color:#24292E;">                    weight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">calculateWarmupWeight</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)uptime, warmup, weight);</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(weight, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>calculateWarmupWeight() 方法的目的是对还在预热状态的 Provider 节点进行降权，避免 Provider 一启动就有大量请求涌进来。服务预热是一个优化手段，这是由 JVM 本身的一些特性决定的，例如，JIT 等方面的优化，我们一般会在服务启动之后，让其在小流量状态下运行一段时间，然后再逐步放大流量。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">calculateWarmupWeight</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> uptime, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> warmup, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> weight) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算权重，随着服务运行时间uptime增大，权重ww的值会慢慢接近配置值weight</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ww </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">) ( uptime </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> ((</span><span style="color:#F97583;">float</span><span style="color:#E1E4E8;">) warmup </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> weight));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ww </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(ww, weight));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">calculateWarmupWeight</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> uptime, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> warmup, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> weight) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算权重，随着服务运行时间uptime增大，权重ww的值会慢慢接近配置值weight</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ww </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">) ( uptime </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> ((</span><span style="color:#D73A49;">float</span><span style="color:#24292E;">) warmup </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> weight));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ww </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(ww, weight));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>了解了 LoadBalance 接口的定义以及 AbstractLoadBalance 提供的公共能力之后，下面我们开始逐个介绍 LoadBalance 接口的具体实现。</p><h3 id="consistenthashloadbalance" tabindex="-1">ConsistentHashLoadBalance <a class="header-anchor" href="#consistenthashloadbalance" aria-label="Permalink to &quot;ConsistentHashLoadBalance&quot;">​</a></h3><p>ConsistentHashLoadBalance 底层使用一致性 Hash 算法实现负载均衡。为了让你更好地理解这部分内容，我们先来简单介绍一下一致性 Hash 算法相关的知识点。</p><h4 id="_1-一致性-hash-简析" tabindex="-1">1. 一致性 Hash 简析 <a class="header-anchor" href="#_1-一致性-hash-简析" aria-label="Permalink to &quot;1. 一致性 Hash 简析&quot;">​</a></h4><p><strong>一致性 Hash 负载均衡可以让参数相同的请求每次都路由到相同的服务节点上</strong>，这种负载均衡策略可以在某些 Provider 节点下线的时候，让这些节点上的流量平摊到其他 Provider 上，不会引起流量的剧烈波动。</p><p>下面我们通过一个示例，简单介绍一致性 Hash 算法的原理。</p><p>假设现在有 1、2、3 三个 Provider 节点对外提供服务，有 100 个请求同时到达，如果想让请求尽可能均匀地分布到这三个 Provider 节点上，我们可能想到的最简单的方法就是 Hash 取模，即 hash(请求参数) % 3。如果参与 Hash 计算的是请求的全部参数，那么参数相同的请求将会落到同一个 Provider 节点上。不过此时如果突然有一个 Provider 节点出现宕机的情况，那我们就需要对 2 取模，即请求会重新分配到相应的 Provider 之上。在极端情况下，甚至会出现所有请求的处理节点都发生了变化，这就会造成比较大的波动。</p><p>为了避免因一个 Provider 节点宕机，而导致大量请求的处理节点发生变化的情况，我们可以考虑使用一致性 Hash 算法。<strong>一致性 Hash 算法的原理也是取模算法，与 Hash 取模的不同之处在于：Hash 取模是对 Provider 节点数量取模，而一致性 Hash 算法是对 2^32 取模。</strong></p><p>一致性 Hash 算法需要同时对 Provider 地址以及请求参数进行取模：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(Provider地址) </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#F97583;">^</span><span style="color:#79B8FF;">32</span></span>
<span class="line"><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(请求参数) </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#F97583;">^</span><span style="color:#79B8FF;">32</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(Provider地址) </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#D73A49;">^</span><span style="color:#005CC5;">32</span></span>
<span class="line"><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(请求参数) </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#D73A49;">^</span><span style="color:#005CC5;">32</span></span></code></pre></div><p>Provider 地址和请求经过对 2^32 取模得到的结果值，都会落到一个 Hash 环上，如下图所示：</p>`,21),h=s("p",null,"一致性 Hash 节点均匀分布图",-1),d=s("p",null,"我们按顺时针的方向，依次将请求分发到对应的 Provider。这样，当某台 Provider 节点宕机或增加新的 Provider 节点时，只会影响这个 Provider 节点对应的请求。",-1),g=s("p",null,"在理想情况下，一致性 Hash 算法会将这三个 Provider 节点均匀地分布到 Hash 环上，请求也可以均匀地分发给这三个 Provider 节点。但在实际情况中，这三个 Provider 节点地址取模之后的值，可能差距不大，这样会导致大量的请求落到一个 Provider 节点上，如下图所示：",-1),A=s("p",null,"一致性 Hash 节点非均匀分布图",-1),v=s("p",null,[n("这就出现了数据倾斜的问题。"),s("strong",null,"所谓数据倾斜是指由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到少量请求的情况"),n("。")],-1),D=s("p",null,"为了解决一致性 Hash 算法中出现的数据倾斜问题，又演化出了 Hash 槽的概念。",-1),u=s("p",null,"Hash 槽解决数据倾斜的思路是：既然问题是由 Provider 节点在 Hash 环上分布不均匀造成的，那么可以虚拟出 n 组 P1、P2、P3 的 Provider 节点 ，让多组 Provider 节点相对均匀地分布在 Hash 环上。如下图所示，相同阴影的节点均为同一个 Provider 节点，比如 P1-1、P1-2......P1-99 表示的都是 P1 这个 Provider 节点。引入 Provider 虚拟节点之后，让 Provider 在圆环上分散开来，以避免数据倾斜问题。",-1),C=p(`<p>数据倾斜解决示意图</p><h4 id="_2-consistenthashselector-实现分析" tabindex="-1">2. ConsistentHashSelector 实现分析 <a class="header-anchor" href="#_2-consistenthashselector-实现分析" aria-label="Permalink to &quot;2. ConsistentHashSelector 实现分析&quot;">​</a></h4><p>了解了一致性 Hash 算法的基本原理之后，我们再来看一下 ConsistentHashLoadBalance 一致性 Hash 负载均衡的具体实现。首先来看 doSelect() 方法的实现，其中会根据 ServiceKey 和 methodName 选择一个 ConsistentHashSelector 对象，<strong>核心算法都委托给 ConsistentHashSelector 对象完成。</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSelect</span><span style="color:#E1E4E8;">(List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, URL url, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取调用的方法名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    String methodName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcUtils.</span><span style="color:#B392F0;">getMethodName</span><span style="color:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将ServiceKey和方法拼接起来，构成一个key</span></span>
<span class="line"><span style="color:#E1E4E8;">    String key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getServiceKey</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;.&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> methodName;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意：这是为了在invokers列表发生变化时都会重新生成ConsistentHashSelector对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> invokersHashCode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">hashCode</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据key获取对应的ConsistentHashSelector对象，selectors是一个ConcurrentMap&lt;String, ConsistentHashSelector&gt;集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    ConsistentHashSelector&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; selector </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ConsistentHashSelector</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">) selectors.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (selector </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> selector.identityHashCode </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> invokersHashCode) { </span><span style="color:#6A737D;">// 未查找到ConsistentHashSelector对象，则进行创建</span></span>
<span class="line"><span style="color:#E1E4E8;">        selectors.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(key, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ConsistentHashSelector&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;(invokers, methodName, invokersHashCode));</span></span>
<span class="line"><span style="color:#E1E4E8;">        selector </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ConsistentHashSelector</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">) selectors.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过ConsistentHashSelector对象选择一个Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> selector.</span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSelect</span><span style="color:#24292E;">(List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, URL url, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取调用的方法名称</span></span>
<span class="line"><span style="color:#24292E;">    String methodName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcUtils.</span><span style="color:#6F42C1;">getMethodName</span><span style="color:#24292E;">(invocation);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将ServiceKey和方法拼接起来，构成一个key</span></span>
<span class="line"><span style="color:#24292E;">    String key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getServiceKey</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;.&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> methodName;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意：这是为了在invokers列表发生变化时都会重新生成ConsistentHashSelector对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> invokersHashCode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">hashCode</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据key获取对应的ConsistentHashSelector对象，selectors是一个ConcurrentMap&lt;String, ConsistentHashSelector&gt;集合</span></span>
<span class="line"><span style="color:#24292E;">    ConsistentHashSelector&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; selector </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (ConsistentHashSelector</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">) selectors.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (selector </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> selector.identityHashCode </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> invokersHashCode) { </span><span style="color:#6A737D;">// 未查找到ConsistentHashSelector对象，则进行创建</span></span>
<span class="line"><span style="color:#24292E;">        selectors.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(key, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ConsistentHashSelector&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;(invokers, methodName, invokersHashCode));</span></span>
<span class="line"><span style="color:#24292E;">        selector </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (ConsistentHashSelector</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">) selectors.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过ConsistentHashSelector对象选择一个Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> selector.</span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(invocation);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>下面我们来看 ConsistentHashSelector，其核心字段如下所示。</p><ul><li><p>virtualInvokers（TreeMap&lt;Long, Invoker<code>&lt;T&gt;</code>&gt; 类型）：用于记录虚拟 Invoker 对象的 Hash 环。这里使用 TreeMap 实现 Hash 环，并将虚拟的 Invoker 对象分布在 Hash 环上。</p></li><li><p>replicaNumber（int 类型）：虚拟 Invoker 个数。</p></li><li><p>identityHashCode（int 类型）：Invoker 集合的 HashCode 值。</p></li><li><p>argumentIndex（int[] 类型）：需要参与 Hash 计算的参数索引。例如，argumentIndex = [0, 1, 2] 时，表示调用的目标方法的前三个参数要参与 Hash 计算。</p></li></ul><p>接下来看 ConsistentHashSelector 的构造方法，其中的主要任务是：</p><ul><li><p>构建 Hash 槽；</p></li><li><p>确认参与一致性 Hash 计算的参数，默认是第一个参数。</p></li></ul><p>这些操作的目的就是为了让 Invoker 尽可能均匀地分布在 Hash 环上，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">ConsistentHashSelector</span><span style="color:#E1E4E8;">(List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, String methodName, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> identityHashCode) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化virtualInvokers字段，也就是虚拟Hash槽</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.virtualInvokers </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> TreeMap&lt;</span><span style="color:#F97583;">Long</span><span style="color:#E1E4E8;">, Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 记录Invoker集合的hashCode，用该hashCode值来判断Provider列表是否发生了变化</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.identityHashCode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> identityHashCode;</span></span>
<span class="line"><span style="color:#E1E4E8;">    URL url </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从hash.nodes参数中获取虚拟节点的个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.replicaNumber </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> url.</span><span style="color:#B392F0;">getMethodParameter</span><span style="color:#E1E4E8;">(methodName, HASH_NODES, </span><span style="color:#79B8FF;">160</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取参与Hash计算的参数下标值，默认对第一个参数进行Hash运算</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> COMMA_SPLIT_PATTERN.</span><span style="color:#B392F0;">split</span><span style="color:#E1E4E8;">(url.</span><span style="color:#B392F0;">getMethodParameter</span><span style="color:#E1E4E8;">(methodName, HASH_ARGUMENTS, </span><span style="color:#9ECBFF;">&quot;0&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    argumentIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[index.length];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> index.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        argumentIndex[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.</span><span style="color:#B392F0;">parseInt</span><span style="color:#E1E4E8;">(index[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 构建虚拟Hash槽，默认replicaNumber=160，相当于在Hash槽上放160个槽位</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 外层轮询40次，内层轮询4次，共40*4=160次，也就是同一节点虚拟出160个槽位</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; invoker </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> invokers) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        String address </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getAddress</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> replicaNumber </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 对address + i进行md5运算，得到一个长度为16的字节数组</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] digest </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">md5</span><span style="color:#E1E4E8;">(address </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> i);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 对digest部分字节进行4次Hash运算，得到4个不同的long型正整数</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> h </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; h </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">; h</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// h = 0 时，取 digest 中下标为 0~3 的 4 个字节进行位运算</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// h = 1 时，取 digest 中下标为 4~7 的 4 个字节进行位运算</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// h = 2 和 h = 3时，过程同上</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> m </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(digest, h);</span></span>
<span class="line"><span style="color:#E1E4E8;">                virtualInvokers.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(m, invoker);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">ConsistentHashSelector</span><span style="color:#24292E;">(List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, String methodName, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> identityHashCode) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化virtualInvokers字段，也就是虚拟Hash槽</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.virtualInvokers </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> TreeMap&lt;</span><span style="color:#D73A49;">Long</span><span style="color:#24292E;">, Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 记录Invoker集合的hashCode，用该hashCode值来判断Provider列表是否发生了变化</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.identityHashCode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> identityHashCode;</span></span>
<span class="line"><span style="color:#24292E;">    URL url </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从hash.nodes参数中获取虚拟节点的个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.replicaNumber </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> url.</span><span style="color:#6F42C1;">getMethodParameter</span><span style="color:#24292E;">(methodName, HASH_NODES, </span><span style="color:#005CC5;">160</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取参与Hash计算的参数下标值，默认对第一个参数进行Hash运算</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> COMMA_SPLIT_PATTERN.</span><span style="color:#6F42C1;">split</span><span style="color:#24292E;">(url.</span><span style="color:#6F42C1;">getMethodParameter</span><span style="color:#24292E;">(methodName, HASH_ARGUMENTS, </span><span style="color:#032F62;">&quot;0&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    argumentIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[index.length];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> index.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        argumentIndex[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.</span><span style="color:#6F42C1;">parseInt</span><span style="color:#24292E;">(index[i]);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 构建虚拟Hash槽，默认replicaNumber=160，相当于在Hash槽上放160个槽位</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 外层轮询40次，内层轮询4次，共40*4=160次，也就是同一节点虚拟出160个槽位</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; invoker </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> invokers) {</span></span>
<span class="line"><span style="color:#24292E;">        String address </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getAddress</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> replicaNumber </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 对address + i进行md5运算，得到一个长度为16的字节数组</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] digest </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">md5</span><span style="color:#24292E;">(address </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> i);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 对digest部分字节进行4次Hash运算，得到4个不同的long型正整数</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> h </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; h </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">; h</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// h = 0 时，取 digest 中下标为 0~3 的 4 个字节进行位运算</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// h = 1 时，取 digest 中下标为 4~7 的 4 个字节进行位运算</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// h = 2 和 h = 3时，过程同上</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> m </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(digest, h);</span></span>
<span class="line"><span style="color:#24292E;">                virtualInvokers.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(m, invoker);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>最后，请求会通过 ConsistentHashSelector.select() 方法选择合适的 Invoker 对象，其中会先对请求参数进行 md5 以及 Hash 运算，得到一个 Hash 值，然后再通过这个 Hash 值到 TreeMap 中查找目标 Invoker。具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将参与一致性Hash的参数拼接到一起</span></span>
<span class="line"><span style="color:#E1E4E8;">    String key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">toKey</span><span style="color:#E1E4E8;">(invocation.</span><span style="color:#B392F0;">getArguments</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算key的Hash值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] digest </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">md5</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 匹配Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">selectForKey</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">hash</span><span style="color:#E1E4E8;">(digest, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">selectForKey</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> hash) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从virtualInvokers集合（TreeMap是按照Key排序的）中查找第一个节点值大于或等于传入Hash值的Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map.Entry&lt;</span><span style="color:#F97583;">Long</span><span style="color:#E1E4E8;">, Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;&gt; entry </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> virtualInvokers.</span><span style="color:#B392F0;">ceilingEntry</span><span style="color:#E1E4E8;">(hash);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果Hash值大于Hash环中的所有Invoker，则回到Hash环的开头，返回第一个Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (entry </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        entry </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> virtualInvokers.</span><span style="color:#B392F0;">firstEntry</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> entry.</span><span style="color:#B392F0;">getValue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将参与一致性Hash的参数拼接到一起</span></span>
<span class="line"><span style="color:#24292E;">    String key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">toKey</span><span style="color:#24292E;">(invocation.</span><span style="color:#6F42C1;">getArguments</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算key的Hash值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] digest </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">md5</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 匹配Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">selectForKey</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">hash</span><span style="color:#24292E;">(digest, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">selectForKey</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> hash) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从virtualInvokers集合（TreeMap是按照Key排序的）中查找第一个节点值大于或等于传入Hash值的Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    Map.Entry&lt;</span><span style="color:#D73A49;">Long</span><span style="color:#24292E;">, Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;&gt; entry </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> virtualInvokers.</span><span style="color:#6F42C1;">ceilingEntry</span><span style="color:#24292E;">(hash);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果Hash值大于Hash环中的所有Invoker，则回到Hash环的开头，返回第一个Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (entry </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        entry </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> virtualInvokers.</span><span style="color:#6F42C1;">firstEntry</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> entry.</span><span style="color:#6F42C1;">getValue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="randomloadbalance" tabindex="-1">RandomLoadBalance <a class="header-anchor" href="#randomloadbalance" aria-label="Permalink to &quot;RandomLoadBalance&quot;">​</a></h3><p>RandomLoadBalance 使用的负载均衡算法是<strong>加权随机算法</strong>。RandomLoadBalance 是一个简单、高效的负载均衡实现，它也是 Dubbo 默认使用的 LoadBalance 实现。</p><p>这里我们通过一个示例来说明加权随机算法的核心思想。假设我们有三个 Provider 节点 A、B、C，它们对应的权重分别为 5、2、3，权重总和为 10。现在把这些权重值放到一维坐标轴上，[0, 5) 区间属于节点 A，[5, 7) 区间属于节点 B，[7, 10) 区间属于节点 C，如下图所示：</p>`,15),k=p(`<p>权重坐标轴示意图</p><p>下面我们通过随机数生成器在 [0, 10) 这个范围内生成一个随机数，然后计算这个随机数会落到哪个区间中。例如，随机生成 4，就会落到 Provider A 对应的区间中，此时 RandomLoadBalance 就会返回 Provider A 这个节点。</p><p>接下来我们再来看 RandomLoadBalance 中 doSelect() 方法的实现，其核心逻辑分为三个关键点：</p><ul><li><p>计算每个 Invoker 对应的权重值以及总权重值；</p></li><li><p>当各个 Invoker 权重值不相等时，计算随机数应该落在哪个 Invoker 区间中，返回对应的 Invoker 对象；</p></li><li><p>当各个 Invoker 权重值相同时，随机返回一个 Invoker 即可。</p></li></ul><p>RandomLoadBalance 经过多次请求后，能够将调用请求按照权重值均匀地分配到各个 Provider 节点上。下面是 RandomLoadBalance 的核心实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSelect</span><span style="color:#E1E4E8;">(List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, URL url, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> sameWeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算每个Invoker对象对应的权重，并填充到weights[]数组中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] weights </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[length];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 计算第一个Invoker的权重</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> firstWeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getWeight</span><span style="color:#E1E4E8;">(invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">), invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    weights[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstWeight;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// totalWeight用于记录总权重值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> totalWeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> firstWeight;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 计算每个Invoker的权重，以及总权重totalWeight</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> weight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getWeight</span><span style="color:#E1E4E8;">(invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i), invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">        weights[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> weight;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// Sum</span></span>
<span class="line"><span style="color:#E1E4E8;">        totalWeight </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> weight;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 检测每个Provider的权重是否相同</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sameWeight </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> weight </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> firstWeight) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            sameWeight </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 各个Invoker权重值不相等时，计算随机数落在哪个区间上</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (totalWeight </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">sameWeight) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 随机获取一个[0, totalWeight) 区间内的数字</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> offset </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ThreadLocalRandom.</span><span style="color:#B392F0;">current</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">nextInt</span><span style="color:#E1E4E8;">(totalWeight);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 循环让offset数减去Invoker的权重值，当offset小于0时，返回相应的Invoker</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            offset </span><span style="color:#F97583;">-=</span><span style="color:#E1E4E8;"> weights[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (offset </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 各个Invoker权重值相同时，随机返回一个Invoker即可</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(ThreadLocalRandom.</span><span style="color:#B392F0;">current</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">nextInt</span><span style="color:#E1E4E8;">(length));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSelect</span><span style="color:#24292E;">(List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, URL url, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> sameWeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算每个Invoker对象对应的权重，并填充到weights[]数组中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] weights </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[length];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 计算第一个Invoker的权重</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> firstWeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getWeight</span><span style="color:#24292E;">(invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">), invocation);</span></span>
<span class="line"><span style="color:#24292E;">    weights[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstWeight;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// totalWeight用于记录总权重值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> totalWeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> firstWeight;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 计算每个Invoker的权重，以及总权重totalWeight</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> weight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getWeight</span><span style="color:#24292E;">(invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i), invocation);</span></span>
<span class="line"><span style="color:#24292E;">        weights[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> weight;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// Sum</span></span>
<span class="line"><span style="color:#24292E;">        totalWeight </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> weight;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 检测每个Provider的权重是否相同</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sameWeight </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> weight </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> firstWeight) {</span></span>
<span class="line"><span style="color:#24292E;">            sameWeight </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 各个Invoker权重值不相等时，计算随机数落在哪个区间上</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (totalWeight </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">sameWeight) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 随机获取一个[0, totalWeight) 区间内的数字</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> offset </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ThreadLocalRandom.</span><span style="color:#6F42C1;">current</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">nextInt</span><span style="color:#24292E;">(totalWeight);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 循环让offset数减去Invoker的权重值，当offset小于0时，返回相应的Invoker</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            offset </span><span style="color:#D73A49;">-=</span><span style="color:#24292E;"> weights[i];</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (offset </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 各个Invoker权重值相同时，随机返回一个Invoker即可</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(ThreadLocalRandom.</span><span style="color:#6F42C1;">current</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">nextInt</span><span style="color:#24292E;">(length));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时我们重点介绍了 Dubbo Cluster 层中负载均衡相关的内容。首先我们介绍了 LoadBalance 接口的定义以及 AbstractLoadBalance 抽象类提供的公共能力。然后我们还详细讲解了 ConsistentHashLoadBalance 的核心实现，其中还简单说明了一致性 Hash 算法的基础知识点。最后，我们又一块儿分析了 RandomLoadBalance 的基本原理和核心实现。</p><p>下一课时，我们将继续介绍负载均衡的剩余实现类，记得按时来听课。</p>`,9);function m(I,B,_,H,T,b){const a=e("Image");return t(),r("div",null,[E,y,l(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/71/0A/Ciqc1F-81uuAdW51AAH-O1mrOoA018.png"}),n(),i,l(a,{alt:"Lark20201124-174750.png",src:"https://s0.lgstatic.com/i/image/M00/71/15/CgqCHl-81vaAYmqRAAFYpTlQI0s741.png"}),n(),F,l(a,{alt:"Lark20201124-174752.png",src:"https://s0.lgstatic.com/i/image/M00/71/15/CgqCHl-81wSAO1YfAAFfH6Qgse0640.png"}),n(),h,d,g,l(a,{alt:"Lark20201124-174755.png",src:"https://s0.lgstatic.com/i/image/M00/71/15/CgqCHl-81w2ATT5qAAFjvpkgTNM463.png"}),n(),A,v,D,u,l(a,{alt:"Lark20201124-174743.png",src:"https://s0.lgstatic.com/i/image/M00/71/15/CgqCHl-81xaAEUSbAAG0t7C-hcQ544.png"}),n(),C,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/71/0A/Ciqc1F-81ySAdj_7AAAxc2j-s5k730.png"}),n(),k])}const f=o(c,[["render",m]]);export{P as __pageData,f as default};
