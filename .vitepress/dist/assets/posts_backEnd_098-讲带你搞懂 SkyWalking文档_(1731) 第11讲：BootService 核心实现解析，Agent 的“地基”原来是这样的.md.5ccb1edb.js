import{_ as e,j as o,o as t,g as c,k as a,s,h as p,Q as l}from"./chunks/framework.e0c66c3f.js";const N=JSON.parse('{"title":"网络连接管理 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1731) 第11讲：BootService 核心实现解析，Agent 的“地基”原来是这样的.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1731) 第11讲：BootService 核心实现解析，Agent 的“地基”原来是这样的.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1731) 第11讲：BootService 核心实现解析，Agent 的“地基”原来是这样的.md"},E=s("p",null,'在 08 课时"SkyWalking Agent 启动流程剖析"中我详细介绍了 ServiceManager 加载并初始化 BootService 实现的核心逻辑。下图展示了 BootService 接口的所有实现类，本课时将深入分析这些 BootService 实现类的具体逻辑：',-1),y=s("h3",{id:"网络连接管理",tabindex:"-1"},[p("网络连接管理 "),s("a",{class:"header-anchor",href:"#网络连接管理","aria-label":'Permalink to "网络连接管理"'},"​")],-1),i=s("p",null,"在前面的介绍中提到 SkyWalking Agent 会定期将收集到的 JVM 监控和 Trace 数据定期发送到后端的 OAP 集群，GRPCChannelManager 负责维护 Agent 与后端 OAP 集群通信时使用的网络连接。这里首先说一下 gRPC 里面的两个组件：",-1),C=s("ul",null,[s("li",null,"**ManagedChanne l：它是 gRPC 客户端的核心类之一，它逻辑上表示一个 Channel，底层持有一个 TCP 链接，并负责维护此连接的活性。也就是说，在 RPC 调用的任何时机，如果检测到底层连接处于关闭状态（terminated），将会尝试重建连接。通常情况下，我们不需要在 RPC 调用结束后就关闭 Channel ，该 Channel 可以被一直重用，直到整个客户端程序关闭。当然，我们可以在客户端内以连接池的方式使用多个 ManagedChannel ，在每次 RPC 请求时选择使用轮训或是随机等算法选择一个可用的 Channel，这样可以提高客户端整体的并发能力。"),s("li",null,"**ManagedChannelBuilder：**它负责创建客户端 Channel，ManagedChannelBuilder 使用了 provider 机制，具体是创建了哪种 Channel 由 provider 决定，常用的 ManagedChannelBuilder 有三种：NettyChannelBuilder、OkHttpChannelBuilder、InProcessChannelBuilder，如下图所示：")],-1),d=l(`<p>在 SkyWalking Agent 中用的是 NettyChannelBuilder，其创建的 Channel 底层是基于 Netty 实现的。OkHttpChannelBuilder 创建的 Channel 底层是基于 OkHttp 库实现的。InProcessChannelBuilder 用于创建进程内通信使用的 Channel。</p><p>SkyWalking 在 ManagedChannel 的基础上封装了自己的 Channel 实现 ------ GRPCChannel ，可以添加一些装饰器，目前就只有一个验证权限的修饰器，实现比较简单，这里就不展开分析了。</p><p>介绍完基础知识之后，回到 GRPCChannelManager，其中维护了一个 GRPCChannel 连接以及注册在其上的 Listener 监听，另外还会维护一个后台线程定期检测该 GRPCChannel 的连接状态，如果发现连接断开，则会进行重连。GRPCChannelManager 的核心字段如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 封装了上面介绍的gRPC Channel</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> GRPCChannel managedChannel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#6A737D;">// 定时检查 GRPCChannel的连接状态重连gRPC Server的定时任务</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> ScheduledFuture&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; connectCheckFuture; </span></span>
<span class="line"><span style="color:#6A737D;">// 是否重连。当 GRPCChannel断开时会标记 reconnect为 true，后台线程会根据该标</span></span>
<span class="line"><span style="color:#6A737D;">// 识决定是否进行重连</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> reconnect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#6A737D;">// 加在 Channel上的监听器，主要是监听 Channel的状态变化</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">GRPCChannelListener</span><span style="color:#E1E4E8;">&gt; listeners;</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 可选的 gRPC Server集合，即后端OAP集群中各个OAP实例的地址</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">volatile</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; grpcServers;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 封装了上面介绍的gRPC Channel</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> GRPCChannel managedChannel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#6A737D;">// 定时检查 GRPCChannel的连接状态重连gRPC Server的定时任务</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> ScheduledFuture&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; connectCheckFuture; </span></span>
<span class="line"><span style="color:#6A737D;">// 是否重连。当 GRPCChannel断开时会标记 reconnect为 true，后台线程会根据该标</span></span>
<span class="line"><span style="color:#6A737D;">// 识决定是否进行重连</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> reconnect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#6A737D;">// 加在 Channel上的监听器，主要是监听 Channel的状态变化</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">GRPCChannelListener</span><span style="color:#24292E;">&gt; listeners;</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 可选的 gRPC Server集合，即后端OAP集群中各个OAP实例的地址</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">volatile</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; grpcServers;</span></span></code></pre></div><p>前文介绍 ServiceManager 时提到，Agent 启动过程中会依次调用 BootService 实现的 prepare() 方法 → boot() 方法 → onComplete() 方法之后，才能真正对外提供服务。GRPCChannelManager 的 prepare() 方法 、onComplete() 方法都是空实现，在 boot() 方法中首先会解析 agent.config 配置文件指定的后端 OAP 实例地址初始化 grpcServers 字段，然后会初始化这个定时任务，初次会立即执行，之后每隔 30s 执行一次，具体执行的就是 GRPCChannelManager.run() 方法，其核心逻辑是检测链接状态并适时重连：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (reconnect </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> grpcServers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 根据配置，连接指定OAP实例的IP和端口</span></span>
<span class="line"><span style="color:#E1E4E8;">        managedChannel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> GRPCChannel.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">(ipAndPort[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">], </span></span>
<span class="line"><span style="color:#E1E4E8;">                Integer.</span><span style="color:#B392F0;">parseInt</span><span style="color:#E1E4E8;">(ipAndPort[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]))</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addManagedChannelBuilder</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">StandardChannelBuilder</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addManagedChannelBuilder</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TLSChannelBuilder</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">addChannelDecorator</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AuthenticationDecorator</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// notify()方法会循环调用所有注册在当前连接上的GRPCChannelListener实</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 例(记录在listeners集合中)的statusChanged()方法，通知它们连接创建</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 成功的事件</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">notify</span><span style="color:#E1E4E8;">(GRPCChannelStatus.CONNECTED);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 设置 reconnect字段为false，暂时不会再重建连接了</span></span>
<span class="line"><span style="color:#E1E4E8;">        reconnect </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (reconnect </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> grpcServers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 根据配置，连接指定OAP实例的IP和端口</span></span>
<span class="line"><span style="color:#24292E;">        managedChannel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> GRPCChannel.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">(ipAndPort[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">], </span></span>
<span class="line"><span style="color:#24292E;">                Integer.</span><span style="color:#6F42C1;">parseInt</span><span style="color:#24292E;">(ipAndPort[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]))</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addManagedChannelBuilder</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">StandardChannelBuilder</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addManagedChannelBuilder</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TLSChannelBuilder</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">addChannelDecorator</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AuthenticationDecorator</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// notify()方法会循环调用所有注册在当前连接上的GRPCChannelListener实</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 例(记录在listeners集合中)的statusChanged()方法，通知它们连接创建</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 成功的事件</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">notify</span><span style="color:#24292E;">(GRPCChannelStatus.CONNECTED);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 设置 reconnect字段为false，暂时不会再重建连接了</span></span>
<span class="line"><span style="color:#24292E;">        reconnect </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>GRPCChannelListener 是一个监听器接口，有多个需要发送网络请求的 BootService 实现类同时实现了该接口，如下图所示，后面会详细介绍这些 BootService 实现类的具体功能。</p>`,7),g=s("p",null,"最后，GRPCChannelManager 对外提供了 reportError() 方法，在其他依赖该网络连接的 BootService 实现发送请求失败时，可以通过该方法将 reconnect 字段设置为 true，并由后台线程重新创建 GRPCChannel。",-1),u=s("h3",{id:"注册协议及实现",tabindex:"-1"},[p("注册协议及实现 "),s("a",{class:"header-anchor",href:"#注册协议及实现","aria-label":'Permalink to "注册协议及实现"'},"​")],-1),F=s("p",null,"介绍完 Agent 与后端 OAP 集群基本的连接方式之后，还需要了解 Agent 和 Server 交互的流程和协议。在 Agent 与后端 OAP 创建连接成功后的第一件事是进行注册流程。",-1),A=s("p",null,"首先来介绍注册协议涉及的 proto 的定义------ Register.proto 文件，其位置如下：",-1),v=l(`<p>Register.proto 中定义了 Register 服务，这里先关注 doServiceRegister() 和 doServiceInstanceRegister() 两个 RPC 接口，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">service Register {</span></span>
<span class="line"><span style="color:#E1E4E8;">    rpc </span><span style="color:#B392F0;">doServiceRegister</span><span style="color:#E1E4E8;">(Services)</span><span style="color:#B392F0;">returns</span><span style="color:#E1E4E8;">(ServiceRegisterMapping) {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    rpc </span><span style="color:#B392F0;">doServiceInstanceRegister</span><span style="color:#E1E4E8;"> (ServiceInstances) returns</span></span>
<span class="line"><span style="color:#E1E4E8;">        (ServiceInstanceRegisterMapping) {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    # 还有三个方法，这里省略一下，后面会介绍</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">service Register {</span></span>
<span class="line"><span style="color:#24292E;">    rpc </span><span style="color:#6F42C1;">doServiceRegister</span><span style="color:#24292E;">(Services)</span><span style="color:#6F42C1;">returns</span><span style="color:#24292E;">(ServiceRegisterMapping) {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    rpc </span><span style="color:#6F42C1;">doServiceInstanceRegister</span><span style="color:#24292E;"> (ServiceInstances) returns</span></span>
<span class="line"><span style="color:#24292E;">        (ServiceInstanceRegisterMapping) {}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    # 还有三个方法，这里省略一下，后面会介绍</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li><strong>doServiceRegister() 接口</strong>：将服务（Service）的名称注册到后端的 OAP 集群。参数 Services 中会携带当前服务的名称（其中还可以附加一些 KV 格式的信息）；返回的 ServiceRegisterMapping 其实是多个 KV，其中就包含了后端 OAP 服务端生成的ServiceId。</li><li><strong>doServiceInstanceRegister() 接口</strong>：将服务实例（ServiceInstance）的名称注册到后端 OAP 集群。参数 ServiceInstances 中会携带服务实例（ServiceInstance）的名称，以及 serviceId、时间戳等信息；返回的 ServiceInstanceRegisterMapping 本质也是一堆 KV，其中包含 OAP 为服务实例生成的 ServiceInstanceId。</li></ul><blockquote><p>Service、ServiceInstance 的概念可以回顾本课程的第一课时&quot;Skywalking 初体验&quot;。</p></blockquote><p>与 Service 注册流程相关的 BootService 实现是 ServiceAndEndpointRegisterClient。ServiceAndEndpointRegisterClient 实现了 GRPCChannelListener 接口，在其 prepare() 方法中首先会将其注册到 GRPCChannelManager 来监听网络连接，然后生成当前 ServiceInstance 的唯一标识：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">prepare</span><span style="color:#E1E4E8;">() throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 查找 GRPCChannelManager实例(前面介的ServiceManager.bootedServices</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 集合会按照类型维护BootService实例，查找也是查找该集合)，然后将 </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ServiceAndEndpointRegisterClient注册成Listener</span></span>
<span class="line"><span style="color:#E1E4E8;">    ServiceManager.INSTANCE.</span><span style="color:#B392F0;">findService</span><span style="color:#E1E4E8;">(GRPCChannelManager.class)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">addChannelListener</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 确定INSTANCE_UUID，优先使用gent.config文件中配置的INSTANCE_UUID，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若未配置则随机生成</span></span>
<span class="line"><span style="color:#E1E4E8;">    INSTANCE_UUID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> StringUtil.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(Config.Agent.INSTANCE_UUID) </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">         UUID.</span><span style="color:#B392F0;">randomUUID</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">replaceAll</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;-&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">         Config.Agent.INSTANCE_UUID;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">prepare</span><span style="color:#24292E;">() throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 查找 GRPCChannelManager实例(前面介的ServiceManager.bootedServices</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 集合会按照类型维护BootService实例，查找也是查找该集合)，然后将 </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ServiceAndEndpointRegisterClient注册成Listener</span></span>
<span class="line"><span style="color:#24292E;">    ServiceManager.INSTANCE.</span><span style="color:#6F42C1;">findService</span><span style="color:#24292E;">(GRPCChannelManager.class)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">addChannelListener</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 确定INSTANCE_UUID，优先使用gent.config文件中配置的INSTANCE_UUID，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若未配置则随机生成</span></span>
<span class="line"><span style="color:#24292E;">    INSTANCE_UUID </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> StringUtil.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(Config.Agent.INSTANCE_UUID) </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">         UUID.</span><span style="color:#6F42C1;">randomUUID</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">replaceAll</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;-&quot;</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">         Config.Agent.INSTANCE_UUID;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在网络连接建立之后，会通知其 statusChanged() 方法更新 registerBlockingStub 字段：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">statusChanged</span><span style="color:#E1E4E8;">(GRPCChannelStatus status) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(status)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 网络连接创建成功时，会依赖该连接创建两个stub客户端</span></span>
<span class="line"><span style="color:#E1E4E8;">        Channel channel </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ServiceManager.INSTANCE.</span><span style="color:#B392F0;">findService</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                GRPCChannelManager.class).</span><span style="color:#B392F0;">getChannel</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        registerBlockingStub </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RegisterGrpc.</span><span style="color:#B392F0;">newBlockingStub</span><span style="color:#E1E4E8;">(channel);</span></span>
<span class="line"><span style="color:#E1E4E8;">        serviceInstancePingStub </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ServiceInstancePingGrpc</span></span>
<span class="line"><span style="color:#E1E4E8;">             .</span><span style="color:#B392F0;">newBlockingStub</span><span style="color:#E1E4E8;">(channel);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 网络连接断开时，更新两个stub字段（它们都是volatile修饰）</span></span>
<span class="line"><span style="color:#E1E4E8;">        registerBlockingStub </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        serviceInstancePingStub </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.status </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> status; </span><span style="color:#6A737D;">// 更新status字段，记录网络状态</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">statusChanged</span><span style="color:#24292E;">(GRPCChannelStatus status) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(status)) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 网络连接创建成功时，会依赖该连接创建两个stub客户端</span></span>
<span class="line"><span style="color:#24292E;">        Channel channel </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ServiceManager.INSTANCE.</span><span style="color:#6F42C1;">findService</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                GRPCChannelManager.class).</span><span style="color:#6F42C1;">getChannel</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        registerBlockingStub </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RegisterGrpc.</span><span style="color:#6F42C1;">newBlockingStub</span><span style="color:#24292E;">(channel);</span></span>
<span class="line"><span style="color:#24292E;">        serviceInstancePingStub </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ServiceInstancePingGrpc</span></span>
<span class="line"><span style="color:#24292E;">             .</span><span style="color:#6F42C1;">newBlockingStub</span><span style="color:#24292E;">(channel);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 网络连接断开时，更新两个stub字段（它们都是volatile修饰）</span></span>
<span class="line"><span style="color:#24292E;">        registerBlockingStub </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        serviceInstancePingStub </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.status </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> status; </span><span style="color:#6A737D;">// 更新status字段，记录网络状态</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>registerBlockingStub 是 gRPC 框架生成的一个客户端辅助类，可以帮助我们轻松的完成请求的序列化、数据发送以及响应的反序列化。gRPC 的基础使用这里不再展开。</p><p>ServiceAndEndpointRegisterClient 也同时实现了 Runnable 接口，在 boot() 方法中会启动一个定时任务，默认每 3s 执行一次其 run() 方法，该定时任务首先会通过 doServiceRegister() 接口完成 Service 注册，相关实现片段如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(status) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> shouldTry) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    shouldTry </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测当前Agent是否已完成了Service注册</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (RemoteDownstreamConfig.Agent.SERVICE_ID </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">            DictionaryUtil.</span><span style="color:#B392F0;">nullValue</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (registerBlockingStub </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 第二次检查网络状态</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 通过doServiceRegister()接口进行Service注册</span></span>
<span class="line"><span style="color:#E1E4E8;">            ServiceRegisterMapping serviceRegisterMapping </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              registerBlockingStub.</span><span style="color:#B392F0;">doServiceRegister</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                Services.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">addServices</span><span style="color:#E1E4E8;">(Service.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                 .</span><span style="color:#B392F0;">setServiceName</span><span style="color:#E1E4E8;">(Config.Agent.SERVICE_NAME)).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (KeyIntValuePair registered </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">               serviceRegisterMapping.</span><span style="color:#B392F0;">getServicesList</span><span style="color:#E1E4E8;">()) {</span><span style="color:#6A737D;">// 遍历所有KV</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Config.Agent.SERVICE_NAME</span></span>
<span class="line"><span style="color:#E1E4E8;">                          .</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(registered.</span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">())) { </span></span>
<span class="line"><span style="color:#E1E4E8;">                    RemoteDownstreamConfig.Agent.SERVICE_ID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">                           registered.</span><span style="color:#B392F0;">getValue</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 记录serviceId</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 设置shouldTry，紧跟着会执行服务实例注册</span></span>
<span class="line"><span style="color:#E1E4E8;">                    shouldTry </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 后续会执行服务实例注册以及心跳操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        ... ... </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(status) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> shouldTry) {</span></span>
<span class="line"><span style="color:#24292E;">    shouldTry </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测当前Agent是否已完成了Service注册</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (RemoteDownstreamConfig.Agent.SERVICE_ID </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">            DictionaryUtil.</span><span style="color:#6F42C1;">nullValue</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (registerBlockingStub </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 第二次检查网络状态</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 通过doServiceRegister()接口进行Service注册</span></span>
<span class="line"><span style="color:#24292E;">            ServiceRegisterMapping serviceRegisterMapping </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">              registerBlockingStub.</span><span style="color:#6F42C1;">doServiceRegister</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                Services.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">addServices</span><span style="color:#24292E;">(Service.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                 .</span><span style="color:#6F42C1;">setServiceName</span><span style="color:#24292E;">(Config.Agent.SERVICE_NAME)).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (KeyIntValuePair registered </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">               serviceRegisterMapping.</span><span style="color:#6F42C1;">getServicesList</span><span style="color:#24292E;">()) {</span><span style="color:#6A737D;">// 遍历所有KV</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Config.Agent.SERVICE_NAME</span></span>
<span class="line"><span style="color:#24292E;">                          .</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(registered.</span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">())) { </span></span>
<span class="line"><span style="color:#24292E;">                    RemoteDownstreamConfig.Agent.SERVICE_ID </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">                           registered.</span><span style="color:#6F42C1;">getValue</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 记录serviceId</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 设置shouldTry，紧跟着会执行服务实例注册</span></span>
<span class="line"><span style="color:#24292E;">                    shouldTry </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 后续会执行服务实例注册以及心跳操作</span></span>
<span class="line"><span style="color:#24292E;">        ... ... </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过分析这段代码，我们可以知道：</p><ul><li>如果在 agent.config 配置文件中直接配置了 serviceId 是无需进行服务注册的。</li><li>ServiceAndEndpointRegisterClient 会根据监听 GRPCChannel 的连接状态，决定是否发送服务注册请求、服务实例注册请求以及心跳请求。</li></ul><p>完成服务（Service）注册之后，ServiceAndEndpointRegisterClient 定时任务会立即进行服务实例（ServiceInstance）注册，具体逻辑如下，逻辑与服务注册非常类似：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(status) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> shouldTry) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (RemoteDownstreamConfig.Agent.SERVICE_ID </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">            DictionaryUtil.</span><span style="color:#B392F0;">nullValue</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ... </span><span style="color:#6A737D;">// 省略服务注册逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">                   DictionaryUtil.</span><span style="color:#B392F0;">nullValue</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 调用 doServiceInstanceRegister()接口，用serviceId和</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// INSTANCE_UUID换取SERVICE_INSTANCE_ID</span></span>
<span class="line"><span style="color:#E1E4E8;">            ServiceInstanceRegisterMapping instanceMapping </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">                  registerBlockingStub.</span><span style="color:#B392F0;">doServiceInstanceRegister</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                 ServiceInstances.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">addInstances</span><span style="color:#E1E4E8;">(ServiceInstance.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">setServiceId</span><span style="color:#E1E4E8;">(RemoteDownstreamConfig.Agent.SERVICE_ID)</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 除了serviceId，还会传递uuid、时间戳以及系统信息之类的</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">setInstanceUUID</span><span style="color:#E1E4E8;">(INSTANCE_UUID)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">setTime</span><span style="color:#E1E4E8;">(System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">addAllProperties</span><span style="color:#E1E4E8;">(OSUtil.</span><span style="color:#B392F0;">buildOSInfo</span><span style="color:#E1E4E8;">())).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (KeyIntValuePair serviceInstance </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">                    instanceMapping.</span><span style="color:#B392F0;">getServiceInstancesList</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (INSTANCE_UUID.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(serviceInstance.</span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 记录serviceIntanceId</span></span>
<span class="line"><span style="color:#E1E4E8;">                    RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">                        serviceInstance.</span><span style="color:#B392F0;">getValue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">            ... </span><span style="color:#6A737D;">// 省略心跳的相关逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(status) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> shouldTry) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (RemoteDownstreamConfig.Agent.SERVICE_ID </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">            DictionaryUtil.</span><span style="color:#6F42C1;">nullValue</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        ... </span><span style="color:#6A737D;">// 省略服务注册逻辑</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">                   DictionaryUtil.</span><span style="color:#6F42C1;">nullValue</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 调用 doServiceInstanceRegister()接口，用serviceId和</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// INSTANCE_UUID换取SERVICE_INSTANCE_ID</span></span>
<span class="line"><span style="color:#24292E;">            ServiceInstanceRegisterMapping instanceMapping </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">                  registerBlockingStub.</span><span style="color:#6F42C1;">doServiceInstanceRegister</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                 ServiceInstances.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">addInstances</span><span style="color:#24292E;">(ServiceInstance.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">setServiceId</span><span style="color:#24292E;">(RemoteDownstreamConfig.Agent.SERVICE_ID)</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 除了serviceId，还会传递uuid、时间戳以及系统信息之类的</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">setInstanceUUID</span><span style="color:#24292E;">(INSTANCE_UUID)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">setTime</span><span style="color:#24292E;">(System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">addAllProperties</span><span style="color:#24292E;">(OSUtil.</span><span style="color:#6F42C1;">buildOSInfo</span><span style="color:#24292E;">())).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (KeyIntValuePair serviceInstance </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">                    instanceMapping.</span><span style="color:#6F42C1;">getServiceInstancesList</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (INSTANCE_UUID.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(serviceInstance.</span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 记录serviceIntanceId</span></span>
<span class="line"><span style="color:#24292E;">                    RemoteDownstreamConfig.Agent.SERVICE_INSTANCE_ID </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">                        serviceInstance.</span><span style="color:#6F42C1;">getValue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span><span style="color:#D73A49;">else</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">            ... </span><span style="color:#6A737D;">// 省略心跳的相关逻辑</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="心跳协议及实现" tabindex="-1">心跳协议及实现 <a class="header-anchor" href="#心跳协议及实现" aria-label="Permalink to &quot;心跳协议及实现&quot;">​</a></h3><p>在完成服务注册以及服务实例操作之后，ServiceAndEndpointRegisterClient 会开始定期发送心跳请求，通知后端 OAP 服务当前 Agent 在线。心跳涉及一个新的 gRPC 接口如下（定义在 InstancePing.proto 文件中）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">service ServiceInstancePing {</span></span>
<span class="line"><span style="color:#E1E4E8;">    rpc </span><span style="color:#B392F0;">doPing</span><span style="color:#E1E4E8;"> (ServiceInstancePingPkg) </span><span style="color:#B392F0;">returns</span><span style="color:#E1E4E8;"> (Commands) {}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">service ServiceInstancePing {</span></span>
<span class="line"><span style="color:#24292E;">    rpc </span><span style="color:#6F42C1;">doPing</span><span style="color:#24292E;"> (ServiceInstancePingPkg) </span><span style="color:#6F42C1;">returns</span><span style="color:#24292E;"> (Commands) {}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ServiceAndEndpointRegisterClient 中心跳请求相关的代码片段如下，心跳请求会携带serviceInstanceId、时间戳、INSTANCE_UUID 三个信息：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(status) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> shouldTry) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Agent.SERVICE_ID </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> DictionaryUtil.</span><span style="color:#B392F0;">nullValue</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ... </span><span style="color:#6A737D;">// 省略服务注册逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Agent.SERVICE_INSTANCE_ID </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> DictionaryUtil.</span><span style="color:#B392F0;">nullValue</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            ... </span><span style="color:#6A737D;">// 省略服务实例注册逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;">{ </span><span style="color:#6A737D;">// 并没有对心跳请求的响应做处理</span></span>
<span class="line"><span style="color:#E1E4E8;">            serviceInstancePingStub.</span><span style="color:#B392F0;">doPing</span><span style="color:#E1E4E8;">(ServiceInstancePingPkg</span></span>
<span class="line"><span style="color:#E1E4E8;">               .</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">setServiceInstanceId</span><span style="color:#E1E4E8;">(SERVICE_INSTANCE_ID)</span></span>
<span class="line"><span style="color:#E1E4E8;">               .</span><span style="color:#B392F0;">setTime</span><span style="color:#E1E4E8;">(System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">               .</span><span style="color:#B392F0;">setServiceInstanceUUID</span><span style="color:#E1E4E8;">(INSTANCE_UUID).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (GRPCChannelStatus.CONNECTED.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(status) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> shouldTry) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Agent.SERVICE_ID </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> DictionaryUtil.</span><span style="color:#6F42C1;">nullValue</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        ... </span><span style="color:#6A737D;">// 省略服务注册逻辑</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Agent.SERVICE_INSTANCE_ID </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> DictionaryUtil.</span><span style="color:#6F42C1;">nullValue</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            ... </span><span style="color:#6A737D;">// 省略服务实例注册逻辑</span></span>
<span class="line"><span style="color:#24292E;">        }</span><span style="color:#D73A49;">else</span><span style="color:#24292E;">{ </span><span style="color:#6A737D;">// 并没有对心跳请求的响应做处理</span></span>
<span class="line"><span style="color:#24292E;">            serviceInstancePingStub.</span><span style="color:#6F42C1;">doPing</span><span style="color:#24292E;">(ServiceInstancePingPkg</span></span>
<span class="line"><span style="color:#24292E;">               .</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">setServiceInstanceId</span><span style="color:#24292E;">(SERVICE_INSTANCE_ID)</span></span>
<span class="line"><span style="color:#24292E;">               .</span><span style="color:#6F42C1;">setTime</span><span style="color:#24292E;">(System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">               .</span><span style="color:#6F42C1;">setServiceInstanceUUID</span><span style="color:#24292E;">(INSTANCE_UUID).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="endpoint、networkaddress-同步" tabindex="-1">Endpoint、NetWorkAddress 同步 <a class="header-anchor" href="#endpoint、networkaddress-同步" aria-label="Permalink to &quot;Endpoint、NetWorkAddress 同步&quot;">​</a></h3><p>在前文介绍 SkyWalking 基本使用时看到，Trace 数据中包含了请求的 URL 地址、RPC 接口名称、HTTP 服务或 RPC 服务的地址、数据库的 IP 以及端口等信息，这些信息在整个服务上线稳定之后，不会经常发生变动。而在海量 Trace 中包含这些重复的字符串，会非常浪费网络带宽以及存储资源，常见的解决方案是将字符串映射成数字编号并维护一张映射表，在传输、存储时使用映射后的数字编号，在展示时根据映射表查询真正的字符串进行展示即可。这类似于编码、解码的思想。SkyWalking 也是如此处理 Trace 中重复字符串的。</p><p>SkyWalking 中有两个 DictionaryManager：</p><ul><li><strong>EndpointNameDictionary</strong>：用于同步 Endpoint 字符串的映射关系。</li><li><strong>NetworkAddressDictionary</strong>：用于同步网络地址的映射关系。</li></ul><p>EndpointNameDictionary 中维护了两个集合：</p><ul><li><strong>endpointDictionary</strong>：记录已知的 Endpoint 名称映射的数字编号。</li><li><strong>unRegisterEndpoints</strong>：记录了未知的 Endpoint 名称。</li></ul><p>EndpointNameDictionary 对外提供了两类操作，一个是查询操作（核心实现在 find0() 方法），在查询时首先去 endpointDictionary 集合查找指定 Endpoint 名称是否已存在相应的数字编号，若存在则正常返回数字编号，若不存在则记录到 unRegisterEndpoints 集合中。为了防止占用过多内存导致频繁 GC，endpointDictionary 和 unRegisterEndpoints 集合大小是有上限的（默认两者之和为 10^7）。</p><p>另一个操作是同步操作（核心实现在 syncRemoteDictionary() 方法），在 ServiceAndEndpointRegisterClient 收到心跳响应之后，会将 unRegisterEndpoints 集合中未知的 Endpoint 名称发送到 OAP 集群，然后由 OAP 集群统一分配相应的数字编码，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">syncRemoteDictionary</span><span style="color:#E1E4E8;">(RegisterGrpc.RegisterBlockingStub </span></span>
<span class="line"><span style="color:#E1E4E8;">          serviceNameDiscoveryServiceBlockingStub) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建请求，每个Endpoint中都封装了 Endpoint名称以及关联的serviceId</span></span>
<span class="line"><span style="color:#E1E4E8;">    Endpoints.Builder builder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Endpoints.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (OperationNameKey operationNameKey </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> unRegisterEndpoints) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Endpoint endpoint </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Endpoint.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">setServiceId</span><span style="color:#E1E4E8;">(operationNameKey.</span><span style="color:#B392F0;">getServiceId</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">setEndpointName</span><span style="color:#E1E4E8;">(operationNameKey.</span><span style="color:#B392F0;">getEndpointName</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">setFrom</span><span style="color:#E1E4E8;">(operationNameKey.</span><span style="color:#B392F0;">getSpanType</span><span style="color:#E1E4E8;">()) </span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        builder.</span><span style="color:#B392F0;">addEndpoints</span><span style="color:#E1E4E8;">(endpoint);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 发送同步请求</span></span>
<span class="line"><span style="color:#E1E4E8;">    EndpointMapping serviceNameMappingCollection </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">       serviceNameDiscoveryServiceBlockingStub</span></span>
<span class="line"><span style="color:#E1E4E8;">           .</span><span style="color:#B392F0;">doEndpointRegister</span><span style="color:#E1E4E8;">(builder.</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (EndpointMappingElement element </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">         serviceNameMappingCollection.</span><span style="color:#B392F0;">getElementsList</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将返回的映射关系，记录到 endpointDictionary集合中，并从 </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// unRegisterEndpoints集合中删除Endpoint信息</span></span>
<span class="line"><span style="color:#E1E4E8;">        OperationNameKey key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">OperationNameKey</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">            element.</span><span style="color:#B392F0;">getServiceId</span><span style="color:#E1E4E8;">(), element.</span><span style="color:#B392F0;">getEndpointName</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">            DetectPoint.server.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(element.</span><span style="color:#B392F0;">getFrom</span><span style="color:#E1E4E8;">()),</span></span>
<span class="line"><span style="color:#E1E4E8;">            DetectPoint.client.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(element.</span><span style="color:#B392F0;">getFrom</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">        unRegisterEndpoints.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(key);</span></span>
<span class="line"><span style="color:#E1E4E8;">        endpointDictionary.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(key, element.</span><span style="color:#B392F0;">getEndpointId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">syncRemoteDictionary</span><span style="color:#24292E;">(RegisterGrpc.RegisterBlockingStub </span></span>
<span class="line"><span style="color:#24292E;">          serviceNameDiscoveryServiceBlockingStub) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建请求，每个Endpoint中都封装了 Endpoint名称以及关联的serviceId</span></span>
<span class="line"><span style="color:#24292E;">    Endpoints.Builder builder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Endpoints.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (OperationNameKey operationNameKey </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> unRegisterEndpoints) {</span></span>
<span class="line"><span style="color:#24292E;">        Endpoint endpoint </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Endpoint.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">setServiceId</span><span style="color:#24292E;">(operationNameKey.</span><span style="color:#6F42C1;">getServiceId</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">setEndpointName</span><span style="color:#24292E;">(operationNameKey.</span><span style="color:#6F42C1;">getEndpointName</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">setFrom</span><span style="color:#24292E;">(operationNameKey.</span><span style="color:#6F42C1;">getSpanType</span><span style="color:#24292E;">()) </span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        builder.</span><span style="color:#6F42C1;">addEndpoints</span><span style="color:#24292E;">(endpoint);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 发送同步请求</span></span>
<span class="line"><span style="color:#24292E;">    EndpointMapping serviceNameMappingCollection </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">       serviceNameDiscoveryServiceBlockingStub</span></span>
<span class="line"><span style="color:#24292E;">           .</span><span style="color:#6F42C1;">doEndpointRegister</span><span style="color:#24292E;">(builder.</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (EndpointMappingElement element </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">         serviceNameMappingCollection.</span><span style="color:#6F42C1;">getElementsList</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将返回的映射关系，记录到 endpointDictionary集合中，并从 </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// unRegisterEndpoints集合中删除Endpoint信息</span></span>
<span class="line"><span style="color:#24292E;">        OperationNameKey key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">OperationNameKey</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">            element.</span><span style="color:#6F42C1;">getServiceId</span><span style="color:#24292E;">(), element.</span><span style="color:#6F42C1;">getEndpointName</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">            DetectPoint.server.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(element.</span><span style="color:#6F42C1;">getFrom</span><span style="color:#24292E;">()),</span></span>
<span class="line"><span style="color:#24292E;">            DetectPoint.client.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(element.</span><span style="color:#6F42C1;">getFrom</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">        unRegisterEndpoints.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(key);</span></span>
<span class="line"><span style="color:#24292E;">        endpointDictionary.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(key, element.</span><span style="color:#6F42C1;">getEndpointId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>NetworkAddressDictionary 实现与 EndpointNameDictionary 类似，就留给你自己进行分析，这里不再展开。</p><h3 id="收集-jvm-监控" tabindex="-1">收集 JVM 监控 <a class="header-anchor" href="#收集-jvm-监控" aria-label="Permalink to &quot;收集 JVM 监控&quot;">​</a></h3><p>在前面介绍 SkyWalking Rocketbot 时看到 SkyWalking 可以监控服务实例的 CPU、堆内存使用情况以及 GC 信息，这些信息都是通过 JVMService 收集的。JVMService 也实现了 BootService 接口。JVMService 的结构大致如下图所示：</p>`,32),D=l(`<p>在 JVMService 中会启动一个独立 collectMetric 线程请求 MXBean 来收集 JVM 的监控数据，然后将监控数据保存到 queue 队列（LinkedBlockingQueue 类型）中缓存，之后会启动另一个线程读取 queue 队列并将监控数据通过 gRPC 请求发送到后端的 OAP 集群。</p><p>在 JVMService.boot() 方法的实现中会初始化 queue 缓冲队列以及 Sender 对象，如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">prepare</span><span style="color:#E1E4E8;">() throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedBlockingQueue</span><span style="color:#E1E4E8;">(Config.Jvm.BUFFER_SIZE);</span></span>
<span class="line"><span style="color:#E1E4E8;">    sender </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Sender</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    ServiceManager.INSTANCE.</span><span style="color:#B392F0;">findService</span><span style="color:#E1E4E8;">(GRPCChannelManager.class)</span></span>
<span class="line"><span style="color:#E1E4E8;">         .</span><span style="color:#B392F0;">addChannelListener</span><span style="color:#E1E4E8;">(sender); </span><span style="color:#6A737D;">// sender会监听底层的连接状态</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">prepare</span><span style="color:#24292E;">() throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    queue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedBlockingQueue</span><span style="color:#24292E;">(Config.Jvm.BUFFER_SIZE);</span></span>
<span class="line"><span style="color:#24292E;">    sender </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Sender</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    ServiceManager.INSTANCE.</span><span style="color:#6F42C1;">findService</span><span style="color:#24292E;">(GRPCChannelManager.class)</span></span>
<span class="line"><span style="color:#24292E;">         .</span><span style="color:#6F42C1;">addChannelListener</span><span style="color:#24292E;">(sender); </span><span style="color:#6A737D;">// sender会监听底层的连接状态</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 Sender.run() 方法中封装了读取 queue 队列以及发送 gRPC 请求的逻辑，其中会根据底层的 GRPCChannel 连接状态、当前服务以及服务实例的注册情况决定该任务是否执行。Sender.run() 方法的核心逻辑如下（省略全部边界检查逻辑）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">JVMMetricCollection.Builder builder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">           JVMMetricCollection.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">LinkedList&lt;</span><span style="color:#F97583;">JVMMetric</span><span style="color:#E1E4E8;">&gt; buffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedList&lt;</span><span style="color:#F97583;">JVMMetric</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#6A737D;">// 将 queue队列中缓存的全部监控数据填充到 buffer中</span></span>
<span class="line"><span style="color:#E1E4E8;">queue.</span><span style="color:#B392F0;">drainTo</span><span style="color:#E1E4E8;">(buffer);</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 gRPC请求参数</span></span>
<span class="line"><span style="color:#E1E4E8;">builder.</span><span style="color:#B392F0;">addAllMetrics</span><span style="color:#E1E4E8;">(buffer);</span></span>
<span class="line"><span style="color:#E1E4E8;">builder.</span><span style="color:#B392F0;">setServiceInstanceId</span><span style="color:#E1E4E8;">(Agent.SERVICE_INSTANCE_ID); </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#6A737D;">// 通过 gRPC调用将JVM监控数据发送到后端 OAP集群</span></span>
<span class="line"><span style="color:#E1E4E8;">stub.</span><span style="color:#B392F0;">collect</span><span style="color:#E1E4E8;">(builder.</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">());</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">JVMMetricCollection.Builder builder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">           JVMMetricCollection.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">LinkedList&lt;</span><span style="color:#D73A49;">JVMMetric</span><span style="color:#24292E;">&gt; buffer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedList&lt;</span><span style="color:#D73A49;">JVMMetric</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#6A737D;">// 将 queue队列中缓存的全部监控数据填充到 buffer中</span></span>
<span class="line"><span style="color:#24292E;">queue.</span><span style="color:#6F42C1;">drainTo</span><span style="color:#24292E;">(buffer);</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 gRPC请求参数</span></span>
<span class="line"><span style="color:#24292E;">builder.</span><span style="color:#6F42C1;">addAllMetrics</span><span style="color:#24292E;">(buffer);</span></span>
<span class="line"><span style="color:#24292E;">builder.</span><span style="color:#6F42C1;">setServiceInstanceId</span><span style="color:#24292E;">(Agent.SERVICE_INSTANCE_ID); </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#6A737D;">// 通过 gRPC调用将JVM监控数据发送到后端 OAP集群</span></span>
<span class="line"><span style="color:#24292E;">stub.</span><span style="color:#6F42C1;">collect</span><span style="color:#24292E;">(builder.</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">());</span></span></code></pre></div><p>简单看一下该 gRPC 接口以及参数的定义，非常简单：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">service JVMMetricReportService {</span></span>
<span class="line"><span style="color:#E1E4E8;">    rpc </span><span style="color:#B392F0;">collect</span><span style="color:#E1E4E8;"> (JVMMetricCollection) </span><span style="color:#B392F0;">returns</span><span style="color:#E1E4E8;"> (Commands) {}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">service JVMMetricReportService {</span></span>
<span class="line"><span style="color:#24292E;">    rpc </span><span style="color:#6F42C1;">collect</span><span style="color:#24292E;"> (JVMMetricCollection) </span><span style="color:#6F42C1;">returns</span><span style="color:#24292E;"> (Commands) {}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 JVMMetricCollection 中封装了 ServiceInstanceId 以及 JVMMetric 集合，JVMMetric 封装了一个时刻抓取到的 CPU、堆内存使用情况以及 GC 等信息，这里不再展开。</p><p>了解了发送过程之后，我们再来看收集 JVM 监控的原理。在 collectMetric 线程中会定期执行 JVMService.run() 方法，其中通过 MXBean 抓取 JVM 监控信息，然后填充到 JVMMetric 对象中并记录到 queue 缓冲队列中，大致实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 通过JMX获取CPU、Memory、GC的信息，然后组装成JVMMetric</span></span>
<span class="line"><span style="color:#E1E4E8;">JVMMetric.Builder jvmBuilder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> JVMMetric.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">jvmBuilder.</span><span style="color:#B392F0;">setTime</span><span style="color:#E1E4E8;">(currentTimeMillis);</span></span>
<span class="line"><span style="color:#6A737D;">// 通过 MXBean获取 CPU、内存以及GC相关的信息，并填充到 JVMMetric</span></span>
<span class="line"><span style="color:#E1E4E8;">jvmBuilder.</span><span style="color:#B392F0;">setCpu</span><span style="color:#E1E4E8;">(CPUProvider.INSTANCE.</span><span style="color:#B392F0;">getCpuMetric</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">jvmBuilder.</span><span style="color:#B392F0;">addAllMemory</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">     MemoryProvider.INSTANCE.</span><span style="color:#B392F0;">getMemoryMetricList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">jvmBuilder.</span><span style="color:#B392F0;">addAllMemoryPool</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">     MemoryPoolProvider.INSTANCE.</span><span style="color:#B392F0;">getMemoryPoolMetricsList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">jvmBuilder.</span><span style="color:#B392F0;">addAllGc</span><span style="color:#E1E4E8;">(GCProvider.INSTANCE.</span><span style="color:#B392F0;">getGCList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">JVMMetric jvmMetric </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> jvmBuilder.</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 将JVMMetric写入到queue缓冲队列中</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">queue.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(jvmMetric)) { </span><span style="color:#6A737D;">// queue缓冲队列的长度默认为600</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 如果queue队列被填满，则抛弃最老的监控信息，保留最新的</span></span>
<span class="line"><span style="color:#E1E4E8;">    queue.</span><span style="color:#B392F0;">offer</span><span style="color:#E1E4E8;">(jvmMetric);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 通过JMX获取CPU、Memory、GC的信息，然后组装成JVMMetric</span></span>
<span class="line"><span style="color:#24292E;">JVMMetric.Builder jvmBuilder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> JVMMetric.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">jvmBuilder.</span><span style="color:#6F42C1;">setTime</span><span style="color:#24292E;">(currentTimeMillis);</span></span>
<span class="line"><span style="color:#6A737D;">// 通过 MXBean获取 CPU、内存以及GC相关的信息，并填充到 JVMMetric</span></span>
<span class="line"><span style="color:#24292E;">jvmBuilder.</span><span style="color:#6F42C1;">setCpu</span><span style="color:#24292E;">(CPUProvider.INSTANCE.</span><span style="color:#6F42C1;">getCpuMetric</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">jvmBuilder.</span><span style="color:#6F42C1;">addAllMemory</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">     MemoryProvider.INSTANCE.</span><span style="color:#6F42C1;">getMemoryMetricList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">jvmBuilder.</span><span style="color:#6F42C1;">addAllMemoryPool</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">     MemoryPoolProvider.INSTANCE.</span><span style="color:#6F42C1;">getMemoryPoolMetricsList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">jvmBuilder.</span><span style="color:#6F42C1;">addAllGc</span><span style="color:#24292E;">(GCProvider.INSTANCE.</span><span style="color:#6F42C1;">getGCList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">JVMMetric jvmMetric </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> jvmBuilder.</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 将JVMMetric写入到queue缓冲队列中</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">queue.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(jvmMetric)) { </span><span style="color:#6A737D;">// queue缓冲队列的长度默认为600</span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 如果queue队列被填满，则抛弃最老的监控信息，保留最新的</span></span>
<span class="line"><span style="color:#24292E;">    queue.</span><span style="color:#6F42C1;">offer</span><span style="color:#24292E;">(jvmMetric);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里深入介绍一下 JDK 提供的 MXBean 是如何使用的。我们以 GCProvider 为例进行分析（获取其他监控指标的方式也是类似的）。GCProvider 通过枚举方式实现了单例，在其构造方法中，会先获取 MXBean 并封装成相应的 GCMetricAccessor 实现，大致实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 获取GC相关的MXBean</span></span>
<span class="line"><span style="color:#E1E4E8;">beans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ManagementFactory.</span><span style="color:#B392F0;">getGarbageCollectorMXBeans</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (GarbageCollectorMXBean bean </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> beans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bean.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 解析MXBean的名称即可得知当前使用的是哪种垃圾收集器，我们就可以创建相应</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 的GCMetricAccessor实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    GCMetricAccessor accessor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">findByBeanName</span><span style="color:#E1E4E8;">(name);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (accessor </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        metricAccessor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> accessor;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 获取GC相关的MXBean</span></span>
<span class="line"><span style="color:#24292E;">beans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ManagementFactory.</span><span style="color:#6F42C1;">getGarbageCollectorMXBeans</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (GarbageCollectorMXBean bean </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> beans) {</span></span>
<span class="line"><span style="color:#24292E;">    String name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bean.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 解析MXBean的名称即可得知当前使用的是哪种垃圾收集器，我们就可以创建相应</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 的GCMetricAccessor实现</span></span>
<span class="line"><span style="color:#24292E;">    GCMetricAccessor accessor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">findByBeanName</span><span style="color:#24292E;">(name);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (accessor </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        metricAccessor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> accessor;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>GCMetricAccessor 接口的实现类如下图所示，针对每一种垃圾收集器都有相应的实现：</p>`,13),S=l(`<p>GCMetricAccessor 接口中提供了一个 getGCList() 方法用于读取 MXBean 获取 GC 的信息，在抽象类 GCModule 中实现了 getGCList() 方法的核心逻辑：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">GC</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getGCList</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">GC</span><span style="color:#E1E4E8;">&gt; gcList </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedList&lt;</span><span style="color:#F97583;">GC</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (GarbageCollectorMXBean bean </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> beans) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        String name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bean.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        GCPhrase phrase;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> gcCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> gcTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 下面根据 MXBean的名称判断具体的GC信息</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (name.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getNewGCName</span><span style="color:#E1E4E8;">())) { </span><span style="color:#6A737D;">// Young GC的信息</span></span>
<span class="line"><span style="color:#E1E4E8;">            phrase </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> GCPhrase.NEW;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 计算GC次数，从MXBean直接拿到的是GC总次数</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> collectionCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bean.</span><span style="color:#B392F0;">getCollectionCount</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            gcCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> collectionCount </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> lastYGCCount;</span></span>
<span class="line"><span style="color:#E1E4E8;">            lastYGCCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> collectionCount; </span><span style="color:#6A737D;">// 更新 lastYGCCount</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 计算GC时间，从 MXBean直接拿到的是GC总时间</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> time </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bean.</span><span style="color:#B392F0;">getCollectionTime</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            gcTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> time </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> lastYGCCollectionTime;</span></span>
<span class="line"><span style="color:#E1E4E8;">            lastYGCCollectionTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> time; </span><span style="color:#6A737D;">// 更新lastYGCCollectionTime</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (name.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getOldGCName</span><span style="color:#E1E4E8;">())) { </span><span style="color:#6A737D;">// Old GC的信息</span></span>
<span class="line"><span style="color:#E1E4E8;">            phrase </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> GCPhrase.OLD;</span></span>
<span class="line"><span style="color:#E1E4E8;">            ... ... </span><span style="color:#6A737D;">// Old GC的计算方式与Young GC的计算方式相同，不再重复</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span></span>
<span class="line"><span style="color:#E1E4E8;">        gcList.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">( </span><span style="color:#6A737D;">// 最后将 GC信息封装成List返回</span></span>
<span class="line"><span style="color:#E1E4E8;">            GC.</span><span style="color:#B392F0;">newBuilder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">setPhrase</span><span style="color:#E1E4E8;">(phrase)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">setCount</span><span style="color:#E1E4E8;">(gcCount).</span><span style="color:#B392F0;">setTime</span><span style="color:#E1E4E8;">(gcTime).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">        );</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> gcList;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">GC</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getGCList</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">GC</span><span style="color:#24292E;">&gt; gcList </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedList&lt;</span><span style="color:#D73A49;">GC</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (GarbageCollectorMXBean bean </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> beans) {</span></span>
<span class="line"><span style="color:#24292E;">        String name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bean.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        GCPhrase phrase;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> gcCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> gcTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 下面根据 MXBean的名称判断具体的GC信息</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (name.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getNewGCName</span><span style="color:#24292E;">())) { </span><span style="color:#6A737D;">// Young GC的信息</span></span>
<span class="line"><span style="color:#24292E;">            phrase </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> GCPhrase.NEW;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 计算GC次数，从MXBean直接拿到的是GC总次数</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> collectionCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bean.</span><span style="color:#6F42C1;">getCollectionCount</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            gcCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> collectionCount </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> lastYGCCount;</span></span>
<span class="line"><span style="color:#24292E;">            lastYGCCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> collectionCount; </span><span style="color:#6A737D;">// 更新 lastYGCCount</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 计算GC时间，从 MXBean直接拿到的是GC总时间</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> time </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bean.</span><span style="color:#6F42C1;">getCollectionTime</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            gcTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> time </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> lastYGCCollectionTime;</span></span>
<span class="line"><span style="color:#24292E;">            lastYGCCollectionTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> time; </span><span style="color:#6A737D;">// 更新lastYGCCollectionTime</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (name.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getOldGCName</span><span style="color:#24292E;">())) { </span><span style="color:#6A737D;">// Old GC的信息</span></span>
<span class="line"><span style="color:#24292E;">            phrase </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> GCPhrase.OLD;</span></span>
<span class="line"><span style="color:#24292E;">            ... ... </span><span style="color:#6A737D;">// Old GC的计算方式与Young GC的计算方式相同，不再重复</span></span>
<span class="line"><span style="color:#24292E;">        } </span></span>
<span class="line"><span style="color:#24292E;">        gcList.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">( </span><span style="color:#6A737D;">// 最后将 GC信息封装成List返回</span></span>
<span class="line"><span style="color:#24292E;">            GC.</span><span style="color:#6F42C1;">newBuilder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">setPhrase</span><span style="color:#24292E;">(phrase)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">setCount</span><span style="color:#24292E;">(gcCount).</span><span style="color:#6F42C1;">setTime</span><span style="color:#24292E;">(gcTime).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">        );</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> gcList;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在不同类型的垃圾收集器中，Young GC、Old GC 的名称不太相同（例如，G1 中叫 G1 Young Generation 和 G1 Old Generation，在 CMS 中则叫 ParNew 和 ConcurrentMarkSweep），所以这里调用的 getNewGCName() 方法和 getOldGCName() 方法都是抽象方法，延迟到了 GCModule 子类中才真正实现，这是典型的模板方法模式。</p><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><p>BootService 接口的剩余四个实现与 Trace 数据的收集和发送相关，在后面的课时中会详细展开分析，这里简单说一下它们的核心功能。</p><ul><li>ContextManager：负责管理一个 SkyWalking Agent 中所有的 Context 对象。</li><li>ContextManagerExtendService：负责创建 Context 对象。</li><li>TraceSegmentServiceClient：负责将 Trace 数据序列化并发送到 OAP 集群。</li><li>SamplingService：负责实现 Trace 的采样。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时深入介绍了 BootService 的三个核心实现。 GRPCChannelManager 负责管理 Agent 到 OAP 集群的网络连接，并实时的通知注册的 Listener。ServiceAndEndpointRegisterClient 的核心功能有三项。</p><ol><li>注册功能：其中包括服务注册和服务实例注册两次请求。</li><li>定期发送心跳请求：与后端 OAP 集群维持定期探活，让后端 OAP 集群知道该 Agent 正常在线。</li><li>定期同步 Endpoint 名称以及网络地址：维护当前 Agent 中字符串与数字编号的映射关系，减少后续 Trace 数据传输的网络压力，提高请求的有效负载。</li></ol><p>JVMService 负责定期请求 MXBean 获取 JVM 监控信息并发送到后端的 OAP 集群。</p>`,10);function h(B,m,I,M,b,P){const n=o("Image");return t(),c("div",null,[E,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/D6/Cgq2xl6OzXqACRPAAAEm5IQEH5Y241.png"}),y,i,C,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/C0/Ciqah16OzXqAYIu0AABBDZDMT8c843.png"}),d,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/D6/Cgq2xl6OzXqAXhA7AACNDBlVUrQ730.png"}),g,u,F,A,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/C0/Ciqah16OzXuAO6enAAJXETLoQmo373.png"}),v,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/D6/Cgq2xl6OzXuAWM3MAAHZFmJeMwM515.png"}),D,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/C0/Ciqah16OzXuAH1obAACj_oQjWi4810.png"}),S])}const _=e(r,[["render",h]]);export{N as __pageData,_ as default};
