import{_ as o,j as t,o as e,g as r,k as p,h as a,s,Q as l}from"./chunks/framework.b3d8e22e.js";const x=JSON.parse('{"title":"三色标记-清除算法（Tri-Color Mark Sweep） ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学操作系统_文档/(4637) 28  内存回收下篇：三色标记-清除算法是怎么回事？.md","filePath":"posts/backEnd/重学操作系统_文档/(4637) 28  内存回收下篇：三色标记-清除算法是怎么回事？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/重学操作系统_文档/(4637) 28  内存回收下篇：三色标记-清除算法是怎么回事？.md"},i=s("p",null,"今天我们继续讨论内存回收问题。在上一讲，我们发现双色标记-清除算法有一个明显的问题，如下图所示：",-1),_=s("p",null,"你可以把 GC 的过程看作标记、清除及程序不断对内存进行修改的过程，分成 3 种任务：",-1),E=s("ol",null,[s("li",null,[s("p",null,"标记程序（Mark）")]),s("li",null,[s("p",null,"清除程序（Sweep）")]),s("li",null,[s("p",null,"变更程序（Mutation）")])],-1),g=s("p",null,[s("strong",null,"标记（Mark）就是找到不用的内存，清除（Sweep）就是回收不用的资源，而修改（Muation）则是指用户程序对内存进行了修改"),a("。通常情况下，在 GC 的设计中，上述 3 种程序不允许并行执行（Simultaneously）。对于 Mark、Sweep、Mutation 来说内存是共享的。如果并行执行相当于需要同时处理大量竞争条件的手段，这会增加非常多的开销。当然你可以开多个线程去 Mark、Mutation 或者 Sweep，但前提是每个过程都是独立的。")],-1),y=s("p",null,"因为 Mark 和 Sweep 的过程都是 GC 管理，而 Mutation 是在执行应用程序，在实时性要求高的情况下可以允许一边 Mark，一边 Sweep 的情况； 优秀的算法设计也可能会支持一边 Mark、一边 Mutation 的情况。这种算法通常使用了 Read On Write 技术，本质就是先把内存拷贝一份去 Mark/Sweep，让 Mutation 完全和 Mark 隔离。",-1),d=s("p",null,"上图中 GC 开始后，拷贝了一份内存的原本，进行 Mark 和 Sweep，整理好内存之后，再将原本中所有的 Mutation 合并进新的内存。 这种算法设计起来会非常复杂，但是可以保证实时性 GC。",-1),C=s("p",null,"上图的这种 GC 设计比较少见，通常 GC 都会发生 STL（Stop The World）问题，Mark/Sweep/Mutation 只能够交替执行。也就是说， 一种程序执行的时候，另一种程序必须停止。",-1),h=s("p",null,[s("strong",null,"对于双色标记-清除算法，如果 Mark 和 Sweep 之间存在 Mutation，那么 Mutation 的伤害是比较大的"),a("。比如 Mutation 新增了一个白色的对象，这个白色的对象就可能会在 Sweep 启动后被清除。当然也可以考虑新增黑色的对象，这样对象就不会在 Sweep 启动时被回收。但是会发生下面这个问题，如下图所示：")],-1),u=l("",7),m=s("p",null,"第一次执行，算法将 Root 集合能直接引用的对象加入灰色集合，如下图所示：",-1),A=l("",8),S=l("",6),F=s("p",null,[s("strong",null,"在调整已有的引用关系时，三色标记算法的表现明显更好"),a("。下图是对象 B 将对 C 的引用改成了对 F 的引用，C,F 被加入灰色集合。接下来 GC 会递归遍历 C,F，最终然后 F,E,G 都会进入灰色集合。")],-1),k=s("p",null,[a('内存回收就好比有人在随手扔垃圾，清洁工需要不停打扫。如果清洁工能够跟上人们扔垃圾的速度，那么就不需要太多的 STL（Stop The World）。如果清洁工跟不上扔垃圾的速度，最终环境就会被全部弄乱，这个时候清洁工就会要求"Stop The World"。'),s("strong",null,'三色算法的优势就在于它支持多一些情况的 Mutation，这样能够提高"垃圾"被并发回收的概率'),a("。")],-1),G=s("p",null,"目前的 GC 主要都是基于三色标记算法。 至于清除算法，有原地回收算法，也有把存活下来的对象（黑色对象）全部拷贝到一个新的区域的算法。",-1),M=s("h3",{id:"碎片整理和生代技术",tabindex:"-1"},[a("碎片整理和生代技术 "),s("a",{class:"header-anchor",href:"#碎片整理和生代技术","aria-label":'Permalink to "碎片整理和生代技术"'},"​")],-1),b=s("p",null,"三色标记-清除算法，还没有解决内存回收产生碎片的问题。通常，我们会在三色标记-清除算法之上，再构建一个整理内存（Compact）的算法。如下图所示：",-1),v=s("p",null,"Compact 算法将对象重新挤压到一起，让更多空间可以被使用。我们在设计这个算法时，观察到了一个现象：新创建出来的对象，死亡（被回收）概率会更高，而那些已经存在了一段时间的对象，往往更不容易死亡。这有点类似 LRU 缓存，其实是一个概率问题。接下来我们考虑针对这个现象进行优化。",-1),T=s("p",null,"如上图所示，你可以把新创建的对象，都先放到一个统一的区域，在 Java 中称为伊甸园（Eden）。这个区域因为频繁有新对象死亡，因此需要经常 GC。考虑整理使用中的对象成本较高，因此可以考虑将存活下来的对象拷贝到另一个区域，Java 中称为存活区（Survior）。存活区生存下来的对象再进入下一个区域，Java 中称为老生代。",-1),w=s("p",null,[a("上图展示的三个区域，"),s("strong",null,"Eden、Survior 及老生代之间的关系是对象的死亡概率逐级递减，对象的存活周期逐级增加"),a("。三个区域都采用三色标记-清除算法。每次 Eden 存活下来的对象拷贝到 Survivor 区域之后，Eden 就可以完整的回收重利用。Eden 可以考虑和 Survivor 用 1:1 的空间，老生代则可以用更大的空间。Eden 中全量 GC 可以频繁执行，也可以增量 GC 混合全量 GC 执行。老生代中的 GC 频率可以更低，偶尔执行一次全量的 GC。")],-1),D=s("h3",{id:"gc-的选择",tabindex:"-1"},[a("GC 的选择 "),s("a",{class:"header-anchor",href:"#gc-的选择","aria-label":'Permalink to "GC 的选择"'},"​")],-1),f=s("p",null,[a("最后我们来聊聊 GC 的选择。"),s("strong",null,"通常选择 GC 会有实时性要求（最大容忍的暂停时间），需要从是否为高并发场景、内存实际需求等维度去思考"),a(" 。"),s("strong",null,"在选择 GC 的时候，复杂的算法并不一定更有效。下面是一些简单有效的思考和判断"),a("。")],-1),j=l("",13);function B(P,V,Z,q,I,N){const n=t("Image");return e(),r("div",null,[i,p(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image2/M01/02/27/Cip5yF_Z2CCAZ4MFAABZx6AzarA983.png"}),_,E,g,p(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image2/M01/02/27/Cip5yF_Z2CiASF0QAACL55G2CDE848.png"}),y,p(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/8A/54/CgqCHl_Z2C-ABz5lAAC4Jo2Y4mQ994.png"}),d,C,h,p(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/8A/49/Ciqc1F_Z2DeAGJzgAABVUsm0aqE938.png"}),u,p(n,{alt:"图片35.png",src:"https://s0.lgstatic.com/i/image/M00/8A/59/CgqCHl_Z4YuATwAMAAFgNx9KdWo799.png"}),m,p(n,{alt:"图片36.png",src:"https://s0.lgstatic.com/i/image2/M01/02/2C/Cip5yF_Z4eWAc6oqAAFWo21QkuY797.png"}),A,p(n,{alt:"图片33.png",src:"https://s0.lgstatic.com/i/image2/M01/02/2D/CgpVE1_Z4h2AKNQnAAFJ-m6TgJw012.png"}),a(),S,p(n,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image2/M01/02/28/CgpVE1_Z2NiAbW5kAAD-d5qJRoI176.png"}),F,p(n,{alt:"图片32.png",src:"https://s0.lgstatic.com/i/image/M00/8A/4F/Ciqc1F_Z4mCANcwoAAFFnKmGj_w824.png"}),k,G,M,b,p(n,{alt:"图片32.png",src:"https://s0.lgstatic.com/i/image/M00/8A/59/CgqCHl_Z4LSAbg0BAAFFnKmGj_w022.png"}),a(),v,p(n,{alt:"Drawing 15.png",src:"https://s0.lgstatic.com/i/image2/M01/02/28/CgpVE1_Z2OuAXxFjAABfInodsKw867.png"}),T,w,D,f,p(n,{alt:"Drawing 17.png",src:"https://s0.lgstatic.com/i/image2/M01/02/28/Cip5yF_Z2POASXuMAACh7n5TBi8380.png"}),j])}const J=o(c,[["render",B]]);export{x as __pageData,J as default};
