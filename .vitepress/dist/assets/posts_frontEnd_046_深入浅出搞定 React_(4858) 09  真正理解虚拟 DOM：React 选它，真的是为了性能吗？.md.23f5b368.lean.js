import{_ as t,j as l,o as e,g as c,k as a,h as o,Q as n,s as p}from"./chunks/framework.4e7d56ce.js";const S=JSON.parse('{"title":"快速搞定虚拟 DOM 的两个\\"大问题\\" ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(4858) 09  真正理解虚拟 DOM：React 选它，真的是为了性能吗？.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(4858) 09  真正理解虚拟 DOM：React 选它，真的是为了性能吗？.md","lastUpdated":1696417798000}'),r={name:"posts/frontEnd/046_深入浅出搞定 React/(4858) 09  真正理解虚拟 DOM：React 选它，真的是为了性能吗？.md"},E=n("",7),i=n("",43),y=p("p",null,"而在虚拟 DOM 的加持下，事情变成了这样：",-1),D=p("p",null,'注意图中的"模板"二字加了引号，这是因为虚拟 DOM 在实现上并不总是借助模板。比如 React 就使用了 JSX，前面咱们着重讲过，JSX 本质不是模板，而是一种使用体验和模板相似的 JS 语法糖。',-1),M=p("p",null,[o('区别就在于多出了一层虚拟 DOM 作为缓冲层。这个缓冲层带来的利好是：当 DOM 操作（渲染更新）比较频繁时，它会先将前后两次的虚拟 DOM 树进行对比，定位出具体需要更新的部分，生成一个"补丁集"，最后只把"补丁"打在需要更新的那部分真实 DOM 上，实现精准的"'),p("strong",null,"差量更新"),o('"。这个过程对应的虚拟 DOM 工作流如下图所示：')],-1),u=n("",8),O=n("",11),d=n("",7);function g(q,_,h,m,A,b){const s=l("Image");return e(),c("div",null,[E,a(s,{alt:"Lark20201106-192037.png",src:"https://s0.lgstatic.com/i/image/M00/68/F3/Ciqc1F-lMbGAZJopAAJVEWRSZj4098.png"}),i,a(s,{alt:"Lark20201106-192050.png",src:"https://s0.lgstatic.com/i/image/M00/68/F3/Ciqc1F-lMciARJRWAABf3Qw2zLE639.png"}),y,a(s,{alt:"Lark20201106-192053.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMdaAD-COAAB2DeSedec916.png"}),D,M,a(s,{alt:"Lark20201106-192055.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMeWADhSdAABuVFS6_bo480.png"}),u,a(s,{alt:"Lark20201106-192058.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMhKAbHiXAACFes1Uw30648.png"}),o(),a(s,{alt:"Lark20201106-192100.png",src:"https://s0.lgstatic.com/i/image/M00/68/FE/CgqCHl-lMheAZqbEAACP9ZvpCP8374.png"}),O,a(s,{alt:"Lark20201109-110626.png",src:"https://s0.lgstatic.com/i/image/M00/69/AE/CgqCHl-otLSAT1ivAACwY9bVkZQ836.png"}),d])}const F=t(r,[["render",g]]);export{S as __pageData,F as default};
