import{_ as s,j as i,o as n,g as c,k as o,h as t,s as a,Q as e}from"./chunks/framework.4e7d56ce.js";const pa=JSON.parse('{"title":"第04讲：架构核心技术之分布式数据存储","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/架构师的 36 项修炼/(21) 第04讲：架构核心技术之分布式数据存储.md","filePath":"posts/backEnd/架构师的 36 项修炼/(21) 第04讲：架构核心技术之分布式数据存储.md","lastUpdated":1696682708000}'),h={name:"posts/backEnd/架构师的 36 项修炼/(21) 第04讲：架构核心技术之分布式数据存储.md"},_=a("h1",{id:"第04讲-架构核心技术之分布式数据存储",tabindex:"-1"},[t("第04讲：架构核心技术之分布式数据存储 "),a("a",{class:"header-anchor",href:"#第04讲-架构核心技术之分布式数据存储","aria-label":'Permalink to "第04讲：架构核心技术之分布式数据存储"'},"​")],-1),r=a("p",null,"本课时主题为分布式数据存储，知识架构图如下所示。",-1),p=e("",6),d=a("h2",{id:"一主多从复制",tabindex:"-1"},[t("一主多从复制 "),a("a",{class:"header-anchor",href:"#一主多从复制","aria-label":'Permalink to "一主多从复制"'},"​")],-1),A=a("p",null,"MySQL 的主从复制是一种数据同步机制，除了可以将一个主数据库中的数据同步复制到一个从数据库上，还可以将一个主数据库上的数据同步复制到多个从数据库上，也就是所谓的 MySQL 的一主多从复制。如下图所示，多个从数据库关联到主数据库后，将主数据库上的 Binlog 日志同步地复制到了多个从数据库上，通过执行日志，每个从数据库的数据都和主数据库上的数据保持了一致。这里面的数据更新操作表示的是所有数据库的更新操作，除了 SELECT 之类的查询读操作以外，其他的 INSERT、DELETE、UPDATE 这样的 DML 写操作，以及 CREATE TABLE、DROPT ABLE、ALTER TABLE 等 DDL 操作都可以同步复制到从数据库上去。",-1),g=a("h2",{id:"一主多从复制的优点",tabindex:"-1"},[t("一主多从复制的优点 "),a("a",{class:"header-anchor",href:"#一主多从复制的优点","aria-label":'Permalink to "一主多从复制的优点"'},"​")],-1),m=a("p",null,"一主多从复制有四大优点：分摊负载、专机专用、便于冷备、高可用。",-1),u=e("",13),b=a("p",null,"那么，当使用 MySQL 服务器实现主主复制时，数据库服务器失效该如何应对？",-1),P=a("p",null,"如下图所示，正常情况下用户会写入到主服务器 A 中，然后数据从 A 复制到主服务器 B 上。当主服务器 A 失效的时候，写操作会被发送到主服务器 B 中去，数据从 B 服务器复制到 A 服务器。",-1),B=a("p",null,"再具体看一下主主失效的维护过程，如下图。",-1),C=e("",18),S=a("p",null,"这种硬编码主要的缺点在于，数据库的分片逻辑是应用程序自身实现的，应用程序需要耦合数据库分片逻辑，不利于应用程序的维护和扩展。",-1),L=a("p",null,"一个简单的解决办法就是将映射关系存储在外面。如下图所示，应用程序在连接数据库进行 SQL 操作的时候，通过查找外部的数据存储查询自己应该连接到哪台服务器上面，然后根据返回的服务器的编号，连接对应的服务器执行相应的操作。在这个例子中，用户 ID 33 查找服务器是 2，用户 ID 94 查找服务器也是 2，它们根据查找到的用户服务器的编号，连接对应的服务器，将数据写入到对应的服务器分片中。",-1),M=a("p",null,"通过这种手段实现数据分片的主要挑战在于，第一需要额外的代码，业务逻辑因此变得复杂。另一个就是无法执行分片的联合操作，也就是执行查询操作的时候，只能在一个分片上进行。多个分片多张表进行 join 联合查询，这种操作，分片技术是无法实现的。还有个问题在于无法使用数据库的事务。我们知道现在的数据库事务是通过数据库自身的日志实现，数据库将多个更新操作，当做一个事务来执行，要么全部完成，要么完全不执行。但是如果是通过分片的方式，不同的数据操作落在不同的服务器上，不同的服务器之间是无法实现所有的更新操作全部完成或者全部不执行的，因此也就无法使用数据库的事务。还有一个挑战就是系统的数据量是逐渐增加的，在增加的过程中，如果服务器不够用了，分片不够用了，需要扩大分片的时候，如何增加分片，增加服务器？",-1),y=a("p",null,`现在有一些专门的分布式数据库中间件来解决上述这些问题，比较知名的有 Mycat。Mycat 是一个专门的分布式数据库中间件，应用程序像连接数据库一样去连接 Mycat，而数据分片的操作完全交给了 Mycat 去完成。在下图所示的例子中，有 3 个分片数据库服务器------数据库服务器 dn1、dn2 和 dn3，它们的分片规则是根据 prov 字段进行分片。那么，当我们执行一个查询操作"select * from orders where prov='wuhan'"的时候，Mycat 会根据分片规则将这条 SQL 操作路由到 dn1 这个服务器节点上。dn1 执行数据查询操作返回结果后，Mycat 再返回给应用程序。通过使用 Mycat 这样的分布式数据库中间件，应用程序可以透明地、无感知地使用分片数据库。同时，Mycat 还一定程度上支持分片数据库的联合 join 查询以及数据库事务。`,-1),T=a("h2",{id:"分片数据库的伸缩扩容",tabindex:"-1"},[t("分片数据库的伸缩扩容 "),a("a",{class:"header-anchor",href:"#分片数据库的伸缩扩容","aria-label":'Permalink to "分片数据库的伸缩扩容"'},"​")],-1),Q=a("p",null,"下面来看分片数据库如何进行扩容伸缩。一开始，数据量还不是太多，两个数据库服务器就够了。但是随着数据的不断增长，可能需要增加第三个、第四个、第五个，甚至更多的服务器。在增加服务器的过程中，分片规则需要改变。分片规则改变后，以前写入到原来的数据库中的数据，根据新的分片规则，可能要访问新的服务器，所以还需要进行数据迁移。",-1),E=a("p",null,"不管是更改分片的路由算法规则，还是进行数据迁移，都是一些比较麻烦和复杂的事情。因此在实践中通常的做法是数据分片使用逻辑数据库，也就是说一开始虽然只需要两个服务器就可以完成数据分片存储，但是依然在逻辑上把它切分成多个逻辑数据库。",-1),x=a("p",null,"在下图所示的例子中，我们将数据库切分成 32 个逻辑数据库，但是开始的时候只有两个物理服务器，我们把 32 个数据库分别启动在两个物理服务器上面。那么，路由算法就还是按照 32 进行路由分区，数据分片也是 32 片。当两台服务器不能够满足数据存储和访问要求的时候，我们只需要简单地将这些逻辑数据库迁移到其他的物理服务器上就可以完成扩容。因为迁移后数据分片还是 32 片，数据分片的算法不需要改变。数据迁移也仅仅是将逻辑数据库迁移到新的服务器上面去，而这种迁移通过数据库的主从复制就可以完成。",-1),f=a("h1",{id:"数据库部署方案",tabindex:"-1"},[t("数据库部署方案 "),a("a",{class:"header-anchor",href:"#数据库部署方案","aria-label":'Permalink to "数据库部署方案"'},"​")],-1),k=a("p",null,"那么，实践中，数据库的部署方案有哪些？",-1),D=a("h2",{id:"单一服务和单一数据库",tabindex:"-1"},[t("单一服务和单一数据库 "),a("a",{class:"header-anchor",href:"#单一服务和单一数据库","aria-label":'Permalink to "单一服务和单一数据库"'},"​")],-1),I=a("p",null,"最简单的就是单一服务和单一数据库。应用服务器可能有多个，但是它们完成的功能是单一的功能。多个完成单一功能的服务器，通过负载均衡对外提供服务。它们只连一台单一数据库服务器，这是应用系统早期用户量比较低的时候的一种架构方法，如下图所示。",-1),N=a("h2",{id:"主从复制-1",tabindex:"-1"},[t("主从复制 "),a("a",{class:"header-anchor",href:"#主从复制-1","aria-label":'Permalink to "主从复制"'},"​")],-1),R=a("p",null,"如果对系统的可用性和对数据库的访问性能提出更高要求，就可以通过数据库的主从复制进行初步的伸缩。通过主从复制，实现一主多从。应用服务器的写操作连接主数据库，读操作从从服务器上进行读取，如下图所示。",-1),q=a("h2",{id:"业务分库",tabindex:"-1"},[t("业务分库 "),a("a",{class:"header-anchor",href:"#业务分库","aria-label":'Permalink to "业务分库"'},"​")],-1),V=a("p",null,"随着业务更加复杂，为了提供更高的数据库处理能力，可以进行数据的业务分库。数据的业务分库是一种逻辑上的，是基于功能的一种分割，将不同用途的数据表存储在不同的物理数据库上面去。",-1),W=a("p",null,"在下图的例子中，我们有产品类目服务和用户服务，两个应用服务器集群，对应地，我们将数据库也拆分成两个，一个叫作类目数据库，一个叫作用户数据库。每个数据库依然使用主从复制。通过业务分库的方式，我们在同一个系统中，提供了更多的数据库存储，同时也就提供了更强大的数据访问能力，同时也使系统变得更加简单，系统的耦合变得更低。",-1),O=a("h2",{id:"综合部署",tabindex:"-1"},[t("综合部署 "),a("a",{class:"header-anchor",href:"#综合部署","aria-label":'Permalink to "综合部署"'},"​")],-1),F=a("p",null,"而更复杂的综合部署方案，则是根据不同数据的访问特点，使用不同的解决方案进行应对。比如类目数据库，也许通过主从复制就能够满足所有的访问要求，但是如果用户量特别大，进行主从复制或主主复制，还是不能够满足数据存储以及写操作的访问压力，这时候就可以对用户数据库进行数据分片存储了，同时每个分片数据库也使用主从复制的方式进行部署，如下图所示。",-1),K=a("h1",{id:"nosql-数据库",tabindex:"-1"},[t("NoSQL 数据库 "),a("a",{class:"header-anchor",href:"#nosql-数据库","aria-label":'Permalink to "NoSQL 数据库"'},"​")],-1),v=a("p",null,"像 MySQL 这类关系数据库，在历史上使用比较广泛，但是随着互联网业务的发展，出现了一种新的数据库叫作 NoSQL 数据库。这种数据库和传统的关系数据库不同，它的主要访问方式也不再使用 SQL 进行操作，所以被称作 NoSQL 数据库。NoSQL 数据库主要是解决大规模分布式数据的存储问题。",-1),H=a("h2",{id:"cap-原理与数据一致性",tabindex:"-1"},[t("CAP 原理与数据一致性 "),a("a",{class:"header-anchor",href:"#cap-原理与数据一致性","aria-label":'Permalink to "CAP 原理与数据一致性"'},"​")],-1),J=a("p",null,"对于大规模的数据分布式存储有一个著名的 CAP 原理。CAP 原理是说，对于一个分布式系统，它不能够同时满足一致性（C）、可用性（A）以及分区耐受性（P）这三个特点。其中，一致性是说，任何时候集群中所有的数据的备份都是一致的；可用性是说，当分布式集群中某些服务器节点失效的时候，集群依然是可用的；分区耐受性是说所当网络失效的时候，节点无法通信的时候，系统依然是可用的。而 CAP 原理就是说这三者无法同时满足。通常一个分布式应用系统，可用性是必不可少的，而分区耐受性也是需要满足的。因此在现实中，很多系统是通过对数据的一致性做文章，来提供一个满足要求的分布式系统的。",-1),Y=a("p",null,"我们先看一下数据是如何不一致的。如下图，假如说有一个分布式集群，有 ABC3 个服务节点，对于客户端 1，如果执行某个操作，对 ID 55 执行价格等于 99 的 update 操作，这个操作执行在节点 A 上。同时有另一个客户端，对 ID 55 执行价格等于 75 的操作，这个操作执行在节点 B 上。正常情况下 3 个节点之间互相通信，会把 ID 等于 55 的数据同步给其他的节点，三个节点存储的数据一致。但是当网络通信以及节点失效的情况下，这种数据同步就无法完成，就会导致节点 A 和节点 B 上对同一个 ID 存储的数据是不同的，这个时候如果有其他的应用程序连接数据存储集群，并且它们连接的分别是节点 A 和节点 B，那么得到的结果也是不同的，这就会导致数据的不一致。",-1),U=a("p",null,"那么，既然 CAP 原理说数据的一致性、可用性和分区耐受性是无法同时满足的，而可用性和分区耐受性我们通常又是不得不保证的。那么更多的时候，我们通过解决一致性的问题，来实现分布式系统。",-1),G=a("h2",{id:"一致性冲突解决方案",tabindex:"-1"},[t("一致性冲突解决方案 "),a("a",{class:"header-anchor",href:"#一致性冲突解决方案","aria-label":'Permalink to "一致性冲突解决方案"'},"​")],-1),j=a("p",null,"解决一致性冲突的方案就是实现最终一致性。一致性是说，在任何时间，数据的多个备份存储都是一致的。而最终一致是说，在一个分布式系统中，在某个时候，不同服务器上存储的同一个数据可能是不一致的，但是它最终还是一致的，只要不一致的时间不影响应用程序的正确性，我们就是可以接受的，这种一致性叫作最终一致性。",-1),w=a("p",null,"比如说，如下图，客户端 A 连接到服务器 1，客户端 C 连接到服务器 2，客户端 A 对数据作出变更操作，服务器 1 将变更扩散到服务器 2，那么，客户端 C 连接到服务器 2 的时候，可能不会立即得到最新的数据，但是过一会儿，等变更扩散完成了，就可以获得最新的数据了。",-1),$=a("p",null,"当数据在写的过程中多个数据备份有冲突的时候，如何解决呢？",-1),X=a("p",null,"一种方法是根据时间戳进行判断。最后写入的，也就是时间戳在后面的，覆盖时间戳在前面的。在下图例子中，两个客户端连接到不同的服务器节点，对同一个数据做更新操作。那么，在数据复制的时候就会出现数据冲突，这个时候解决冲突的办法就是根据时间戳进行判断，时间戳大的，也就是说最新的数据，覆盖时间戳小的、旧的数据。",-1),z=a("p",null,"另一种解决冲突的机制是通过客户端进行冲突解决。在下图例子中，客户端 1 保存用户购物车编号，用户 123 的购物车编号是 55，客户端 2 保存用户 123 购车编号是 70。当客户端 3 去获取用户 123 的购物车编号时，它就得到了两个编号的购物车。解决办法就是将这两个购物车进行合并，合并成一个购物车，并且把它重新写入到分步式存储集群中。",-1),Z=a("p",null,"还有一种冲突的解决方案是通过投票进行解决。典型的就是 Cassandra 中的冲突解决机制。如下图所示，一个客户端向一个分布式集群中写入数据的时候，它会同时向 3 个节点写入数据，并且至少等待两个节点响应写入成功。而另一个客户端想要读取这个数据的时候，至少要从 3 个节点中去读取数据，并且至少有 2 个节点有返回，然后根据返回的节点数进行投票，获取最新版本的数据。",-1),aa=a("h1",{id:"总结回顾",tabindex:"-1"},[t("总结回顾 "),a("a",{class:"header-anchor",href:"#总结回顾","aria-label":'Permalink to "总结回顾"'},"​")],-1),ta=a("p",null,"分布式数据库和分布式存储是分布式系统中难度最大、挑战最大，也是最容易出问题的地方。解决的办法主要是数据库的复制，通过数据库的复制，提升数据库的读性能和系统的可用性。",-1),la=a("p",null,"如果对数据存储和数据库的写操作有更高要求的时候，就需要通过数据分片的方式来实现。在具体的部署过程中，可以混合使用数据复制、数据分库和数据分片几种技术方案。如果你的应用不是非要使用关系数据库的话，你还可以选择 NoSQL 数据库，NoSQL 数据库会提供更强大的数据存储能力和并发读写能力，但是 NoSQL 数据库因为 CAP 原理的约束可能会遇到数据不一致的问题。数据不一致的问题，可以通过时间戳合并、客户端判断以及投票这样的几种机制解决，实现最终一致性。",-1),oa=a("p",null,"下一课时的主题是分布式微服务架构。",-1);function ea(sa,ia,na,ca,ha,_a){const l=i("Image");return n(),c("div",null,[_,r,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/EC/CgotOV13HsiAXNKNAAGilToW6a4338.png"}),t(),p,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/40/CgotOV13W-WANQYbAAR8RKLKV9U675.png"}),t(),d,A,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/0A/CgoB5l13TW2ADnx0AAFtYmgkr0Y145.png"}),t(),g,m,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/09/CgoB5l13TKOAFFotAADHFIrfxQk219.png"}),t(),u,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/20/CgoB5l13W7SAR1iEAAUv-NT59RI274.png"}),t(),b,P,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/20/CgoB5l13W5OAGyUpAAPoxrnObJo370.png"}),t(),B,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3A/CgotOV13WKyAEPxFAAJHaNshZYg195.png"}),t(),C,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3A/CgotOV13WOiAeJnvAAIteNo08c8975.png"}),t(),S,L,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3B/CgotOV13WTKAWRl6AAOpzLgF2Bs560.png"}),t(),M,y,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/1D/CgoB5l13WnKAFf4WAAKr7xhpGyc048.png"}),t(),T,Q,E,x,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgotOV13HsyANcQIAAx0gxI145s868.png"}),t(),f,k,D,I,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/1D/CgoB5l13WoSAVRDFAAHw6hoKJ9E861.png"}),t(),N,R,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3E/CgotOV13Wr2AI4XBAAIw5NYxRSY754.png"}),t(),q,V,W,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3E/CgotOV13WtGAG5nxAAPFQPN1lBs026.png"}),t(),O,F,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/1E/CgoB5l13WtuAaFvJAARjv_I5qRM960.png"}),t(),K,v,H,J,Y,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3E/CgotOV13WuSAPm_PAAJ2eEQkqVA858.png"}),t(),U,G,j,w,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/3E/CgotOV13Wu6AaG3jAALIUgL6dlE525.png"}),t(),$,X,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgotOV13Hs-Ad34IAAH2XLaPnyk947.png"}),t(),z,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/CD/CgoB5l13HtCAPTFQAAJUAwtt4uY430.png"}),t(),Z,o(l,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/1F/CgoB5l13W1WAT5WIAAK-aY2RDbQ691.png"}),t(),aa,ta,la,oa])}const da=s(h,[["render",ea]]);export{pa as __pageData,da as default};
