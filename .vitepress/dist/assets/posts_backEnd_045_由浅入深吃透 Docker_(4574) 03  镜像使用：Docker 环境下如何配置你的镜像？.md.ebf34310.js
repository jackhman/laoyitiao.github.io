import{_ as o,j as e,o as c,g as t,k as l,h as a,s,Q as p}from"./chunks/framework.b3d8e22e.js";const x=JSON.parse('{"title":"镜像操作 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/045_由浅入深吃透 Docker/(4574) 03  镜像使用：Docker 环境下如何配置你的镜像？.md","filePath":"posts/backEnd/045_由浅入深吃透 Docker/(4574) 03  镜像使用：Docker 环境下如何配置你的镜像？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/045_由浅入深吃透 Docker/(4574) 03  镜像使用：Docker 环境下如何配置你的镜像？.md"},y=s("p",null,"今天我将围绕 Docker 核心概念镜像展开，首先重点讲解一下镜像的基本操作，然后介绍一下镜像的实现原理。首先说明，咱们本课时的镜像均指 Docker 镜像。",-1),i=s("p",null,"你是否还记得镜像是什么？我们先回顾一下。",-1),E=s("p",null,[a("镜像是一个只读的 Docker 容器模板，包含启动容器所需要的所有文件系统结构和内容。简单来讲，镜像是一个特殊的文件系统，它提供了容器运行时所需的程序、软件库、资源、配置等静态数据。即"),s("strong",null,"镜像不包含任何动态数据，镜像内容在构建后不会被改变"),a("。")],-1),d=s("p",null,"然后我们来看下如何操作镜像。",-1),b=s("h3",{id:"镜像操作",tabindex:"-1"},[a("镜像操作 "),s("a",{class:"header-anchor",href:"#镜像操作","aria-label":'Permalink to "镜像操作"'},"​")],-1),u=p(`<p>图 1 镜像操作</p><p>从图中可知，镜像的操作可分为：</p><ul><li><p>拉取镜像，使用<code>docker pull</code>命令拉取远程仓库的镜像到本地 ；</p></li><li><p>重命名镜像，使用<code>docker tag</code>命令&quot;重命名&quot;镜像 ；</p></li><li><p>查看镜像，使用<code>docker image ls</code>或<code>docker images</code>命令查看本地已经存在的镜像 ；</p></li><li><p>删除镜像，使用<code>docker rmi</code>命令删除无用镜像 ；</p></li><li><p>构建镜像，构建镜像有两种方式。第一种方式是使用<code>docker build</code>命令基于 Dockerfile 构建镜像，也是我比较推荐的镜像构建方式；第二种方式是使用<code>docker commit</code>命令基于已经运行的容器提交为镜像。</p></li></ul><p>下面，我们逐一详细介绍。</p><h4 id="拉取镜像" tabindex="-1">拉取镜像 <a class="header-anchor" href="#拉取镜像" aria-label="Permalink to &quot;拉取镜像&quot;">​</a></h4><p>Docker 镜像的拉取使用<code>docker pull</code>命令， 命令格式一般为 docker pull [Registry]/[Repository]/[Image]:[Tag]。</p><ul><li><p>Registry 为注册服务器，Docker 默认会从 docker.io 拉取镜像，如果你有自己的镜像仓库，可以把 Registry 替换为自己的注册服务器。</p></li><li><p>Repository 为镜像仓库，通常把一组相关联的镜像归为一个镜像仓库，<code>library</code>为 Docker 默认的镜像仓库。</p></li><li><p>Image 为镜像名称。</p></li><li><p>Tag 为镜像的标签，如果你不指定拉取镜像的标签，默认为<code>latest</code>。</p></li></ul><p>例如，我们需要获取一个 busybox 镜像，可以执行以下命令：</p><blockquote><p>busybox 是一个集成了数百个 Linux 命令（例如 curl、grep、mount、telnet 等）的精简工具箱，只有几兆大小，被誉为 Linux 系统的瑞士军刀。我经常会使用 busybox 做调试来查找生产环境中遇到的问题。</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker pull busybox</span></span>
<span class="line"><span style="color:#E1E4E8;">Using </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> tag</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> latest</span></span>
<span class="line"><span style="color:#E1E4E8;">latest</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> Pulling from library</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">busybox</span></span>
<span class="line"><span style="color:#E1E4E8;">61c5ed1cbdf8</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> Pull complete</span></span>
<span class="line"><span style="color:#E1E4E8;">Digest</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> sha256</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">4f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977</span></span>
<span class="line"><span style="color:#E1E4E8;">Status</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> Downloaded newer image </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> busybox</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">latest</span></span>
<span class="line"><span style="color:#E1E4E8;">docker.io</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">library</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">busybox</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">latest</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker pull busybox</span></span>
<span class="line"><span style="color:#24292E;">Using </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> tag</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> latest</span></span>
<span class="line"><span style="color:#24292E;">latest</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Pulling from library</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">busybox</span></span>
<span class="line"><span style="color:#24292E;">61c5ed1cbdf8</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Pull complete</span></span>
<span class="line"><span style="color:#24292E;">Digest</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> sha256</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">4f47c01fa91355af2865ac10fef5bf6ec9c7f42ad2321377c21e844427972977</span></span>
<span class="line"><span style="color:#24292E;">Status</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Downloaded newer image </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> busybox</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">latest</span></span>
<span class="line"><span style="color:#24292E;">docker.io</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">library</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">busybox</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">latest</span></span></code></pre></div><p>实际上执行<code>docker pull busybox</code>命令，都是先从本地搜索，如果本地搜索不到<code>busybox</code>镜像则从 Docker Hub 下载镜像。</p><p>拉取完镜像，如果你想查看镜像，应该怎么操作呢？</p><h4 id="查看镜像" tabindex="-1">查看镜像 <a class="header-anchor" href="#查看镜像" aria-label="Permalink to &quot;查看镜像&quot;">​</a></h4><p>Docker 镜像查看使用<code>docker images</code>或者<code>docker image ls</code>命令。</p><p>下面我们使用<code>docker images</code>命令列出本地所有的镜像。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker images</span></span>
<span class="line"><span style="color:#E1E4E8;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#E1E4E8;">nginx               latest              4bb46517cac3        </span><span style="color:#79B8FF;">9</span><span style="color:#E1E4E8;"> days ago          133MB</span></span>
<span class="line"><span style="color:#E1E4E8;">nginx               </span><span style="color:#79B8FF;">1.15</span><span style="color:#E1E4E8;">                53f3fd8007f7        </span><span style="color:#79B8FF;">15</span><span style="color:#E1E4E8;"> months ago       109MB</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             latest              018c9d7b792b        </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> weeks ago         1.</span><span style="color:#FDAEB7;font-style:italic;">22MB</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker images</span></span>
<span class="line"><span style="color:#24292E;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#24292E;">nginx               latest              4bb46517cac3        </span><span style="color:#005CC5;">9</span><span style="color:#24292E;"> days ago          133MB</span></span>
<span class="line"><span style="color:#24292E;">nginx               </span><span style="color:#005CC5;">1.15</span><span style="color:#24292E;">                53f3fd8007f7        </span><span style="color:#005CC5;">15</span><span style="color:#24292E;"> months ago       109MB</span></span>
<span class="line"><span style="color:#24292E;">busybox             latest              018c9d7b792b        </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> weeks ago         1.</span><span style="color:#B31D28;font-style:italic;">22MB</span></span></code></pre></div><p>如果我们想要查询指定的镜像，可以使用<code>docker image ls</code>命令来查询。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker image ls busybox</span></span>
<span class="line"><span style="color:#E1E4E8;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             latest              018c9d7b792b        </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> weeks ago         1.</span><span style="color:#FDAEB7;font-style:italic;">22MB</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker image ls busybox</span></span>
<span class="line"><span style="color:#24292E;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#24292E;">busybox             latest              018c9d7b792b        </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> weeks ago         1.</span><span style="color:#B31D28;font-style:italic;">22MB</span></span></code></pre></div><p>当然你也可以使用<code>docker images</code>命令列出所有镜像，然后使用<code>grep</code>命令进行过滤。使用方法如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker images </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">grep busybox</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             latest              018c9d7b792b        </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> weeks ago         1.</span><span style="color:#FDAEB7;font-style:italic;">22MB</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker images </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">grep busybox</span></span>
<span class="line"><span style="color:#24292E;">busybox             latest              018c9d7b792b        </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> weeks ago         1.</span><span style="color:#B31D28;font-style:italic;">22MB</span></span></code></pre></div><h4 id="重命名-镜像" tabindex="-1">&quot;重命名&quot;镜像 <a class="header-anchor" href="#重命名-镜像" aria-label="Permalink to &quot;&quot;重命名&quot;镜像&quot;">​</a></h4><p>如果你想要自定义镜像名称或者推送镜像到其他镜像仓库，你可以使用<code>docker tag</code>命令将镜像重命名。<code>docker tag</code>的命令格式为 docker tag [SOURCE_IMAGE][:TAG] [TARGET_IMAGE][:TAG]。</p><p>下面我们通过实例演示一下：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker tag busybox:latest mybusybox:latest</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker tag busybox:latest mybusybox:latest</span></span></code></pre></div><p>执行完<code>docker tag</code>命令后，可以使用查询镜像命令查看一下镜像列表：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">docker images</span></span>
<span class="line"><span style="color:#E1E4E8;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             latest              018c9d7b792b        3 weeks ago         1.22MB</span></span>
<span class="line"><span style="color:#E1E4E8;">mybusybox           latest              018c9d7b792b        3 weeks ago         1.22MB</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">docker images</span></span>
<span class="line"><span style="color:#24292E;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#24292E;">busybox             latest              018c9d7b792b        3 weeks ago         1.22MB</span></span>
<span class="line"><span style="color:#24292E;">mybusybox           latest              018c9d7b792b        3 weeks ago         1.22MB</span></span></code></pre></div><p>可以看到，镜像列表中多了一个<code>mybusybox</code>的镜像。但细心的同学可能已经发现，<code>busybox</code>和<code>mybusybox</code>这两个镜像的 IMAGE ID 是完全一样的。为什么呢？实际上它们指向了同一个镜像文件，只是别名不同而已。</p><p>如果我不需要<code>mybusybox</code>镜像了，想删除它，应该怎么操作呢？</p><h4 id="删除镜像" tabindex="-1">删除镜像 <a class="header-anchor" href="#删除镜像" aria-label="Permalink to &quot;删除镜像&quot;">​</a></h4><p>你可以使用<code>docker rmi</code>或者<code>docker image rm</code>命令删除镜像。</p><p>举例：你可以使用以下命令删除<code>mybusybox</code>镜像。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker rmi mybusybox</span></span>
<span class="line"><span style="color:#B392F0;">Untagged</span><span style="color:#E1E4E8;">: </span><span style="color:#B392F0;">mybusybox</span><span style="color:#E1E4E8;">:latest</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker rmi mybusybox</span></span>
<span class="line"><span style="color:#6F42C1;">Untagged</span><span style="color:#24292E;">: </span><span style="color:#6F42C1;">mybusybox</span><span style="color:#24292E;">:latest</span></span></code></pre></div><p>此时，再次使用<code>docker images</code>命令查看一下我们机器上的镜像列表。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker images</span></span>
<span class="line"><span style="color:#E1E4E8;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             latest              018c9d7b792b        </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> weeks ago         1.</span><span style="color:#FDAEB7;font-style:italic;">22MB</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker images</span></span>
<span class="line"><span style="color:#24292E;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#24292E;">busybox             latest              018c9d7b792b        </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> weeks ago         1.</span><span style="color:#B31D28;font-style:italic;">22MB</span></span></code></pre></div><p>通过上面的输出，我们可以看到，<code>mybusybox</code>镜像已经被删除。</p><p>如果你想构建属于自己的镜像，应该怎么做呢？</p><h4 id="构建镜像" tabindex="-1">构建镜像 <a class="header-anchor" href="#构建镜像" aria-label="Permalink to &quot;构建镜像&quot;">​</a></h4><p>构建镜像主要有两种方式：</p><ol><li><p>使用<code>docker commit</code>命令从运行中的容器提交为镜像；</p></li><li><p>使用<code>docker build</code>命令从 Dockerfile 构建镜像。</p></li></ol><p>首先介绍下如何从运行中的容器提交为镜像。我依旧使用 busybox 镜像举例，使用以下命令创建一个名为 busybox 的容器并进入 busybox 容器。</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker run </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">rm </span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">name</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">busybox </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">it busybox sh</span></span>
<span class="line"><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> #</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker run </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">rm </span><span style="color:#D73A49;">--</span><span style="color:#24292E;">name</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">busybox </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">it busybox sh</span></span>
<span class="line"><span style="color:#D73A49;">/</span><span style="color:#24292E;"> #</span></span></code></pre></div><p>执行完上面的命令后，当前窗口会启动一个 busybox 容器并且进入容器中。在容器中，执行以下命令创建一个文件并写入内容：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> # touch hello.txt </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> echo </span><span style="color:#9ECBFF;">&quot;I love Docker. &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> hello.txt</span></span>
<span class="line"><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> #</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">/</span><span style="color:#24292E;"> # touch hello.txt </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> echo </span><span style="color:#032F62;">&quot;I love Docker. &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> hello.txt</span></span>
<span class="line"><span style="color:#D73A49;">/</span><span style="color:#24292E;"> #</span></span></code></pre></div><p>此时在容器的根目录下，已经创建了一个 hello.txt 文件，并写入了 &quot;I love Docker. &quot;。下面，我们新打开另一个命令行窗口，运行以下命令提交镜像：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker commit busybox busybox:hello</span></span>
<span class="line"><span style="color:#E1E4E8;">sha256:cbc6406aaef080d1dd3087d4ea1e6c6c9915ee0ee0f5dd9e0a90b03e2215e81c</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker commit busybox busybox:hello</span></span>
<span class="line"><span style="color:#24292E;">sha256:cbc6406aaef080d1dd3087d4ea1e6c6c9915ee0ee0f5dd9e0a90b03e2215e81c</span></span></code></pre></div><p>然后使用上面讲到的<code>docker image ls</code>命令查看镜像：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ docker image ls busybox</span></span>
<span class="line"><span style="color:#E1E4E8;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             hello               cbc6406aaef0        </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> minutes ago       1.</span><span style="color:#FDAEB7;font-style:italic;">22MB</span></span>
<span class="line"><span style="color:#E1E4E8;">busybox             latest              018c9d7b792b        </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> weeks ago         1.</span><span style="color:#FDAEB7;font-style:italic;">22MB</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ docker image ls busybox</span></span>
<span class="line"><span style="color:#24292E;">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span></span>
<span class="line"><span style="color:#24292E;">busybox             hello               cbc6406aaef0        </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> minutes ago       1.</span><span style="color:#B31D28;font-style:italic;">22MB</span></span>
<span class="line"><span style="color:#24292E;">busybox             latest              018c9d7b792b        </span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> weeks ago         1.</span><span style="color:#B31D28;font-style:italic;">22MB</span></span></code></pre></div><p>此时我们可以看到主机上新生成了 busybox:hello 这个镜像。</p><p>第二种方式是最重要也是最常用的镜像构建方式：Dockerfile。Dockerfile 是一个包含了用户所有构建命令的文本。通过<code>docker build</code>命令可以从 Dockerfile 生成镜像。</p><p>使用 Dockerfile 构建镜像具有以下特性：</p><ul><li><p>Dockerfile 的每一行命令都会生成一个独立的镜像层，并且拥有唯一的 ID；</p></li><li><p>Dockerfile 的命令是完全透明的，通过查看 Dockerfile 的内容，就可以知道镜像是如何一步步构建的；</p></li><li><p>Dockerfile 是纯文本的，方便跟随代码一起存放在代码仓库并做版本管理。</p></li></ul><p>看到使用 Dockerfile 的方式构建镜像有这么多好的特性，你是不是已经迫不及待想知道如何使用了。别着急，我们先学习下 Dockerfile 常用的指令。</p><table><thead><tr><th>Dockerfile 指令</th><th>指令简介</th></tr></thead><tbody><tr><td>FROM</td><td>Dockerfile 除了注释第一行必须是 FROM ，FROM 后面跟镜像名称，代表我们要基于哪个基础镜像构建我们的容器。</td></tr><tr><td>RUN</td><td>RUN 后面跟一个具体的命令，类似于 Linux 命令行执行命令。</td></tr><tr><td>ADD</td><td>拷贝本机文件或者远程文件到镜像内</td></tr><tr><td>COPY</td><td>拷贝本机文件到镜像内</td></tr><tr><td>USER</td><td>指定容器启动的用户</td></tr><tr><td>ENTRYPOINT</td><td>容器的启动命令</td></tr><tr><td>CMD</td><td>CMD 为 ENTRYPOINT 指令提供默认参数，也可以单独使用 CMD 指定容器启动参数</td></tr><tr><td>ENV</td><td>指定容器运行时的环境变量，格式为 key=value</td></tr><tr><td>ARG</td><td>定义外部变量，构建镜像时可以使用 build-arg = 的格式传递参数用于构建</td></tr><tr><td>EXPOSE</td><td>指定容器监听的端口，格式为 [port]/tcp 或者 [port]/udp</td></tr><tr><td>WORKDIR</td><td>为 Dockerfile 中跟在其后的所有 RUN、CMD、ENTRYPOINT、COPY 和 ADD 命令设置工作目录。</td></tr></tbody></table><p>看了这么多指令，感觉有点懵？别担心，我通过一个实例让你来熟悉它们。这是一个 Dockerfile：</p><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> centos:7</span></span>
<span class="line"><span style="color:#F97583;">COPY</span><span style="color:#E1E4E8;"> nginx.repo /etc/yum.repos.d/nginx.repo</span></span>
<span class="line"><span style="color:#F97583;">RUN</span><span style="color:#E1E4E8;"> yum install -y nginx</span></span>
<span class="line"><span style="color:#F97583;">EXPOSE</span><span style="color:#E1E4E8;"> 80</span></span>
<span class="line"><span style="color:#F97583;">ENV</span><span style="color:#E1E4E8;"> HOST=mynginx</span></span>
<span class="line"><span style="color:#F97583;">CMD</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;nginx&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;-g&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;daemon off;&quot;</span><span style="color:#E1E4E8;">]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> centos:7</span></span>
<span class="line"><span style="color:#D73A49;">COPY</span><span style="color:#24292E;"> nginx.repo /etc/yum.repos.d/nginx.repo</span></span>
<span class="line"><span style="color:#D73A49;">RUN</span><span style="color:#24292E;"> yum install -y nginx</span></span>
<span class="line"><span style="color:#D73A49;">EXPOSE</span><span style="color:#24292E;"> 80</span></span>
<span class="line"><span style="color:#D73A49;">ENV</span><span style="color:#24292E;"> HOST=mynginx</span></span>
<span class="line"><span style="color:#D73A49;">CMD</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;nginx&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;-g&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;daemon off;&quot;</span><span style="color:#24292E;">]</span></span></code></pre></div><p>好，我来逐行分析一下上述的 Dockerfile。</p><ul><li><p>第一行表示我要基于 centos:7 这个镜像来构建自定义镜像。这里需要注意，每个 Dockerfile 的第一行除了注释都必须以 FROM 开头。</p></li><li><p>第二行表示拷贝本地文件 nginx.repo 文件到容器内的 /etc/yum.repos.d 目录下。这里拷贝 nginx.repo 文件是为了添加 nginx 的安装源。</p></li><li><p>第三行表示在容器内运行<code>yum install -y nginx</code>命令，安装 nginx 服务到容器内，执行完第三行命令，容器内的 nginx 已经安装完成。</p></li><li><p>第四行声明容器内业务（nginx）使用 80 端口对外提供服务。</p></li><li><p>第五行定义容器启动时的环境变量 HOST=mynginx，容器启动后可以获取到环境变量 HOST 的值为 mynginx。</p></li><li><p>第六行定义容器的启动命令，命令格式为 json 数组。这里设置了容器的启动命令为 nginx ，并且添加了 nginx 的启动参数 -g &#39;daemon off;&#39; ，使得 nginx 以前台的方式启动。</p></li></ul><p>上面这个 Dockerfile 的例子基本涵盖了常用的镜像构建指令，代码我已经放在 <a href="https://github.com/wilhelmguo/docker-demo/tree/master/dockerfiles" target="_blank" rel="noreferrer">GitHub</a>上，如果你感兴趣可以到 <a href="https://github.com/wilhelmguo/docker-demo/tree/master/dockerfiles" target="_blank" rel="noreferrer">GitHub 下载源码</a>并尝试构建这个镜像。</p><p>学习了镜像的各种操作，下面我们深入了解一下镜像的实现原理。</p><h3 id="镜像的实现原理" tabindex="-1">镜像的实现原理 <a class="header-anchor" href="#镜像的实现原理" aria-label="Permalink to &quot;镜像的实现原理&quot;">​</a></h3><p>其实 Docker 镜像是由一系列镜像层（layer）组成的，每一层代表了镜像构建过程中的一次提交。下面以一个镜像构建的 Dockerfile 来说明镜像是如何分层的。</p><div class="language-dockerfile vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dockerfile</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">FROM</span><span style="color:#E1E4E8;"> busybox</span></span>
<span class="line"><span style="color:#F97583;">COPY</span><span style="color:#E1E4E8;"> test /tmp/test</span></span>
<span class="line"><span style="color:#F97583;">RUN</span><span style="color:#E1E4E8;"> mkdir /tmp/testdir</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">FROM</span><span style="color:#24292E;"> busybox</span></span>
<span class="line"><span style="color:#D73A49;">COPY</span><span style="color:#24292E;"> test /tmp/test</span></span>
<span class="line"><span style="color:#D73A49;">RUN</span><span style="color:#24292E;"> mkdir /tmp/testdir</span></span></code></pre></div><p>上面的 Dockerfile 由三步组成：</p><p>第一行基于 busybox 创建一个镜像层；</p><p>第二行拷贝本机 test 文件到镜像内；</p><p>第三行在 /tmp 文件夹下创建一个目录 testdir。</p><p>为了验证镜像的存储结构，我们使用<code>docker build</code>命令在上面 Dockerfile 所在目录构建一个镜像：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">docker</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">build</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">-t</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">mybusybox</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">.</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">$</span><span style="color:#24292E;"> </span><span style="color:#032F62;">docker</span><span style="color:#24292E;"> </span><span style="color:#032F62;">build</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">-t</span><span style="color:#24292E;"> </span><span style="color:#032F62;">mybusybox</span><span style="color:#24292E;"> </span><span style="color:#032F62;">.</span></span></code></pre></div><p>这里我的 Docker 使用的是 overlay2 文件驱动，进入到<code>/var/lib/docker/overlay2</code>目录下使用<code>tree .</code>命令查看产生的镜像文件：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki github-dark has-diff vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ tree .</span></span>
<span class="line"><span style="color:#E1E4E8;"># 以下为 tree . 命令输出内容</span></span>
<span class="line"><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> 3e89b959f921227acab94f5ab4524252ae0a829ff8a3687178e3aca56d605679</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> diff  # 这一层为基础层，对应上述 </span><span style="color:#79B8FF;">Dockerfile</span><span style="color:#E1E4E8;"> 第一行，包含 busybox 镜像所有文件内容，例如 </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">etc,</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">bin,</span><span style="color:#F97583;">/var</span><span style="color:#E1E4E8;"> 等目录</span></span>
<span class="line"><span style="color:#E1E4E8;">... 此次省略部分原始镜像文件内容</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> link </span></span>
<span class="line"><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> 6591d4e47eb2488e6297a0a07a2439f550cdb22845b6d2ddb1be2466ae7a9391</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> diff   # 这一层对应上述 </span><span style="color:#79B8FF;">Dockerfile</span><span style="color:#E1E4E8;"> 第二行，拷贝 test 文件到 </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">tmp 文件夹下，因此 diff 文件夹下有了 </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">tmp</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">test 文件</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> tmp</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">       \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> test</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> link</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> lower</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> work</span></span>
<span class="line"><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> backingFsBlockDev</span></span>
<span class="line"><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> bec6a018080f7b808565728dee8447b9e86b3093b16ad5e6a1ac3976528a8bb1</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> diff  # 这一层对应上述 </span><span style="color:#79B8FF;">Dockerfile</span><span style="color:#E1E4E8;"> 第三行，在 </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">tmp 文件夹下创建 testdir 文件夹，因此 diff 文件夹下有了 </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">tmp</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">testdir 文件夹</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> tmp</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">       \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> testdir</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> link</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">|--</span><span style="color:#E1E4E8;"> lower</span></span>
<span class="line"><span style="color:#F97583;">|</span><span style="color:#E1E4E8;">   \`</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;"> work</span></span>
<span class="line"><span style="color:#E1E4E8;">...</span></span></code></pre><pre class="shiki github-light has-diff vp-code-light"><code><span class="line"><span style="color:#24292E;">$ tree .</span></span>
<span class="line"><span style="color:#24292E;"># 以下为 tree . 命令输出内容</span></span>
<span class="line"><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> 3e89b959f921227acab94f5ab4524252ae0a829ff8a3687178e3aca56d605679</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> diff  # 这一层为基础层，对应上述 </span><span style="color:#005CC5;">Dockerfile</span><span style="color:#24292E;"> 第一行，包含 busybox 镜像所有文件内容，例如 </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">etc,</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">bin,</span><span style="color:#D73A49;">/var</span><span style="color:#24292E;"> 等目录</span></span>
<span class="line"><span style="color:#24292E;">... 此次省略部分原始镜像文件内容</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> link </span></span>
<span class="line"><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> 6591d4e47eb2488e6297a0a07a2439f550cdb22845b6d2ddb1be2466ae7a9391</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> diff   # 这一层对应上述 </span><span style="color:#005CC5;">Dockerfile</span><span style="color:#24292E;"> 第二行，拷贝 test 文件到 </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">tmp 文件夹下，因此 diff 文件夹下有了 </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">tmp</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">test 文件</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">   \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> tmp</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">       \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> test</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> link</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> lower</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> work</span></span>
<span class="line"><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> backingFsBlockDev</span></span>
<span class="line"><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> bec6a018080f7b808565728dee8447b9e86b3093b16ad5e6a1ac3976528a8bb1</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> diff  # 这一层对应上述 </span><span style="color:#005CC5;">Dockerfile</span><span style="color:#24292E;"> 第三行，在 </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">tmp 文件夹下创建 testdir 文件夹，因此 diff 文件夹下有了 </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">tmp</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">testdir 文件夹</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">   \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> tmp</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|</span><span style="color:#24292E;">       \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> testdir</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> link</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   </span><span style="color:#D73A49;">|--</span><span style="color:#24292E;"> lower</span></span>
<span class="line"><span style="color:#D73A49;">|</span><span style="color:#24292E;">   \`</span><span style="color:#D73A49;">--</span><span style="color:#24292E;"> work</span></span>
<span class="line"><span style="color:#24292E;">...</span></span></code></pre></div><p>通过上面的目录结构可以看到，Dockerfile 的每一行命令，都生成了一个镜像层，每一层的 diff 夹下只存放了增量数据，如图 2 所示。</p>`,71),g=p('<p>图 2 镜像文件系统</p><p>分层的结构使得 Docker 镜像非常轻量，每一层根据镜像的内容都有一个唯一的 ID 值，当不同的镜像之间有相同的镜像层时，便可以实现不同的镜像之间共享镜像层的效果。</p><p>总结一下， Docker 镜像是静态的分层管理的文件组合，镜像底层的实现依赖于联合文件系统（UnionFS）。充分掌握镜像的原理，可以帮助我们在生产实践中构建出最优的镜像，同时也可以帮助我们更好地理解容器和镜像的关系。</p><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>到此，相信你已经对 Docker 镜像这一核心概念有了较深的了解，并熟悉了 Docker 镜像的常用操作（拉取、查看、&quot;重命名&quot;、删除和构建自定义镜像）及底层实现原理。</p><p>本课时内容精华，我帮你总结如下：</p><blockquote><p>镜像操作命令：</p><ol><li><p>拉取镜像，使用 docker pull 命令拉取远程仓库的镜像到本地 ；</p></li><li><p>重命名镜像，使用 docker tag 命令&quot;重命名&quot;镜像 ；</p></li><li><p>查看镜像，使用 docker image ls 或 docker images 命令查看本地已经存在的镜像；</p></li><li><p>删除镜像，使用 docker rmi 命令删除无用镜像 ；</p></li><li><p>构建镜像，构建镜像有两种方式。第一种方式是使用 docker build 命令基于 Dockerfile 构建镜像，也是我比较推荐的镜像构建方式；第二种方式是使用 docker commit 命令基于已经运行的容器提交为镜像。</p></li></ol><p>镜像的实现原理：</p><p>镜像是由一系列的镜像层（layer ）组成，每一层代表了镜像构建过程中的一次提交，当我们需要修改镜像内的某个文件时，只需要在当前镜像层的基础上新建一个镜像层，并且只存放修改过的文件内容。分层结构使得镜像间共享镜像层变得非常简单和方便。</p></blockquote><p>最后试想下，如果有一天我们机器存储空间不足，那你知道使用什么命令可以清理本地无用的镜像和容器文件吗？思考后，可以把你的想法写在留言区。</p><p><a href="https://github.com/wilhelmguo/docker-demo/tree/master/dockerfiles" target="_blank" rel="noreferrer">点击即可查看本课时相关源码</a></p>',9);function k(h,D,m,F,f,A){const n=e("Image");return c(),t("div",null,[y,i,E,d,b,l(n,{alt:"Lark20200904-175130.png",src:"https://s0.lgstatic.com/i/image/M00/4A/AD/CgqCHl9SDkWAaxh7AAFaMgWI7cI029.png"}),a(),u,l(n,{alt:"Lark20200904-175137.png",src:"https://s0.lgstatic.com/i/image/M00/4A/AD/CgqCHl9SDmGACBEjAABkgtnn_hE625.png"}),a(),g])}const C=o(r,[["render",k]]);export{x as __pageData,C as default};
