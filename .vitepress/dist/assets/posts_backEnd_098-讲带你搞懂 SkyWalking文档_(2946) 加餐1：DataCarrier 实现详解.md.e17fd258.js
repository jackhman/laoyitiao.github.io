import{_ as o,j as e,o as t,g as r,k as a,s,Q as l,h as p}from"./chunks/framework.e0c66c3f.js";const V=JSON.parse('{"title":"Buffer 核心原理 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2946) 加餐1：DataCarrier 实现详解.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2946) 加餐1：DataCarrier 实现详解.md","lastUpdated":1696338709000}'),c={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(2946) 加餐1：DataCarrier 实现详解.md"},E=s("p",null,"在开始介绍 Trace 相关 BootService 实现以及 Trace 数据的收集和发送之前，我们需要了解另一个关键的组件 ------ DataCarrier 。DataCarrier 是一个轻量级的生产者-消费者模式的实现库， SkyWalking Agent 在收集到 Trace 数据之后，会先写入到 DataCarrier 中的缓存，然后由后台线程定时发送到后端的 OAP。其实，在多数涉及网络传输的场景中都会使用这种设计：先在本地缓存数据，然后聚合，最后定时批量发送。",-1),y=s("p",null,"DataCarrier 之前是一个单独的项目，现在并入 SkyWalking 之中作为一个独立的子模块存在，具体位置如下图所示：",-1),i=l(`<h4 id="buffer-核心原理" tabindex="-1">Buffer 核心原理 <a class="header-anchor" href="#buffer-核心原理" aria-label="Permalink to &quot;Buffer 核心原理&quot;">​</a></h4><p>DataCarrier 底层使用多个定长数组作为存储缓冲区，即 apm-datacarrier 模块中的 Buffer 类，其底层的 buffer 字段（Object[] 类型）是真正存储数据的地方。每个 Buffer 内部维护了一个环形指针（AtomicRangeInteger 类型），我们可以指定其中的 value 字段（AtomicInteger 类型）从 start 值开始递增，当 value 递增到 end 值（int 类型）时，value 字段会被重置为 start 值，实现环形指针的效果，这样，Buffer 就可以实现循环覆盖写入的模式了。</p><p>需要注意的是，AtomicRangeInteger 环形指针底层是基于乐观锁实现的，这样就能够解决并发问题。AtomicRangeInteger 的核心方法 getAndIncrement() 实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getAndIncrement</span><span style="color:#E1E4E8;">() { </span><span style="color:#6A737D;">//  典型的基于乐观锁的环形指针实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">do</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.value.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> endValue </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.value.</span><span style="color:#B392F0;">compareAndSet</span><span style="color:#E1E4E8;">(next, startValue)) { </span><span style="color:#6A737D;">// CAS操作</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> endValue;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> endValue);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> next </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getAndIncrement</span><span style="color:#24292E;">() { </span><span style="color:#6A737D;">//  典型的基于乐观锁的环形指针实现</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">do</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (next </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> endValue </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">              </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value.</span><span style="color:#6F42C1;">compareAndSet</span><span style="color:#24292E;">(next, startValue)) { </span><span style="color:#6A737D;">// CAS操作</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> endValue;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (next </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> endValue);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> next </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Buffer 可以指定下面三种写入策略，这些策略只在 Buffer 写满的情况下才生效：</p><ul><li><strong>BLOCKING 策略</strong>（默认）：写入线程阻塞等待，直到 Buffer 有空闲空间为止。如果选择了 BLOCKING 策略，我们可以向 Buffer 中注册 Callback 回调，当发生阻塞时 Callback 会收到相应的事件。</li><li><strong>OVERRIDE 策略</strong>：覆盖旧数据，会导致缓存在 Buffer 中的旧数据丢失。</li><li><strong>IF_POSSIBLE 策略</strong>：如果无法写入则直接返回 false，由上层应用判断如何处理。</li></ul><p>Buffer 提供了读写底层 Objec[] 数组的相关方法，其中 save() 方法负责向底层数组中填充数据，实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(T data) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// AtomicRangeInteger已经处理了并发问题，这里i对应的位置只有当前线程操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> index.</span><span style="color:#B392F0;">getAndIncrement</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果当前位置空闲，可以直接填充即可，否则需要按照策略进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (buffer[i] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (strategy) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> BLOCKING</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// BLOCKING策略</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isFirstTimeBlocking </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (buffer[i] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span><span style="color:#6A737D;">// 自旋等待下标为i的位置被释放</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (isFirstTimeBlocking) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 阻塞当前线程，并通知所有Callback</span></span>
<span class="line"><span style="color:#E1E4E8;">                        isFirstTimeBlocking </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (QueueBlockingCallback&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; callback </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">                              callbacks) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                            callback.</span><span style="color:#B392F0;">notify</span><span style="color:#E1E4E8;">(data);</span></span>
<span class="line"><span style="color:#E1E4E8;">                        }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1L</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// sleep</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> IF_POSSIBLE</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// IF_POSSIBLE策略直接返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> OVERRIDE</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// OVERRIDE策略直接走下面的赋值逻辑，覆盖旧数据</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">default:</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    buffer[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> data; </span><span style="color:#6A737D;">// 向下标为i的位置填充数据</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(T data) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// AtomicRangeInteger已经处理了并发问题，这里i对应的位置只有当前线程操作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> index.</span><span style="color:#6F42C1;">getAndIncrement</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果当前位置空闲，可以直接填充即可，否则需要按照策略进行处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (buffer[i] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (strategy) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> BLOCKING</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// BLOCKING策略</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isFirstTimeBlocking </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (buffer[i] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span><span style="color:#6A737D;">// 自旋等待下标为i的位置被释放</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (isFirstTimeBlocking) {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 阻塞当前线程，并通知所有Callback</span></span>
<span class="line"><span style="color:#24292E;">                        isFirstTimeBlocking </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (QueueBlockingCallback&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; callback </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">                              callbacks) {</span></span>
<span class="line"><span style="color:#24292E;">                            callback.</span><span style="color:#6F42C1;">notify</span><span style="color:#24292E;">(data);</span></span>
<span class="line"><span style="color:#24292E;">                        }</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                    Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1L</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// sleep</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> IF_POSSIBLE</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// IF_POSSIBLE策略直接返回false</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> OVERRIDE</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// OVERRIDE策略直接走下面的赋值逻辑，覆盖旧数据</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">default:</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    buffer[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> data; </span><span style="color:#6A737D;">// 向下标为i的位置填充数据</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>obtain() 方法提供了一次性读取（并清理） Buffer 中全部数据的功能，同时也提供了部分读取的重载，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> LinkedList</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">obtain</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> start, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> end) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedList&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedList&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 start~end 之间的元素返回，消费者消费这个result集合就行了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> end; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (buffer[i] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            result.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">((T)buffer[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">            buffer[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> LinkedList</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">obtain</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> start, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> end) {</span></span>
<span class="line"><span style="color:#24292E;">    LinkedList&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedList&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 start~end 之间的元素返回，消费者消费这个result集合就行了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> end; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (buffer[i] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            result.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">((T)buffer[i]);</span></span>
<span class="line"><span style="color:#24292E;">            buffer[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p><strong>思考题</strong></p><p>假设在 Buffer 写满的情况下，两个线程同时调用 save() 方法写入同一个位置时，会出现什么问题？我们应该如何解决呢？</p></blockquote><h4 id="channels" tabindex="-1">Channels <a class="header-anchor" href="#channels" aria-label="Permalink to &quot;Channels&quot;">​</a></h4><p>Channels 底层管理了多个 Buffer 对象，提供了 IDataPartitioner 选择器用于确定一个数据元素写入到底层的哪个 Buffer 对象中。如果你了解 Kafka 可能知道，Kafka Producer 在发送数据时也会有相应的分区策略，IDataPartitioner 与之类似。当数据并行写入的时候，由 IDataPartitioner 选择器根据一定的均衡策略将数据分散到不同的 Buffer 中写入，这样就可以有效减少并发导致的自旋锁等待时间，降低整个 Channels 的写入压力，提高写入效率。IDataPartitioner 接口有两个实现，如下图所示：</p>`,13),u=l("<ul><li><strong>ProducerThreadPartitioner</strong> 会根据写入的 Thread ID 进行分发，这样可以保证相同线程写入的数据都在一个 Buffer 中。</li><li><strong>SimpleRollingPartitioner</strong> 简单循环自增选择器，使用无锁整型（volatile 修饰）的自增并取模，选择要写入的 Buffer 。当然，在高负载时会产生批量连续写入一个 Buffer 的情况，但在中低负载情况下，可以很好的避免不同线程写入数据量不均衡的问题，从而提供较好性能。</li></ul><p>在初始化 Channels 时，有两个特殊的参数需要进行说明：</p><ul><li><strong>channelSize 参数</strong>：指定 Channels 底层 Buffer 的数量，合理的 Buffer 数量搭配合理的分区选择器，可以让整个 Channels 写入无竞争或很少出现竞争。</li><li><strong>bufferSize</strong>：指定每个 Buffer 的大小，合理的 Buffer 大小可以在满足缓冲能力的同时占用合理的内存大小。</li></ul><p>下图展示了 bufferSize 、channelSize 参数与 Channels之间的关系：</p>",4),d=l(`<h4 id="datacarrier-消费者" tabindex="-1">DataCarrier 消费者 <a class="header-anchor" href="#datacarrier-消费者" aria-label="Permalink to &quot;DataCarrier 消费者&quot;">​</a></h4><p>DataCarrier 没有为生产者定义特殊的接口，上层应用直接调用其 save() 方法即可完成写入。而 DataCarrier 消费者的具体行为都定义在 IConsumer 接口之中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IConsumer</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">init</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 初始化消费者</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">consume</span><span style="color:#E1E4E8;">(List&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 批量消费消息</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(List&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">data</span><span style="color:#E1E4E8;">, Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 处理消费过程中发生的异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onExit</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 消费结束时通过该方法关闭消费者，释放资源</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IConsumer</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">init</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 初始化消费者</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">consume</span><span style="color:#24292E;">(List&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">data</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 批量消费消息</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(List&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">data</span><span style="color:#24292E;">, Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 处理消费过程中发生的异常</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onExit</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 消费结束时通过该方法关闭消费者，释放资源</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ConsumerThread 是专门与 IConsumer 对象配合使用的消费线程，它继承 Thread ，并封装了一个 IConsumer 对象，每个 ConsumerThread 线程可以消费多个 DataSource，这里的 DataSource 是 Buffer 的一部分或是完整的 Buffer（DataSource 通过 start、end 字段标记当前 ConsumerThread 消费的 Buffer 区域）。下图展示了 ConsumerThread 的结构图：</p>`,4),C=l(`<p>这里的 ConsumerThread 1 线程同时消费了三个 Buffer，后面介绍 Driver 接口实现时会看到，一个 ConsumerThread 消费的 Buffer 都是来自同一个 Channels。如上图所示，ConsumerThread 1 线程会消费 Buffer 1 和 Buffer 2 中 1~3 这部分元素；同时也会消费 Buffer 3 中 2 ~ 5 这部分元素。ConsumerThread 2 线程只会消费Buffer 3 中 0 ~ 1 这部分元素。</p><p>在 run() 方法中，ConsumerThread 线程会定时循环遍历其负责的所有 Buffer 区域，一旦发现可消费的数据，就会调用 consume() 方法进行处理。ConsumerThread.consume() 方法的核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">consume</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> hasData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedList&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; consumeList </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> LinkedList&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (DataSource dataSource </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dataSources) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// DataSource.obtain()方法是对Buffer.obtain()方法的封装</span></span>
<span class="line"><span style="color:#E1E4E8;">        LinkedList&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> dataSource.</span><span style="color:#B392F0;">obtain</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (data.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">; }</span></span>
<span class="line"><span style="color:#E1E4E8;">        consumeList.</span><span style="color:#B392F0;">addAll</span><span style="color:#E1E4E8;">(data); </span><span style="color:#6A737D;">// 将待消费的数据转存到consumeList集合</span></span>
<span class="line"><span style="color:#E1E4E8;">        hasData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 标记此次消费是否有数据</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (consumeList.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 执行IConsumer.consume()方法中封装的消费逻辑处理消息</span></span>
<span class="line"><span style="color:#E1E4E8;">            consumer.</span><span style="color:#B392F0;">consume</span><span style="color:#E1E4E8;">(consumeList);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span><span style="color:#6A737D;">// 消费过程中出现异常的时候</span></span>
<span class="line"><span style="color:#E1E4E8;">            consumer.</span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(consumeList, t);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> hasData;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">consume</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> hasData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    LinkedList&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; consumeList </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> LinkedList&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (DataSource dataSource </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dataSources) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// DataSource.obtain()方法是对Buffer.obtain()方法的封装</span></span>
<span class="line"><span style="color:#24292E;">        LinkedList&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> dataSource.</span><span style="color:#6F42C1;">obtain</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (data.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">; }</span></span>
<span class="line"><span style="color:#24292E;">        consumeList.</span><span style="color:#6F42C1;">addAll</span><span style="color:#24292E;">(data); </span><span style="color:#6A737D;">// 将待消费的数据转存到consumeList集合</span></span>
<span class="line"><span style="color:#24292E;">        hasData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 标记此次消费是否有数据</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (consumeList.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 执行IConsumer.consume()方法中封装的消费逻辑处理消息</span></span>
<span class="line"><span style="color:#24292E;">            consumer.</span><span style="color:#6F42C1;">consume</span><span style="color:#24292E;">(consumeList);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span><span style="color:#6A737D;">// 消费过程中出现异常的时候</span></span>
<span class="line"><span style="color:#24292E;">            consumer.</span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(consumeList, t);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> hasData;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>使用 ConsumerThread 我们可以实现一个或多个消费线程处理同一个 Channels 的消费模式。MultipleChannelsConsumer 提供了另一种消费模式，与 ConsumerThread 的区别在于：MultipleChannelsConsumer 线程可以处理多组 Group，每个 Group 都是一个 IConsumer + 一个 Channels 的组合。</p>`,4),D=l(`<p>上图展示了 MultipleChannelsConsumer 的消费模型，MultipleChannelsConsumer 可以同时消费多个 Group，每个 Group 中的 IConsumer 对象包含了消费逻辑，Channels 对象包含了待消费的数据，需要注意的是，一旦 Channels 被添加到 MultipleChannelsConsumer 中，将会被一个 MultipleChannelsConsumer 完全消费，不会像 ConsumerThread 那样分区域部分消费。</p><p>在 run() 方法中，MultipleChannelsConsumer 线程会定时循环遍历其消费的全部 Group，一旦发现可消费的数据，就会循环调用 consume() 方法处理每个 Group。</p><p>MultipleChannelsConsumer.consume() 方法的核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">consume</span><span style="color:#E1E4E8;">(Group target) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> hasData;</span></span>
<span class="line"><span style="color:#E1E4E8;">    LinkedList consumeList </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LinkedList</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> target.channels.</span><span style="color:#B392F0;">getChannelSize</span><span style="color:#E1E4E8;">(); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Buffer buffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> target.channels.</span><span style="color:#B392F0;">getBuffer</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将该Group中Channels全部可消费的数据都导出到consumeList列表</span></span>
<span class="line"><span style="color:#E1E4E8;">        consumeList.</span><span style="color:#B392F0;">addAll</span><span style="color:#E1E4E8;">(buffer.</span><span style="color:#B392F0;">obtain</span><span style="color:#E1E4E8;">()); </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (hasData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> consumeList.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 通过该Group中相应的IConsumer消费数据</span></span>
<span class="line"><span style="color:#E1E4E8;">            target.consumer.</span><span style="color:#B392F0;">consume</span><span style="color:#E1E4E8;">(consumeList);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 消费过程的异常处理</span></span>
<span class="line"><span style="color:#E1E4E8;">            target.consumer.</span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(consumeList, t);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> hasData;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">consume</span><span style="color:#24292E;">(Group target) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> hasData;</span></span>
<span class="line"><span style="color:#24292E;">    LinkedList consumeList </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LinkedList</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> target.channels.</span><span style="color:#6F42C1;">getChannelSize</span><span style="color:#24292E;">(); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        Buffer buffer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> target.channels.</span><span style="color:#6F42C1;">getBuffer</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将该Group中Channels全部可消费的数据都导出到consumeList列表</span></span>
<span class="line"><span style="color:#24292E;">        consumeList.</span><span style="color:#6F42C1;">addAll</span><span style="color:#24292E;">(buffer.</span><span style="color:#6F42C1;">obtain</span><span style="color:#24292E;">()); </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (hasData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> consumeList.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 通过该Group中相应的IConsumer消费数据</span></span>
<span class="line"><span style="color:#24292E;">            target.consumer.</span><span style="color:#6F42C1;">consume</span><span style="color:#24292E;">(consumeList);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 消费过程的异常处理</span></span>
<span class="line"><span style="color:#24292E;">            target.consumer.</span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(consumeList, t);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> hasData;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>MultipleChannelsConsumer 底层通过一个 ArrayList 维护 Group 集合（consumeTargets 字段），MultipleChannelsConsumer 通过 Copy-on-Write 的方式保证线程安全，即在调用 addNewTarget() 方法向 consumeTargets 集合添加 Group 时，会创建一个新的 ArrayList 集合并拷贝原集合内容，然后向新集合中添加数据，待新集合添加完成之后，直接替换原有集合。之所以这样做是因为在添加的过程中，MultipleChannelsConsumer 线程可能正在循环处理 consumeTargets 集合，这也是 consumeTargets 用 volatile 修饰的原因。下图展示了添加 Group 的核心逻辑：</p>`,5),A=s("h4",{id:"idriver-实现剖析",tabindex:"-1"},[p("IDriver 实现剖析 "),s("a",{class:"header-anchor",href:"#idriver-实现剖析","aria-label":'Permalink to "IDriver 实现剖析"'},"​")],-1),F=s("p",null,"IDriver 接口会将前文介绍的 IConsumer 消费者以及 ConsumerThread 线程或 MultipleChannelsConsumer 线程按照一定的消费模式集成到一起，提供更加简单易用的 API。",-1),h=s("p",null,"IDriver 接口的继承关系如下图所示，其中依赖 ConsumerThread 的实现是 ConsumerDriver ，依赖 MultipleChannelsConsumer 的实现是 BulkConsumerPool ：",-1),g=l(`<p>在 IDriver 接口中定义了三个与消费线程生命周期相关方法：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IDriver</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">begin</span><span style="color:#E1E4E8;">(Channels </span><span style="color:#FFAB70;">channels</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 启动消费线程</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isRunning</span><span style="color:#E1E4E8;">(Channels </span><span style="color:#FFAB70;">channels</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 检测当前IDriver是否正在运行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(Channels </span><span style="color:#FFAB70;">channels</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 关闭消费线程</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IDriver</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">begin</span><span style="color:#24292E;">(Channels </span><span style="color:#E36209;">channels</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 启动消费线程</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isRunning</span><span style="color:#24292E;">(Channels </span><span style="color:#E36209;">channels</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 检测当前IDriver是否正在运行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(Channels </span><span style="color:#E36209;">channels</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 关闭消费线程</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 ConsumerDriver 实现中维护了固定数量的 ConsumerThread 线程（consumerThreads 字段，ConsumerThread[] 类型），它们共同消费一个 Channels 中的数据（channels 字段，Channels 类型）。</p><p>ConsumerDriver 的核心逻辑是在其 begin() 方法中，它会根据 Channels 中的 Buffer 数量以及ConsumerThread 线程数进行分配：</p><ul><li>如果 Buffer 个数较多，则一个 ConsumerThread 线程需要处理多个 Buffer。</li><li>如果 ConsumerThread 线程数较多，则一个 Buffer 会被划分为多个区域，由不同的 ConsumerThread 线程进行消费，也就是前文介绍的，每个 ConsumerThread 线程负责消费一个 Buffer 的一个区域。</li><li>如果两者数量正好相同，则是一对一的消费关系。</li></ul><p>消费的 Channels、ConsumerThread 线程数以及两者的绑定关系一旦确定，在整个 ConsumerDriver 的生命周期中不会再进行变更。</p><p>BulkConsumePool 是 IDriver 接口的另一个实现，在其 allConsumers 字段（List类型）中维护了当前启动的 MultipleChannelsConsumer 线程。BulkConsumePool 的核心实现在其 add() 方法，通过该方法向 BulkConsumePool 添加新 Channels 以及对应 IConsumer 时，会通过 getLowestPayload() 方法选择负载最低的 MultipleChannelsConsumer 线程进行处理（即当前处理 Group 最少的线程）。</p><h4 id="datacarrier" tabindex="-1">DataCarrier <a class="header-anchor" href="#datacarrier" aria-label="Permalink to &quot;DataCarrier&quot;">​</a></h4><p>DataCarrier 是整个 DataCarrier 模块最顶层的门面类，其中整合 Channels、IDriver 并给 Producer 提供了一个统一的入口。</p><p>在 DataCarrier 构造方法中会接收 channelSize、bufferSize 两个参数初始化 Channels ，默认使用 SimpleRollingPartitioner 分区选择器以及 BLOCKING 策略（同时，DataCarrier 提供了修改这两项配置的方法）。DataCarrier 为生产者提供了 produce() 方法（底层调用 Channels.save() 方法），统一写入数据的入口。</p><p>DataCarrier 最核心的是提供了多个 consume() 方法的重载，下图四个 consume() 方法重载底层是根据参数指定线程数以及轮训时间来新建 ConsumerDriver 实现消费能力的：</p>`,11),m=s("p",null,"下图的 consume() 方法重载则是依赖传入的 BulkConsumePool 实现数据消费能力的（注意，这里不会新建 BulkConsumePool）：",-1),f=s("p",null,"这里传入的 BulkConsumePool 对象一般统一维护在 ConsumerPoolFactory 中。ConsumerPoolFactory 是通过枚举方式实现的单例类，其底层维护了一个 Map<String, ConsumerPool> 集合，其中 Key 就是 BulkConsumePool 的名称，后面会看到大量通过名称在 ConsumerPoolFactory 中查找 BulkConsumePool 对象的场景。",-1),B=s("h4",{id:"总结",tabindex:"-1"},[p("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),_=s("p",null,"本课时主要介绍了 DataCarrier 这个轻量级的生产者-消费者模式的实现库，首先介绍了 DataCarrier 最底层的数据存储组件 Buffer 和 Channels 以及相关的填充策略，接下来深入分析了 DataCarrier 提供的消费者接口以及两种消费模型，最后介绍了 IDriver 接口和 DataCarrier 门面类提供的 API 实现。",-1);function b(v,T,k,I,L,S){const n=e("Image");return t(),r("div",null,[E,y,a(n,{alt:"sw1.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/D8/Cgq2xl6enDGAd7mqAAF-K97sPzE781.png"}),i,a(n,{alt:"sw2.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/D9/Cgq2xl6enRKAKlx5AAAlHmaDotA329.png"}),u,a(n,{alt:"sw3.png",src:"https://s0.lgstatic.com/i/image3/M01/05/95/CgoCgV6enVKAMtBMAABQyIHkIPs184.png"}),d,a(n,{alt:"sw4.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/DA/Cgq2xl6enYSAPp8SAADKo6QU_14981.png"}),C,a(n,{alt:"sw5.png",src:"https://s0.lgstatic.com/i/image3/M01/05/95/CgoCgV6eneaAei7OAACQCaME7Fk880.png"}),D,a(n,{alt:"sw6.png",src:"https://s0.lgstatic.com/i/image3/M01/8B/DA/Cgq2xl6enhKADPe-AAIoMSB90P4701.png"}),A,F,h,a(n,{alt:"sw7.png",src:"https://s0.lgstatic.com/i/image3/M01/05/95/CgoCgV6enimAbhHkAAIykJeqP-I840.png"}),g,a(n,{alt:"sw8.png",src:"https://s0.lgstatic.com/i/image3/M01/12/C5/Ciqah16enoiAAR34AABZQEoOOp8211.png"}),m,a(n,{alt:"sw9.png",src:"https://s0.lgstatic.com/i/image3/M01/05/96/CgoCgV6enpaAGX-EAAAccs9p1lw523.png"}),f,B,_])}const x=o(c,[["render",b]]);export{V as __pageData,x as default};
