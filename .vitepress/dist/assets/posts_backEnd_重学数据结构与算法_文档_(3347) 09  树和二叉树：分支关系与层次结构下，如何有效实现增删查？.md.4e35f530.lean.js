import{_ as o,j as e,o as t,g as c,k as l,h as n,s,Q as p}from"./chunks/framework.4e7d56ce.js";const os=JSON.parse('{"title":"09树和二叉树：分支关系与层次结构下，如何有效实现增删查？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学数据结构与算法_文档/(3347) 09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md","filePath":"posts/backEnd/重学数据结构与算法_文档/(3347) 09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/重学数据结构与算法_文档/(3347) 09  树和二叉树：分支关系与层次结构下，如何有效实现增删查？.md"},E=s("h1",{id:"_09树和二叉树-分支关系与层次结构下-如何有效实现增删查",tabindex:"-1"},[n("09树和二叉树：分支关系与层次结构下，如何有效实现增删查？ "),s("a",{class:"header-anchor",href:"#_09树和二叉树-分支关系与层次结构下-如何有效实现增删查","aria-label":'Permalink to "09树和二叉树：分支关系与层次结构下，如何有效实现增删查？"'},"​")],-1),i=s("p",null,"前面课时我们学习了线性表、栈、队列和数组。栈、队列都是特殊的线性表，数组可以看成是线性表的一种推广。根据学习，我们知道了这几种数据结构，在对数据的增删查操作上各有千秋。这一课时再来学习另一种从形式上看上去差异比较大的数据结构，树，以及如何用树和二叉树实现对数据的增删查的操作。",-1),y=s("h3",{id:"树是什么",tabindex:"-1"},[n("树是什么 "),s("a",{class:"header-anchor",href:"#树是什么","aria-label":'Permalink to "树是什么"'},"​")],-1),d=s("p",null,"树是由结点和边组成的，不存在环的一种数据结构。通过下图，我们就可以更直观的认识树的结构。",-1),u=s("p",null,"树满足递归定义的特性。也就是说，如果一个数据结构是树结构，那么剔除掉根结点后，得到的若干个子结构也是树，通常称作子树。",-1),_=s("p",null,"在一棵树中，根据结点之间层次关系的不同，对结点的称呼也有所不同。我们来看下面这棵树，如下图所示:",-1),h=s("ul",null,[s("li",null,[s("p",null,"A 结点是 B 结点和 C 结点的上级，则 A 就是 B 和 C 的父结点，B 和 C 是 A 的子结点。")]),s("li",null,[s("p",null,'B 和 C 同时是 A 的"孩子"，则可以称 B 和 C 互为兄弟结点。')]),s("li",null,[s("p",null,"A 没有父结点，则可以称 A 为根结点。")]),s("li",null,[s("p",null,"G、H、I、F 结点都没有子结点，则称 G、H、I、F 为叶子结点。")])],-1),F=s("p",null,'当有了一棵树之后，还需要用深度、层来描述这棵树中结点的位置。结点的层次从根结点算起，根为第一层，根的"孩子"为第二层，根的"孩子"的"孩子"为第三层，依此类推。树中结点的最大层次数，就是这棵树的树深（称为深度，也称为高度）。如下图所示，就是一棵深度为 4 的树。',-1),A=s("h3",{id:"二叉树是什么",tabindex:"-1"},[n("二叉树是什么 "),s("a",{class:"header-anchor",href:"#二叉树是什么","aria-label":'Permalink to "二叉树是什么"'},"​")],-1),g=s("p",null,"在树的大家族中，有一种被高频使用的特殊树，它就是二叉树。在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。",-1),C=s("p",null,"在二叉树中，有下面两个特殊的类型，如下图所示：",-1),m=s("ul",null,[s("li",null,[s("p",null,"满二叉树，定义为只有最后一层无任何子结点，其他所有层上的所有结点都有两个子结点的二叉树。")]),s("li",null,[s("p",null,"完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。")])],-1),D=s("p",null,"你可能会困惑，完全二叉树看上去并不完全，但为什么这样称呼它呢？这其实和二叉树的存储有关系。存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。",-1),q=s("ul",null,[s("li",null,"链式存储法，也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针，如下图所示：")],-1),f=s("ul",null,[s("li",null,"顺序存储法，就是按照规律把结点存放在数组里，如下图所示，为了方便计算，我们会约定把根结点放在下标为 1 的位置。随后，B 结点存放在下标为 2 的位置，C 结点存放在下标为 3 的位置，依次类推。")],-1),T=s("p",null,"根据这种存储方法，我们可以发现如果结点 X 的下标为 i，那么 X 的左子结点总是存放在 2 * i 的位置，X 的右子结点总是存放在 2 * i + 1 的位置。",-1),v=s("p",null,"之所以称为完全二叉树，是从存储空间利用效率的视角来看的。对于一棵完全二叉树而言，仅仅浪费了下标为 0 的存储位置。而如果是一棵非完全二叉树，则会浪费大量的存储空间。",-1),B=s("p",null,"我们来看如下图所示的非完全二叉树，它既需要保留出 5 和 6 的位置。同时，还需要保留 5 的两个子结点 10 和 11 的位置，以及 6 的两个子结点 12 和 13 的位置。这样的二叉树，没有完全利用好数组的存储空间。",-1),b=p("",6),O=p("",7),V=p("",9),k=s("p",null,"二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。",-1),S=s("p",null,"二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。我们分为下面三种情况讨论。",-1),N=s("ul",null,[s("li",null,"情况一，如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。")],-1),P=s("ul",null,[s("li",null,"情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。")],-1),M=s("ul",null,[s("li",null,"情况三，如果要删除的结点有两个子结点，则有两种可行的操作方式。")],-1),I=s("p",null,"第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。",-1),x=s("p",null,"第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。",-1),H=s("p",null,[s("strong",null,"树的案例")],-1),L=s("p",null,[s("strong",null,"我们来看一道例题:")],-1),X=s("p",null,"输入一个字符串，判断它在已有的字符串集合中是否出现过?（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）如，已有字符串集合包含 6 个字符串分别为，cat, car, city, dog,door, deep。输入 cat，输出 true；输入 home，输出 false。",-1),R=s("p",null,"我们假设采用最暴力的办法，估算一下时间复杂度。假设字符串集合包含了 n 个字符串，其中的字符串平均长度为 m。那么新来的一个字符串，需要与每个字符串的每个字符进行匹配。则时间复杂度为 O(nm)。",-1),j=s("p",null,'但在 nm 的复杂度中，显然存在很多的无效匹配。例如，输入 home 时，6 个字符串都没有 h 开头的，则不需要进行后续的匹配。因此，如果可以通过对字符前缀进行处理，就可以最大限度地减少无谓的字符串比较，从而提高查询效率。这就是"用空间换时间"的思想，再利用共同前缀来提高查询效率。',-1),Q=s("p",null,"其实，这个问题利用树结构也可以完成。我们对字符串建立一个的树结构，如下图所示，它将字符串集合的前缀进行合并，每个根结点到叶子结点的链条就是一个字符串。",-1),Y=p("",4),w=s("h3",{id:"总结",tabindex:"-1"},[n("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),G=s("p",null,"本课时的内容围绕着不同种类树的原理、二叉树对于数据的增删查操作展开。要想利用二叉树实现增删查操作，你需要熟练掌握二叉树的三种遍历方式。遍历的时间复杂度是 O(n)。有了遍历方式之后，你可以完成在指定位置的数据增删操作。增删操作的时间复杂度都是 O(1)。",-1),K=s("p",null,'对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是 O(n)。如果是二叉查找树，则可以在 O(logn) 的时间复杂度内完成查找动作。树结构在存在"一对多"的数据关系中，可被高频使用，这也是它区别于链表系列数据结构的关键点。',-1),Z=s("h3",{id:"练习题",tabindex:"-1"},[n("练习题 "),s("a",{class:"header-anchor",href:"#练习题","aria-label":'Permalink to "练习题"'},"​")],-1),z=s("p",null,"关于树结构，我们留一道习题。给定一棵树，按照层次顺序遍历并打印这棵树。例如:",-1),J=p("",4);function $(U,W,ss,ns,as,ls){const a=e("Image");return t(),c("div",null,[E,i,y,d,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVdOACaCRAAFIFEOq3NE138.png"}),n(),u,_,h,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D5/Ciqc1F7nVeCAYb0BAAChbrfNgQQ166.png"}),n(),F,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D5/Ciqc1F7nVfiAHZTqAAC7ANRZP1Q581.png"}),n(),A,g,C,m,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D5/Ciqc1F7nVgiAaAzDAACeT1A4his243.png"}),n(),D,q,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVhKAJVYKAABbMx2OS5o954.png"}),n(),f,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVhyAF-yqAAFEIfF2-z4697.png"}),n(),T,v,B,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D5/Ciqc1F7nVi2AVfUZAAFA7ZImLgI310.png"}),n(),b,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D5/Ciqc1F7nVj-AAdDtAAELYCm71vU805.png"}),n(),O,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVlCAP5SrAACStyOKMQk846.png"}),n(),V,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVl2AGCqGAAXB0pVx-_0832.gif"}),n(),k,S,N,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVm-AdApcAAgmVCpx8jY016.gif"}),n(),P,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVn6ACTNEAAmR8p1hP4E398.gif"}),n(),M,I,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D6/Ciqc1F7nVpCAYOHzAA5XF5kRkGM004.gif"}),n(),x,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/20/39/CgqCHl7oQIGAYpwKABBpD6_zh_c805.gif"}),n(),H,L,X,R,j,Q,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/E1/CgqCHl7nVuSASW8lAADCDPk2Zv0987.png"}),n(),Y,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D7/Ciqc1F7nWKeAJpLCABmfZlb-Jaw490.gif"}),n(),w,G,K,Z,z,l(a,{alt:"image",src:"https://s0.lgstatic.com/i/image/M00/1F/D7/Ciqc1F7nWLqAXKf2AACTorL2-YQ429.png"}),n(),J])}const es=o(r,[["render",$]]);export{os as __pageData,es as default};
