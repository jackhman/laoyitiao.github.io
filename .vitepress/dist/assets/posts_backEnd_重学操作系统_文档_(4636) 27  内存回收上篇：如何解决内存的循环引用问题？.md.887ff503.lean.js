import{_ as l,j as e,o as t,g as c,k as p,h as a,Q as o,s}from"./chunks/framework.a0d18f64.js";const w=JSON.parse('{"title":"27内存回收上篇：如何解决内存的循环引用问题？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学操作系统_文档/(4636) 27  内存回收上篇：如何解决内存的循环引用问题？.md","filePath":"posts/backEnd/重学操作系统_文档/(4636) 27  内存回收上篇：如何解决内存的循环引用问题？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/重学操作系统_文档/(4636) 27  内存回收上篇：如何解决内存的循环引用问题？.md"},i=o("",9),E=o("",20),_=s("p",null,"如果一个节点的引用计数是 0，就意味着没有任何一个节点引用它------此时，理论上这个节点应该被回收。GC 不断扫描引用计数为 0 的节点进行回收，就构成了最简单的一个内存回收算法。",-1),d=s("p",null,"但是，这个算法可能会出现下图中循环引用的问题（我们写程序的过程中经常会遇到这样的引用关系）。下图中三个节点，因为循环引用，引用计数都是 1。",-1),h=s("p",null,"引用计数是 1，因此就算这 3 个对象不会再使用了，GC 不会回收它们。",-1),g=s("p",null,"另一个考虑是在多线程环境下引用计数的算法一旦算错 1 次（比如因为没有处理好竞争条件），那么就无法再纠正了。而且处理竞争条件本身也比较耗费性能。",-1),C=s("p",null,"还有就是引用计数法回收内存会产生碎片，当然碎片不是只有引用计数法才有的问题，所有的 GC 都需要面对碎片。下图中内存回收的碎片可以通过整理的方式，清理出更多空间出来。关于内存空间的碎片，下一讲会有专门的一个小节讨论。",-1),y=s("p",null,[a("综上，"),s("strong",null,"引用计数法出错概率大"),a(" ，比如我们编程时会有对象的循环引用；另一方面，"),s("strong",null,"引用计数法容错能力差"),a("，一旦计算错了，就会导致内存永久无法被回收，因此我们需要更好的方式。")],-1),u=s("h3",{id:"root-tracing-算法",tabindex:"-1"},[a("Root Tracing 算法 "),s("a",{class:"header-anchor",href:"#root-tracing-算法","aria-label":'Permalink to "Root Tracing 算法"'},"​")],-1),G=s("p",null,"下面我再给你介绍一种更好的方式------ Root Tracing 算法。这是一类算法，后面我们会讲解的标记-清除算法和 3 色标记-清除算法都属于这一类。",-1),b=s("p",null,"Root Tracing 的原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用关系的源头。比如用户在栈中创建的对象指针；程序启动之初导入数据区的全局对象等。在 Java 中根对象就包括在栈上创建指向堆的对象；JVM 的一些元数据，包括 Method Area 中的对象等。",-1),m=o("",13),k=o("",7),A=s("p",null,"假设用户程序和 GC 交替执行，用户程序不断进行修改（Mutation），而 GC 不断执行标记-清除算法。那么这中间会产生大量浮动垃圾影响 GC 的效果。",-1),T=s("p",null,"另一方面，考虑到 GC 是一个非常消耗性能程序，在某些情况下，我们希望 GC 能够增量回收。 比如说，用户仅仅是高频删除了一部分对象，那么是否可以考虑设计不需要从整个 Root 集合进行遍历，而是增量的只处理最近这一批变更的算法呢？答案是可以的，我们平时可以多执行增量 GC，偶尔执行一次全量 GC。具体增量的方式会在下一讲为你讲解。",-1),v=s("h3",{id:"总结",tabindex:"-1"},[a("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),f=s("p",null,"讨论到这里，相信你已经对 GC 有了一个大致的认识，但是具体到不同的场景如何设计 GC 算法，比如上面提到的标记-清除算法的缺陷，该如何去弥补呢？ 还有在高并发场景应该如何选择 GC 算法呢？当你拿到一个 GC 工具，又应该如何去设置参数，调整计算资源和存储资源比例呢？这些问题， 你可以先在自己脑海中思考，然后我会在下一讲为你讲解更好的方案。",-1),S=s("p",null,'另外，本讲关联的面试题：如何解决内存的循环引用问题？也请你先进行一定的思考，再来"28 讲"查看详细的分析过程。',-1);function j(P,F,q,R,D,M){const n=e("Image");return t(),c("div",null,[i,p(n,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image/M00/84/76/CgqCHl_TUM2APvozAAB0lmNeQnw264.png"}),a(),E,p(n,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image2/M01/03/6E/CgpVE1_cGkiAQg5eAACZco3DsVw877.png"}),a(),_,d,p(n,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image/M00/84/6B/Ciqc1F_TUQ6AGct7AACd_pMg8rA373.png"}),a(),h,g,C,p(n,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image/M00/84/76/CgqCHl_TUSuAPeDgAACSOYD8YQE974.png"}),a(),y,u,G,b,p(n,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image/M00/8B/9A/CgqCHl_cGjOAErigAAE9Hos_mIo707.png"}),a(),m,p(n,{alt:"图片6.png",src:"https://s0.lgstatic.com/i/image/M00/84/78/CgqCHl_TUaqAcfrDAAFJuEq7pNM130.png"}),a(),k,p(n,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image/M00/84/7B/CgqCHl_TU2iAVazmAACFSSdQ3Os503.png"}),a(),A,T,v,f,S])}const B=l(r,[["render",j]]);export{w as __pageData,B as default};
