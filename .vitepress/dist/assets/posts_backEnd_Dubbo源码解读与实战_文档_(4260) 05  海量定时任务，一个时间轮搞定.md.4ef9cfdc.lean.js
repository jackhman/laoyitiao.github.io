import{_ as s,j as a,o as r,g as n,k as o,h as t,s as e,Q as l}from"./chunks/framework.4e7d56ce.js";const E=JSON.parse('{"title":"05海量定时任务，一个时间轮搞定","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4260) 05  海量定时任务，一个时间轮搞定.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4260) 05  海量定时任务，一个时间轮搞定.md","lastUpdated":1696682708000}'),p={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4260) 05  海量定时任务，一个时间轮搞定.md"},h=e("h1",{id:"_05海量定时任务-一个时间轮搞定",tabindex:"-1"},[t("05海量定时任务，一个时间轮搞定 "),e("a",{class:"header-anchor",href:"#_05海量定时任务-一个时间轮搞定","aria-label":'Permalink to "05海量定时任务，一个时间轮搞定"'},"​")],-1),u=e("p",null,"在很多开源框架中，都需要定时任务的管理功能，例如 ZooKeeper、Netty、Quartz、Kafka 以及 Linux 操作系统。",-1),d=e("p",null,[t("JDK 提供的 java.util.Timer 和 DelayedQueue 等工具类，可以帮助我们实现简单的定时任务管理，其底层实现使用的是"),e("strong",null,"堆"),t(" 这种数据结构，存取操作的复杂度都是 O(nlog(n))，无法支持大量的定时任务。在定时任务量比较大、性能要求比较高的场景中，为了将定时任务的存取操作以及取消操作的时间复杂度降为 O(1)，一般会使用"),e("strong",null,"时间轮"),t("的方式。")],-1),m=e("p",null,[e("strong",null,"时间轮是一种高效的、批量管理定时任务的调度模型"),t("。时间轮一般会实现成一个环形结构，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用双向链表存储定时任务；指针周期性地跳动，跳动到一个槽位，就执行该槽位的定时任务。")],-1),T=l("",5),g=e("p",null,"Timer 接口定义了定时器的基本行为，如下图所示，其核心是 newTimeout() 方法：提交一个定时任务（TimerTask）并返回关联的 Timeout 对象，这有点类似于向线程池提交任务的感觉。",-1),c=l("",30);function _(b,k,H,W,D,A){const i=a("Image");return r(),n("div",null,[h,u,d,m,o(i,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/40/41/CgqCHl8yQfKAEM41AAB8fTu5PCY623.png"}),t(),T,o(i,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/40/42/CgqCHl8yQiKAGNLJAABUa6k9juY124.png"}),t(),g,o(i,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/40/42/CgqCHl8yQiuAC-1HAABO-eN3cPE094.png"}),t(),c])}const P=s(p,[["render",_]]);export{E as __pageData,P as default};
