import{_ as e,j as p,o,g as t,k as a,s,h as c,Q as l}from"./chunks/framework.4e7d56ce.js";const O=JSON.parse('{"title":"JVMMetricReportServiceHandler ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1742) 第24讲：jvm-receiver 插件探秘 ，不仅有 Trace 还可以有监控.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1742) 第24讲：jvm-receiver 插件探秘 ，不仅有 Trace 还可以有监控.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1742) 第24讲：jvm-receiver 插件探秘 ，不仅有 Trace 还可以有监控.md"},i=s("p",null,"在第 11 课时中，我介绍了 Agent 中 JVMService 的核心原理，它会定期通过 JMX 获取 JVM 监控信息，然后通过 JVMMetricReportService 这个 gRPC 接口上报到后端 OAP 集群。",-1),E=s("p",null,"本节课我将深入分析 SkyWalking OAP 对 JVM 监控数据的处理。",-1),y=s("h3",{id:"jvmmetricreportservicehandler",tabindex:"-1"},[c("JVMMetricReportServiceHandler "),s("a",{class:"header-anchor",href:"#jvmmetricreportservicehandler","aria-label":'Permalink to "JVMMetricReportServiceHandler"'},"​")],-1),d=s("p",null,"在 SkyWalking OAP 提供了 jvm-receiver-plugin 插件用于接收 Agent 发送的 JVMMetric 。jvm-receiver-plugin 插件的 SPI 配置文件中指定的 ModuleDefine 实现是 JVMModule（名称为 receiver-jvm），ModuleProvider 实现是 JVMModuleProvider（名称为 default）。在 JVMModuleProvider 的 start() 方法中会将 JVMMetricReportServiceHandler 注册到 GRPCServer 中。JVMMetricReportServiceHandler 实现了 JVMMetric.proto 文件中定义的 JVMMetricReportService gRPC 接口，其 collect() 方法负责处理 JVMMetric 对象。",-1),g=s("p",null,"首先，会通过 TimeBucket 工具类整理对齐每个 JVMMetric 所在的时间窗口，TimeBucket 会根据指定的 DownSampling 精度生成不同格式的时间窗口，如下图所示：",-1),u=l(`<p>JVMMetricReportServiceHandler 中默认使用的 DownSampling 值为 Minute。</p><p>接下来，JVMMetricReportServiceHandler 会将 JVMMetrics 交给 JVMSourceDispatcher 处理，JVMSourceDispatcher 会按照 CPU、Memory、MemoryPool、GC 四个大类对监控数据进行拆分并转发：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sendMetric</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceInstanceId, </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> minuteTimeBucket, </span></span>
<span class="line"><span style="color:#E1E4E8;">      JVMMetric metrics) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取 JVMMetric 对应的 ServiceId</span></span>
<span class="line"><span style="color:#E1E4E8;">    ServiceInstanceInventory serviceInstanceInventory </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">          instanceInventoryCache.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(serviceInstanceId);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> serviceInstanceInventory.</span><span style="color:#B392F0;">getServiceId</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//将 JVMMetric 分类转发</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">sendToCpuMetricProcess</span><span style="color:#E1E4E8;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#E1E4E8;">          minuteTimeBucket, metrics.</span><span style="color:#B392F0;">getCpu</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">sendToMemoryMetricProcess</span><span style="color:#E1E4E8;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#E1E4E8;">          minuteTimeBucket, metrics.</span><span style="color:#B392F0;">getMemoryList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">sendToMemoryPoolMetricProcess</span><span style="color:#E1E4E8;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#E1E4E8;">          minuteTimeBucket, metrics.</span><span style="color:#B392F0;">getMemoryPoolList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">sendToGCMetricProcess</span><span style="color:#E1E4E8;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#E1E4E8;">          minuteTimeBucket, metrics.</span><span style="color:#B392F0;">getGcList</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sendMetric</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceInstanceId, </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> minuteTimeBucket, </span></span>
<span class="line"><span style="color:#24292E;">      JVMMetric metrics) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取 JVMMetric 对应的 ServiceId</span></span>
<span class="line"><span style="color:#24292E;">    ServiceInstanceInventory serviceInstanceInventory </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">          instanceInventoryCache.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(serviceInstanceId);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> serviceInstanceInventory.</span><span style="color:#6F42C1;">getServiceId</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//将 JVMMetric 分类转发</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">sendToCpuMetricProcess</span><span style="color:#24292E;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#24292E;">          minuteTimeBucket, metrics.</span><span style="color:#6F42C1;">getCpu</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">sendToMemoryMetricProcess</span><span style="color:#24292E;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#24292E;">          minuteTimeBucket, metrics.</span><span style="color:#6F42C1;">getMemoryList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">sendToMemoryPoolMetricProcess</span><span style="color:#24292E;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#24292E;">          minuteTimeBucket, metrics.</span><span style="color:#6F42C1;">getMemoryPoolList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">sendToGCMetricProcess</span><span style="color:#24292E;">(serviceId, serviceInstanceId, </span></span>
<span class="line"><span style="color:#24292E;">          minuteTimeBucket, metrics.</span><span style="color:#6F42C1;">getGcList</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里先以 JVM GC 的监控数据为例进行分析。在 sendToGCMetricProcess() 方法中会将 GC 对象转换为 ServiceInstanceJVMGC 对象（ServiceInstanceJVMGC 中除了包含 GC 对象中的监控数据，还记录了 serviceId 以及 serviceInstanceId，也就明确了这些监控数据的归属）。然后， DispatcherManager 会将 ServiceInstanceJVMGC 转发到相应的 SourceDispatcher。</p><p>同理，JVMMetric 中关于 CPU、Memory、MemoryPool 的三类监控数据分别填充到了 ServiceInstanceJVMCPU、ServiceInstanceJVMMemory、ServiceInstanceJVMMemoryPool 对象中，继承关系如下图所示：</p>`,5),h=l(`<h3 id="dispatcher-dispatchermanager" tabindex="-1">Dispatcher &amp; DispatcherManager <a class="header-anchor" href="#dispatcher-dispatchermanager" aria-label="Permalink to &quot;Dispatcher \\&amp; DispatcherManager&quot;">​</a></h3><p>在 DispatchManager 中维护了一个 Map&lt;Integer, List &gt; 集合，该集合记录了各个 Source 类型对应的 Dispatcher 实现，其中 Key 是 Source 类型对应的 scope 值，Source 的不同子类对应不同的 scope 值，例如：ServiceInstanceJVMGC 对应的 scope 值为 11，ServiceInstanceJVMCPU 对应的 scope 值为 8。其中的 Value 是处理该 Source 子类的 Dispatcher 集合，例如：ServiceInstanceJVMGCDispatcher 就是负责分发 ServiceInstanceJVMGC 的 SourceDispatcher 实现，ServiceInstanceJVMGCDispatcher 的定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ServiceInstanceJVMGCDispatcher</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SourceDispatcher</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">ServiceInstanceJVMGC</span><span style="color:#E1E4E8;">&gt; {...}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ServiceInstanceJVMGCDispatcher</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SourceDispatcher</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">ServiceInstanceJVMGC</span><span style="color:#24292E;">&gt; {...}</span></span></code></pre></div><p>在 CoreModuleProvider 启动的时候（即 start() 方法），会扫描 classpath 下全部 SourceDispatcher 实现类，并识别其处理的 Source 子类类型进行分类并填充 Map&lt;Integer, List &gt; 集合。具体的扫描逻辑在 DispatcherManager.scan() 方法中，如果你感兴趣可以翻一下代码。</p><blockquote><p>还有需要注意的是，这些 SourceDispatcher 的部分实现是通过 OAL 脚本生成的，OAL 语言的内容在后面会展开分析，这里先专注于监控指标的处理流程上。</p></blockquote><p>回到 ServiceInstanceJVMGC 的处理流程上，默认与它对应的 SourceDispatcher 实现只有 ServiceInstanceJVMGCDispatcher，其 dispatch() 方法会将 ServiceInstanceJVMGC 对象转换成相应的 Metrics 对象，实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(ServiceInstanceJVMGC source) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">doInstanceJvmYoungGcTime</span><span style="color:#E1E4E8;">(source);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">doInstanceJvmOldGcTime</span><span style="color:#E1E4E8;">(source);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">doInstanceJvmYoungGcCount</span><span style="color:#E1E4E8;">(source);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">doInstanceJvmOldGcCount</span><span style="color:#E1E4E8;">(source);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(ServiceInstanceJVMGC source) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">doInstanceJvmYoungGcTime</span><span style="color:#24292E;">(source);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">doInstanceJvmOldGcTime</span><span style="color:#24292E;">(source);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">doInstanceJvmYoungGcCount</span><span style="color:#24292E;">(source);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">doInstanceJvmOldGcCount</span><span style="color:#24292E;">(source);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里的 doInstanceJvm*() 方法是将 ServiceInstanceJVMGC 转换成相应的 Metrics ，我们可以看到，在 ServiceInstanceJVMGC 中包含了 GCPhrase、GC 时间、 GC 次数三个维度的数据，而转换后的一个 Metrics 子类型只表示一个维度的监控数据。这里涉及的 Metrics 子类如下图所示：</p>`,8),m=l(`<p>在前面的&quot;SkyWalking OAP 存储体系剖析&quot;课时中提到了 Metrics 抽象类，你可以回顾一下，Metrics 抽象类是所有监控指标的顶级抽象，其中定义了一个 TimeBucket 字段（long 类型），用于记录该监控数据所在的分钟级窗口。</p><p>下面来看上图涉及的 Metrics 子类，在 LongAvgMetrics 抽象类中增加了下面三个字段：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> summation; </span><span style="color:#6A737D;">// 总和</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> count; </span><span style="color:#6A737D;">// 次数</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> value; </span><span style="color:#6A737D;">// 平均值</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> summation; </span><span style="color:#6A737D;">// 总和</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> count; </span><span style="color:#6A737D;">// 次数</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> value; </span><span style="color:#6A737D;">// 平均值</span></span></code></pre></div><p>在 combine() 方法实现中，会将传入的 LongAvgMetrics 对象的 summation 和 count 字段累加到当前 LongAvgMetrics 对象中。在 calculate() 方法中会计算 value 字段的值：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.summation </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.count;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.summation </span><span style="color:#D73A49;">/</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.count;</span></span></code></pre></div><p>下面会以 Old GC Time 监控数据继续分析，这里的 doInstanceJvmOldGcTime() 方法会将 ServiceInstanceJVMGC 转换成 InstanceJvmOldGcTimeMetrics，其中又添加了 serviceId 和 entityid（用于构造 Document Id，InstanceJvmOldGcTimeMetrics 中就是 serviceInstanceId）两个字段，用于记录该 GC 监控数据所属的服务实例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;entity_id&quot;</span><span style="color:#E1E4E8;">) @</span><span style="color:#F97583;">IDColumn</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String entityId;</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;service_id&quot;</span><span style="color:#E1E4E8;">)  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceId;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;entity_id&quot;</span><span style="color:#24292E;">) @</span><span style="color:#D73A49;">IDColumn</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String entityId;</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;service_id&quot;</span><span style="color:#24292E;">)  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceId;</span></span></code></pre></div><p>SkyWalking OAP 中很多其他类型的监控数据，例如：</p><ul><li><strong>SumMetrics</strong> 计算的是时间窗口内的总和。</li><li><strong>MaxDoubleMetrics、MaxLongMetrics</strong> 计算的是时间窗口内的最大值。</li><li><strong>PercentMetrics</strong> 计算的是时间窗口内符合条件数据所占的百分比（即 match / total）。</li><li><strong>PxxMetrics</strong> 计算的是时间窗口内的分位数，例如： P99Metrics、P95Metrics、P70Metrics等。</li><li><strong>CPMMetrics</strong> 计算的是应用的吞吐量，默认是通过分钟级别的调用次数计算的。</li></ul><p>最后，依旧以 InstanceJvmOldGcTimeMetrics 为例，看看 Metrics 实现类中定义的 ElasticSearch 索引名称以及各个字段对应的 Field 名称：</p>`,10),C=l(`<p>回到 GC 监控数据的处理流程中，在 doInstanceJvmOldGcTime() 方法完成监控数据粒度的细分之后，会将细分后的 InstanceJvmOldGcTimeMetrics 对象交给 MetricsStreamProcessor 处理。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doInstanceJvmOldGcTime</span><span style="color:#E1E4E8;">(ServiceInstanceJVMGC source) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建 InstanceJvmOldGcTimeMetrics 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    InstanceJvmOldGcTimeMetrics metrics </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InstanceJvmOldGcTimeMetrics</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">EqualMatch</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">setLeft</span><span style="color:#E1E4E8;">(source.</span><span style="color:#B392F0;">getPhrase</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">setRight</span><span style="color:#E1E4E8;">(GCPhrase.OLD).</span><span style="color:#B392F0;">match</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;     </span><span style="color:#6A737D;">// 只处理 Old GC</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    metrics.</span><span style="color:#B392F0;">setTimeBucket</span><span style="color:#E1E4E8;">(source.</span><span style="color:#B392F0;">getTimeBucket</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// 分钟级别的时间窗口</span></span>
<span class="line"><span style="color:#E1E4E8;">    metrics.</span><span style="color:#B392F0;">setEntityId</span><span style="color:#E1E4E8;">(source.</span><span style="color:#B392F0;">getEntityId</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// serviceInstanceId</span></span>
<span class="line"><span style="color:#E1E4E8;">    metrics.</span><span style="color:#B392F0;">setServiceId</span><span style="color:#E1E4E8;">(source.</span><span style="color:#B392F0;">getServiceId</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// serviceId</span></span>
<span class="line"><span style="color:#E1E4E8;">    metrics.</span><span style="color:#B392F0;">combine</span><span style="color:#E1E4E8;">(source.</span><span style="color:#B392F0;">getTime</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 记录 GC 时间，count 为1</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 交给 MetricsStreamProcessor 继续后续处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    MetricsStreamProcessor.</span><span style="color:#B392F0;">getInstance</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">in</span><span style="color:#E1E4E8;">(metrics);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doInstanceJvmOldGcTime</span><span style="color:#24292E;">(ServiceInstanceJVMGC source) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建 InstanceJvmOldGcTimeMetrics 对象</span></span>
<span class="line"><span style="color:#24292E;">    InstanceJvmOldGcTimeMetrics metrics </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InstanceJvmOldGcTimeMetrics</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">EqualMatch</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">setLeft</span><span style="color:#24292E;">(source.</span><span style="color:#6F42C1;">getPhrase</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">setRight</span><span style="color:#24292E;">(GCPhrase.OLD).</span><span style="color:#6F42C1;">match</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;     </span><span style="color:#6A737D;">// 只处理 Old GC</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    metrics.</span><span style="color:#6F42C1;">setTimeBucket</span><span style="color:#24292E;">(source.</span><span style="color:#6F42C1;">getTimeBucket</span><span style="color:#24292E;">()); </span><span style="color:#6A737D;">// 分钟级别的时间窗口</span></span>
<span class="line"><span style="color:#24292E;">    metrics.</span><span style="color:#6F42C1;">setEntityId</span><span style="color:#24292E;">(source.</span><span style="color:#6F42C1;">getEntityId</span><span style="color:#24292E;">()); </span><span style="color:#6A737D;">// serviceInstanceId</span></span>
<span class="line"><span style="color:#24292E;">    metrics.</span><span style="color:#6F42C1;">setServiceId</span><span style="color:#24292E;">(source.</span><span style="color:#6F42C1;">getServiceId</span><span style="color:#24292E;">()); </span><span style="color:#6A737D;">// serviceId</span></span>
<span class="line"><span style="color:#24292E;">    metrics.</span><span style="color:#6F42C1;">combine</span><span style="color:#24292E;">(source.</span><span style="color:#6F42C1;">getTime</span><span style="color:#24292E;">(), </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 记录 GC 时间，count 为1</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 交给 MetricsStreamProcessor 继续后续处理</span></span>
<span class="line"><span style="color:#24292E;">    MetricsStreamProcessor.</span><span style="color:#6F42C1;">getInstance</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">in</span><span style="color:#24292E;">(metrics);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="metricsstreamprocessor" tabindex="-1">MetricsStreamProcessor <a class="header-anchor" href="#metricsstreamprocessor" aria-label="Permalink to &quot;MetricsStreamProcessor&quot;">​</a></h3><p>前面在介绍服务注册流程的时候，分析过 InventoryStreamProcessor 处理注册请求的核心逻辑，在这里，MetricsStreamProcessor 处理 Metrics 数据的流程也有异曲同工之处。</p><p>MetricsStreamProcessor 中为每个 Metrics 类型维护了一个 Worker 链，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Map&lt;Class&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Metrics</span><span style="color:#E1E4E8;">&gt;, </span><span style="color:#F97583;">MetricsAggregateWorker</span><span style="color:#E1E4E8;">&gt; entryWorkers </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashMap&lt;&gt;();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Map&lt;Class&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Metrics</span><span style="color:#24292E;">&gt;, </span><span style="color:#D73A49;">MetricsAggregateWorker</span><span style="color:#24292E;">&gt; entryWorkers </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span></code></pre></div><p>MetricsStreamProcessor 初始化 entryWorkers 集合的核心逻辑也是在 create() 方法中，下图展示了 InstanceJvmOldGcTimeMetrics 对应的 Worker 链结构：</p>`,7),D=l(`<p>具体代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 创建 minutePersistentWorker</span></span>
<span class="line"><span style="color:#E1E4E8;">MetricsPersistentWorker minutePersistentWorker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">   </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">minutePersistentWorker</span><span style="color:#E1E4E8;">(moduleDefineHolder, metricsDAO, model);</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 MetricsTransWorker，后续 worker 指向 minutePersistenceWorker 对象(以及</span></span>
<span class="line"><span style="color:#6A737D;">// hour、day、monthPersistentWorker)</span></span>
<span class="line"><span style="color:#E1E4E8;">MetricsTransWorker transWorker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MetricsTransWorker</span><span style="color:#E1E4E8;">(moduleDefineHolder, stream.</span><span style="color:#B392F0;">name</span><span style="color:#E1E4E8;">(), </span></span>
<span class="line"><span style="color:#E1E4E8;">        minutePersistentWorker, hourPersistentWorker, </span></span>
<span class="line"><span style="color:#E1E4E8;">            dayPersistentWorker, monthPersistentWorker);</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 MetricsRemoteWorker，并将 nextWorker 指向上面的 MetricsTransWorker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">MetricsRemoteWorker remoteWorker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">MetricsRemoteWorker</span><span style="color:#E1E4E8;">(moduleDefineHolder, transWorker, stream.</span><span style="color:#B392F0;">name</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 MetricsAggregateWorker，并将 nextWorker 指向上面的</span></span>
<span class="line"><span style="color:#6A737D;">// MetricsRemoteWorker 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">MetricsAggregateWorker aggregateWorker </span><span style="color:#F97583;">=</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MetricsAggregateWorker</span><span style="color:#E1E4E8;">(moduleDefineHolder, remoteWorker, </span></span>
<span class="line"><span style="color:#E1E4E8;">         stream.</span><span style="color:#B392F0;">name</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#6A737D;">// 将上述 worker 链与指定 Metrics 类型绑定</span></span>
<span class="line"><span style="color:#E1E4E8;">entryWorkers.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(metricsClass, aggregateWorker);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 创建 minutePersistentWorker</span></span>
<span class="line"><span style="color:#24292E;">MetricsPersistentWorker minutePersistentWorker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">   </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">minutePersistentWorker</span><span style="color:#24292E;">(moduleDefineHolder, metricsDAO, model);</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 MetricsTransWorker，后续 worker 指向 minutePersistenceWorker 对象(以及</span></span>
<span class="line"><span style="color:#6A737D;">// hour、day、monthPersistentWorker)</span></span>
<span class="line"><span style="color:#24292E;">MetricsTransWorker transWorker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MetricsTransWorker</span><span style="color:#24292E;">(moduleDefineHolder, stream.</span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">(), </span></span>
<span class="line"><span style="color:#24292E;">        minutePersistentWorker, hourPersistentWorker, </span></span>
<span class="line"><span style="color:#24292E;">            dayPersistentWorker, monthPersistentWorker);</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 MetricsRemoteWorker，并将 nextWorker 指向上面的 MetricsTransWorker对象</span></span>
<span class="line"><span style="color:#24292E;">MetricsRemoteWorker remoteWorker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">MetricsRemoteWorker</span><span style="color:#24292E;">(moduleDefineHolder, transWorker, stream.</span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 MetricsAggregateWorker，并将 nextWorker 指向上面的</span></span>
<span class="line"><span style="color:#6A737D;">// MetricsRemoteWorker 对象</span></span>
<span class="line"><span style="color:#24292E;">MetricsAggregateWorker aggregateWorker </span><span style="color:#D73A49;">=</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MetricsAggregateWorker</span><span style="color:#24292E;">(moduleDefineHolder, remoteWorker, </span></span>
<span class="line"><span style="color:#24292E;">         stream.</span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#6A737D;">// 将上述 worker 链与指定 Metrics 类型绑定</span></span>
<span class="line"><span style="color:#24292E;">entryWorkers.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(metricsClass, aggregateWorker);</span></span></code></pre></div><p>其中 minutePersistentWorker 是一定会存在的，其他 DownSampling（Hour、Day、Month） 对应的 PersistentWorker 则会根据配置的创建并添加，在 CoreModuleProvider.prepare() 方法中有下面这行代码，会获取 Downsampling 配置并保存于 DownsamplingConfigService 对象中配置。后续创建上述 Worker 时，会从中获取配置的 DownSampling。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">registerServiceImplementation</span><span style="color:#E1E4E8;">(DownsamplingConfigService.class, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DownsamplingConfigService</span><span style="color:#E1E4E8;">(moduleConfig.</span><span style="color:#B392F0;">getDownsampling</span><span style="color:#E1E4E8;">()));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">registerServiceImplementation</span><span style="color:#24292E;">(DownsamplingConfigService.class, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DownsamplingConfigService</span><span style="color:#24292E;">(moduleConfig.</span><span style="color:#6F42C1;">getDownsampling</span><span style="color:#24292E;">()));</span></span></code></pre></div><h3 id="mergedatacache-缓冲区设计与实现" tabindex="-1">MergeDataCache 缓冲区设计与实现 <a class="header-anchor" href="#mergedatacache-缓冲区设计与实现" aria-label="Permalink to &quot;MergeDataCache 缓冲区设计与实现&quot;">​</a></h3><p>在深入介绍上述 Worker 的实现之前，需要先要来介绍一下其中使用到的 MergeDataCache 缓冲区组件的设计与实现。</p><p>Window 抽象类是 MergeDataCache 缓冲区的基类，使用双缓冲队列的结构实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> SWCollection&lt;</span><span style="color:#F97583;">DATA</span><span style="color:#E1E4E8;">&gt; pointer; </span><span style="color:#6A737D;">// 指向当前正在写入的缓冲队列</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> SWCollection&lt;</span><span style="color:#F97583;">DATA</span><span style="color:#E1E4E8;">&gt; windowDataA; </span><span style="color:#6A737D;">// A、B两个缓冲队列</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> SWCollection&lt;</span><span style="color:#F97583;">DATA</span><span style="color:#E1E4E8;">&gt; windowDataB;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> SWCollection&lt;</span><span style="color:#D73A49;">DATA</span><span style="color:#24292E;">&gt; pointer; </span><span style="color:#6A737D;">// 指向当前正在写入的缓冲队列</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> SWCollection&lt;</span><span style="color:#D73A49;">DATA</span><span style="color:#24292E;">&gt; windowDataA; </span><span style="color:#6A737D;">// A、B两个缓冲队列</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> SWCollection&lt;</span><span style="color:#D73A49;">DATA</span><span style="color:#24292E;">&gt; windowDataB;</span></span></code></pre></div><p>为了便于后面的描述，这里简单区分两个缓冲队列，其中 pointer 指向的队列称为 &quot;current 队列&quot;（一般是有空闲空间的队列，主要负责缓冲新写入数据），另一个队列称为 &quot;last 队列&quot;（一般填充了一定量的数据，会有其他线程从中读取数据进行消费）。</p><p>SWCollection 接口定义了缓冲队列的基本行为，下面是其继承关系图：</p>`,10),F=l(`<p>这里重点分析 MergeDataCollection 实现类，它底层是通过一个 HashMap 实现的，一对 KV 中的 Key 和 Value 指向的是同一个 StreamData 对象。MergeDataCollection 暴露了 Map 的基本方法，例如：put、get、containKey 等方法。另外，它还封装了两个 volatile boolean 类型的字段 ------ reading、writing，用于标记该缓冲队列的状态，也提供了这两个状态字段相应的 getter/setter 方法。简单说明一下这两个状态字段的含义：</p><ul><li>当队列的 reading 被设置为 true 时，处于 reading 状态，表示可能有线程在从该队列中读取数据。</li><li>当队列的 writing 被设置为 true 时，处于 writing 状态，表示可能有线程在向该队列中写入数据。</li></ul><p>通过 MergeDataCollection 类暴露方法，我们完全可以让一个队列同时处于 reading 和 writing 两个状态，但是这样会出现并发问题。所以在后面用到 MergeDataCollection 及 MergeDataCache 的地方我们也可以看到，即使一个队列偶尔同时处于两个状态，也会通过循环等待的方式，等待其中一个状态退出。</p><p>LimitSizeDateCollection 与 MergeDataCollection 的大致实现类似，区别在于 LimitSizeDateCollection 底层的 Map 类型是 HashMap&lt;T, LinkedList &gt;，Value 中的 LinkedList 都是有序队列。在 LimitSizeDateCollection.put() 方法中会限制每个 LinkedList 的长度，当超过指定的长度时，只会保留最大的 TOP N。</p><p>回到 Window 抽象类，其中还定义了一个控制 pointer 指针切换的字段，如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> AtomicInteger windowSwitch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AtomicInteger</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> AtomicInteger windowSwitch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AtomicInteger</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span></code></pre></div><p>以及相应的切换检查方法，如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 检查 windowSwitch 字段，以及 last 队列是否处于可读状态</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">trySwitchPointer</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> windowSwitch.</span><span style="color:#B392F0;">incrementAndGet</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#B392F0;">getLast</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">isReading</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果此时 last 队列处于 reading 状态，切换后，last 队列会变成current队列，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 就会出现两个线程(一个读线程、一个写线程)并发操作该队列的可能，所以需要进行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// reading 状态的检测</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在 trySwitchPointer()方法尝试之后，需要在 finally 代码块中恢复windowSwitch</span></span>
<span class="line"><span style="color:#6A737D;">// 字段的值，为下次检查做准备</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">trySwitchPointerFinally</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    windowSwitch.</span><span style="color:#B392F0;">addAndGet</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 检查 windowSwitch 字段，以及 last 队列是否处于可读状态</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">trySwitchPointer</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> windowSwitch.</span><span style="color:#6F42C1;">incrementAndGet</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">              </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">getLast</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">isReading</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果此时 last 队列处于 reading 状态，切换后，last 队列会变成current队列，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 就会出现两个线程(一个读线程、一个写线程)并发操作该队列的可能，所以需要进行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// reading 状态的检测</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 在 trySwitchPointer()方法尝试之后，需要在 finally 代码块中恢复windowSwitch</span></span>
<span class="line"><span style="color:#6A737D;">// 字段的值，为下次检查做准备</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">trySwitchPointerFinally</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    windowSwitch.</span><span style="color:#6F42C1;">addAndGet</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 switchPointer() 方法中实现了 pointer 字段的切换，同时也会更新 last 队列的状态：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">switchPointer</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (pointer </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> windowDataA) { </span><span style="color:#6A737D;">// 根据 pointer 当前的指向，进行修改</span></span>
<span class="line"><span style="color:#E1E4E8;">        pointer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> windowDataB;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        pointer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> windowDataA;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">getLast</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">reading</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 修改 last 队列的状态</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">switchPointer</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (pointer </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> windowDataA) { </span><span style="color:#6A737D;">// 根据 pointer 当前的指向，进行修改</span></span>
<span class="line"><span style="color:#24292E;">        pointer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> windowDataB;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        pointer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> windowDataA;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">getLast</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">reading</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 修改 last 队列的状态</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来重点看 MergeDataCache 类的实现，有两个点需要注意：</p><ul><li>它将 A、B 两个队列初始化为 MergeDataCollection 队列。</li><li>它维护了一个 lockedMergeDataCollection 字段。在开始写入的时候，会先调用 writing() 方法将 lockedMergeDataCollection 字段指向当前的 current 队列，直至写入操作完成。即使在写入操作过程中发生了 pointer 的切换，lockedMergeDataCollection 字段的指向也不会发生变化。在写入操作完成之后，会调用 finishWriting() 方法将 lockedMergeDataCollection 字段设置为 null。</li></ul><p>LimitedSizeDataCache 与 MergeDataCache 的实现有些类似，但功能上有所区别，在后面介绍慢查询的处理（TopNStreamProcessor）时，会介绍 LimitedSizeDataCache 的核心实现。</p><h3 id="metricsaggregateworker" tabindex="-1">MetricsAggregateWorker <a class="header-anchor" href="#metricsaggregateworker" aria-label="Permalink to &quot;MetricsAggregateWorker&quot;">​</a></h3><p>回到 InstanceJvmOldGcTimeMetrics 的处理流程上继续分析，Worker 链中的第一个是 MetricsAggregateWorker，其功能就是进行简单的聚合，模型如下图所示：</p>`,15),v=l(`<p>MetricsAggregateWorker 在收到 Metrics 数据的时候，会先写到内部的 DataCarrier 中缓存，然后由 Consumer 线程（都属于名为 &quot;METRICS_L1_AGGREGATION&quot; 的 BulkConsumePool）消费并进行聚合，并将聚合结果写入到 MergeDataCache 中的 current 队列暂存。</p><p>同时，Consumer 会定期（默认1秒，通过 METRICS_L1_AGGREGATION_SEND_CYCLE 配置修改）触发 current 队列和 last 队列的切换，然后读取 last 队列中暂存的数据，并发送到下一个 Worker 中处理。</p><p>上图中写入 DataCarrier 的逻辑在前面已经分析过了，这里不再赘述。下面深入分析两个点：</p><ol><li>Consumer 线程消费 DataCarrier 并聚合监控数据的相关实现。</li><li>Consumer 线程定期清理 MergeDataCache 缓冲区并发送监控数据的相关实现。</li></ol><p>Consumer 线程在消费 DataCarrier 数据的时候，首先会进行 Metrics 聚合（即相同 Metrics 合并成一个），然后写入 MergeDataCache 中，实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">aggregate</span><span style="color:#E1E4E8;">(Metrics metrics) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 lockedMergeDataCollection 指向 current 队列，并设置其 writing标记</span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">writing</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (mergeDataCache.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(metrics)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 存在重复的监控数据，则进行合并，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 不同 Metrics子类的 combine()方法实现有所不同，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里的 InstanceJvmOldGcTimeMetrics 的实现就 summation 的累加、</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// count 加一</span></span>
<span class="line"><span style="color:#E1E4E8;">        mergeDataCache.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(metrics).</span><span style="color:#B392F0;">combine</span><span style="color:#E1E4E8;">(metrics);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 该 Metrics 第一次出现，直接写入到</span></span>
<span class="line"><span style="color:#E1E4E8;">        mergeDataCache.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(metrics);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 清理 current 队列的 writing 标记，之后清理 lockedMergeDataCollection </span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">finishWriting</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">aggregate</span><span style="color:#24292E;">(Metrics metrics) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 lockedMergeDataCollection 指向 current 队列，并设置其 writing标记</span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">writing</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (mergeDataCache.</span><span style="color:#6F42C1;">containsKey</span><span style="color:#24292E;">(metrics)) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 存在重复的监控数据，则进行合并，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 不同 Metrics子类的 combine()方法实现有所不同，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里的 InstanceJvmOldGcTimeMetrics 的实现就 summation 的累加、</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// count 加一</span></span>
<span class="line"><span style="color:#24292E;">        mergeDataCache.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(metrics).</span><span style="color:#6F42C1;">combine</span><span style="color:#24292E;">(metrics);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 该 Metrics 第一次出现，直接写入到</span></span>
<span class="line"><span style="color:#24292E;">        mergeDataCache.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(metrics);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 清理 current 队列的 writing 标记，之后清理 lockedMergeDataCollection </span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">finishWriting</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>将聚合后的 Metrics 写入 MergeDataCache 之后，Consumer 线程会每隔一秒将 MergeDataCache 中的数据发送到下一个 Worker 处理，相关实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sendToNext</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 首先进行队列切换，之后会设置 last 队列的 reading 状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">switchPointer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 此时可能其他的 Consumer 线程还在写入 last队列，需要等待写入完成</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (mergeDataCache.</span><span style="color:#B392F0;">getLast</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">isWriting</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 开始读取 last 队列中的全部 Metrics 数据并发送到下一个 worker 处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">getLast</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">collection</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(data </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        nextWorker.</span><span style="color:#B392F0;">in</span><span style="color:#E1E4E8;">(data);</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 读取完成后，清空 last 队列以及其 reading 状态</span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">finishReadingLast</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sendToNext</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 首先进行队列切换，之后会设置 last 队列的 reading 状态</span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">switchPointer</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 此时可能其他的 Consumer 线程还在写入 last队列，需要等待写入完成</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (mergeDataCache.</span><span style="color:#6F42C1;">getLast</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">isWriting</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 开始读取 last 队列中的全部 Metrics 数据并发送到下一个 worker 处理</span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">getLast</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">collection</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(data </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        nextWorker.</span><span style="color:#6F42C1;">in</span><span style="color:#24292E;">(data);</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 读取完成后，清空 last 队列以及其 reading 状态</span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">finishReadingLast</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>MetricsAggregateWorker 的核心逻辑到这里就分析完了。</p><p>MetricsAggregateWorker 指向的下一个 Worker 是 MetricsRemoteWorker ，其实现与 RegisterRemoteWorker 类似，底层也是通过 RemoteSenderService 将监控数据发送到远端节点，具体实现不再展开。</p><h3 id="metricstransworker" tabindex="-1">MetricsTransWorker <a class="header-anchor" href="#metricstransworker" aria-label="Permalink to &quot;MetricsTransWorker&quot;">​</a></h3><p>MetricsRemoteWorker 之后的下一个 worker 是 MetricsTransWorker，其中有四个字段分别指向四个不同 Downsampling 粒度的 PersistenceWorker 对象，如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> MetricsPersistentWorker minutePersistenceWorker;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> MetricsPersistentWorker hourPersistenceWorker;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> MetricsPersistentWorker dayPersistenceWorker;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> MetricsPersistentWorker monthPersistenceWorker;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> MetricsPersistentWorker minutePersistenceWorker;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> MetricsPersistentWorker hourPersistenceWorker;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> MetricsPersistentWorker dayPersistenceWorker;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> MetricsPersistentWorker monthPersistenceWorker;</span></span></code></pre></div><p>MetricsTransWorker.in() 方法会根据上述字段是否为空，将 Metrics 数据分别转发到不同的 PersistenceWorker 中进行处理：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">in</span><span style="color:#E1E4E8;">(Metrics metrics) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测 Hour、Day、Month 对应的 PersistenceWorker 是否为空，若不为空，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 则将 Metrics 数据拷贝一份并调整时间窗口粒度，交到相应的 </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// PersistenceWorker 处理，这里省略了具体逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 最后，直接转发给 minutePersistenceWorker 进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Objects.</span><span style="color:#B392F0;">nonNull</span><span style="color:#E1E4E8;">(minutePersistenceWorker)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        aggregationMinCounter.</span><span style="color:#B392F0;">inc</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        minutePersistenceWorker.</span><span style="color:#B392F0;">in</span><span style="color:#E1E4E8;">(metrics);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">in</span><span style="color:#24292E;">(Metrics metrics) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测 Hour、Day、Month 对应的 PersistenceWorker 是否为空，若不为空，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 则将 Metrics 数据拷贝一份并调整时间窗口粒度，交到相应的 </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// PersistenceWorker 处理，这里省略了具体逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 最后，直接转发给 minutePersistenceWorker 进行处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Objects.</span><span style="color:#6F42C1;">nonNull</span><span style="color:#24292E;">(minutePersistenceWorker)) { </span></span>
<span class="line"><span style="color:#24292E;">        aggregationMinCounter.</span><span style="color:#6F42C1;">inc</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        minutePersistenceWorker.</span><span style="color:#6F42C1;">in</span><span style="color:#24292E;">(metrics);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="metricspersistentworker" tabindex="-1">MetricsPersistentWorker <a class="header-anchor" href="#metricspersistentworker" aria-label="Permalink to &quot;MetricsPersistentWorker&quot;">​</a></h3><p>MetricsPersistentWorker 主要负责 Metrics 数据的持久化，其核心结构如下图所示：</p>`,17),A=s("p",null,"与前文介绍的 MetricsAggregateWorker 处理流程类似，MetricsPersistentWorker 在接收到 Metrics 数据的时候先将其暂存到 DataCarrier 中，然后由后续 Consumer 线程消费。",-1),M=s("br",null,null,-1),k=s("p",null,"Consumer 线程实际上调用的是 PersistenceWorker.onWork() 方法，PersistenceWorker是 MetricsPersistentWorker 的父类，继承关系如下图所示：",-1),b=l(`<p>RecordPersistenceWorker 等子类在后面会详细分析。</p><p>PersistenceWorker.onWork() 方法的逻辑是将 Metrics 数据写入 MergeDataCache 中暂存，待其中积累的数据量到达阈值（固定值 1000）之后，会进行一次批量写入 ElasticSearch 的操作，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onWork</span><span style="color:#E1E4E8;">(INPUT input) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测 current 队列中缓冲的数据量是否打到阈值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">getCache</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">currentCollectionSize</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> batchSize) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 检测是否符合切换缓冲队列的条件，在分析 Windows 抽象类时也说过，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// trySwitchPointer()会检测 windowSwitch 标记以及 last 队列的 reading状态</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">getCache</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">trySwitchPointer</span><span style="color:#E1E4E8;">()) { </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 切换 current 缓冲队列，同时会设置切换后的 last 队列的 reading标记</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">getCache</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">switchPointer</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 创建一批请求并批量执行</span></span>
<span class="line"><span style="color:#E1E4E8;">                List&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; collection </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buildBatchCollection</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                batchDAO.</span><span style="color:#B392F0;">batchPersistence</span><span style="color:#E1E4E8;">(collection);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// trySwitchPointerFinally()方法会重置 windowSwitch标记</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">getCache</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">trySwitchPointerFinally</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">cacheData</span><span style="color:#E1E4E8;">(input); </span><span style="color:#6A737D;">// 写入缓存</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onWork</span><span style="color:#24292E;">(INPUT input) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测 current 队列中缓冲的数据量是否打到阈值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">getCache</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">currentCollectionSize</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> batchSize) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 检测是否符合切换缓冲队列的条件，在分析 Windows 抽象类时也说过，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// trySwitchPointer()会检测 windowSwitch 标记以及 last 队列的 reading状态</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">getCache</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">trySwitchPointer</span><span style="color:#24292E;">()) { </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 切换 current 缓冲队列，同时会设置切换后的 last 队列的 reading标记</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">getCache</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">switchPointer</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 创建一批请求并批量执行</span></span>
<span class="line"><span style="color:#24292E;">                List&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; collection </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buildBatchCollection</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                batchDAO.</span><span style="color:#6F42C1;">batchPersistence</span><span style="color:#24292E;">(collection);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// trySwitchPointerFinally()方法会重置 windowSwitch标记</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">getCache</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">trySwitchPointerFinally</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">cacheData</span><span style="color:#24292E;">(input); </span><span style="color:#6A737D;">// 写入缓存</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>下面深入 onWorker() 方法的细节实现中进行分析。先来看 cacheData() 方法，MetricsPersistentWorker 在该方法实现中提供了标准的写入 MergeDataCache 操作：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">cacheData</span><span style="color:#E1E4E8;">(Metrics input) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 lockedMergeDataCollection 指向 current 队列，并设置其 writing 标记</span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">writing</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (mergeDataCache.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(input)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 存在重复的监控数据，则进行合并</span></span>
<span class="line"><span style="color:#E1E4E8;">        Metrics metrics </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mergeDataCache.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(input);</span></span>
<span class="line"><span style="color:#E1E4E8;">        metrics.</span><span style="color:#B392F0;">combine</span><span style="color:#E1E4E8;">(input);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 重新计算该监控值，不同 Metrics 实现的计算方式不同，例如，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// LongAvgMetrics.calculate()方法就是计算平均值</span></span>
<span class="line"><span style="color:#E1E4E8;">        metrics.</span><span style="color:#B392F0;">calculate</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        input.</span><span style="color:#B392F0;">calculate</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 第一次计算该监控值</span></span>
<span class="line"><span style="color:#E1E4E8;">        mergeDataCache.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(input);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 更新 lockedMergeDataCollection 队列的 writing 状态，然后清空lockedMergeDataCollection</span></span>
<span class="line"><span style="color:#E1E4E8;">    mergeDataCache.</span><span style="color:#B392F0;">finishWriting</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">cacheData</span><span style="color:#24292E;">(Metrics input) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 lockedMergeDataCollection 指向 current 队列，并设置其 writing 标记</span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">writing</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (mergeDataCache.</span><span style="color:#6F42C1;">containsKey</span><span style="color:#24292E;">(input)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 存在重复的监控数据，则进行合并</span></span>
<span class="line"><span style="color:#24292E;">        Metrics metrics </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mergeDataCache.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(input);</span></span>
<span class="line"><span style="color:#24292E;">        metrics.</span><span style="color:#6F42C1;">combine</span><span style="color:#24292E;">(input);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 重新计算该监控值，不同 Metrics 实现的计算方式不同，例如，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// LongAvgMetrics.calculate()方法就是计算平均值</span></span>
<span class="line"><span style="color:#24292E;">        metrics.</span><span style="color:#6F42C1;">calculate</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        input.</span><span style="color:#6F42C1;">calculate</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 第一次计算该监控值</span></span>
<span class="line"><span style="color:#24292E;">        mergeDataCache.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(input);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 更新 lockedMergeDataCollection 队列的 writing 状态，然后清空lockedMergeDataCollection</span></span>
<span class="line"><span style="color:#24292E;">    mergeDataCache.</span><span style="color:#6F42C1;">finishWriting</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来看 buildBatchCollection() 方法的实现。在前面的 trySwitchPointer() 检测中只保证了 last 队列已退出 reading 状态，并未检查 current 队列是否已经退出了writing 状态，所以在切换完成后，第一件事就是先循环等待 last 队列（切换前是 current 队列）退出 writing 状态：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">getCache</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getLast</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">isWriting</span><span style="color:#E1E4E8;">()) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">);   </span><span style="color:#6A737D;">// 循环检测 last 队列的 writing 状态</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">getCache</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getLast</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">isWriting</span><span style="color:#24292E;">()) { </span></span>
<span class="line"><span style="color:#24292E;">    Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">);   </span><span style="color:#6A737D;">// 循环检测 last 队列的 writing 状态</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>当 last 队列解除了 writing 状态的时候，上面的循环会退出，然后执行 prepareBatch() 方法遍历 last 队列，为每一个 Metrics 对象生成一条相应的 IndexRequest 或 UpdateRequest，具体的处理如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 根据id从底层存储中查询 Metrics</span></span>
<span class="line"><span style="color:#E1E4E8;">Metrics dbData </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> metricsDAO.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(model, data);</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">nonNull</span><span style="color:#E1E4E8;">(dbData)) { </span><span style="color:#6A737D;">// 已存在相应的 Document</span></span>
<span class="line"><span style="color:#E1E4E8;">    data.</span><span style="color:#B392F0;">combine</span><span style="color:#E1E4E8;">(dbData); </span><span style="color:#6A737D;">// 已存在则进行合并</span></span>
<span class="line"><span style="color:#E1E4E8;">    data.</span><span style="color:#B392F0;">calculate</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 重新计算 value 值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 产生相应的 UpdateRequest 请求，并添加到 batchCollection 集合中</span></span>
<span class="line"><span style="color:#E1E4E8;">    batchCollection.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(metricsDAO.</span><span style="color:#B392F0;">prepareBatchUpdate</span><span style="color:#E1E4E8;">(model, data));</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 产生相应的 IndexRequest 请求，并添加到 batchCollection 集合中</span></span>
<span class="line"><span style="color:#E1E4E8;">    batchCollection.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(metricsDAO.</span><span style="color:#B392F0;">prepareBatchInsert</span><span style="color:#E1E4E8;">(model, data));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 根据id从底层存储中查询 Metrics</span></span>
<span class="line"><span style="color:#24292E;">Metrics dbData </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> metricsDAO.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(model, data);</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">nonNull</span><span style="color:#24292E;">(dbData)) { </span><span style="color:#6A737D;">// 已存在相应的 Document</span></span>
<span class="line"><span style="color:#24292E;">    data.</span><span style="color:#6F42C1;">combine</span><span style="color:#24292E;">(dbData); </span><span style="color:#6A737D;">// 已存在则进行合并</span></span>
<span class="line"><span style="color:#24292E;">    data.</span><span style="color:#6F42C1;">calculate</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 重新计算 value 值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 产生相应的 UpdateRequest 请求，并添加到 batchCollection 集合中</span></span>
<span class="line"><span style="color:#24292E;">    batchCollection.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(metricsDAO.</span><span style="color:#6F42C1;">prepareBatchUpdate</span><span style="color:#24292E;">(model, data));</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 产生相应的 IndexRequest 请求，并添加到 batchCollection 集合中</span></span>
<span class="line"><span style="color:#24292E;">    batchCollection.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(metricsDAO.</span><span style="color:#6F42C1;">prepareBatchInsert</span><span style="color:#24292E;">(model, data));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里产生的 batchCollection 集合接下来会交给 BatchProcessEsDAO 批量执行，其底层是通过 ES High Level Client 提供的 BulkProcessor 实现批量操作的，该部分实现位于 BatchProcessEsDAO.batchPersistence() 方法中，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">batchPersistence</span><span style="color:#E1E4E8;">(List</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> batchCollection) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (bulkProcessor </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 创建 BulkProcessor，创建方式与前面&quot;ElasticSearch基础入门&quot;小节中展示的示例相同，不再重复</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.bulkProcessor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getClient</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">createBulkProcessor</span><span style="color:#E1E4E8;">(bulkActions, bulkSize, flushInterval, concurrentRequests);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    batchCollection.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(builder </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 遍历batchCollection，将 Request添加到BulkProcessor中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (builder </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> IndexRequest) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.bulkProcessor.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">((IndexRequest)builder);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (builder </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> UpdateRequest) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.bulkProcessor.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">((UpdateRequest)builder);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.bulkProcessor.</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 将上面添加的请求发送到 ElasticSearch 集群执行</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">batchPersistence</span><span style="color:#24292E;">(List</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> batchCollection) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (bulkProcessor </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 创建 BulkProcessor，创建方式与前面&quot;ElasticSearch基础入门&quot;小节中展示的示例相同，不再重复</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.bulkProcessor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getClient</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">createBulkProcessor</span><span style="color:#24292E;">(bulkActions, bulkSize, flushInterval, concurrentRequests);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    batchCollection.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(builder </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 遍历batchCollection，将 Request添加到BulkProcessor中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (builder </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> IndexRequest) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.bulkProcessor.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">((IndexRequest)builder);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (builder </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> UpdateRequest) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.bulkProcessor.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">((UpdateRequest)builder);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.bulkProcessor.</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 将上面添加的请求发送到 ElasticSearch 集群执行</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>从上面的代码中我们可以看到，在一个 OAP 实例中只会创建一个 BulkProcessor 对象，然后将其封装到 BatchProcessEsDAO 中循环使用。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>到这里，SkyWalking OAP 处理 Metrics 监控数据的整个流程就分析完了。下面通过一张图总结整个处理流程：</p>`,14),P=s("p",null,"JVMMetricReportServiceHandler 在收到 JVM Metrics 请求时，由 DispatcherManager 对 JVMMetric 进行分类（ CPU、Memory、MemoryPool、GC 四类）并转换成相应的 Source 对象，接下来根据 Source 类型查找相应的 SourceDispatcher 集合进行处理。",-1),S=s("p",null,"在 SourceDispatcher 中会将监控数据再次拆分，转换单一维度的 Metrics 对象，例如，在 ServiceInstanceJVMGCDispatcher 中会将 GC 监控拆分成 Old GC Time、Old GC Count、New GC Time、New GC Count 四类。之后，SourceDispatcher 会将 Metrics 对象传递给 MetricsStreamProcessor 中的 worker 进行处理。",-1),B=s("p",null,"MetricsAggregateWorker 通过 MergeDataCache 对 Metrics 数据进行暂存以及简单聚合。",-1),_=s("p",null,"MetricsRemoteWorker 通过底层的 RemoteSenderService 将 Metrics 数据送到 OAP 集群中的其他远端节点。",-1),I=s("p",null,"MetricsTransWorker 会将 Metrics 数据复制多份，转发到各个 DownSampling 对应的 MetricsPersistentWorker 中实现持久化。",-1),W=s("p",null,"MetricsPersistentWorker 会先将数据缓存在 MergeDataCache 中，当缓存数据量到达一定阈值，执行批量写入（或更新） ElasticSearch 操作，批量操作是通过 High Level Client 中的 BulkProcessor 实现的。",-1);function w(T,G,f,J,V,q){const n=p("Image");return o(),t("div",null,[i,E,y,d,g,a(n,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/18/79/Ciqc1F7YtnGAMAYGAAJwEbFWmzY337.png"}),u,a(n,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/18/79/Ciqc1F7YtoOABepsAAEMFZwAVUo208.png"}),h,a(n,{alt:"image (7).png",src:"https://s0.lgstatic.com/i/image/M00/18/79/Ciqc1F7Ytp6AYxkTAAE2IyTdv1A381.png"}),m,a(n,{alt:"image (8).png",src:"https://s0.lgstatic.com/i/image/M00/18/85/CgqCHl7YtreATj7GAARBmbdpdkw991.png"}),C,a(n,{alt:"image (9).png",src:"https://s0.lgstatic.com/i/image/M00/18/7A/Ciqc1F7Yts6AUU4bAABZiou-upc728.png"}),D,a(n,{alt:"image (10).png",src:"https://s0.lgstatic.com/i/image/M00/18/7A/Ciqc1F7YtumAfQZeAAFcY5KP8TM078.png"}),F,a(n,{alt:"image (11).png",src:"https://s0.lgstatic.com/i/image/M00/18/86/CgqCHl7YtwqAOhwEAAGQdRPvCuM193.png"}),v,a(n,{alt:"image (12).png",src:"https://s0.lgstatic.com/i/image/M00/18/7A/Ciqc1F7YtziAPKFvAAFUA42eQDc822.png"}),A,M,k,a(n,{alt:"image (13).png",src:"https://s0.lgstatic.com/i/image/M00/18/86/CgqCHl7Yt0SAW_XHAAGAflXWY6Q440.png"}),b,a(n,{alt:"image (14).png",src:"https://s0.lgstatic.com/i/image/M00/18/7B/Ciqc1F7Yt2OAJnGpAABb_jqSXp0511.png"}),P,S,B,_,I,W])}const j=e(r,[["render",w]]);export{O as __pageData,j as default};
