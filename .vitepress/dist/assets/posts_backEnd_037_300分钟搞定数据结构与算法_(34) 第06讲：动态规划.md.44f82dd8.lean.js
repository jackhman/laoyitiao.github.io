import{_ as e,j as o,o as t,g as i,k as a,Q as p,s,h as l}from"./chunks/framework.e0c66c3f.js";const Y=JSON.parse('{"title":"判断动态规划 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/037_300分钟搞定数据结构与算法/(34) 第06讲：动态规划.md","filePath":"posts/backEnd/037_300分钟搞定数据结构与算法/(34) 第06讲：动态规划.md","lastUpdated":1696338709000}'),c={name:"posts/backEnd/037_300分钟搞定数据结构与算法/(34) 第06讲：动态规划.md"},r=p("",11),E=s("ol",{start:"2"},[s("li",null,"是编程的方法------重叠子问题")],-1),y=s("br",null,null,-1),d=s("p",null,"动态规划是编程的方法指，可以借助编程的技巧去保证每个重叠的子问题只会被求解一次。",-1),u=s("br",null,null,-1),h=s("p",null,"引出了动态规划的第二个重要的属性：重叠子问题（Overlapping Sub-problems）。",-1),m=s("p",null,"下面通过几个小例题来判断其方法是否符合动态规划。",-1),f=s("p",null,[s("strong",null,"举例 1"),l("：斐波那契数列问题。")],-1),_=s("br",null,null,-1),g=s("p",null,"解法：为了求出第 5 个斐波那契数，得先求出第 4 个和第 3 个数，但是在求第 4 个数的时候，又得重复计算一次第 3 个数，同样，对于第 2 个数的计算也出现了重复。",-1),b=s("p",null,"因此，判断一个问题能不能称得上是动态规划的问题，需要看它是否同时满足这两个重要的属性：最优子结构（Optimal Substructure）和重叠子问题（Overlapping Sub-problems）",-1),x=s("p",null,[s("strong",null,"举例 2"),l("：给定如下的一个有向图，求出从顶点 A 到 C 的最长的路径。要求路径中的点只能出现一次。")],-1),A=s("p",null,"按照题目的要求，可以看到，从 A 通往 C 有两条最长的路径：A -> B -> C 和 A -> D -> C。",-1),T=s("br",null,null,-1),B=s("p",null,"对于 A -> B -> C，A 到 B 的最长距离是：A -> D -> C -> B",-1),j=s("p",null,"B 到 C 的最长距离是：B -> A -> D -> C",-1),q=s("p",null,"组合路径：A -> D -> C -> B -> A -> D -> C",-1),O=p("",26),C=s("p",null,"[10, 9, 2, 5] 最长的子序列应该是 [2, 5]，而 [3, 7, 101, 4] 最长的子序列是 [3, 7, 101]，由于 3 比 5 小，无法简单地组合在一起。即该方法下，总问题的解无法直观地通过子问题的最优解求得。",-1),k=s("ol",{start:"2"},[s("li",null,"找最优子结构：每次减一个")],-1),D=s("br",null,null,-1),S=s("p",null,"假设 f(n) 表示的是数组 nums[0，...，n−1] 中最长的子序列，那么 f(n−1) 就是数组 nums[0，...，n−2] 中最长的子序列，依此类推，f(1) 就是 nums[0] 的最长子序列。",-1),P=s("p",null,"假设已经解决了 f(1)，f(2)，... f(n−1) 的问题，考虑最后一个数 nums[n−1]，也必然考虑到倒数第二个数 nums[n−2]，所以 f(n) 指：如果包含了最后的数，那么最长的子序列应该是什么。",-1),I=s("p",null,"注意：最后这个数必须包含在子序列当中的。",-1),v=s("p",null,"如何通过 f(1)，f(2)，...f(n−1) 推导出 f(n) 呢？由于最后一个数是 4，我们只需要在前面的 f(1)，f(2)，...f(n−1) 当中，找出一个以小于 4 的数作为结尾的最长的子序列，然后把 4 添加到最后，那么 f(n) 就一定是以 4 作为结尾的最长的子序列了。",-1),F=s("p",null,"最长的子序列并不一定会包含 4，遍历 f(1)，f(2)，...f(n−1) ，找出最长的。例如，以 101 结尾的最长的上升子序列是什么。",-1),M=p("",41),H=p("",42),V=p("",49),L=s("p",null,"而计算机都是用二进制来表示一个数，假设涵盖从 0 到 W 的区间需要 m 位的二进制数，那么 W 就能写成 2^m^。因此 0-1 背包问题的复杂度就成为了 O(n×2^m^)。",-1),N=s("p",null,"现在问题的规模取决于物品的个数以及需要用多少位二进制数来表示背包的重量，很明显，它是一个指数级的计算量，是一个非多项式级别的复杂度。",-1),W=s("h6",{id:"结语",tabindex:"-1"},[l("结语 "),s("a",{class:"header-anchor",href:"#结语","aria-label":'Permalink to "结语"'},"​")],-1),R=s("p",null,"这节课后，大家应该能对动态规划有了比较清晰的认识。学习动态规划没有什么捷径，除了掌握好本节课的知识点，更重要的是多练。",-1),z=s("br",null,null,-1);function w(K,U,Z,$,G,J){const n=o("Image");return t(),i("div",null,[r,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/EF/CgoB5l2IcqKAT-iFAAvZ0mB2w9o185.gif"}),E,y,d,u,h,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/0F/CgotOV2IcqKAee79ADIs6KpFExY310.gif"}),m,f,_,g,b,x,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/EF/CgoB5l2IcqOAXphFAA-GWGuo2C0144.gif"}),A,T,B,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/0F/CgotOV2IcqSAeVmBABezjz1sSV0529.gif"}),j,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/EF/CgoB5l2IcqSAb1L3ABPxU8fyZuk520.gif"}),q,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/0F/CgotOV2IcqWAfxMeABZ4L440D5c286.gif"}),O,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/EF/CgoB5l2IcqWAfAX8ACiK5xevrOI755.gif"}),C,k,D,S,P,I,v,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/0F/CgotOV2IcqWAdiFJACpjs_86OCY252.gif"}),F,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/EF/CgoB5l2IcqaAZ_nOADpppdMvQp0237.gif"}),M,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/0F/CgotOV2IcqaAZ_YzABSfIxvIih8411.gif"}),H,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/EF/CgoB5l2IcqeAQlJTAAAkWU86cG8012.png"}),V,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/0F/CgotOV2IcqeARptuAAAixqNCom0540.png"}),L,N,W,R,z])}const X=e(c,[["render",w]]);export{Y as __pageData,X as default};
