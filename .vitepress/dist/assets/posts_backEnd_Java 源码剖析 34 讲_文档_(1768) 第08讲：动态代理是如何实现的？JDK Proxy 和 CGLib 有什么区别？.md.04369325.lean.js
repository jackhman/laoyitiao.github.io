import{_ as o,j as e,o as t,h as c,k as a,f as l,Q as p,s}from"./chunks/framework.d3daa342.js";const B=JSON.parse('{"title":"第08讲：动态代理是如何实现的？JDKProxy和CGLib有什么区别？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md","filePath":"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/Java 源码剖析 34 讲_文档/(1768) 第08讲：动态代理是如何实现的？JDK Proxy 和 CGLib 有什么区别？.md"},E=p("",37),y=s("p",null,"接下来讲讲 Lombok 的原理。",-1),i=s("p",null,"Lombok 的实现和反射没有任何关系，前面我们说了反射是程序在运行期的一种自省（introspect）能力，而 Lombok 的实现是在编译期就完成了，为什么这么说呢？",-1),F=s("p",null,"回到我们刚才 Setter/Getter 的方法，当我们打开 Person 的编译类就会发现，使用了 Lombok 的 @Data 注解后的源码竟然是这样的：",-1),g=s("p",null,"可以看出 Lombok 是在编译期就为我们生成了对应的字节码。",-1),d=s("p",null,"其实 Lombok 是基于 Java 1.6 实现的 JSR 269: Pluggable Annotation Processing API 来实现的，也就是通过编译期自定义注解处理器来实现的，它的执行步骤如下：",-1),D=p("",8);function A(b,h,u,C,v,m){const n=e("Image");return t(),c("div",null,[E,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/05/Ciqah16HCB6AcjsPAAIhVz8yo1o620.png"}),l(),y,i,F,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/1B/Cgq2xl6HCB6AXaC5AAHG477g0yQ093.png"}),l(),g,d,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/1B/Cgq2xl6HCB-AAsAKAACfTHorgDA111.png"}),l(),D])}const k=o(r,[["render",A]]);export{B as __pageData,k as default};
