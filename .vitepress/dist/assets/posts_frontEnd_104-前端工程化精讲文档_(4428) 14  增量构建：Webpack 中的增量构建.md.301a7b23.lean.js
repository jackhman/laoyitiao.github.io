import{_ as o,j as e,o as c,g as t,k as n,h as s,Q as p,s as l}from"./chunks/framework.4e7d56ce.js";const f=JSON.parse('{"title":"14增量构建：Webpack中的增量构建","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/104-前端工程化精讲文档/(4428) 14  增量构建：Webpack 中的增量构建.md","filePath":"posts/frontEnd/104-前端工程化精讲文档/(4428) 14  增量构建：Webpack 中的增量构建.md","lastUpdated":1696417798000}'),r={name:"posts/frontEnd/104-前端工程化精讲文档/(4428) 14  增量构建：Webpack 中的增量构建.md"},E=p("",8),i=p("",4),y=p("",4),h=l("p",null,[s("正如我们所期望的，再次构建时，在编译模块阶段只对有变化的文件进行了重新编译，实现了"),l("strong",null,"增量编译"),s("的效果。")],-1),d=l("p",null,"但是美中不足的是，在优化阶段压缩代码时仍然耗费了较多的时间。这一点很容易理解：",-1),u=l("p",null,"体积最大的 react、react-dom 等模块和入口模块打入了同一个 Chunk 中，即使修改的模块是单独分离的 bar.js，但它的产物名称的变化仍然需要反映在入口 Chunk 的 runtime 模块中。因此入口 Chunk 也需要跟着重新压缩而无法复用压缩缓存数据。根据前面几节课的知识点，我们对配置再做一些优化，将 vendor 分离后再来看看效果，如下面的图片所示：",-1),g=p("",25);function m(b,F,C,_,A,k){const a=e("Image");return c(),t("div",null,[E,n(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/57/0E/CgqCHl9sTsWAbetxAAGoldlDrIw704.png"}),s(),n(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/57/03/Ciqc1F9sTsmAJc8YAADz9x_Zsvo780.png"}),s(),i,n(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/57/0E/CgqCHl9sTtOAPzPRAAHMQJnGHlo474.png"}),s(),n(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/57/0E/CgqCHl9sTtiAB2seAAG0v0B0ORQ594.png"}),s(),y,n(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/57/0F/CgqCHl9sTuuAc0_4AAHBe2Lt3do732.png"}),s(),n(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/57/03/Ciqc1F9sTvCAY2NvAAEtJYxCA_8121.png"}),s(),h,d,u,n(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/57/0F/CgqCHl9sTvqAP1oIAAG2kbb-DGY688.png"}),s(),n(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/57/0F/CgqCHl9sTv6AYxTKAAFAsmUEZMg953.png"}),s(),g])}const w=o(r,[["render",m]]);export{f as __pageData,w as default};
