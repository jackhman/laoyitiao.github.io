import{_ as e,j as o,o as t,g as r,k as n,h as a,s as l,Q as p}from"./chunks/framework.4e7d56ce.js";const I=JSON.parse('{"title":"ChannelBuffer 接口 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4270) 18  Buffer 缓冲区：我们不生产数据，我们只是数据的搬运工.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4270) 18  Buffer 缓冲区：我们不生产数据，我们只是数据的搬运工.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4270) 18  Buffer 缓冲区：我们不生产数据，我们只是数据的搬运工.md"},y=l("p",null,"Buffer 是一种字节容器，在 Netty 等 NIO 框架中都有类似的设计，例如，Java NIO 中的ByteBuffer、Netty4 中的 ByteBuf。Dubbo 抽象出了 ChannelBuffer 接口对底层 NIO 框架中的 Buffer 设计进行统一，其子类如下图所示：",-1),E=p('<p>ChannelBuffer 继承关系图</p><p>下面我们就按照 ChannelBuffer 的继承结构，从顶层的 ChannelBuffer 接口开始，逐个向下介绍，直至最底层的各个实现类。</p><h3 id="channelbuffer-接口" tabindex="-1">ChannelBuffer 接口 <a class="header-anchor" href="#channelbuffer-接口" aria-label="Permalink to &quot;ChannelBuffer 接口&quot;">​</a></h3><p><strong>ChannelBuffer 接口</strong>的设计与 Netty4 中 ByteBuf 抽象类的设计基本一致，也有 readerIndex 和 writerIndex 指针的概念，如下所示，它们的核心方法也是如出一辙。</p><ul><li><p>getBytes()、setBytes() 方法：从参数指定的位置读、写当前 ChannelBuffer，不会修改 readerIndex 和 writerIndex 指针的位置。</p></li><li><p>readBytes() 、writeBytes() 方法：也是读、写当前 ChannelBuffer，但是 readBytes() 方法会从 readerIndex 指针开始读取数据，并移动 readerIndex 指针；writeBytes() 方法会从 writerIndex 指针位置开始写入数据，并移动 writerIndex 指针。</p></li><li><p>markReaderIndex()、markWriterIndex() 方法：记录当前 readerIndex 指针和 writerIndex 指针的位置，一般会和 resetReaderIndex()、resetWriterIndex() 方法配套使用。resetReaderIndex() 方法会将 readerIndex 指针重置到 markReaderIndex() 方法标记的位置，resetwriterIndex() 方法同理。</p></li><li><p>capacity()、clear()、copy() 等辅助方法用来获取 ChannelBuffer 容量以及实现清理、拷贝数据的功能，这里不再赘述。</p></li><li><p>factory() 方法：该方法返回创建 ChannelBuffer 的工厂对象，ChannelBufferFactory 中定义了多个 getBuffer() 方法重载来创建 ChannelBuffer，如下图所示，这些 ChannelBufferFactory的实现都是单例的。</p></li></ul>',5),i=p(`<p>ChannelBufferFactory 继承关系图</p><p><strong>AbstractChannelBuffer 抽象类</strong>实现了 ChannelBuffer 接口的大部分方法，其核心是维护了以下四个索引。</p><ul><li><p>readerIndex、writerIndex（int 类型）：通过 readBytes() 方法及其重载读取数据时，会后移 readerIndex 索引；通过 writeBytes() 方法及其重载写入数据的时候，会后移 writerIndex 索引。</p></li><li><p>markedReaderIndex、markedWriterIndex（int 类型）：实现记录 readerIndex（writerIndex）以及回滚 readerIndex（writerIndex）的功能，前面我们已经介绍过markReaderIndex() 方法、resetReaderIndex() 方法以及 markWriterIndex() 方法、resetWriterIndex() 方法，你可以对比学习。</p></li></ul><p>AbstractChannelBuffer 中 readBytes() 和 writeBytes() 方法的各个重载最终会通过 getBytes() 方法和 setBytes() 方法实现数据的读写，这些方法在 AbstractChannelBuffer 子类中实现。下面以读写一个 byte 数组为例，进行介绍：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">readBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] dst, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dstIndex, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测可读字节数是否足够</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">checkReadableBytes</span><span style="color:#E1E4E8;">(length);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将readerIndex之后的length个字节数读取到dst数组中dstIndex~</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// dstIndex+length的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">getBytes</span><span style="color:#E1E4E8;">(readerIndex, dst, dstIndex, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将readerIndex后移length个字节</span></span>
<span class="line"><span style="color:#E1E4E8;">    readerIndex </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> length;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">writeBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] src, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> srcIndex, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将src数组中srcIndex~srcIndex+length的数据写入当前buffer中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// writerIndex~writerIndex+length的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setBytes</span><span style="color:#E1E4E8;">(writerIndex, src, srcIndex, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将writeIndex后移length个字节</span></span>
<span class="line"><span style="color:#E1E4E8;">    writerIndex </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> length;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">readBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] dst, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dstIndex, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测可读字节数是否足够</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">checkReadableBytes</span><span style="color:#24292E;">(length);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将readerIndex之后的length个字节数读取到dst数组中dstIndex~</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// dstIndex+length的位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">getBytes</span><span style="color:#24292E;">(readerIndex, dst, dstIndex, length);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将readerIndex后移length个字节</span></span>
<span class="line"><span style="color:#24292E;">    readerIndex </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> length;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">writeBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] src, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> srcIndex, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将src数组中srcIndex~srcIndex+length的数据写入当前buffer中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// writerIndex~writerIndex+length的位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setBytes</span><span style="color:#24292E;">(writerIndex, src, srcIndex, length);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将writeIndex后移length个字节</span></span>
<span class="line"><span style="color:#24292E;">    writerIndex </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> length;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="buffer-各实现类解析" tabindex="-1">Buffer 各实现类解析 <a class="header-anchor" href="#buffer-各实现类解析" aria-label="Permalink to &quot;Buffer 各实现类解析&quot;">​</a></h3><p>了解了 ChannelBuffer 接口的核心方法以及 AbstractChannelBuffer 的公共实现之后，我们再来看 ChannelBuffer 的具体实现。</p><p><strong>HeapChannelBuffer 是基于字节数组的 ChannelBuffer 实现</strong>，我们可以看到其中有一个 array（byte[]数组）字段，它就是 HeapChannelBuffer 存储数据的地方。HeapChannelBuffer 的 setBytes() 以及 getBytes() 方法实现是调用 System.arraycopy() 方法完成数组操作的，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index, </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] src, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> srcIndex, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.</span><span style="color:#B392F0;">arraycopy</span><span style="color:#E1E4E8;">(src, srcIndex, array, index, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index, </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] dst, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dstIndex, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.</span><span style="color:#B392F0;">arraycopy</span><span style="color:#E1E4E8;">(array, index, dst, dstIndex, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index, </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] src, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> srcIndex, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    System.</span><span style="color:#6F42C1;">arraycopy</span><span style="color:#24292E;">(src, srcIndex, array, index, length);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index, </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] dst, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dstIndex, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    System.</span><span style="color:#6F42C1;">arraycopy</span><span style="color:#24292E;">(array, index, dst, dstIndex, length);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>HeapChannelBuffer 对应的 ChannelBufferFactory 实现是 HeapChannelBufferFactory，其 getBuffer() 方法会通过 ChannelBuffers 这个工具类创建一个指定大小 HeapChannelBuffer 对象，下面简单介绍两个 getBuffer() 方法重载：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> ChannelBuffer </span><span style="color:#B392F0;">getBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> capacity) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 新建一个HeapChannelBuffer，底层的会新建一个长度为capacity的byte数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ChannelBuffers.</span><span style="color:#B392F0;">buffer</span><span style="color:#E1E4E8;">(capacity); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> ChannelBuffer </span><span style="color:#B392F0;">getBuffer</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] array, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> offset, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 新建一个HeapChannelBuffer，并且会拷贝array数组中offset~offset+lenght</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 的数据到新HeapChannelBuffer中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ChannelBuffers.</span><span style="color:#B392F0;">wrappedBuffer</span><span style="color:#E1E4E8;">(array, offset, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> ChannelBuffer </span><span style="color:#6F42C1;">getBuffer</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> capacity) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 新建一个HeapChannelBuffer，底层的会新建一个长度为capacity的byte数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ChannelBuffers.</span><span style="color:#6F42C1;">buffer</span><span style="color:#24292E;">(capacity); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> ChannelBuffer </span><span style="color:#6F42C1;">getBuffer</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] array, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> offset, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 新建一个HeapChannelBuffer，并且会拷贝array数组中offset~offset+lenght</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 的数据到新HeapChannelBuffer中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ChannelBuffers.</span><span style="color:#6F42C1;">wrappedBuffer</span><span style="color:#24292E;">(array, offset, length);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其他 getBuffer() 方法重载这里就不再展示，你若感兴趣的话可以参考源码进行学习。<br><strong>DynamicChannelBuffer 可以认为是其他 ChannelBuffer 的装饰器，它可以为其他 ChannelBuffer 添加动态扩展容量的功能</strong>。DynamicChannelBuffer 中有两个核心字段：</p><ul><li><p>buffer（ChannelBuffer 类型），是被修饰的 ChannelBuffer，默认为 HeapChannelBuffer。</p></li><li><p>factory（ChannelBufferFactory 类型），用于创建被修饰的 HeapChannelBuffer 对象的 ChannelBufferFactory 工厂，默认为 HeapChannelBufferFactory。</p></li></ul><p>DynamicChannelBuffer 需要关注的是 ensureWritableBytes() 方法，该方法实现了动态扩容的功能，在每次写入数据之前，都需要调用该方法确定当前可用空间是否足够，调用位置如下图所示：</p>`,14),f=p(`<p>ensureWritableBytes() 方法如果检测到底层 ChannelBuffer 对象的空间不足，则会创建一个新的 ChannelBuffer（空间扩大为原来的两倍），然后将原来 ChannelBuffer 中的数据拷贝到新 ChannelBuffer 中，最后将 buffer 字段指向新 ChannelBuffer 对象，完成整个扩容操作。ensureWritableBytes() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ensureWritableBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> minWritableBytes) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (minWritableBytes </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">writableBytes</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> newCapacity;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">capacity</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        newCapacity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        newCapacity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">capacity</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> minNewCapacity </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">writerIndex</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> minWritableBytes;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (newCapacity </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> minNewCapacity) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        newCapacity </span><span style="color:#F97583;">&lt;&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ChannelBuffer newBuffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">factory</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getBuffer</span><span style="color:#E1E4E8;">(newCapacity);</span></span>
<span class="line"><span style="color:#E1E4E8;">    newBuffer.</span><span style="color:#B392F0;">writeBytes</span><span style="color:#E1E4E8;">(buffer, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">writerIndex</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    buffer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newBuffer;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ensureWritableBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> minWritableBytes) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (minWritableBytes </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">writableBytes</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> newCapacity;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">capacity</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        newCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">capacity</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> minNewCapacity </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">writerIndex</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> minWritableBytes;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (newCapacity </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> minNewCapacity) {</span></span>
<span class="line"><span style="color:#24292E;">        newCapacity </span><span style="color:#D73A49;">&lt;&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    ChannelBuffer newBuffer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">factory</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getBuffer</span><span style="color:#24292E;">(newCapacity);</span></span>
<span class="line"><span style="color:#24292E;">    newBuffer.</span><span style="color:#6F42C1;">writeBytes</span><span style="color:#24292E;">(buffer, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">writerIndex</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    buffer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newBuffer;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>ByteBufferBackedChannelBuffer 是基于 Java NIO 中 ByteBuffer 的 ChannelBuffer 实现</strong>，其中的方法基本都是通过组合 ByteBuffer 的 API 实现的。下面以 getBytes() 方法和 setBytes() 方法的一个重载为例，进行分析：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index, </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] dst, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dstIndex, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ByteBuffer data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> buffer.</span><span style="color:#B392F0;">duplicate</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 移动ByteBuffer中的指针</span></span>
<span class="line"><span style="color:#E1E4E8;">        data.</span><span style="color:#B392F0;">limit</span><span style="color:#E1E4E8;">(index </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> length).</span><span style="color:#B392F0;">position</span><span style="color:#E1E4E8;">(index);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (IllegalArgumentException </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IndexOutOfBoundsException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过ByteBuffer的get()方法实现读取</span></span>
<span class="line"><span style="color:#E1E4E8;">    data.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(dst, dstIndex, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setBytes</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index, </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] src, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> srcIndex, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> length) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ByteBuffer data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> buffer.</span><span style="color:#B392F0;">duplicate</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 移动ByteBuffer中的指针</span></span>
<span class="line"><span style="color:#E1E4E8;">    data.</span><span style="color:#B392F0;">limit</span><span style="color:#E1E4E8;">(index </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> length).</span><span style="color:#B392F0;">position</span><span style="color:#E1E4E8;">(index);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将数据写入底层的ByteBuffer中</span></span>
<span class="line"><span style="color:#E1E4E8;">    data.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(src, srcIndex, length);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index, </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] dst, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dstIndex, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    ByteBuffer data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> buffer.</span><span style="color:#6F42C1;">duplicate</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 移动ByteBuffer中的指针</span></span>
<span class="line"><span style="color:#24292E;">        data.</span><span style="color:#6F42C1;">limit</span><span style="color:#24292E;">(index </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> length).</span><span style="color:#6F42C1;">position</span><span style="color:#24292E;">(index);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (IllegalArgumentException </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IndexOutOfBoundsException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过ByteBuffer的get()方法实现读取</span></span>
<span class="line"><span style="color:#24292E;">    data.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(dst, dstIndex, length);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setBytes</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index, </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] src, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> srcIndex, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> length) {</span></span>
<span class="line"><span style="color:#24292E;">    ByteBuffer data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> buffer.</span><span style="color:#6F42C1;">duplicate</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 移动ByteBuffer中的指针</span></span>
<span class="line"><span style="color:#24292E;">    data.</span><span style="color:#6F42C1;">limit</span><span style="color:#24292E;">(index </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> length).</span><span style="color:#6F42C1;">position</span><span style="color:#24292E;">(index);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将数据写入底层的ByteBuffer中</span></span>
<span class="line"><span style="color:#24292E;">    data.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(src, srcIndex, length);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ByteBufferBackedChannelBuffer 的其他方法实现比较简单，这里就不再展示，你若感兴趣的话可以参考源码进行学习。</p><p><strong>NettyBackedChannelBuffer 是基于 Netty 中 ByteBuf 的 ChannelBuffer 实现</strong>，Netty 中的 ByteBuf 内部维护了 readerIndex 和 writerIndex 以及 markedReaderIndex、markedWriterIndex 这四个索引，所以 NettyBackedChannelBuffer 没有再继承 AbstractChannelBuffer 抽象类，而是直接实现了 ChannelBuffer 接口。</p><p>NettyBackedChannelBuffer 对 ChannelBuffer 接口的实现都是调用底层封装的 Netty ByteBuf 实现的，这里就不再展开介绍，你若感兴趣的话也可以参考相关代码进行学习。</p><h3 id="相关-stream-以及门面类" tabindex="-1">相关 Stream 以及门面类 <a class="header-anchor" href="#相关-stream-以及门面类" aria-label="Permalink to &quot;相关 Stream 以及门面类&quot;">​</a></h3><p>在 ChannelBuffer 基础上，Dubbo 提供了一套输入输出流，如下图所示：</p>`,9),d=l("p",null,"ChannelBufferInputStream 底层封装了一个 ChannelBuffer，其实现 InputStream 接口的 read*() 方法全部都是从 ChannelBuffer 中读取数据。ChannelBufferInputStream 中还维护了一个 startIndex 和一个endIndex 索引，作为读取数据的起止位置。ChannelBufferOutputStream 与 ChannelBufferInputStream 类似，会向底层的 ChannelBuffer 写入数据，这里就不再展开，你若感兴趣的话可以参考源码进行分析。",-1),u=l("p",null,[a("最后要介绍 ChannelBuffers 这个"),l("strong",null,"门面类"),a("，下图展示了 ChannelBuffers 这个门面类的所有方法：")],-1),B=p(`<p>对这些方法进行分类，可归纳出如下这些方法。</p><ul><li><p>dynamicBuffer() 方法：创建 DynamicChannelBuffer 对象，初始化大小由第一个参数指定，默认为 256。</p></li><li><p>buffer() 方法：创建指定大小的 HeapChannelBuffer 对象。</p></li><li><p>wrappedBuffer() 方法：将传入的 byte[] 数字封装成 HeapChannelBuffer 对象。</p></li><li><p>directBuffer() 方法：创建 ByteBufferBackedChannelBuffer 对象，需要注意的是，底层的 ByteBuffer 使用的堆外内存，需要特别关注堆外内存的管理。</p></li><li><p>equals() 方法：用于比较两个 ChannelBuffer 是否相同，其中会逐个比较两个 ChannelBuffer 中的前 7 个可读字节，只有两者完全一致，才算两个 ChannelBuffer 相同。其核心实现如下示例代码：</p></li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(ChannelBuffer bufferA, ChannelBuffer bufferB) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> aLen </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bufferA.</span><span style="color:#B392F0;">readableBytes</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (aLen </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> bufferB.</span><span style="color:#B392F0;">readableBytes</span><span style="color:#E1E4E8;">()) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 比较两个ChannelBuffer的可读字节数</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> byteCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> aLen </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">7</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 只比较前7个字节</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> aIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bufferA.</span><span style="color:#B392F0;">readerIndex</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> bIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bufferB.</span><span style="color:#B392F0;">readerIndex</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> byteCount; i </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (bufferA.</span><span style="color:#B392F0;">getByte</span><span style="color:#E1E4E8;">(aIndex) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> bufferB.</span><span style="color:#B392F0;">getByte</span><span style="color:#E1E4E8;">(bIndex)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 前7个字节发现不同，则返回false</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        aIndex</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        bIndex</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(ChannelBuffer bufferA, ChannelBuffer bufferB) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> aLen </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bufferA.</span><span style="color:#6F42C1;">readableBytes</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (aLen </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> bufferB.</span><span style="color:#6F42C1;">readableBytes</span><span style="color:#24292E;">()) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 比较两个ChannelBuffer的可读字节数</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> byteCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> aLen </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">7</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 只比较前7个字节</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> aIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bufferA.</span><span style="color:#6F42C1;">readerIndex</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> bIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bufferB.</span><span style="color:#6F42C1;">readerIndex</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> byteCount; i </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (bufferA.</span><span style="color:#6F42C1;">getByte</span><span style="color:#24292E;">(aIndex) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> bufferB.</span><span style="color:#6F42C1;">getByte</span><span style="color:#24292E;">(bIndex)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 前7个字节发现不同，则返回false</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        aIndex</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        bIndex</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>compare() 方法：用于比较两个 ChannelBuffer 的大小，会逐个比较两个 ChannelBuffer 中的全部可读字节，具体实现与 equals() 方法类似，这里就不再重复讲述。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时重点介绍了 dubbo-remoting 模块 buffers 包中的核心实现。我们首先介绍了 ChannelBuffer 接口这一个顶层接口，了解了 ChannelBuffer 提供的核心功能和运作原理；接下来介绍了 ChannelBuffer 的多种实现，其中包括 HeapChannelBuffer、DynamicChannelBuffer、ByteBufferBackedChannelBuffer 等具体实现类，以及 AbstractChannelBuffer 这个抽象类；最后分析了 ChannelBufferFactory 使用到的 ChannelBuffers 工具类以及在 ChannelBuffer 之上封装的 InputStream 和 OutputStream 实现。</p><p>关于本课时，你若还有什么疑问或想法，欢迎你留言跟我分享。</p>`,7);function h(C,F,A,g,b,D){const s=o("Image");return t(),r("div",null,[y,n(s,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/55/0F/CgqCHl9pudyACkPPAABei6G8kSc033.png"}),a(),E,n(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/55/04/Ciqc1F9pugWAMFoIAABVU01bqiI007.png"}),a(),i,n(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/55/0F/CgqCHl9puiWABaDpAACaisslR0Q430.png"}),f,n(s,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/55/04/Ciqc1F9puj2AXLalAALcfencKx0331.png"}),d,u,n(s,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/55/10/CgqCHl9pukOAT_8kAACo0xRQ2po574.png"}),B])}const _=e(c,[["render",h]]);export{I as __pageData,_ as default};
