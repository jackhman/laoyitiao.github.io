import{_ as o,j as e,o as t,g as r,k as p,h as a,s,Q as l}from"./chunks/framework.e0c66c3f.js";const f=JSON.parse('{"title":"MapperRegistry ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/深入剖析 MyBatis 核心原理_文档/(6379) 08  Mapper 文件与 Java 接口的优雅映射之道.md","filePath":"posts/backEnd/深入剖析 MyBatis 核心原理_文档/(6379) 08  Mapper 文件与 Java 接口的优雅映射之道.md","lastUpdated":1696338709000}'),c={name:"posts/backEnd/深入剖析 MyBatis 核心原理_文档/(6379) 08  Mapper 文件与 Java 接口的优雅映射之道.md"},E=l('<p>在<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=612&amp;sid=20-h5Url-0#/detail/pc?id=6373" target="_blank" rel="noreferrer">使用 MyBatis 实现订单系统示例的时候</a>，我们会为每个 Mapper.xml 配置文件创建一个对应的 Mapper 接口，例如，订单系统示例中的 CustomerMapper.xml 配置文件与 CustomerMapper 接口，定义完 CustomerMapper 接口之后，我们无须提供 CustomerMapper 接口实现，就可以直接调用 CustomerMapper 对象的方法执行 CustomerMapper.xml 配置文件中的 SQL 语句。</p><p>这里你可能会有几个疑惑：</p><ul><li><p>为什么需要 CustomerMapper 接口来执行对应的 SQL 语句呢？</p></li><li><p>为什么无须提供 CustomerMapper 接口的实现类呢？</p></li><li><p>实际使用的 CustomerMapper 对象是什么呢？CustomerMapper 对象是怎么创建的呢？底层原理是什么呢？</p></li></ul><p>学习完这一讲，你就会找到这些问题的答案。</p><p>MyBatis 的前身是 iBatis，我们在使用 iBatis 的时候，如果想查询一个 Customer 对象的话，可以调用 SqlSession.queryForObject (&quot;find&quot;, customerId) 方法，queryForObject() 方法的这两个参数分别是要执行的 SQL 语句唯一标识（示例中就是定义在 CustomerMapper.xml 中的 id 为 find 的 SQL 语句），以及 SQL 语句执行时需要的实参（示例中就是顾客 ID）。</p><p>这里 SQL 语句的唯一标识是一个字符串，如果我们在写代码的时候，不小心写错了这个唯一标识，例如将&quot;find&quot;写成了&quot;finb&quot;，在代码编译以及 iBatis 初始化的过程中，根本发现不了这个问题，而是在真正执行到这行代码的时候才会抛出异常，这样其实对流量是有损的。</p><p>MyBatis 中的 Mapper 接口就可以很好地解决这个问题。</p><p>示例中的 CustomerMapper 接口中定义了 SQL 语句唯一标识同名的 find() 方法，我们在写代码的时候使用的是 CustomerMapper.find() 方法，如果拼写成 CustomerMapper.finb()，编译会失败。这是因为 MyBatis 初始化的时候会尝试<strong>将 CustomerMapper 接口中的 find() 方法名与 CustomerMapper.xml 配置文件中的 SQL 唯一标识进行映射</strong>，如果 SQL 语句唯一标识写错成&quot;finb&quot;，MyBatis 会发现这个错误，并在初始化过程中就抛出异常，这样编译器以及 MyBatis 就可以帮助我们更早发现异常，避免线上流量的损失。</p><p><strong>在 MyBatis 中，实现 CustomerMapper 接口与 CustomerMapper.xml 配置文件映射功能的是 binding 模块</strong>，其中涉及的核心类如下图所示：</p>',9),y=l(`<p>binding 模块核心组件关系图</p><p>下面我们就开始详细分析 binding 模块中涉及的这些核心组件。</p><h3 id="mapperregistry" tabindex="-1">MapperRegistry <a class="header-anchor" href="#mapperregistry" aria-label="Permalink to &quot;MapperRegistry&quot;">​</a></h3><p><strong>MapperRegistry 是 MyBatis 初始化过程中构造的一个对象，主要作用就是统一维护 Mapper 接口以及这些 Mapper 的代理对象工厂</strong>。</p><p>下面我们先来看 MapperRegistry 中的核心字段。</p><ul><li><p>config（Configuration 类型）：指向 MyBatis 全局唯一的 Configuration 对象，其中维护了解析之后的全部 MyBatis 配置信息。</p></li><li><p>knownMappers（Map&lt;Class<code>&lt;?&gt;</code>, MapperProxyFactory&lt;?&gt;&gt; 类型）：维护了所有解析到的 Mapper 接口以及 MapperProxyFactory 工厂对象之间的映射关系。</p></li></ul><p>在 MyBatis 初始化时，会读取全部 Mapper.xml 配置文件，还会扫描全部 Mapper 接口中的注解信息，之后会调用 MapperRegistry.addMapper() 方法填充 knownMappers 集合。在 addMapper() 方法填充 knownMappers 集合之前，MapperRegistry 会先保证传入的 type 参数是一个接口且 knownMappers 集合没有加载过 type 类型，然后才会创建相应的 MapperProxyFactory 工厂并记录到 knownMappers 集合中。</p><p>在我们使用 CustomerMapper.find() 方法执行数据库查询的时候，MyBatis 会先从MapperRegistry 中获取 CustomerMapper 接口的代理对象，这里就使用到 MapperRegistry.getMapper()方法，它会拿到前面创建的 MapperProxyFactory 工厂对象，并调用其 newInstance() 方法创建 Mapper 接口的代理对象。</p><h3 id="mapperproxyfactory" tabindex="-1">MapperProxyFactory <a class="header-anchor" href="#mapperproxyfactory" aria-label="Permalink to &quot;MapperProxyFactory&quot;">​</a></h3><p>正如分析 MapperRegistry 时介绍的那样，<strong>MapperProxyFactory 的核心功能就是创建 Mapper 接口的代理对象</strong>，其底层核心原理就是前面《06 | 日志框架千千万，MyBatis 都能兼容的秘密是什么？》介绍的 JDK 动态代理。</p><p>在 MapperRegistry 中会依赖 MapperProxyFactory 的 newInstance() 方法创建代理对象，底层则是通过 JDK 动态代理的方式生成代理对象的，如下代码所示，这里使用的 InvocationHandler 实现是 MapperProxy。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> T </span><span style="color:#B392F0;">newInstance</span><span style="color:#E1E4E8;">(MapperProxy</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> mapperProxy) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建实现了mapperInterface接口的动态代理对象，这里使用的InvocationHandler 实现是MapperProxy</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (T) Proxy.</span><span style="color:#B392F0;">newProxyInstance</span><span style="color:#E1E4E8;">(mapperInterface.</span><span style="color:#B392F0;">getClassLoader</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Class</span><span style="color:#E1E4E8;">[]{mapperInterface}, mapperProxy);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> T </span><span style="color:#6F42C1;">newInstance</span><span style="color:#24292E;">(MapperProxy</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> mapperProxy) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建实现了mapperInterface接口的动态代理对象，这里使用的InvocationHandler 实现是MapperProxy</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (T) Proxy.</span><span style="color:#6F42C1;">newProxyInstance</span><span style="color:#24292E;">(mapperInterface.</span><span style="color:#6F42C1;">getClassLoader</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Class</span><span style="color:#24292E;">[]{mapperInterface}, mapperProxy);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="mapperproxy" tabindex="-1">MapperProxy <a class="header-anchor" href="#mapperproxy" aria-label="Permalink to &quot;MapperProxy&quot;">​</a></h3><p>通过分析 MapperProxyFactory 这个工厂类，我们可以清晰地看到<strong>MapperProxy 是生成 Mapper 接口代理对象的关键，它实现了 InvocationHandler 接口</strong>。</p><p>下面我们先来介绍一下 MapperProxy 中的核心字段。</p><ul><li><p>sqlSession（SqlSession 类型）：记录了当前 MapperProxy 关联的 SqlSession 对象。在与当前 MapperProxy 关联的代理对象中，会用该 SqlSession 访问数据库。</p></li><li><p>mapperInterface（Class<code>&lt;T&gt;</code> 类型）：Mapper 接口类型，也是当前 MapperProxy 关联的代理对象实现的接口类型。</p></li><li><p>methodCache（Map&lt;Method, MapperMethodInvoker&gt; 类型）：用于缓存 MapperMethodInvoker 对象的集合。methodCache 中的 key 是 Mapper 接口中的方法，value 是该方法对应的 MapperMethodInvoker 对象。</p></li><li><p>lookupConstructor（Constructor 类型）：针对 JDK 8 中的特殊处理，该字段指向了 MethodHandles.Lookup 的构造方法。</p></li><li><p>privateLookupInMethod（Method 类型）：除了 JDK 8 之外的其他 JDK 版本会使用该字段，该字段指向 MethodHandles.privateLookupIn() 方法。</p></li></ul><p>这里涉及 MethodHandle 的内容，所以下面我们就来简单介绍一下 MethodHandle 的基础知识点。</p><h4 id="_1-methodhandle-简介" tabindex="-1">1. MethodHandle 简介 <a class="header-anchor" href="#_1-methodhandle-简介" aria-label="Permalink to &quot;1. MethodHandle 简介&quot;">​</a></h4><p>从 Java 7 开始，除了反射之外，在 java.lang.invoke 包中新增了 MethodHandle 这个类，它的基本功能与反射中的 Method 类似，但它比反射更加灵活。<strong>反射是 Java API 层面支持的一种机制，MethodHandle 则是 JVM 层支持的机制，相较而言，反射更加重量级，MethodHandle 则更轻量级，性能也比反射更好些</strong>。</p><p>使用 MethodHandle 进行方法调用的时候，往往会涉及下面几个核心步骤：</p><ol><li><p>创建 MethodType 对象，确定方法的签名，这个签名会涉及方法参数及返回值的类型；</p></li><li><p>在 MethodHandles.Lookup 这个工厂对象中，根据方法名称以及上面创建的 MethodType 查找对应 MethodHandle 对象；</p></li><li><p>将 MethodHandle 绑定到一个具体的实例对象；</p></li><li><p>调用 MethodHandle.invoke()/invokeWithArguments()/invokeExact() 方法，完成方法调用。</p></li></ol><p>下面是 MethodHandle 的一个简单示例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MethodHandleDemo</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 定义一个sayHello()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">s</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello, &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> s;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 初始化MethodHandleDemo实例</span></span>
<span class="line"><span style="color:#E1E4E8;">        MethodHandleDemo subMethodHandleDemo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubMethodHandleDemo</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 定义sayHello()方法的签名，第一个参数是方法的返回值类型，第二个参数是方法的参数列表</span></span>
<span class="line"><span style="color:#E1E4E8;">        MethodType methodType </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> MethodType.</span><span style="color:#B392F0;">methodType</span><span style="color:#E1E4E8;">(String.class, String.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 根据方法名和MethodType在MethodHandleDemo中查找对应的MethodHandle</span></span>
<span class="line"><span style="color:#E1E4E8;">        MethodHandle methodHandle </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> MethodHandles.</span><span style="color:#B392F0;">lookup</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">findVirtual</span><span style="color:#E1E4E8;">(MethodHandleDemo.class, </span><span style="color:#9ECBFF;">&quot;sayHello&quot;</span><span style="color:#E1E4E8;">, methodType);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将MethodHandle绑定到一个对象上，然后通过invokeWithArguments()方法传入实参并执行</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(methodHandle.</span><span style="color:#B392F0;">bindTo</span><span style="color:#E1E4E8;">(subMethodHandleDemo)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">invokeWithArguments</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;MethodHandleDemo&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 下面是调用MethodHandleDemo对象(即父类)的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        MethodHandleDemo methodHandleDemo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MethodHandleDemo</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(methodHandle.</span><span style="color:#B392F0;">bindTo</span><span style="color:#E1E4E8;">(methodHandleDemo)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">invokeWithArguments</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;MethodHandleDemo&quot;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SubMethodHandleDemo</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MethodHandleDemo</span><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 定义一个sayHello()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">s</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Sub Hello, &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> s;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MethodHandleDemo</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 定义一个sayHello()方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">sayHello</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">s</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello, &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> s;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Throwable {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 初始化MethodHandleDemo实例</span></span>
<span class="line"><span style="color:#24292E;">        MethodHandleDemo subMethodHandleDemo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubMethodHandleDemo</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 定义sayHello()方法的签名，第一个参数是方法的返回值类型，第二个参数是方法的参数列表</span></span>
<span class="line"><span style="color:#24292E;">        MethodType methodType </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> MethodType.</span><span style="color:#6F42C1;">methodType</span><span style="color:#24292E;">(String.class, String.class);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 根据方法名和MethodType在MethodHandleDemo中查找对应的MethodHandle</span></span>
<span class="line"><span style="color:#24292E;">        MethodHandle methodHandle </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> MethodHandles.</span><span style="color:#6F42C1;">lookup</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">findVirtual</span><span style="color:#24292E;">(MethodHandleDemo.class, </span><span style="color:#032F62;">&quot;sayHello&quot;</span><span style="color:#24292E;">, methodType);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将MethodHandle绑定到一个对象上，然后通过invokeWithArguments()方法传入实参并执行</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(methodHandle.</span><span style="color:#6F42C1;">bindTo</span><span style="color:#24292E;">(subMethodHandleDemo)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">invokeWithArguments</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;MethodHandleDemo&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 下面是调用MethodHandleDemo对象(即父类)的方法</span></span>
<span class="line"><span style="color:#24292E;">        MethodHandleDemo methodHandleDemo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MethodHandleDemo</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(methodHandle.</span><span style="color:#6F42C1;">bindTo</span><span style="color:#24292E;">(methodHandleDemo)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">invokeWithArguments</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;MethodHandleDemo&quot;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SubMethodHandleDemo</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MethodHandleDemo</span><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 定义一个sayHello()方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">sayHello</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">s</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Sub Hello, &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> s;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 MethodHandle 调用方法的时候，也是支持多态的，在通过 bindTo() 方法绑定到某个实例对象的时候，在 bind 过程中会进行类型检查等一系列检查操作。</p><p>通过上面这个示例我们可以看出，使用 MethodHandle 实现反射的效果，更像我们平时通过 Java 代码生成的字节码，例如，在字节码中可以看到创建的方法签名（MethodType）、方法的具体调用方式（findStatic()、findSpecial()、findVirtual() 等方法）以及类型的隐式转换。</p><h4 id="_2-methodproxy-中的代理逻辑" tabindex="-1">2. MethodProxy 中的代理逻辑 <a class="header-anchor" href="#_2-methodproxy-中的代理逻辑" aria-label="Permalink to &quot;2. MethodProxy 中的代理逻辑&quot;">​</a></h4><p>介绍完 MethodHandle 的基础之后，我们回到 MethodProxy 继续分析。</p><p><strong>MapperProxy.invoke() 方法是代理对象执行的入口</strong>，其中会拦截所有非 Object 方法，针对每个被拦截的方法，都会调用 cachedInvoker() 方法获取对应的 MapperMethod 对象，并调用其 invoke() 方法执行代理逻辑以及目标方法。</p><p>在 cachedInvoker() 方法中，首先会查询 methodCache 缓存，如果查询的方法为 default 方法，则会根据当前使用的 JDK 版本，获取对应的 MethodHandle 并封装成 DefaultMethodInvoker 对象写入缓存；如果查询的方法是非 default 方法，则创建 PlainMethodInvoker 对象写入缓存。</p><p>cachedInvoker() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> MapperMethodInvoker </span><span style="color:#B392F0;">cachedInvoker</span><span style="color:#E1E4E8;">(Method method) throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 尝试从methodCache缓存中查询方法对应的MapperMethodInvoker</span></span>
<span class="line"><span style="color:#E1E4E8;">    MapperMethodInvoker invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> methodCache.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(method);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (invoker </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果方法在缓存中没有对应的MapperMethodInvoker，则进行创建</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> methodCache.</span><span style="color:#B392F0;">computeIfAbsent</span><span style="color:#E1E4E8;">(method, m </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (m.</span><span style="color:#B392F0;">isDefault</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 针对default方法的处理</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这里根据JDK版本的不同，获取方法对应的MethodHandle的方式也有所不同</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 在JDK 8中使用的是lookupConstructor字段，而在JDK 9中使用的是</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// privateLookupInMethod字段。获取到MethodHandle之后，会使用</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// DefaultMethodInvoker进行封装</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (privateLookupInMethod </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DefaultMethodInvoker</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getMethodHandleJava8</span><span style="color:#E1E4E8;">(method));</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DefaultMethodInvoker</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getMethodHandleJava9</span><span style="color:#E1E4E8;">(method));</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 对于其他方法，会创建MapperMethod并使用PlainMethodInvoker封装</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PlainMethodInvoker</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MapperMethod</span><span style="color:#E1E4E8;">(mapperInterface, method, sqlSession.</span><span style="color:#B392F0;">getConfiguration</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> MapperMethodInvoker </span><span style="color:#6F42C1;">cachedInvoker</span><span style="color:#24292E;">(Method method) throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 尝试从methodCache缓存中查询方法对应的MapperMethodInvoker</span></span>
<span class="line"><span style="color:#24292E;">    MapperMethodInvoker invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> methodCache.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(method);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (invoker </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invoker;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果方法在缓存中没有对应的MapperMethodInvoker，则进行创建</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> methodCache.</span><span style="color:#6F42C1;">computeIfAbsent</span><span style="color:#24292E;">(method, m </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (m.</span><span style="color:#6F42C1;">isDefault</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 针对default方法的处理</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这里根据JDK版本的不同，获取方法对应的MethodHandle的方式也有所不同</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 在JDK 8中使用的是lookupConstructor字段，而在JDK 9中使用的是</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// privateLookupInMethod字段。获取到MethodHandle之后，会使用</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// DefaultMethodInvoker进行封装</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (privateLookupInMethod </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DefaultMethodInvoker</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getMethodHandleJava8</span><span style="color:#24292E;">(method));</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DefaultMethodInvoker</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getMethodHandleJava9</span><span style="color:#24292E;">(method));</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 对于其他方法，会创建MapperMethod并使用PlainMethodInvoker封装</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PlainMethodInvoker</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MapperMethod</span><span style="color:#24292E;">(mapperInterface, method, sqlSession.</span><span style="color:#6F42C1;">getConfiguration</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其中使用到的 DefaultMethodInvoker 和 PlainMethodInvoker 都是 MapperMethodInvoker 接口的实现，如下图所示：</p>`,32),i=l(`<p>MapperMethodInvoker 接口继承关系图</p><p>在 DefaultMethodInvoker.invoke() 方法中，会通过底层维护的 MethodHandle 完成方法调用，核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object proxy, Method method, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] args, SqlSession sqlSession) throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 首先将MethodHandle绑定到一个实例对象上，然后调用invokeWithArguments()方法执行目标方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> methodHandle.</span><span style="color:#B392F0;">bindTo</span><span style="color:#E1E4E8;">(proxy).</span><span style="color:#B392F0;">invokeWithArguments</span><span style="color:#E1E4E8;">(args);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Object proxy, Method method, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] args, SqlSession sqlSession) throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 首先将MethodHandle绑定到一个实例对象上，然后调用invokeWithArguments()方法执行目标方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> methodHandle.</span><span style="color:#6F42C1;">bindTo</span><span style="color:#24292E;">(proxy).</span><span style="color:#6F42C1;">invokeWithArguments</span><span style="color:#24292E;">(args);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 PlainMethodInvoker.invoke() 方法中，会通过底层维护的 MapperMethod 完成方法调用，其核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object proxy, Method method, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] args, SqlSession sqlSession) throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 直接执行MapperMethod.execute()方法完成方法调用</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> mapperMethod.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(sqlSession, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Object proxy, Method method, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] args, SqlSession sqlSession) throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 直接执行MapperMethod.execute()方法完成方法调用</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> mapperMethod.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(sqlSession, args);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="mappermethod" tabindex="-1">MapperMethod <a class="header-anchor" href="#mappermethod" aria-label="Permalink to &quot;MapperMethod&quot;">​</a></h3><p>通过对 MapperProxy 的分析我们知道，<strong>MapperMethod 是最终执行 SQL 语句的地方，同时也记录了 Mapper 接口中的对应方法</strong>，其核心字段也围绕这两方面的内容展开。</p><h4 id="_1-sqlcommand" tabindex="-1">1. SqlCommand <a class="header-anchor" href="#_1-sqlcommand" aria-label="Permalink to &quot;1. SqlCommand&quot;">​</a></h4><p><strong>MapperMethod 的第一个核心字段是 command（SqlCommand 类型），其中维护了关联 SQL 语句的相关信息</strong>。在 MapperMethod$SqlCommand 这个内部类中，通过 name 字段记录了关联 SQL 语句的唯一标识，通过 type 字段（SqlCommandType 类型）维护了 SQL 语句的操作类型，这里 SQL 语句的操作类型分为 INSERT、UPDATE、DELETE、SELECT 和 FLUSH 五种。</p><p>下面我们就来看看 SqlCommand 如何查找 Mapper 接口中一个方法对应的 SQL 语句的信息，该逻辑在 SqlCommand 的构造方法中实现，如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SqlCommand</span><span style="color:#E1E4E8;">(Configuration configuration, Class</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> mapperInterface, Method method) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取Mapper接口中对应的方法名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> String methodName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取Mapper接口的类型</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Class&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; declaringClass </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">getDeclaringClass</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将Mapper接口名称和方法名称拼接起来作为SQL语句唯一标识，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 到Configuration这个全局配置对象中查找SQL语句</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// MappedStatement对象就是Mapper.xml配置文件中一条SQL语句解析之后得到的对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    MappedStatement ms </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">resolveMappedStatement</span><span style="color:#E1E4E8;">(mapperInterface, </span></span>
<span class="line"><span style="color:#E1E4E8;">            methodName, declaringClass, configuration);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ms </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 针对@Flush注解的处理</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (method.</span><span style="color:#B392F0;">getAnnotation</span><span style="color:#E1E4E8;">(Flush.class) </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            type </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> SqlCommandType.FLUSH;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 没有@Flush注解，会抛出异常</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BindingException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;...&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 记录SQL语句唯一标识</span></span>
<span class="line"><span style="color:#E1E4E8;">        name </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ms.</span><span style="color:#B392F0;">getId</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 记录SQL语句的操作类型</span></span>
<span class="line"><span style="color:#E1E4E8;">        type </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ms.</span><span style="color:#B392F0;">getSqlCommandType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SqlCommand</span><span style="color:#24292E;">(Configuration configuration, Class</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> mapperInterface, Method method) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取Mapper接口中对应的方法名称</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> String methodName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取Mapper接口的类型</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Class&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; declaringClass </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">getDeclaringClass</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将Mapper接口名称和方法名称拼接起来作为SQL语句唯一标识，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 到Configuration这个全局配置对象中查找SQL语句</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// MappedStatement对象就是Mapper.xml配置文件中一条SQL语句解析之后得到的对象</span></span>
<span class="line"><span style="color:#24292E;">    MappedStatement ms </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">resolveMappedStatement</span><span style="color:#24292E;">(mapperInterface, </span></span>
<span class="line"><span style="color:#24292E;">            methodName, declaringClass, configuration);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ms </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 针对@Flush注解的处理</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (method.</span><span style="color:#6F42C1;">getAnnotation</span><span style="color:#24292E;">(Flush.class) </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            type </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> SqlCommandType.FLUSH;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 没有@Flush注解，会抛出异常</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BindingException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;...&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 记录SQL语句唯一标识</span></span>
<span class="line"><span style="color:#24292E;">        name </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ms.</span><span style="color:#6F42C1;">getId</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 记录SQL语句的操作类型</span></span>
<span class="line"><span style="color:#24292E;">        type </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ms.</span><span style="color:#6F42C1;">getSqlCommandType</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里调用的 resolveMappedStatement() 方法不仅会尝试根据 SQL 语句的唯一标识从 Configuration 全局配置对象中查找关联的 MappedStatement 对象，还会尝试顺着 Mapper 接口的继承树进行查找，直至查找成功为止。具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> MappedStatement </span><span style="color:#B392F0;">resolveMappedStatement</span><span style="color:#E1E4E8;">(Class</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> mapperInterface, String methodName,</span></span>
<span class="line"><span style="color:#E1E4E8;">                                                   Class</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> declaringClass, Configuration configuration) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将Mapper接口名称和方法名称拼接起来作为SQL语句唯一标识</span></span>
<span class="line"><span style="color:#E1E4E8;">        String statementId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> mapperInterface.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;.&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> methodName;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 检测Configuration中是否包含相应的MappedStatement对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (configuration.</span><span style="color:#B392F0;">hasStatement</span><span style="color:#E1E4E8;">(statementId)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> configuration.</span><span style="color:#B392F0;">getMappedStatement</span><span style="color:#E1E4E8;">(statementId);</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (mapperInterface.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(declaringClass)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果方法就定义在当前接口中，则证明没有对应的SQL语句，返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果当前检查的Mapper接口(mapperInterface)中不是定义该方法的接口(declaringClass)，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 则会从mapperInterface开始，沿着继承关系向上查找递归每个接口，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 查找该方法对应的MappedStatement对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Class&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; superInterface </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> mapperInterface.</span><span style="color:#B392F0;">getInterfaces</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (declaringClass.</span><span style="color:#B392F0;">isAssignableFrom</span><span style="color:#E1E4E8;">(superInterface)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                MappedStatement ms </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">resolveMappedStatement</span><span style="color:#E1E4E8;">(superInterface, methodName,</span></span>
<span class="line"><span style="color:#E1E4E8;">                        declaringClass, configuration);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ms </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ms;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> MappedStatement </span><span style="color:#6F42C1;">resolveMappedStatement</span><span style="color:#24292E;">(Class</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> mapperInterface, String methodName,</span></span>
<span class="line"><span style="color:#24292E;">                                                   Class</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> declaringClass, Configuration configuration) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将Mapper接口名称和方法名称拼接起来作为SQL语句唯一标识</span></span>
<span class="line"><span style="color:#24292E;">        String statementId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> mapperInterface.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;.&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> methodName;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 检测Configuration中是否包含相应的MappedStatement对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (configuration.</span><span style="color:#6F42C1;">hasStatement</span><span style="color:#24292E;">(statementId)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> configuration.</span><span style="color:#6F42C1;">getMappedStatement</span><span style="color:#24292E;">(statementId);</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (mapperInterface.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(declaringClass)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果方法就定义在当前接口中，则证明没有对应的SQL语句，返回null</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果当前检查的Mapper接口(mapperInterface)中不是定义该方法的接口(declaringClass)，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 则会从mapperInterface开始，沿着继承关系向上查找递归每个接口，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 查找该方法对应的MappedStatement对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Class&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; superInterface </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> mapperInterface.</span><span style="color:#6F42C1;">getInterfaces</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (declaringClass.</span><span style="color:#6F42C1;">isAssignableFrom</span><span style="color:#24292E;">(superInterface)) {</span></span>
<span class="line"><span style="color:#24292E;">                MappedStatement ms </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">resolveMappedStatement</span><span style="color:#24292E;">(superInterface, methodName,</span></span>
<span class="line"><span style="color:#24292E;">                        declaringClass, configuration);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ms </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ms;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h4 id="_2-methodsignature" tabindex="-1">2. MethodSignature <a class="header-anchor" href="#_2-methodsignature" aria-label="Permalink to &quot;2. MethodSignature&quot;">​</a></h4><p><strong>MapperMethod 的第二个核心字段是 method 字段（MethodSignature 类型），其中维护了 Mapper 接口中方法的相关信息。</strong></p><p>首先是 Mapper 接口方法返回值的相关信息，涉及下面七个字段。</p><ul><li><p>returnsMany、returnsMap、returnsVoid、returnsCursor、returnsOptional（boolean 类型）：用于表示方法返回值是否为 Collection 集合或数组、Map 集合、void、Cursor、Optional 类型。</p></li><li><p>returnType（Class&lt;?&gt; 类型）：方法返回值的具体类型。</p></li><li><p>mapKey（String 类型）：如果方法的返回值为 Map 集合，则通过 mapKey 字段记录了作为 key 的列名。mapKey 字段的值是通过解析方法上的 @MapKey 注解得到的。</p></li></ul><p>接下来是与 Mapper 接口方法的参数列表相关的三个字段。</p><ul><li><p>resultHandlerIndex（Integer 类型）：记录了 Mapper 接口方法的参数列表中 ResultHandler 类型参数的位置。</p></li><li><p>rowBoundsIndex（Integer 类型）：记录了 Mapper 接口方法的参数列表中 RowBounds 类型参数的位置。</p></li><li><p>paramNameResolver（ParamNameResolver 类型）：用来解析方法参数列表的工具类。</p></li></ul><p>在上述字段中，需要着重讲解的是 ParamNameResolver 这个解析方法参数列表的工具类。</p><p>在 ParamNameResolver 中有一个 names 字段（SortedMap&lt;Integer, String&gt;类型）记录了各个参数在参数列表中的位置以及参数名称，其中 key 是参数在参数列表中的位置索引，value 为参数的名称。我们可以通过 @Param 注解指定一个参数名称，如果没有特别指定，则默认使用参数列表中的变量名称作为其名称，这与 ParamNameResolver 的 useActualParamName 字段相关。useActualParamName 是一个全局配置。</p><p>如果我们将 useActualParamName 配置为 false，ParamNameResolver 会使用参数的下标索引作为其名称。另外，names 集合会跳过 RowBounds 类型以及 ResultHandler 类型的参数，如果使用下标索引作为参数名称，在 names 集合中就会出现 KV 不一致的场景。例如下图就很好地说明了这种不一致的场景，其中 saveCustomer(long id, String name, RowBounds bounds, String address) 方法对应的 names 集合为 { {0, &quot;0&quot;}, {1, &quot;1&quot;}, {2, &quot;3&quot;}}。</p>`,22),d=l(`<p>names 集合中 KV 不一致示意图</p><p>从图中可以看到，由于 RowBounds 参数的存在，第四个参数在 names 集合中的 KV 出现了不一致（即 key = 2 与 value = &quot;3&quot; 不一致）。</p><p>完成 names 集合的初始化之后，我们再来看如何从 names 集合中查询参数名称，该部分逻辑在 ParamNameResolver.getNamedParams() 方法，其中会将 Mapper 接口方法的实参与 names 集合中记录的参数名称相关联，其核心逻辑如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">getNamedParams</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取方法中非特殊类型(RowBounds类型和ResultHandler类型)的参数个数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> paramCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> names.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (args </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> paramCount </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 方法没有非特殊类型参数，返回null即可</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">hasParamAnnotation </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> paramCount </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 方法参数列表中没有使用@Param注解，且只有一个非特殊类型参数</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> args[names.</span><span style="color:#B392F0;">firstKey</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">wrapToMapIfCollection</span><span style="color:#E1E4E8;">(value, useActualParamName </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> names.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 处理存在@Param注解或是存在多个非特殊类型参数的场景</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// param集合用于记录了参数名称与实参之间的映射关系</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 这里的ParamMap继承了HashMap，与HashMap的唯一不同是：</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 向ParamMap中添加已经存在的key时，会直接抛出异常，而不是覆盖原有的Key</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; param </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ParamMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Map.Entry&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; entry </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> names.</span><span style="color:#B392F0;">entrySet</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 将参数名称与实参的映射保存到param集合中</span></span>
<span class="line"><span style="color:#E1E4E8;">            param.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(entry.</span><span style="color:#B392F0;">getValue</span><span style="color:#E1E4E8;">(), args[entry.</span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">()]);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 同时，为参数创建&quot;param+索引&quot;格式的默认参数名称，具体格式为：param1, param2等，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 将&quot;param+索引&quot;的默认参数名称与实参的映射关系也保存到param集合中</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> String genericParamName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> GENERIC_NAME_PREFIX </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">names.</span><span style="color:#B392F0;">containsValue</span><span style="color:#E1E4E8;">(genericParamName)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                param.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(genericParamName, args[entry.</span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">()]);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> param;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">getNamedParams</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取方法中非特殊类型(RowBounds类型和ResultHandler类型)的参数个数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> paramCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> names.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (args </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> paramCount </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 方法没有非特殊类型参数，返回null即可</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">hasParamAnnotation </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> paramCount </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 方法参数列表中没有使用@Param注解，且只有一个非特殊类型参数</span></span>
<span class="line"><span style="color:#24292E;">        Object value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> args[names.</span><span style="color:#6F42C1;">firstKey</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">wrapToMapIfCollection</span><span style="color:#24292E;">(value, useActualParamName </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> names.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 处理存在@Param注解或是存在多个非特殊类型参数的场景</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// param集合用于记录了参数名称与实参之间的映射关系</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 这里的ParamMap继承了HashMap，与HashMap的唯一不同是：</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 向ParamMap中添加已经存在的key时，会直接抛出异常，而不是覆盖原有的Key</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; param </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ParamMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Map.Entry&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; entry </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> names.</span><span style="color:#6F42C1;">entrySet</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 将参数名称与实参的映射保存到param集合中</span></span>
<span class="line"><span style="color:#24292E;">            param.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(entry.</span><span style="color:#6F42C1;">getValue</span><span style="color:#24292E;">(), args[entry.</span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">()]);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 同时，为参数创建&quot;param+索引&quot;格式的默认参数名称，具体格式为：param1, param2等，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 将&quot;param+索引&quot;的默认参数名称与实参的映射关系也保存到param集合中</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> String genericParamName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> GENERIC_NAME_PREFIX </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">names.</span><span style="color:#6F42C1;">containsValue</span><span style="color:#24292E;">(genericParamName)) {</span></span>
<span class="line"><span style="color:#24292E;">                param.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(genericParamName, args[entry.</span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">()]);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> param;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>了解了 ParamNameResolver 的核心功能之后，我们回到 MethodSignature 继续分析，在其构造函数中会解析方法中的返回值、参数列表等信息，并初始化前面介绍的核心字段，这里也会使用到前面介绍的 ParamNameResolver 工具类。下面是 MethodSignature 构造方法的核心实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MethodSignature</span><span style="color:#E1E4E8;">(Configuration configuration, Class</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> mapperInterface, Method method) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span><span style="color:#6A737D;">// 通过TypeParameterResolver工具类解析方法的返回值类型，初始化returnType字段值，省略该解析部分代码</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据返回值类型，初始化returnsVoid、returnsMany、returnsCursor、</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// returnsMap、returnsOptional这五个与方法返回值类型相关的字段</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.returnsVoid </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> void.class.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.returnType);</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果返回值为Map类型，则从方法的@MapKey注解中获取Map中为key的字段名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mapKey </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getMapKey</span><span style="color:#E1E4E8;">(method);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.returnsMap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.mapKey </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 解析方法中RowBounds类型参数以及ResultHandler类型参数的下标索引位置，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化rowBoundsIndex和resultHandlerIndex字段</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.rowBoundsIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getUniqueParamIndex</span><span style="color:#E1E4E8;">(method, RowBounds.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.resultHandlerIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getUniqueParamIndex</span><span style="color:#E1E4E8;">(method, ResultHandler.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建ParamNameResolver工具对象，在创建ParamNameResolver对象的时候，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 会解析方法的参数列表信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.paramNameResolver </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ParamNameResolver</span><span style="color:#E1E4E8;">(configuration, method);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MethodSignature</span><span style="color:#24292E;">(Configuration configuration, Class</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> mapperInterface, Method method) {</span></span>
<span class="line"><span style="color:#24292E;">    ... </span><span style="color:#6A737D;">// 通过TypeParameterResolver工具类解析方法的返回值类型，初始化returnType字段值，省略该解析部分代码</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据返回值类型，初始化returnsVoid、returnsMany、returnsCursor、</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// returnsMap、returnsOptional这五个与方法返回值类型相关的字段</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.returnsVoid </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> void.class.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.returnType);</span></span>
<span class="line"><span style="color:#24292E;">    ... </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果返回值为Map类型，则从方法的@MapKey注解中获取Map中为key的字段名称</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mapKey </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getMapKey</span><span style="color:#24292E;">(method);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.returnsMap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.mapKey </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 解析方法中RowBounds类型参数以及ResultHandler类型参数的下标索引位置，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化rowBoundsIndex和resultHandlerIndex字段</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.rowBoundsIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getUniqueParamIndex</span><span style="color:#24292E;">(method, RowBounds.class);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.resultHandlerIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getUniqueParamIndex</span><span style="color:#24292E;">(method, ResultHandler.class);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建ParamNameResolver工具对象，在创建ParamNameResolver对象的时候，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 会解析方法的参数列表信息</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.paramNameResolver </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ParamNameResolver</span><span style="color:#24292E;">(configuration, method);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在初始化过程中，我们看到会调用 getUniqueParamIndex() 方法查找目标类型参数的下标索引位置，其核心原理就是遍历方法的参数列表，逐个匹配参数的类型是否为目标类型，如果匹配成功，则会返回当前参数的下标索引。getUniqueParamIndex() 方法的具体实现比较简单，这里就不再展示，你若感兴趣的话可以参考<a href="https://github.com/xxxlxy2008/mybatis" target="_blank" rel="noreferrer">源码</a>进行学习。</p><h4 id="_3-深入-execute-方法" tabindex="-1">3. 深入 execute() 方法 <a class="header-anchor" href="#_3-深入-execute-方法" aria-label="Permalink to &quot;3. 深入 execute() 方法&quot;">​</a></h4><p>分析完 MapperMethod 中的几个核心内部类，我们回到 MapperMethod 继续介绍。</p><p>execute() 方法是 MapperMethod 中最核心的方法之一。<strong>execute() 方法会根据要执行的 SQL 语句的具体类型执行 SqlSession 的相应方法完成数据库操作</strong>，其核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(SqlSession sqlSession, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object result;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (command.</span><span style="color:#B392F0;">getType</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 判断SQL语句的类型</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> INSERT</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 通过ParamNameResolver.getNamedParams()方法将方法的实参与</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 参数的名称关联起来</span></span>
<span class="line"><span style="color:#E1E4E8;">            Object param </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">convertArgsToSqlCommandParam</span><span style="color:#E1E4E8;">(args);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 通过SqlSession.insert()方法执行INSERT语句，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 在rowCountResult()方法中，会根据方法的返回值类型对结果进行转换</span></span>
<span class="line"><span style="color:#E1E4E8;">            result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">rowCountResult</span><span style="color:#E1E4E8;">(sqlSession.</span><span style="color:#B392F0;">insert</span><span style="color:#E1E4E8;">(command.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">(), param));</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> UPDATE</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Object param </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">convertArgsToSqlCommandParam</span><span style="color:#E1E4E8;">(args);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 通过SqlSession.update()方法执行UPDATE语句</span></span>
<span class="line"><span style="color:#E1E4E8;">            result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">rowCountResult</span><span style="color:#E1E4E8;">(sqlSession.</span><span style="color:#B392F0;">update</span><span style="color:#E1E4E8;">(command.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">(), param));</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// DELETE分支与UPDATE类似，省略</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> SELECT</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (method.</span><span style="color:#B392F0;">returnsVoid</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">hasResultHandler</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 如果方法返回值为void，且参数中包含了ResultHandler类型的实参，</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 则查询的结果集将会由ResultHandler对象进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">executeWithResultHandler</span><span style="color:#E1E4E8;">(sqlSession, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">                result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (method.</span><span style="color:#B392F0;">returnsMany</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// executeForMany()方法处理返回值为集合或数组的场景</span></span>
<span class="line"><span style="color:#E1E4E8;">                result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">executeForMany</span><span style="color:#E1E4E8;">(sqlSession, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> ...</span><span style="color:#6A737D;">// 省略针对Map、Cursor以及Optional返回值的处理</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 省略FLUSH和default分支</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(SqlSession sqlSession, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] args) {</span></span>
<span class="line"><span style="color:#24292E;">    Object result;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (command.</span><span style="color:#6F42C1;">getType</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 判断SQL语句的类型</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> INSERT</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 通过ParamNameResolver.getNamedParams()方法将方法的实参与</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 参数的名称关联起来</span></span>
<span class="line"><span style="color:#24292E;">            Object param </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">convertArgsToSqlCommandParam</span><span style="color:#24292E;">(args);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 通过SqlSession.insert()方法执行INSERT语句，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 在rowCountResult()方法中，会根据方法的返回值类型对结果进行转换</span></span>
<span class="line"><span style="color:#24292E;">            result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">rowCountResult</span><span style="color:#24292E;">(sqlSession.</span><span style="color:#6F42C1;">insert</span><span style="color:#24292E;">(command.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">(), param));</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> UPDATE</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            Object param </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">convertArgsToSqlCommandParam</span><span style="color:#24292E;">(args);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 通过SqlSession.update()方法执行UPDATE语句</span></span>
<span class="line"><span style="color:#24292E;">            result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">rowCountResult</span><span style="color:#24292E;">(sqlSession.</span><span style="color:#6F42C1;">update</span><span style="color:#24292E;">(command.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">(), param));</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// DELETE分支与UPDATE类似，省略</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> SELECT</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (method.</span><span style="color:#6F42C1;">returnsVoid</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">hasResultHandler</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 如果方法返回值为void，且参数中包含了ResultHandler类型的实参，</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 则查询的结果集将会由ResultHandler对象进行处理</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">executeWithResultHandler</span><span style="color:#24292E;">(sqlSession, args);</span></span>
<span class="line"><span style="color:#24292E;">                result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (method.</span><span style="color:#6F42C1;">returnsMany</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// executeForMany()方法处理返回值为集合或数组的场景</span></span>
<span class="line"><span style="color:#24292E;">                result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">executeForMany</span><span style="color:#24292E;">(sqlSession, args);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> ...</span><span style="color:#6A737D;">// 省略针对Map、Cursor以及Optional返回值的处理</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 省略FLUSH和default分支</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>在 execute() 方法中，对于 INSERT、UPDATE、DELETE 三类 SQL 语句的返回结果，都会通过 rowCountResult() 方法处理</strong>。我们知道，上述三种类型的 SQL 语句的执行结果是一个数字，多数场景中代表了 SQL 语句影响的数据行数（注意，这个返回值的具体含义根据 MySQL 的配置有所变化），rowCountResult() 方法会将这个 int 值转换成 Mapper 接口方法的返回值，具体规则如下：</p><ul><li><p>Mapper 方法返回值为 void，则忽略 SQL 语句的 int 返回值，直接返回 null；</p></li><li><p>Mapper 方法返回值为 int 或 Integer 类型，则将 SQL 语句返回的 int 值直接返回；</p></li><li><p>Mapper 方法返回值为 long 或 Long 类型，则将 SQL 语句返回的 int 值转换成 long 类型之后返回；</p></li><li><p>Mapper 方法返回值为 boolean 或 Boolean 类型，则将 SQL 语句返回的 int 值与 0 比较大小，并将比较结果返回。</p></li></ul><p>接下来看 execute() 方法<strong>针对 SELECT 语句查询到的结果集的处理</strong>。</p><ul><li><p>如果在方法参数列表中有 ResultHandler 类型的参数存在，则会使用 executeWithResultHandler() 方法完成查询，底层依赖的是 SqlSession.select() 方法，结果集将会交由传入的 ResultHandler 对象进行处理。</p></li><li><p>如果方法返回值为集合类型或是数组类型，则会调用 executeForMany() 方法，底层依赖 SqlSession.selectList() 方法进行查询，并将得到的 List 转换成目标集合类型。</p></li><li><p>如果方法返回值为 Map 类型，则会调用 executeForMap() 方法，底层依赖 SqlSession.selectMap() 方法完成查询，并将结果集映射成 Map 集合。</p></li><li><p>针对 Cursor 以及 Optional返回值的处理，也是依赖的 SqlSession 的相关方法完成查询的，这里不再展开。</p></li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>在这一讲，我们重点介绍了 MyBatis 中的 binding 模块，正是该模块实现了 Mapper 接口与 Mapper.xml 配置文件的映射功能。</p><ul><li><p>首先，介绍了 MapperRegistry 这个注册中心，其中维护了 Mapper 接口与代理工厂对象之间的映射关系。</p></li><li><p>然后，分析了 MapperProxy 和 MapperProxyFactory，其中 MapperProxyFactory 使用 JDK 动态代理方式为相应的 Mapper 接口创建了代理对象，MapperProxy 则封装了核心的代理逻辑，将拦截到的目标方法委托给对应的 MapperMethod 处理。</p></li><li><p>最后，详细讲解了 MapperMethod，分析了它是如何根据方法签名执行相应的 SQL 语句。</p></li></ul><p>到这里，你应该就能回答开篇的那几个疑惑了吧？我这里也总结一下。</p><ul><li><p>使用 CustomerMapper 接口来执行 SQL 语句，是因为可以在编译期提前暴露错误。</p></li><li><p>之所以不用为 CustomerMapper 接口提供具体实现，是因为调用的是 CustomerMapper 的代理对象。</p></li><li><p>CustomerMapper 对象是通过 JDK 动态代理生成的，在调用这些代理对象的方法时，就会按照我们今天这一讲整体讲解的逻辑和顺序（所以这一讲你要系统地去学习，各个知识点和步骤是串联在一起的），找到相应的 CustomerMapper.xml 中定义的 SQL 语句并执行这些 SQL 语句，完成数据库操作。</p></li></ul><p>关于这一讲的内容，若你有什么问题，期待在留言区与我分享和交流。</p><p>在下一讲，我将会继续介绍 MyBatis 中的缓存模块，记得按时来听课。</p><hr>`,23),u={href:"https://shenceyun.lagou.com/t/Mka",target:"_blank",rel:"noreferrer"},m=s("p",null,[s("strong",null,"《Java 工程师高薪训练营》")],-1),h=s("p",null,[a("实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，"),s("a",{href:"https://shenceyun.lagou.com/t/Mka",target:"_blank",rel:"noreferrer"},"点击链接，提升自己"),a("！")],-1);function F(M,g,D,A,C,S){const n=e("Image");return t(),r("div",null,[E,p(n,{alt:"图片5.png",src:"https://s0.lgstatic.com/i/image6/M01/04/83/CioPOWAs1vuAT8xsAAEXCFQuFx4772.png"}),a(),y,p(n,{alt:"图片6.png",src:"https://s0.lgstatic.com/i/image6/M01/04/86/Cgp9HWAs1wuAE1PMAAFC-IQ3qjE268.png"}),a(),i,p(n,{alt:"图片7.png",src:"https://s0.lgstatic.com/i/image6/M01/04/83/CioPOWAs1x-ARSPuAAEfe6Ixv48515.png"}),a(),d,s("p",null,[s("a",u,[p(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/6D/3E/CgqCHl-s60-AC0B_AAhXSgFweBY762.png"})])]),m,h])}const b=o(c,[["render",F]]);export{f as __pageData,b as default};
