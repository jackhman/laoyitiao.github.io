import{_ as s,o as n,g as a,Q as p}from"./chunks/framework.f949202b.js";const b=JSON.parse('{"title":"使用 Context API 维护全局状态 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(4854) 05  数据是如何在 React 组件之间流动的？（下）.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(4854) 05  数据是如何在 React 组件之间流动的？（下）.md","lastUpdated":null}'),l={name:"posts/frontEnd/046_深入浅出搞定 React/(4854) 05  数据是如何在 React 组件之间流动的？（下）.md"},e=p(`<p>在上个课时，我们掌握了 React 数据流方案中风格相对&quot;朴素&quot;的 Props 单向数据流方案，以及通用性较强的&quot;发布-订阅&quot;模式。在本课时，我们将一起认识 React 天然具备的全局通信方式&quot;Context API&quot;，并对 Redux 的设计思想和编码形态进行初步的探索。</p><h3 id="使用-context-api-维护全局状态" tabindex="-1">使用 Context API 维护全局状态 <a class="header-anchor" href="#使用-context-api-维护全局状态" aria-label="Permalink to &quot;使用 Context API 维护全局状态&quot;">​</a></h3><p>Context API 是 React 官方提供的一种组件树全局通信的方式。</p><p>在 React 16.3 之前，Context API 由于存在种种局限性，并不被 React 官方提倡使用，开发者更多的是把它作为一个概念来探讨。而从 v 16.3.0 开始，React 对 Context API 进行了改进，新的 Context API 具备更强的可用性。这里我们首先针对 React 16 下 Context API 的形态进行介绍。</p><h4 id="图解-context-api-工作流" tabindex="-1">图解 Context API 工作流 <a class="header-anchor" href="#图解-context-api-工作流" aria-label="Permalink to &quot;图解 Context API 工作流&quot;">​</a></h4><p>Context API 有 3 个关键的要素：React.createContext、Provider、Consumer。</p><p>我们通过调用 React.createContext，可以创建出一组 Provider。Provider 作为数据的提供方，可以将数据下发给自身组件树中任意层级的 Consumer，这三者之间的关系用一张图来表示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm7iAQ6ZRAAEW2Me7WVg371.png" alt="图片3.png"></p><p>注意：Cosumer 不仅能够读取到 Provider 下发的数据，<strong>还能读取到这些数据后续的更新</strong>。这意味着数据在生产者和消费者之间能够及时同步，这对 Context 这种模式来说至关重要。</p><h4 id="从编码的角度认识-三要素" tabindex="-1">从编码的角度认识&quot;三要素&quot; <a class="header-anchor" href="#从编码的角度认识-三要素" aria-label="Permalink to &quot;从编码的角度认识&quot;三要素&quot;&quot;">​</a></h4><ul><li><strong>React.createContext</strong>，作用是创建一个 context 对象。下面是一个简单的用法示范：</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> AppContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> React.</span><span style="color:#B392F0;">createContext</span><span style="color:#E1E4E8;">()</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> AppContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> React.</span><span style="color:#6F42C1;">createContext</span><span style="color:#24292E;">()</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>注意，在创建的过程中，我们可以选择性地传入一个 defaultValue：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> AppContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> React.</span><span style="color:#B392F0;">createContext</span><span style="color:#E1E4E8;">(defaultValue)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> AppContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> React.</span><span style="color:#6F42C1;">createContext</span><span style="color:#24292E;">(defaultValue)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>从创建出的 context 对象中，我们可以读取到 Provider 和 Consumer：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { Provider, Consumer } </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> AppContext</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> { Provider, Consumer } </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> AppContext</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><strong>Provider</strong>，可以理解为&quot;数据的 Provider（提供者）&quot;。</li></ul><p>我们使用 Provider 对组件树中的根组件进行包裹，然后传入名为&quot;value&quot;的属性，这个 value 就是后续在组件树中流动的&quot;数据&quot;，它可以被 Consumer 消费。使用示例如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Provider value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{title</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.state.title, content</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.state.content}</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Title </span><span style="color:#F97583;">/&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Content </span><span style="color:#F97583;">/&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">Provider</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Provider value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{title</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.state.title, content</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.state.content}</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Title </span><span style="color:#D73A49;">/&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Content </span><span style="color:#D73A49;">/&gt;</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">Provider</span><span style="color:#D73A49;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>Consumer</strong>，顾名思义就是&quot;数据的消费者&quot;，它可以读取 Provider 下发下来的数据。</li></ul><p>其特点是需要接收一个函数作为子元素，这个函数需要返回一个组件。像这样：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#79B8FF;">Consumer</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;{value.title}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;}</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#79B8FF;">Consumer</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#005CC5;">Consumer</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  {</span><span style="color:#E36209;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;{value.title}&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;}</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#005CC5;">Consumer</span><span style="color:#24292E;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意，当 Consumer 没有对应的 Provider 时，value 参数会直接取创建 context 时传递给 createContext 的 defaultValue。</p><h4 id="新的-context-api-解决了什么问题" tabindex="-1">新的 Context API 解决了什么问题 <a class="header-anchor" href="#新的-context-api-解决了什么问题" aria-label="Permalink to &quot;新的 Context API 解决了什么问题&quot;">​</a></h4><p>想要知道新的 Context API 解决了什么问题，先要知道过时的 Context API 存在什么问题。</p><p><strong>我们先从编码角度认识&quot;过时的&quot;Context API</strong></p><p>&quot;过时的&quot;是 React 官方对旧的 Context API 的描述，由于个人和团队在实际项目中都并不会考虑去使用旧 Context API 来解决问题，这里我直接引用<a href="https://zh-hans.reactjs.org/docs/legacy-context.html" target="_blank" rel="noreferrer">过时的文档</a>中的 Context API 使用示例：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> PropTypes </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;prop-types&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Button</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">React</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">style</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{ {background: </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.context.color}}&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.props.children}</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">Button.contextTypes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  color: PropTypes.string</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Message</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">React</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        {</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.props.text} &lt;</span><span style="color:#79B8FF;">Button</span><span style="color:#E1E4E8;">&gt;Delete&lt;/</span><span style="color:#79B8FF;">Button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MessageList</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">React</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">Component</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getChildContext</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {color: </span><span style="color:#9ECBFF;">&quot;purple&quot;</span><span style="color:#E1E4E8;">};</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">children</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.props.messages.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">message</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#79B8FF;">Message</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">text</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{message.text} /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;{children}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">MessageList.childContextTypes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  color: PropTypes.string</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> PropTypes </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;prop-types&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Button</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">React</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">Component</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">style</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{ {background: </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.context.color}}&gt;</span></span>
<span class="line"><span style="color:#24292E;">        {</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.props.children}</span></span>
<span class="line"><span style="color:#24292E;">      &lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">Button.contextTypes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  color: PropTypes.string</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Message</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">React</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">Component</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        {</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.props.text} &lt;</span><span style="color:#005CC5;">Button</span><span style="color:#24292E;">&gt;Delete&lt;/</span><span style="color:#005CC5;">Button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MessageList</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">React</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">Component</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getChildContext</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {color: </span><span style="color:#032F62;">&quot;purple&quot;</span><span style="color:#24292E;">};</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">children</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.props.messages.</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">((</span><span style="color:#E36209;">message</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#005CC5;">Message</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">text</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{message.text} /&gt;</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;{children}&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">MessageList.childContextTypes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  color: PropTypes.string</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>为了方便你理解，我将上述代码对应的组织结构梳理到一张图里，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/62/8C/Ciqc1F-Sm8qAMOB0AAEcBeEv_vs533.png" alt="图片4.png"></p><p>借着这张图，我们来理解旧的 Context API 的工作过程：</p><ul><li><p>首先，通过给 MessageList 设置 childContextTypes 和 getChildContext，可以使其承担起 context 的生产者的角色；</p></li><li><p>然后，MessageList 的组件树内部所有层级的组件都可以通过定义 contextTypes 来成为数据的消费者，进而通过 this.context 访问到 MessageList 提供的数据。</p></li></ul><p>现在回过头来，我们再从编码角度审视一遍&quot;过时的&quot; Context API 的用法。</p><p>首先映入眼帘的第一个问题是<strong>代码不够优雅</strong>：一眼望去，你很难迅速辨别出谁是 Provider、谁是 Consumer。同时这琐碎的属性设置和 API 编写过程，也足够我们写代码的时候&quot;喝一壶了&quot;。总而言之，从编码形态的角度来说，&quot;过时的&quot; Context API 和新 Context API 相去甚远。</p><p>不过，这还不是最要命的，最要命的弊端我们从编码层面暂时感知不出来，但是一旦你感知到它，麻烦就大了------前面我们特别提到过，&quot;Cosumer 不仅能够读取到 Provider 下发的数据，<strong>还能够读取到这些数据后续的更新&quot;</strong>。数据在生产者和消费者之间的及时同步，这一点对于 Context 这种模式来说是至关重要的，但旧的 Conext API 无法保证这一点：</p><blockquote><p>如果组件提供的一个Context发生了变化，而中间父组件的 shouldComponentUpdate 返回 false，<strong>那么使用到该值的后代组件不会进行更新</strong> 。使用了 Context 的组件则完全失控，所以基本上没有办法能够可靠的更新 Context。<a href="https://medium.com/@mweststrate/how-to-safely-use-react-context-b7e343eff076" target="_blank" rel="noreferrer">这篇博客文章</a>很好地解释了为何会出现此类问题，以及你该如何规避它。 ------React 官方</p></blockquote><p>新的 Context API 改进了这一点：<strong>即便组件的 shouldComponentUpdate 返回 false，它仍然可以&quot;穿透&quot;组件继续向后代组件进行传播</strong> ，<strong>进而确保了数据生产者和数据消费者之间数据的一致性</strong>。再加上更加&quot;好看&quot;的语义化的声明式写法，新版 Context API 终于顺利地摘掉了&quot;试验性 API&quot;的帽子，成了一种确实可行的 React 组件间通信解决方案。</p><p>理解了 Context API 的前世今生，接下来我们继续来串联 React 组件间通信的解决方案。</p><h3 id="第三方数据流框架-课代表-初探-redux" tabindex="-1">第三方数据流框架&quot;课代表&quot;：初探 Redux <a class="header-anchor" href="#第三方数据流框架-课代表-初探-redux" aria-label="Permalink to &quot;第三方数据流框架&quot;课代表&quot;：初探 Redux&quot;">​</a></h3><p>对于简单的跨层级组件通信，我们可以使用发布-订阅模式或者 Context API 来搞定。但是随着应用的复杂度不断提升，需要维护的状态越来越多，组件间的关系也越来越难以处理的时候，我们就需要请出 Redux 来帮忙了。</p><h4 id="什么是-redux" tabindex="-1">什么是 Redux <a class="header-anchor" href="#什么是-redux" aria-label="Permalink to &quot;什么是 Redux&quot;">​</a></h4><p>我们先来看一下官方对 Redux 的描述：</p><blockquote><p>Redux 是 JavaScript 状态容器，它提供可预测的状态管理。</p></blockquote><p>我们一起品品这句话背后的深意：</p><ul><li><p>Redux 是为<strong>JavaScript</strong>应用而生的，也就是说它不是 React 的专利，React 可以用，Vue 可以用，原生 JavaScript 也可以用；</p></li><li><p>Redux 是一个<strong>状态容器</strong>，什么是状态容器？这里我举个例子。</p></li></ul><p>假如把一个 React 项目里面的所有组件拉进一个钉钉群，那么 Redux 就充当了这个群里的&quot;群文件&quot;角色，所有的组件都可以把需要在组件树里流动的数据存储在群文件里。当某个数据改变的时候，其他组件都能够通过下载最新的群文件来获取到数据的最新值。这就是&quot;状态容器&quot;的含义------存放公共数据的仓库。</p><p>读懂了这个比喻之后，你对 Redux、数据和 React 组件的关系想必已经形成了一个初步的认知。这里我帮你把这层关系总结进一张图里：</p><p><img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm9qASdHXAAEjhh30y4s113.png" alt="图片5.png"></p><h4 id="redux-是如何帮助-react-管理数据的" tabindex="-1">Redux 是如何帮助 React 管理数据的 <a class="header-anchor" href="#redux-是如何帮助-react-管理数据的" aria-label="Permalink to &quot;Redux 是如何帮助 React 管理数据的&quot;">​</a></h4><p>Redux 主要由三部分组成：store、reducer 和 action。我们先来看看它们各自代表什么：</p><ul><li><p>store 就好比组件群里的&quot;群文件&quot;，它是一个<strong>单一的数据源</strong>，而且是只读的；</p></li><li><p>action 人如其名，是&quot;动作&quot;的意思，它是<strong>对变化的描述</strong>。</p></li></ul><p>举个例子，下面这个对象就是一个 action：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> action </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  type</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;ADD_ITEM&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  payload</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&lt;li&gt;text&lt;/li&gt;&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> action </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  type</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;ADD_ITEM&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  payload</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&lt;li&gt;text&lt;/li&gt;&#39;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>reducer 是一个函数，它负责<strong>对变化进行分发和处理，</strong> 最终将新的数据返回给 store。</li></ul><p>store、action 和 reducer 三者紧密配合，便形成了 Redux 独树一帜的工作流：</p><p><img src="https://s0.lgstatic.com/i/image/M00/62/97/CgqCHl-Sm-yADE6PAACSEywFSaA197.png" alt="图片6.png"></p><p>从上图中，我们首先读出的是数据的流向规律：<strong>在 Redux 的整个工作过程中，数据流是严格单向的</strong>。这一点一定一定要背下来，面试的时候也一定一定要记得说------不管面试官问的是 Redux 的设计思想还是工作流还是别的什么概念性的知识，开局先放这句话，准没错。</p><p>接下来仍然是围绕上图，我们来一起看看 Redux 是如何帮助 React 管理数据流的。对于一个 React 应用来说，视图（View）层面的所有数据（state）都来自 store（再一次诠释了单一数据源的原则）。</p><p>如果你想对数据进行修改，只有一种途径：派发 action。action 会被 reducer 读取，进而根据 action 内容的不同对数据进行修改、生成新的 state（状态），这个新的 state 会更新到 store 对象里，进而驱动视图层面做出对应的改变。</p><p>对于组件来说，任何组件都可以通过约定的方式从 store 读取到全局的状态，任何组件也都可以通过合理地派发 action 来修改全局的状态。<strong>Redux 通过提供一个统一的状态容器，使得数据能够自由而有序地在任意组件之间穿梭</strong>，这就是 Redux 实现组件间通信的思路。</p><h4 id="从编码的角度理解-redux-工作流" tabindex="-1">从编码的角度理解 Redux 工作流 <a class="header-anchor" href="#从编码的角度理解-redux-工作流" aria-label="Permalink to &quot;从编码的角度理解 Redux 工作流&quot;">​</a></h4><p>到这里，你已经了解了 Redux 的设计思想和要素关系。接下来我们将站在编码的角度，探讨 Redux 的工作流，将上文中所提及的各个要素和流程具象化。</p><p><strong>1. 使用 createStore 来完成 store 对象的创建</strong></p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 引入 redux</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { createStore } from &#39;redux&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 store</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> store = createStore(</span></span>
<span class="line"><span style="color:#E1E4E8;">    reducer,</span></span>
<span class="line"><span style="color:#E1E4E8;">    initial_state,</span></span>
<span class="line"><span style="color:#E1E4E8;">    applyMiddleware(middleware1, middleware2, .</span><span style="color:#FDAEB7;font-style:italic;">..</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 引入 redux</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { createStore } from &#39;redux&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 store</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> store = createStore(</span></span>
<span class="line"><span style="color:#24292E;">    reducer,</span></span>
<span class="line"><span style="color:#24292E;">    initial_state,</span></span>
<span class="line"><span style="color:#24292E;">    applyMiddleware(middleware1, middleware2, .</span><span style="color:#B31D28;font-style:italic;">..</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>createStore 方法是一切的开始，它接收三个入参：</p><ul><li><p>reducer；</p></li><li><p>初始状态内容；</p></li><li><p>指定中间件（这个你先不用管）。</p></li></ul><p>这其中一般来说，只有 reducer 是你不得不传的。下面我们就看看 reducer 的编码形态是什么样的。</p><p><strong>2. reducer 的作用是将新的 state 返回给 store</strong></p><p>一个 reducer 一定是一个纯函数，它可以有各种各样的内在逻辑，但它最终一定要返回一个 state：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> reducer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (state, action) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 此处是各种样的 state处理逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> new_state</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> reducer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (state, action) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 此处是各种样的 state处理逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> new_state</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当我们基于某个 reducer 去创建 store 的时候，其实就是给这个 store 指定了一套更新规则：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 更新规则全都写在 reducer 里 </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> store </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createStore</span><span style="color:#E1E4E8;">(reducer)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 更新规则全都写在 reducer 里 </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> store </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createStore</span><span style="color:#24292E;">(reducer)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><strong>3. action 的作用是通知 reducer &quot;让改变发生&quot;</strong></p><p>如何在浩如烟海的 store 状态库中，准确地命中某个我们希望它发生改变的 state 呢？reducer 内部的逻辑虽然不尽相同，但其本质工作都是&quot;将 action 与和它对应的更新动作对应起来，并处理这个更新&quot;。所以说<strong>要想让 state 发生改变，就必须用正确的 action 来驱动这个改变</strong>。</p><p>前面我们已经介绍过 action 的形态，这里再提点一下。首先，action 是一个大致长这样的对象：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> action </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  type</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;ADD_ITEM&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  payload</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&lt;li&gt;text&lt;/li&gt;&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> action </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  type</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;ADD_ITEM&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  payload</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&lt;li&gt;text&lt;/li&gt;&#39;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>action 对象中允许传入的属性有多个，<strong>但只有 type 是必传的</strong>。type 是 action 的唯一标识，reducer 正是通过不同的 type 来识别出需要更新的不同的 state，由此才能够实现精准的&quot;定向更新&quot;。</p><p><strong>4. 派发 action，靠的是 dispatch</strong></p><p>action 本身只是一个对象，要想让 reducer 感知到 action，还需要&quot;派发 action&quot;这个动作，这个动作是由 store.dispatch 完成的。这里我简单地示范一下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { createStore } from &#39;redux&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 reducer</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> reducer = (state, action) =&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 此处是各种样的 state处理逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FDAEB7;font-style:italic;">return</span><span style="color:#E1E4E8;"> new_state</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 基于 reducer 创建 state</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> store = createStore(reducer)</span></span>
<span class="line"><span style="color:#6A737D;">// 创建一个 action，这个 action 用 &quot;ADD_ITEM&quot; 来标识 </span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> action = {</span></span>
<span class="line"><span style="color:#E1E4E8;">  type: &quot;ADD_ITEM&quot;,</span></span>
<span class="line"><span style="color:#E1E4E8;">  payload: &#39;&lt;li&gt;text&lt;/li&gt;&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span></span>
<span class="line"><span style="color:#E1E4E8;">store.dispatch(action)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { createStore } from &#39;redux&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 reducer</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> reducer = (state, action) =&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 此处是各种样的 state处理逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#B31D28;font-style:italic;">return</span><span style="color:#24292E;"> new_state</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 基于 reducer 创建 state</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> store = createStore(reducer)</span></span>
<span class="line"><span style="color:#6A737D;">// 创建一个 action，这个 action 用 &quot;ADD_ITEM&quot; 来标识 </span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> action = {</span></span>
<span class="line"><span style="color:#24292E;">  type: &quot;ADD_ITEM&quot;,</span></span>
<span class="line"><span style="color:#24292E;">  payload: &#39;&lt;li&gt;text&lt;/li&gt;&#39;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 使用 dispatch 派发 action，action 会进入到 reducer 里触发对应的更新</span></span>
<span class="line"><span style="color:#24292E;">store.dispatch(action)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>以上这段代码，是从编码角度对 Redux 主要工作流的概括，这里我同样为你总结了一张对应的流程图：</p><p><img src="https://s0.lgstatic.com/i/image/M00/81/9F/CgqCHl_Rii2AVvUbAADn4s_6rB8369.png" alt="图片7.png"></p><p>注意：先别急着死磕。本课时并不要求你掌握 Redux 中涉及的所有概念和原理，只需要你跟着我的思路走，大致理解 Redux 中几个关键角色之间的关系，进而明白 Redux 是如何驱动数据在 React 组件间流动、如何帮助我们实现<strong>灵活的组件间通信</strong>的，这就够了。关于更多 Redux 的技术细节，我将在专栏的第三个大模块慢慢推敲。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>在 04 和 05 课时，我讲解的知识点覆盖面广、跨度大。面试场景下，考察此类问题的目的也主要是对候选人的知识广度进行检验。因此对于这两节的内容，你应抱着梳理&quot;<strong>知识地图</strong> &quot;的目的去学习，以<strong>构建知识体系</strong>为第一要务。完成第一要务后，再带着一个完整的上下文，去攻克某个具体的薄弱点。</p>`,85),o=[e];function t(r,c,i,E,y,u){return n(),a("div",null,o)}const g=s(l,[["render",t]]);export{b as __pageData,g as default};
