import{_ as l,j as o,o as p,h as r,k as e,f as a,Q as n,s as t}from"./chunks/framework.d3daa342.js";const H=JSON.parse('{"title":"第43讲：优先实现面向接口的测试","description":"","frontmatter":{},"headers":[],"relativePath":"posts/devops/112-高效敏捷测试文档/(1628) 第43讲：优先实现面向接口的测试.md","filePath":"posts/devops/112-高效敏捷测试文档/(1628) 第43讲：优先实现面向接口的测试.md","lastUpdated":1696682708000}'),c={name:"posts/devops/112-高效敏捷测试文档/(1628) 第43讲：优先实现面向接口的测试.md"},i=n("",15),g=t("p",null,"图1 用户查询返回的 Response 信息",-1),_=t("p",null,"第二个场景是添加 3 个新的用户。第三个场景是更新用户 ID 为 1234 的用户信息。第四个测试场景是删除用户 ID 为 1233 的用户。测试用例代码 .feature 文件如图 2 所示。",-1),d=t("p",null,"图2 Karate 接口测试代码示例",-1),A=t("p",null,"上面是一个单接口测试的例子，并不足以展示 Karate 支持复杂场景的强大功能。在实际的测试中，一个业务场景往往是由多个接口的串行调用完成的。并且，一个业务操作会触发后端一系列 API 的级联调用，而后一个 API 需要使用前一个 API 返回结果中的某些信息才能进行测试。图 3 是 Karate 官网中的一段测试代码，在这段代码中，第二个 API 的调用地址就是第一个 API 返回结构中的 ID 信息。",-1),h=n("",10),y=t("p",null,"图 4 Swagger 生成的动态接口文档示例",-1),E=t("p",null,[a("另外一种方式是契约形式的接口文档，契约规定的是接口的调用者和被调用者之间约定的 Request 和 Response 数据交互格式。这里不得不提一下"),t("strong",null,"契约测试方法"),a(" ，又叫"),t("strong",null,"消费者驱动的契约测试（Consumer Driven Contract, CDC）"),a("，在契约测试里，接口的调用者被称为消费者，被调用者称为提供者。其核心思想在于从消费者业务实现的角度出发，由消费者自己定义需要的数据格式及交互细节，并驱动生成一份消费者契约。然后开发者根据契约分别实现自己的业务逻辑，并在服务提供者端进行测试，验证所调用的接口是否按照契约规定的内容返回正确的信息。主流的契约测试工具包括 PACT、Spring Cloud Contract。通过契约测试可以生成需要的契约文档，存放在代码仓库里。")],-1),I=t("p",null,"前端根据这份契约，可以搭建一个 Mock Server 模拟后端服务器的响应，在对前端的测试中所有需要和后端交互的场景下请求都发往这个 Mock Server，以此达到前后端调试的解耦。",-1),P=t("h3",{id:"契约测试和微服务的接口测试",tabindex:"-1"},[a("契约测试和微服务的接口测试 "),t("a",{class:"header-anchor",href:"#契约测试和微服务的接口测试","aria-label":'Permalink to "契约测试和微服务的接口测试"'},"​")],-1),u=t("p",null,"对于微服务来说，应用契约测试的方法进行接口测试比较高效，只要验证被调用的接口组合（已实现的业务逻辑），没有被调用的接口（用不到的逻辑）无须测试。另外，开展微服务的接口测试也需要根据契约，搭建 Mock Server 来实现微服务之间的解耦。一个大型软件系统由多个微服务组成，通常完成一个业务操作需要调用多个服务才能完成。但是，微服务之间的相互调用和依赖关系又比较复杂，如图 5 所示。",-1),m=t("p",null,"图5 微服务之间的依赖关系",-1),f=t("p",null,"当我们对 A 进行接口测试时，A 又会调用 B 和 C，C 又会调用 D，因为微服务都是独立开发的。当 B、C 或者 D 中的任何一个处于不可用状态时，针对 A 的接口测试无法进行。要想在测试中解除微服务 A 对其他服务的依赖，就要用到 Mock 技术。这里是指启动 Mock Service 代替 B 和 C 来响应服务 A 发出的请求，而这时服务 C 对 D 的调用也无须再关心，如图 6 所示。",-1),S=t("p",null,"图6 利用 Mock 技术解除微服务之间的依赖",-1),T=t("p",null,"像 WireMock 和第 15 讲介绍过的服务虚拟化工具 Hoverfly 都提供了在 API 层面 Mock 微服务的功能，另外还有不少 Mock 框架比如 Mokito、Moco 等。Mock Server 在搭建过程中，一个重要方面就是定义出需要模拟的请求和响应，上面说的契约文档在这里就发挥了作用。可以根据微服务 A 和 B、A 和 C 之间的契约文件很容易创建出 Json 格式的请求和响应信息文件，如图 7 所示。当 Mock Service 启动后，不必启动真实的应用，我们再执行如图 2 所示的测试 GET 的测试用例，Mock Service 就可以代替真实应用给出响应。",-1),b=t("p",null,"图7 Mock 请求和响应信息示例",-1),k=t("h3",{id:"ai-助力接口测试",tabindex:"-1"},[a("AI 助力接口测试 "),t("a",{class:"header-anchor",href:"#ai-助力接口测试","aria-label":'Permalink to "AI 助力接口测试"'},"​")],-1),v=t("p",null,"对于 UI 自动化测试来说，接口测试确实具备更大的优势，但同时，也需要负责接口测试的人员具备更高的技术能力，包括对系统架构和接口设计的了解，熟练使用各种工具和技术编写测试脚本、执行接口测试、分析接口信息及接口调用链信息等。",-1),C=t("p",null,"人们已经开始研究如何应用 AI 技术降低接口测试的复杂度。比如，当工程师在 UI 界面上进行操作，利用 AI 技术可以监控系统后台运行，通过分析获取的数据得到 API 调用序列，以及请求和响应信息，进而自动生成 API 测试用例。另外，还可以结合人工智能算法来完善接口测试需要的测试数据。相信在未来 AI 技术一定可以极大提高接口测试的效率。",-1),B=t("p",null,"今天这一讲到这里就结束了，主要结合 Karate 介绍了接口测试的开发、如何获取接口信息，以及微服务的接口测试如何实现服务之间的解耦，还有 AI 技术在接口测试中的应用前景。",-1),M=t("p",null,"今天给你出的思考题是：Karate 和你用过的其他接口测试工具相比，是否更有优势？",-1);function D(q,x,K,R,w,F){const s=o("Image");return p(),r("div",null,[i,e(s,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/14/83/CgqCHl7Q7LmABYj6AAAiP3IYvho647.png"}),a(),g,_,e(s,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/14/78/Ciqc1F7Q7L-AMqOfAACIaf5Sack444.png"}),a(),d,A,e(s,{alt:"3.png",src:"https://s0.lgstatic.com/i/image/M00/14/83/CgqCHl7Q7MiAfyW1AAOBKZnBmqk158.png"}),a(),h,e(s,{alt:"4.png",src:"https://s0.lgstatic.com/i/image/M00/14/78/Ciqc1F7Q7NWAT0veAAOjzoL_ysA572.png"}),a(),y,E,I,P,u,e(s,{alt:"5.png.png",src:"https://s0.lgstatic.com/i/image/M00/14/78/Ciqc1F7Q7N-AbdazAABxmTP1rXE409.png"}),a(),m,f,e(s,{alt:"6.png",src:"https://s0.lgstatic.com/i/image/M00/14/83/CgqCHl7Q7OeAa3QdAAB77wy7fUs059.png"}),a(),S,T,e(s,{alt:"7.png",src:"https://s0.lgstatic.com/i/image/M00/14/78/Ciqc1F7Q7O6AefpqAAApTOMESPA827.png"}),a(),b,k,v,C,B,M])}const N=l(c,[["render",D]]);export{H as __pageData,N as default};
