import{_ as n,j as o,o as i,g as r,k as s,h as l,Q as t,s as a}from"./chunks/framework.a0d18f64.js";const Ja=JSON.parse('{"title":"第25讲：福利：常见JVM面试题补充","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1050) 第25讲：福利：常见 JVM 面试题补充.md","filePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1050) 第25讲：福利：常见 JVM 面试题补充.md","lastUpdated":1696682708000}'),p={name:"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1050) 第25讲：福利：常见 JVM 面试题补充.md"},h=t("",32),c=a("br",null,null,-1),d=a("p",null,"上面是第 02 课时中的一张图，注意左半部分是 Java 8 版本之前的内存区域，右半部分是 Java 8 的内存区域，主要区别就在 Perm 区和 Metaspace 区。",-1),_=a("br",null,null,-1),u=a("p",null,"Perm 区属于堆，独立控制大小，在 Java 8 中被移除了（JEP122），原来的方法区就在这里；Metaspace 是非堆，默认空间无上限，方法区移动到了这里。",-1),b=a("h2",{id:"常见面试题",tabindex:"-1"},[l("常见面试题 "),a("a",{class:"header-anchor",href:"#常见面试题","aria-label":'Permalink to "常见面试题"'},"​")],-1),m=a("h3",{id:"jvm-有哪些内存区域-jvm-的内存布局是什么",tabindex:"-1"},[l("JVM 有哪些内存区域？（JVM 的内存布局是什么？） "),a("a",{class:"header-anchor",href:"#jvm-有哪些内存区域-jvm-的内存布局是什么","aria-label":'Permalink to "JVM 有哪些内存区域？（JVM 的内存布局是什么？）"'},"​")],-1),g=a("p",null,"JVM 包含堆、元空间、Java 虚拟机栈、本地方法栈、程序计数器等内存区域，其中，堆是占用内存最大的一块，如下图所示。",-1),C=a("br",null,null,-1),M=a("h3",{id:"java-的内存模型是什么-jmm-是什么",tabindex:"-1"},[l("Java 的内存模型是什么？（JMM 是什么？） "),a("a",{class:"header-anchor",href:"#java-的内存模型是什么-jmm-是什么","aria-label":'Permalink to "Java 的内存模型是什么？（JMM 是什么？）"'},"​")],-1),q=a("p",null,[l("JVM 试图定义一种统一的内存模型，能将各种底层硬件以及操作系统的内存访问差异进行封装，使 Java 程序在不同硬件以及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器"),a("strong",null,"直接"),l("进行操作，如果一个线程要和另外一个线程通信，那么只能通过主存进行交换，如下图所示。")],-1),v=a("br",null,null,-1),P=a("h3",{id:"jvm-垃圾回收时如何确定垃圾-什么是-gc-roots",tabindex:"-1"},[l("JVM 垃圾回收时如何确定垃圾？什么是 GC Roots？ "),a("a",{class:"header-anchor",href:"#jvm-垃圾回收时如何确定垃圾-什么是-gc-roots","aria-label":'Permalink to "JVM 垃圾回收时如何确定垃圾？什么是 GC Roots？"'},"​")],-1),f=a("p",null,[l("JVM 采用的是"),a("strong",null,"可达性分析算法"),l("。JVM 是通过 GC Roots 来判定对象存活的，从 GC Roots 向下追溯、搜索，会产生一个叫做 Reference Chain 的链条。当一个对象不能和任何一个 GC Root 产生关系时，就判定为垃圾，如下图所示。")],-1),A=a("br",null,null,-1),k=t("",30),J=a("br",null,null,-1),E=a("p",null,"很多垃圾回收器都是分代回收的：",-1),x=a("ul",null,[a("li",null,[a("p",null,"对于年轻代，主要有 Serial、ParNew 等垃圾回收器，回收过程主要使用复制算法；")]),a("li",null,[a("p",null,"老年代的回收算法有 Serial、CMS 等，主要使用标记清除、标记整理算法等。")])],-1),S=a("br",null,null,-1),j=a("p",null,"我们线上使用较多的是 G1，也有年轻代和老年代的概念，不过它是一个整堆回收器，它的回收对象是小堆区 。",-1),T=a("h3",{id:"生产上如何配置垃圾收集器",tabindex:"-1"},[l("生产上如何配置垃圾收集器？ "),a("a",{class:"header-anchor",href:"#生产上如何配置垃圾收集器","aria-label":'Permalink to "生产上如何配置垃圾收集器？"'},"​")],-1),G=t("",11),V=t("",8),y=a("h3",{id:"jit-是什么",tabindex:"-1"},[l("JIT 是什么？ "),a("a",{class:"header-anchor",href:"#jit-是什么","aria-label":'Permalink to "JIT 是什么？"'},"​")],-1),O=a("p",null,"为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器，就称为即时编译器（Just In Time Compiler），简称 JIT 编译器。",-1),I=a("h3",{id:"java-的双亲委托机制是什么",tabindex:"-1"},[l("Java 的双亲委托机制是什么？ "),a("a",{class:"header-anchor",href:"#java-的双亲委托机制是什么","aria-label":'Permalink to "Java 的双亲委托机制是什么？"'},"​")],-1),H=a("p",null,"双亲委托的意思是，除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载，这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载，Java 默认是这种行为。",-1),R=a("br",null,null,-1),N=a("h3",{id:"有哪些打破了双亲委托机制的案例",tabindex:"-1"},[l("有哪些打破了双亲委托机制的案例？ "),a("a",{class:"header-anchor",href:"#有哪些打破了双亲委托机制的案例","aria-label":'Permalink to "有哪些打破了双亲委托机制的案例？"'},"​")],-1),D=a("ul",null,[a("li",null,[a("p",null,"Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；")]),a("li",null,[a("p",null,"Java 的 SPI，发起者是 BootstrapClassLoader，BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。")])],-1),B=a("h3",{id:"简单描述一下-分代-垃圾回收的过程",tabindex:"-1"},[l("简单描述一下（分代）垃圾回收的过程 "),a("a",{class:"header-anchor",href:"#简单描述一下-分代-垃圾回收的过程","aria-label":'Permalink to "简单描述一下（分代）垃圾回收的过程"'},"​")],-1),U=t("",14),F=t("",34),X=a("h3",{id:"safepoint-是什么",tabindex:"-1"},[l("safepoint 是什么？ "),a("a",{class:"header-anchor",href:"#safepoint-是什么","aria-label":'Permalink to "safepoint 是什么？"'},"​")],-1),w=a("p",null,"当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。",-1),L=a("br",null,null,-1),W=a("br",null,null,-1),z=a("p",null,"如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长。",-1),K=a("h3",{id:"minorgc、majorgc、fullgc-都什么时候发生",tabindex:"-1"},[l("MinorGC、MajorGC、FullGC 都什么时候发生？ "),a("a",{class:"header-anchor",href:"#minorgc、majorgc、fullgc-都什么时候发生","aria-label":'Permalink to "MinorGC、MajorGC、FullGC 都什么时候发生？"'},"​")],-1),Q=a("p",null,"MinorGC 在年轻代空间不足的时候发生，MajorGC 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。",-1),Y=a("br",null,null,-1),Z=a("p",null,"FullGC 有三种情况：第一，当老年代无法再分配内存的时候；第二，元空间不足的时候；第三，显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。",-1),$=a("h3",{id:"类加载有几个过程",tabindex:"-1"},[l("类加载有几个过程？ "),a("a",{class:"header-anchor",href:"#类加载有几个过程","aria-label":'Permalink to "类加载有几个过程？"'},"​")],-1),aa=a("p",null,"加载、验证、准备、解析、初始化。",-1),la=a("br",null,null,-1),ea=a("h3",{id:"什么情况下会发生栈溢出",tabindex:"-1"},[l("什么情况下会发生栈溢出？ "),a("a",{class:"header-anchor",href:"#什么情况下会发生栈溢出","aria-label":'Permalink to "什么情况下会发生栈溢出？"'},"​")],-1),sa=a("p",null,"栈的大小可以通过 -Xss 参数进行设置，当递归层次太深的时候，则会发生栈溢出。",-1),ta=a("h3",{id:"生产环境服务器变慢-请谈谈诊断思路和性能评估",tabindex:"-1"},[l("生产环境服务器变慢，请谈谈诊断思路和性能评估？ "),a("a",{class:"header-anchor",href:"#生产环境服务器变慢-请谈谈诊断思路和性能评估","aria-label":'Permalink to "生产环境服务器变慢，请谈谈诊断思路和性能评估？"'},"​")],-1),na=a("p",null,"希望第 11 课时和第 16 课时中的一些思路，能够祝你一臂之力。下图是第 11 课时的一张影响因素的全景图。",-1),oa=a("br",null,null,-1),ia=a("br",null,null,-1),ra=a("p",null,"从各个层次分析代码优化的手段，如下图所示：",-1),pa=a("br",null,null,-1),ha=a("br",null,null,-1),ca=a("p",null,"如果你应聘的是比较高级的职位，那么可以说一下第 23 课时中的最后总结部分。",-1),da=a("h2",{id:"小结",tabindex:"-1"},[l("小结 "),a("a",{class:"header-anchor",href:"#小结","aria-label":'Permalink to "小结"'},"​")],-1),_a=a("p",null,"本课时我们首先修正了一些表述错误的知识点；然后分析了一些常见的面试题，这些面试题的覆盖率是非常有限的，因为很多细节都没有触及到，更多的面试题还需要你自行提取、整理，由于篇幅有限，这里不再重复。",-1),ua=a("br",null,null,-1),ba=a("p",null,"到现在为止，我们的课程内容就结束了。本课程的特色主要体现在实践方面，全部都是工作中的总结和思考；辅之以理论，给你一个在工作中，JVM 相关知识点的全貌。当然，有些课时的难度是比较高的，需要你真正的实际操作一下。",-1),ma=a("br",null,null,-1),ga=a("p",null,"写作的过程中难免会有遗漏的知识点，可通过拉勾客服人员加入本课程的读者群一起讨论；如果你觉得课程不错，从中有所收获的话，不要忘了推荐给身边的朋友哦。前路漫漫，一起加油。",-1);function Ca(Ma,qa,va,Pa,fa,Aa){const e=o("Image");return i(),r("div",null,[h,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4GAXM3XAACpvfOEmdk260.png"}),l(),c,d,_,u,b,m,g,C,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4KAbe-xAACSSN1rS98669.jpg"}),l(),M,q,v,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4KAYGALAAF3j6kY7OI652.png"}),l(),P,f,A,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4KAUCqzAAEDpeV55bE922.png"}),l(),k,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4KAbsMwAACVJa0xdMc029.jpg"}),l(),J,E,x,S,j,T,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4OAcpCUAAAYCOBxrH8618.png"}),l(),G,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4OAT38jAAAl0jcj3H0640.jpg"}),l(),V,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4OAInSTAACWN8lgBuA383.jpg"}),l(),y,O,I,H,R,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4OAX9fAAADieibiUuA348.png"}),l(),N,D,B,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4OAFZj9AAA7U919leM725.jpg"}),l(),U,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4OAYpeDAABCQlC0IWQ535.jpg"}),l(),F,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4OAO_N8AABmfN7QgL0284.jpg"}),l(),X,w,L,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4SAVqTuAABceJSJQk8710.jpg"}),l(),W,z,K,Q,Y,Z,$,aa,la,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4SAYQTJAACt3FpxOSM490.png"}),l(),ea,sa,ta,na,oa,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/09/20/Ciqah16HO4SADz5OAACHagS1bpQ945.jpg"}),l(),ia,ra,pa,s(e,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/82/36/Cgq2xl6HO4SAFAAeAADxCaBZvss793.png"}),l(),ha,ca,da,_a,ua,ba,ma,ga])}const Ea=n(p,[["render",Ca]]);export{Ja as __pageData,Ea as default};
