import{_ as o,j as e,o as t,h as c,k as p,f as n,s,Q as l}from"./chunks/framework.d3daa342.js";const x=JSON.parse('{"title":"23核心接口介绍，RPC层骨架梳理","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4273) 23  核心接口介绍，RPC 层骨架梳理.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4273) 23  核心接口介绍，RPC 层骨架梳理.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4273) 23  核心接口介绍，RPC 层骨架梳理.md"},E=s("h1",{id:"_23核心接口介绍-rpc层骨架梳理",tabindex:"-1"},[n("23核心接口介绍，RPC层骨架梳理 "),s("a",{class:"header-anchor",href:"#_23核心接口介绍-rpc层骨架梳理","aria-label":'Permalink to "23核心接口介绍，RPC层骨架梳理"'},"​")],-1),y=s("p",null,[n("在前面的课程中，我们深入介绍了 Dubbo 架构中的 Dubbo Remoting 层的相关内容，了解了 Dubbo 底层的网络模型以及线程模型。从本课时开始，我们就开始介绍 Dubbo Remoting 上面的一层------ Protocol 层（如下图所示），"),s("strong",null,"Protocol 层是 Remoting 层的使用者"),n("，会通过 Exchangers 门面类创建 ExchangeClient 以及 ExchangeServer，还会创建相应的 ChannelHandler 实现以及 Codec2 实现并交给 Exchange 层进行装饰。")],-1),i=s("p",null,"Dubbo 架构中 Protocol 层的位置图",-1),F=s("p",null,[s("strong",null,"Protocol 层在 Dubbo 源码中对应的是 dubbo-rpc 模块"),n("，该模块的结构如下图所示：")],-1),g=s("p",null,"dubbo-rpc 模块结构图",-1),A=s("p",null,[n("我们可以看到有很多模块，和 dubbo-remoting 模块类似，其中 "),s("strong",null,"dubbo-rpc-api 是对具体协议、服务暴露、服务引用、代理等的抽象，是整个 Protocol 层的核心"),n("。剩余的模块，例如，dubbo-rpc-dubbo、dubbo-rpc-grpc、dubbo-rpc-http 等，都是 Dubbo 支持的具体协议，可以看作dubbo-rpc-api 模块的具体实现。")],-1),v=s("h3",{id:"dubbo-rpc-api",tabindex:"-1"},[n("dubbo-rpc-api "),s("a",{class:"header-anchor",href:"#dubbo-rpc-api","aria-label":'Permalink to "dubbo-rpc-api"'},"​")],-1),d=s("p",null,"这里我们首先来看 dubbo-rpc-api 模块的包结构，如下图所示：",-1),u=l('<p>dubbo-rpc-api 模块的包结构图</p><p>根据上图展示的 dubbo-rpc-api 模块的结构，我们可以看到 dubbo-rpc-api 模块包括了以下几个核心包。</p><ul><li><p>filter 包：在进行服务引用时会进行一系列的过滤，其中包括了很多过滤器。</p></li><li><p>listener 包：在服务发布和服务引用的过程中，我们可以添加一些 Listener 来监听相应的事件，与 Listener 相关的接口 Adapter、Wrapper 实现就在这个包内。</p></li><li><p>protocol 包：一些实现了 Protocol 接口以及 Invoker 接口的抽象类位于该包之中，它们主要是为 Protocol 接口的具体实现以及 Invoker 接口的具体实现提供一些公共逻辑。</p></li><li><p>proxy 包：提供了创建代理的能力，在这个包中支持 JDK 动态代理以及 Javassist 字节码两种方式生成本地代理类。</p></li><li><p>support 包：包括了 RpcUtils 工具类、Mock 相关的 Protocol 实现以及 Invoker 实现。</p></li></ul><p>没有在上述 package 中的接口和类，是更为核心的抽象接口，上述 package 内的类更多的是这些接口的实现类。下面我们就来介绍这些在 org.apache.dubbo.rpc 包下的核心接口。</p><h3 id="核心接口" tabindex="-1">核心接口 <a class="header-anchor" href="#核心接口" aria-label="Permalink to &quot;核心接口&quot;">​</a></h3><p>在 Dubbo RPC 层中涉及的核心接口有 Invoker、Invocation、Protocol、Result、Exporter、ProtocolServer、Filter 等，这些接口分别抽象了 Dubbo RPC 层的不同概念，看似相互独立，但又相互协同，一起构建出了 DubboRPC 层的骨架。下面我们将逐一介绍这些核心接口的含义。</p><p>首先要介绍的是 Dubbo 中非常重要的一个接口------<strong>Invoker 接口</strong>。可以说，Invoker 渗透在整个 Dubbo 代码实现里，Dubbo 中的很多设计思路都会向 Invoker 这个概念靠拢，但这对于刚接触这部分代码的同学们来说，可能不是很友好。</p><p>这里我们借助如下这样一个精简的示意图来对比说明两种最关键的 Invoker：服务提供 Invoker 和服务消费 Invoker。</p>',8),b=l(`<p>Invoker 核心示意图</p><p>以 dubbo-demo-annotation-consumer 这个示例项目中的 Consumer 为例，它会拿到一个 DemoService 对象，如下所示，这其实是一个代理（即上图中的 Proxy），这个 Proxy 底层就会通过 Invoker 完成网络调用：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Component</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;demoServiceComponent&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoServiceComponent</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Reference</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> DemoService demoService;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> demoService.</span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(name);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Component</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;demoServiceComponent&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoServiceComponent</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoService</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Reference</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> DemoService demoService;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">sayHello</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">name</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> demoService.</span><span style="color:#6F42C1;">sayHello</span><span style="color:#24292E;">(name);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>紧接着我们再来看一个 dubbo-demo-annotation-provider 示例中的 Provider 实现：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Service</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoServiceImpl</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoService</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> String </span><span style="color:#B392F0;">sayHello</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">name</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Hello &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> name </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;, response from provider: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getLocalAddress</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Service</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoServiceImpl</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoService</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> String </span><span style="color:#6F42C1;">sayHello</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">name</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Hello &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> name </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;, response from provider: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getLocalAddress</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里的 DemoServiceImpl 类会被封装成为一个 AbstractProxyInvoker 实例，并新生成对应的 Exporter 实例。当 Dubbo Protocol 层收到一个请求之后，会找到这个 Exporter 实例，并调用其对应的 AbstractProxyInvoker 实例，从而完成 Provider 逻辑的调用。这里我先帮你找出了最重要的两类 Invoker ，简单介绍了它们工作场景，当然 Dubbo 中还有其他类型的 Invoker，后面我们再一一介绍。</p><p>下面来看 Invoker 这个接口的具体定义，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Invoker</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Node</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 服务接口</span></span>
<span class="line"><span style="color:#E1E4E8;">    Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getInterface</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 进行一次调用，也有人称之为一次&quot;会话&quot;，你可以理解为一次调用</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Invoker</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Node</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 服务接口</span></span>
<span class="line"><span style="color:#24292E;">    Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getInterface</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 进行一次调用，也有人称之为一次&quot;会话&quot;，你可以理解为一次调用</span></span>
<span class="line"><span style="color:#24292E;">    Result </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>Invocation 接口</strong>是 Invoker.invoke() 方法的参数，抽象了一次 RPC 调用的目标服务和方法信息、相关参数信息、具体的参数值以及一些附加信息，具体定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Invocation</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用Service的唯一标识</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getTargetServiceUniqueName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用的方法名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getMethodName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用的服务名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getServiceName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 参数类型集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    Class&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt;[] </span><span style="color:#B392F0;">getParameterTypes</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 参数签名集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">getCompatibleParamSignatures</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Stream.</span><span style="color:#B392F0;">of</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getParameterTypes</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(Class</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">getName)</span></span>
<span class="line"><span style="color:#E1E4E8;">                .</span><span style="color:#B392F0;">toArray</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[]</span><span style="color:#F97583;">::new</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 此次调用具体的参数值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">getArguments</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 此次调用关联的Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    Invoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getInvoker</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Invoker对象可以设置一些KV属性，这些属性并不会传递给Provider</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getAttributes</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Invocation可以携带一个KV信息作为附加信息，一并传递给Provider，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意与 attribute 的区分</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getAttachments</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getObjectAttachments</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, String </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setObjectAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachmentIfAbsent</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, String </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachmentIfAbsent</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setObjectAttachmentIfAbsent</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getObjectAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, String </span><span style="color:#FFAB70;">defaultValue</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getObjectAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">defaultValue</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Invocation</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用Service的唯一标识</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getTargetServiceUniqueName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用的方法名称</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getMethodName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用的服务名称</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getServiceName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 参数类型集合</span></span>
<span class="line"><span style="color:#24292E;">    Class&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt;[] </span><span style="color:#6F42C1;">getParameterTypes</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 参数签名集合</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">getCompatibleParamSignatures</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Stream.</span><span style="color:#6F42C1;">of</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getParameterTypes</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">(Class</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">getName)</span></span>
<span class="line"><span style="color:#24292E;">                .</span><span style="color:#6F42C1;">toArray</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[]</span><span style="color:#D73A49;">::new</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 此次调用具体的参数值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">getArguments</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 此次调用关联的Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    Invoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getInvoker</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Invoker对象可以设置一些KV属性，这些属性并不会传递给Provider</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">key</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getAttributes</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Invocation可以携带一个KV信息作为附加信息，一并传递给Provider，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意与 attribute 的区分</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getAttachments</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getObjectAttachments</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, String </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setObjectAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachmentIfAbsent</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, String </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachmentIfAbsent</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setObjectAttachmentIfAbsent</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">getObjectAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, String </span><span style="color:#E36209;">defaultValue</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">getObjectAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">defaultValue</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>Result 接口</strong>是 Invoker.invoke() 方法的返回值，抽象了一次调用的返回值，其中包含了被调用方返回值（或是异常）以及附加信息，我们也可以添加回调方法，在 RPC 调用方法结束时会触发这些回调。Result 接口的具体定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Result</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Serializable</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取/设置此次调用的返回值</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getValue</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setValue</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果此次调用发生异常，则可以通过下面三个方法获取</span></span>
<span class="line"><span style="color:#E1E4E8;">    Throwable </span><span style="color:#B392F0;">getException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setException</span><span style="color:#E1E4E8;">(Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">hasException</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// recreate()方法是一个复合操作，如果此次调用发生异常，则直接抛出异常，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果没有异常，则返回结果</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">recreate</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 添加一个回调，当RPC调用完成时，会触发这里添加的回调</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result </span><span style="color:#B392F0;">whenCompleteWithContext</span><span style="color:#E1E4E8;">(BiConsumer&lt;</span><span style="color:#F97583;">Result</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">U</span><span style="color:#E1E4E8;">&gt; CompletableFuture&lt;</span><span style="color:#F97583;">U</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">thenApply</span><span style="color:#E1E4E8;">(Function&lt;</span><span style="color:#F97583;">Result</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">U</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 阻塞线程，等待此次RPC调用完成(或是超时)</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException, ExecutionException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">timeout</span><span style="color:#E1E4E8;">, TimeUnit </span><span style="color:#FFAB70;">unit</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> InterruptedException, ExecutionException, TimeoutException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Result中同样可以携带附加信息</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getAttachments</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getObjectAttachments</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addAttachments</span><span style="color:#E1E4E8;">(Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">map</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">addObjectAttachments</span><span style="color:#E1E4E8;">(Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">map</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachments</span><span style="color:#E1E4E8;">(Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">map</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setObjectAttachments</span><span style="color:#E1E4E8;">(Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">map</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getObjectAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">getAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, String </span><span style="color:#FFAB70;">defaultValue</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Object </span><span style="color:#B392F0;">getObjectAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">defaultValue</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, String </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setObjectAttachment</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">key</span><span style="color:#E1E4E8;">, Object </span><span style="color:#FFAB70;">valu</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Result</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Serializable</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取/设置此次调用的返回值</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">getValue</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setValue</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果此次调用发生异常，则可以通过下面三个方法获取</span></span>
<span class="line"><span style="color:#24292E;">    Throwable </span><span style="color:#6F42C1;">getException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setException</span><span style="color:#24292E;">(Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">hasException</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// recreate()方法是一个复合操作，如果此次调用发生异常，则直接抛出异常，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果没有异常，则返回结果</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">recreate</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Throwable;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 添加一个回调，当RPC调用完成时，会触发这里添加的回调</span></span>
<span class="line"><span style="color:#24292E;">    Result </span><span style="color:#6F42C1;">whenCompleteWithContext</span><span style="color:#24292E;">(BiConsumer&lt;</span><span style="color:#D73A49;">Result</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">fn</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">U</span><span style="color:#24292E;">&gt; CompletableFuture&lt;</span><span style="color:#D73A49;">U</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">thenApply</span><span style="color:#24292E;">(Function&lt;</span><span style="color:#D73A49;">Result</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">U</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">fn</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 阻塞线程，等待此次RPC调用完成(或是超时)</span></span>
<span class="line"><span style="color:#24292E;">    Result </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException, ExecutionException;</span></span>
<span class="line"><span style="color:#24292E;">    Result </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> </span><span style="color:#E36209;">timeout</span><span style="color:#24292E;">, TimeUnit </span><span style="color:#E36209;">unit</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> InterruptedException, ExecutionException, TimeoutException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Result中同样可以携带附加信息</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getAttachments</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getObjectAttachments</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addAttachments</span><span style="color:#24292E;">(Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">map</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">addObjectAttachments</span><span style="color:#24292E;">(Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">map</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachments</span><span style="color:#24292E;">(Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">map</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setObjectAttachments</span><span style="color:#24292E;">(Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">map</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">getObjectAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">getAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, String </span><span style="color:#E36209;">defaultValue</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Object </span><span style="color:#6F42C1;">getObjectAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">defaultValue</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, String </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">value</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setObjectAttachment</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">key</span><span style="color:#24292E;">, Object </span><span style="color:#E36209;">valu</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在上面介绍 Provider 端的 Invoker 时提到，我们的业务接口实现会被包装成一个 AbstractProxyInvoker 对象，然后由 Exporter 暴露出去，让 Consumer 可以调用到该服务。Exporter 暴露 Invoker 的实现，说白了，就是让 Provider 能够根据请求的各种信息，找到对应的 Invoker。我们可以维护一个 Map，其中 Key 可以根据请求中的信息构建，Value 为封装相应服务 Bean 的 Exporter 对象，这样就可以实现上述服务发布的要求了。</p><p>我们先来看 <strong>Exporter 接口</strong>的定义：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Exporter</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取底层封装的Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getInvoker</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 取消发布底层的Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unexport</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Exporter</span><span style="color:#24292E;">&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取底层封装的Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getInvoker</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 取消发布底层的Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unexport</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>为了监听服务发布事件以及取消暴露事件，Dubbo 定义了一个 SPI 扩展接口------<strong>ExporterListener 接口</strong>，其定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ExporterListener</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当有服务发布的时候，会触发该方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">exported</span><span style="color:#E1E4E8;">(Exporter&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">exporter</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当有服务取消发布的时候，会触发该方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">unexported</span><span style="color:#E1E4E8;">(Exporter&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">exporter</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ExporterListener</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当有服务发布的时候，会触发该方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">exported</span><span style="color:#24292E;">(Exporter&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">exporter</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当有服务取消发布的时候，会触发该方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">unexported</span><span style="color:#24292E;">(Exporter&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">exporter</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>虽然 ExporterListener 是个扩展接口，但是 Dubbo 本身并没有提供什么有用的扩展实现，我们需要自己提供具体实现监听感兴趣的事情。</p><p>相应地，我们可以添加 InvokerListener 监听器，监听 Consumer 引用服务时触发的事件，<strong>InvokerListener 接口</strong>的定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InvokerListener</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当服务引用的时候，会触发该方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">referred</span><span style="color:#E1E4E8;">(Invoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当销毁引用的服务时，会触发该方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">destroyed</span><span style="color:#E1E4E8;">(Invoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InvokerListener</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当服务引用的时候，会触发该方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">referred</span><span style="color:#24292E;">(Invoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当销毁引用的服务时，会触发该方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">destroyed</span><span style="color:#24292E;">(Invoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>Protocol 接口</strong>是整个 Dubbo Protocol 层的核心接口之一，其中定义了 export() 和 refer() 两个核心方法，具体定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;dubbo&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 默认使用DubboProtocol实现</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Protocol</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 默认端口</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getDefaultPort</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将一个Invoker暴露出去，export()方法实现需要是幂等的，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 即同一个服务暴露多次和暴露一次的效果是相同的</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; Exporter&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">export</span><span style="color:#E1E4E8;">(Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 引用一个Invoker，refer()方法会根据参数返回一个Invoker对象，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// Consumer端可以通过这个Invoker请求到Provider端的服务</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">refer</span><span style="color:#E1E4E8;">(Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">type</span><span style="color:#E1E4E8;">, URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 销毁export()方法以及refer()方法使用到的Invoker对象，释放</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当前Protocol对象底层占用的资源</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">destroy</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回当前Protocol底层的全部ProtocolServer</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">ProtocolServer</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getServers</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Collections.</span><span style="color:#B392F0;">emptyList</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;dubbo&quot;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 默认使用DubboProtocol实现</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Protocol</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 默认端口</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getDefaultPort</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将一个Invoker暴露出去，export()方法实现需要是幂等的，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 即同一个服务暴露多次和暴露一次的效果是相同的</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; Exporter&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">export</span><span style="color:#24292E;">(Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 引用一个Invoker，refer()方法会根据参数返回一个Invoker对象，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// Consumer端可以通过这个Invoker请求到Provider端的服务</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">refer</span><span style="color:#24292E;">(Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">type</span><span style="color:#24292E;">, URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 销毁export()方法以及refer()方法使用到的Invoker对象，释放</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当前Protocol对象底层占用的资源</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">destroy</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回当前Protocol底层的全部ProtocolServer</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">ProtocolServer</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getServers</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Collections.</span><span style="color:#6F42C1;">emptyList</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 Protocol 接口的实现中，export() 方法并不是简单地将 Invoker 对象包装成 Exporter 对象返回，其中还涉及代理对象的创建、底层 Server 的启动等操作；refer() 方法除了根据传入的 type 类型以及 URL 参数查询 Invoker 之外，还涉及相关 Client 的创建等操作。</p><p>Dubbo 在 Protocol 层专门定义了一个 <strong>ProxyFactory 接口</strong>，作为创建代理对象的工厂。ProxyFactory 接口是一个扩展接口，其中定义了 getProxy() 方法为 Invoker 创建代理对象，还定义了 getInvoker() 方法将代理对象反向封装成 Invoker 对象。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;javassist&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ProxyFactory</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 为传入的Invoker对象创建代理对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span><span style="color:#E1E4E8;">({PROXY_KEY})</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; T </span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">(Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span><span style="color:#E1E4E8;">({PROXY_KEY})</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; T </span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">(Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">generic</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将传入的代理对象封装成Invoker对象，可以暂时理解为getProxy()的逆操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span><span style="color:#E1E4E8;">({PROXY_KEY})</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">getInvoker</span><span style="color:#E1E4E8;">(T </span><span style="color:#FFAB70;">proxy</span><span style="color:#E1E4E8;">, Class&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">type</span><span style="color:#E1E4E8;">, URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;javassist&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ProxyFactory</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 为传入的Invoker对象创建代理对象</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span><span style="color:#24292E;">({PROXY_KEY})</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; T </span><span style="color:#6F42C1;">getProxy</span><span style="color:#24292E;">(Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span><span style="color:#24292E;">({PROXY_KEY})</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; T </span><span style="color:#6F42C1;">getProxy</span><span style="color:#24292E;">(Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#E36209;">generic</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将传入的代理对象封装成Invoker对象，可以暂时理解为getProxy()的逆操作</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span><span style="color:#24292E;">({PROXY_KEY})</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">getInvoker</span><span style="color:#24292E;">(T </span><span style="color:#E36209;">proxy</span><span style="color:#24292E;">, Class&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">type</span><span style="color:#24292E;">, URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>看到 ProxyFactory 上的 @SPI 注解，我们知道其默认实现使用 javassist 来创建代码对象，当然，Dubbo 还提供了其他方式来创建代码，例如 JDK 动态代理。</p><p><strong>ProtocolServer 接口</strong>是对前文介绍的 RemotingServer 的一层简单封装，其实现也都非常简单，这里就不再展开。</p><p>最后一个要介绍的核心接口是 <strong>Filter 接口</strong>。关于 Filter，相信做过 Java Web 编程的同学们会非常熟悉这个基础概念，Java Web 开发中的 Filter 是用来拦截 HTTP 请求的，Dubbo 中的 Filter 接口功能与之类似，是用来拦截 Dubbo 请求的。</p><p>在 Dubbo 的 Filter 接口中，定义了一个 invoke() 方法将请求传递给后续的 Invoker 进行处理（后续的这个 Invoker 对象可能是一个 Filter 封装而成的）。Filter 接口的具体定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Filter</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将请求传给后续的Invoker进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Invoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Listener</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 用于监听响应以及异常</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onResponse</span><span style="color:#E1E4E8;">(Result </span><span style="color:#FFAB70;">appResponse</span><span style="color:#E1E4E8;">, Invoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">, Invoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">invoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Filter</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将请求传给后续的Invoker进行处理</span></span>
<span class="line"><span style="color:#24292E;">    Result </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Invoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Listener</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 用于监听响应以及异常</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onResponse</span><span style="color:#24292E;">(Result </span><span style="color:#E36209;">appResponse</span><span style="color:#24292E;">, Invoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">, Invoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">invoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Filter 也是一个扩展接口，Dubbo 提供了丰富的 Filter 实现来进行功能扩展，当然我们也可以提供自己的 Filter 实现来扩展 Dubbo 的功能。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时我们首先介绍了 Dubbo RPC 层在整个 Dubbo 框架中所处的位置，然后说明了 dubbo-rpc-api 层的结构以及其中各个包提供的基本功能。接下来，我们还详细介绍了 Dubbo RPC 层中涉及的核心接口，包括 Invoker、Invocation、Protocol、Result、ProxyFactory、ProtocolServer 等核心接口，以及 ExporterListener、Filter 等扩展类的接口。</p>`,33);function D(h,k,C,m,B,S){const a=e("Image");return t(),c("div",null,[E,y,p(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C4/Ciqc1F-FS2eAdVorABDINpNLpXY061.png"}),n(),i,F,p(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C4/Ciqc1F-FS4aAMyvkAABpKhWTC9Q132.png"}),n(),g,A,v,d,p(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/5D/CF/CgqCHl-FS5CAP7kCAADYKrhf28A273.png"}),n(),u,p(a,{alt:"Lark20201013-153553.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D2/Ciqc1F-FWQuAb1ypAAC0qPg0sWQ701.png"}),n(),b])}const P=o(r,[["render",D]]);export{x as __pageData,P as default};
