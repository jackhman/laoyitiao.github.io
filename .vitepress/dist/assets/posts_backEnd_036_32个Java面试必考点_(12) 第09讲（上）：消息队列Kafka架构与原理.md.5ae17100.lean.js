import{_ as t,j as r,o as l,g as n,k as o,h as e,Q as p,s as a}from"./chunks/framework.a0d18f64.js";const v=JSON.parse('{"title":"第09讲（上）：消息队列Kafka架构与原理","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/036_32个Java面试必考点/(12) 第09讲（上）：消息队列Kafka架构与原理.md","filePath":"posts/backEnd/036_32个Java面试必考点/(12) 第09讲（上）：消息队列Kafka架构与原理.md","lastUpdated":1696682708000}'),s={name:"posts/backEnd/036_32个Java面试必考点/(12) 第09讲（上）：消息队列Kafka架构与原理.md"},_=p("",5),c=p("",49),h=a("p",null,"首先 Kafka 消息队列由三个角色组成，左面的是消息的生产方 Producer；中间是 Kafka 集群， Kafka 集群由多台 Kafka server 组成，每个 Server 称为一个 Broker，也就是消息代理；右面的是消息的消费方 Consumer。",-1),d=a("p",null,"Kafka 中消息是按照 Topic 进行划分的，一个 Topic 就是一个 Queue。在实际应用中，不同业务数据就可以设置为不同的 Topic。一个 Topic 可以有多个消费方，当生产方在某个 Topic 发出一条消息后，所有订阅了这个 Topic 的消费方都可以收到这条消息。",-1),u=a("p",null,"为了提高并行能力，Kafka 为每个 Topic 维护了多个 Partition 分区，每个分区可以看作一份追加类型的日志。 每个分区中的消息保证 ID 唯一且有序，新消息不断追加到尾部。Partition 实际存储数据时，会对按大小进行分段（Segment），来保证总是对较小的文件进行写操作，提高性能，方便管理。",-1),k=a("p",null,"如图中间部分，Partition 分布于多个 Broker 上。图中绿色的模块表示 Topic1 被分为了 3 个 Partition。每个 Partition 会被复制多份存在于不同的 Broker 上，如图中红色的模块，这样可以保证主分区出现问题时进行容灾。每个 Broker 可以保存多个 Topic 的多个 Partition。",-1),S=a("p",null,"Kafka 只保证一个分区内的消息有序，不能保证一个 Topic 的不同分区之间的消息有序。为了保证较高的处理效率，所有的消息读写都是在主 Partition 中进行，其他副本分区只会从主分区复制数据。Kafka 会在 ZooKeeper 上针对每个 Topic 维护一个称为 ISR（in-sync replica），就是已同步的副本集。如果某个主分区不可用了，Kafka 就会从 ISR 集合中选择一个副本作为新的主分区。",-1),A=a("h6",{id:"消息发布-消费流程",tabindex:"-1"},[e("消息发布/消费流程 "),a("a",{class:"header-anchor",href:"#消息发布-消费流程","aria-label":'Permalink to "消息发布/消费流程"'},"​")],-1),P=a("p",null,"Kafka 通过对消费方进行分组管理来支持消息一写多读，流程如下图所示。",-1),f=a("br",null,null,-1),T=p("",11),m=a("p",null,"第一个原子性，指事务由原子的操作序列组成，所有操作要么全部成功，要么全部失败回滚。",-1),b=a("p",null,"第二个事务的一致性，指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如在做多表操作时，多个表要么都是事务后新的值，要么都是事务前的旧值。",-1),M=a("p",null,"第三个事务的隔离性，指多个用户并发访问数据库时，数据库为每个用户执行的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。事务的隔离级别在后文中介绍。",-1),g=a("p",null,"第四个事务的持久性，指一个事务一旦提交并执行成功，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。",-1),C=a("h6",{id:"并发问题",tabindex:"-1"},[e("并发问题 "),a("a",{class:"header-anchor",href:"#并发问题","aria-label":'Permalink to "并发问题"'},"​")],-1),Q=a("p",null,"在介绍数据的隔离级别之前，先看看没有隔离性的情况下数据库会出现哪些并发问题，如下图左侧部分所示。",-1),B=a("br",null,null,-1),K=p("",13),y=p("",11);function L(N,q,D,I,V,x){const i=r("Image");return l(),n("div",null,[_,o(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/AB/57/CgotOV3WANuANlgNAAE1sI_RJDk707.png"}),e(),c,o(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/AB/37/CgoB5l3WANyAF3c_AADzlbSKXcQ261.png"}),e(),h,d,u,k,S,A,P,f,o(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/AB/57/CgotOV3WANyAeuEAAAEVCeRMppA370.png"}),e(),T,o(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/AB/37/CgoB5l3WANyAYcRMAABaLbJGT1Q369.png"}),e(),m,b,M,g,C,Q,B,o(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/AB/57/CgotOV3WAN2ANddVAADwY17WNNE095.png"}),e(),K,o(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/AB/37/CgoB5l3WANuAZCmHAACv9TI5H7A917.png"}),e(),y])}const E=t(s,[["render",L]]);export{v as __pageData,E as default};
