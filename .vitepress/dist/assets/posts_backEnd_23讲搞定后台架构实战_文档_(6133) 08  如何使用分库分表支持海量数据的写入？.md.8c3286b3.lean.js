import{_ as l,j as a,o as _,g as i,k as s,h as p,s as t,Q as n}from"./chunks/framework.4e7d56ce.js";const v=JSON.parse('{"title":"08 如何使用分库分表支持海量数据的写入？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6133) 08  如何使用分库分表支持海量数据的写入？.md","filePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6133) 08  如何使用分库分表支持海量数据的写入？.md","lastUpdated":1696682708000}'),e={name:"posts/backEnd/23讲搞定后台架构实战_文档/(6133) 08  如何使用分库分表支持海量数据的写入？.md"},r=t("h1",{id:"_08-如何使用分库分表支持海量数据的写入",tabindex:"-1"},[p("08 如何使用分库分表支持海量数据的写入？ "),t("a",{class:"header-anchor",href:"#_08-如何使用分库分表支持海量数据的写入","aria-label":'Permalink to "08 如何使用分库分表支持海量数据的写入？"'},"​")],-1),c=t("p",null,"在上一模块里，我们讲解了如何使用懒加载、全量缓存等机制构建一个能够支撑百万并发的读服务，同时介绍了如何使用自动化回放来提升读服务的测试与回归效率，直接跳读到本模块的同学有空可以返回去学习一下。",-1),g=t("p",null,"在本模块的四讲里，将会介绍如何构建与读服务有着相反差异的写服务。并发百万的读服务每一次请求都不会产生新数据，是无状态的。而写服务不说并发百万，只要并发上万，一天产生的数据量也在亿级左右。本讲将要介绍如何存储这些海量数据，同时保证相对应的写入和查询的性能，以及业务流程不发生太大变化。",-1),h=t("p",null,[p("不管是打车的订单、电商里的支付订单，还是外卖或团购的支付订单，都是后台服务中最重要的一环，关乎公司的营收。因此，本讲及本模块都将以"),t("strong",null,"订单业务"),p("作为案例进行分析。")],-1),d=t("h3",{id:"是否真的要分库",tabindex:"-1"},[p("是否真的要分库？ "),t("a",{class:"header-anchor",href:"#是否真的要分库","aria-label":'Permalink to "是否真的要分库？"'},"​")],-1),u=t("p",null,"分库当然能够解决存储的问题，假设原先单库只能最多存储 2 千万的数据量。采用分库之后，存储架构变成下图 1 所示的分库架构，每个分库都可以存储 2 千万数据量，容量的上限一下提升了。",-1),A=n("",5),m=t("p",null,"图 2：分表架构图",-1),I=t("p",null,[p("以本模块的订单案例来说，假设订单只是"),t("strong",null,"单量多而每一单的数据量较小，这就适合采用分表"),p("。单条数据量小但行数多，会导致写入（因为要构建索引）和查询非常慢，但整体对于容量的占用是可控的。采用分表后，大表变成小表，写入时构建索引的性能消耗会变小，其次小表的查询性能也更好。如果采用了分库，虽然解决了写入和查询的问题，但每张表所占有的磁盘空间很少，也会产生资源浪费。两种方案的对比如下图 3 所示：")],-1),T=n("",9),S=n("",22),C=t("p",null,"图 5：预生成 ID 架构图",-1),D=t("h4",{id:"分库中间件选择",tabindex:"-1"},[p("分库中间件选择 "),t("a",{class:"header-anchor",href:"#分库中间件选择","aria-label":'Permalink to "分库中间件选择"'},"​")],-1),P=t("p",null,[p("现在开源提供分库支持的中间件较多，如 MyCat 等，"),t("strong",null,"整体上各类分库中间件可以分为两大类：一种是代理式、另外一种是内嵌式"),p("。")],-1),q=t("p",null,[t("strong",null,"代理式分库中间件"),p("对于业务应用无任何侵入，业务应用和未分库时一样使用数据库，分库的选择及分库的维度对业务层完全隐藏，接入和使用成本极低。代理式的架构如下图 6 所示：")],-1),b=t("p",null,"图 6：代理式分库架构图",-1),V=t("p",null,"代理式虽有使用成本低的好处，但也存在其他一些问题。",-1),f=t("ol",null,[t("li",null,[t("p",null,"代理式在业务应用和数据库间增加了一层，导致了性能下降。")]),t("li",null,[t("p",null,"代理式需要解析业务应用的 SQL，并根据 SQL 中的分库字段进行路由。它需要解析和适配所有 SQL 语法，增加了代理模块复杂度和出错的可能性。")]),t("li",null,[t("p",null,"代理层是单独进程，需要部署占用资源，带来一定的成本。")])],-1),k=t("p",null,[t("strong",null,"内嵌式分库中间件"),p("是将分库中间件内置在业务应用中，它只负责分库的选择，并不会解析用户的 SQL。在使用时，业务应用需将分库字段传递给内嵌中间件去计算具体对应的分库。它相比代理式性能更好。内嵌式的架构如下图 7 所示：")],-1),E=n("",20);function x(B,Q,M,N,W,F){const o=a("Image");return _(),i("div",null,[r,c,g,h,d,u,s(o,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image/M00/94/03/CgqCHmAW4wuAX6w6AAFSxseqQC4864.png"}),p(),A,s(o,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image2/M01/0B/F0/CgpVE2AW4yOACp2IAAGcCXG_nEg716.png"}),p(),m,I,s(o,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image/M00/93/F8/Ciqc1GAW4zSAHK2IAAIUTwH38qg862.png"}),p(),T,s(o,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image2/M01/0B/ED/Cip5yGAW40iAD36QAADF17Z_iQI008.png"}),p(),S,s(o,{alt:"图片5.png",src:"https://s0.lgstatic.com/i/image2/M01/0B/F0/CgpVE2AW41yAAjdPAAHKzK_c3_o955.png"}),p(),C,D,P,q,s(o,{alt:"图片6.png",src:"https://s0.lgstatic.com/i/image2/M01/0B/F0/CgpVE2AW422AG7CBAADd3We_RVs818.png"}),p(),b,V,f,k,s(o,{alt:"图片7.png",src:"https://s0.lgstatic.com/i/image2/M01/0B/F1/CgpVE2AW43-AWpBXAADamyLAQIs260.png"}),p(),E])}const y=l(e,[["render",x]]);export{v as __pageData,y as default};
