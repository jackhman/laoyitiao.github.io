import{_ as o,j as e,o as t,g as r,k as n,h as a,s as l,Q as p}from"./chunks/framework.4e7d56ce.js";const R=JSON.parse('{"title":"JSON-RPC ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4276) 29  加餐：HTTP 协议 + JSON-RPC，Dubbo 跨语言就是如此简单.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4276) 29  加餐：HTTP 协议 + JSON-RPC，Dubbo 跨语言就是如此简单.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4276) 29  加餐：HTTP 协议 + JSON-RPC，Dubbo 跨语言就是如此简单.md"},E=l("p",null,"在前面课时介绍 Protocol 和 Invoker 实现时，我们重点介绍了 AbstractProtocol 以及 DubboInvoker 实现。其实，Protocol 还有一个实现分支是 AbstractProxyProtocol，如下图所示：",-1),y=p("",37),i=l("p",null,"dubbo-remoting-http 模块位置",-1),F=l("p",null,"dubbo-remoting-http 模块的入口是 HttpBinder 接口，它被 @SPI 注解修饰，是一个扩展接口，有三个扩展实现，默认使用的是 JettyHttpBinder 实现，如下图所示：",-1),u=l("p",null,"JettyHttpBinder 继承关系图",-1),d=l("p",null,"HttpBinder 接口中的 bind() 方法被 @Adaptive 注解修饰，会根据 URL 的 server 参数选择相应的 HttpBinder 扩展实现，不同 HttpBinder 实现返回相应的 HttpServer 实现。HttpServer 的继承关系如下图所示：",-1),v=p("",7),A=p("",14);function g(D,C,S,h,B,b){const s=e("Image");return t(),r("div",null,[E,n(s,{alt:"Lark20201103-162545.png",src:"https://s0.lgstatic.com/i/image/M00/67/57/CgqCHl-hFBOAU2UWAAFM9gWuXAk914.png"}),a(),y,n(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/67/4C/Ciqc1F-hFD-ATNiiAABhOjw9PMM486.png"}),a(),i,F,n(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/67/4C/Ciqc1F-hFEaAUtnPAABBFL3GfzE890.png"}),a(),u,d,n(s,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/67/57/CgqCHl-hFFSAApv5AABUwFas2rw795.png"}),a(),v,n(s,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/67/57/CgqCHl-hFGCARUTkAABNZnY-dJg331.png"}),a(),A])}const q=o(c,[["render",g]]);export{R as __pageData,q as default};
