import{_ as p,D as e,o,g as t,J as a,h as l,Q as s}from"./chunks/framework.f67d7268.js";const v=JSON.parse('{"title":"22Exchange层剖析：彻底搞懂Requet-Repone模型（下）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4828) 22  Exchange 层剖析：彻底搞懂 Requet-Repone 模型（下）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4828) 22  Exchange 层剖析：彻底搞懂 Requet-Repone 模型（下）.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4828) 22  Exchange 层剖析：彻底搞懂 Requet-Repone 模型（下）.md"},c=s('<h1 id="_22exchange层剖析-彻底搞懂requet-repone模型-下" tabindex="-1">22Exchange层剖析：彻底搞懂Requet-Repone模型（下） <a class="header-anchor" href="#_22exchange层剖析-彻底搞懂requet-repone模型-下" aria-label="Permalink to &quot;22Exchange层剖析：彻底搞懂Requet-Repone模型（下）&quot;">​</a></h1><p>在上一课时中，我们重点分析了 Exchange 层中 Channel 接口以及 ChannelHandler 接口的核心实现，同时还介绍 Request、Response 两个基础类，以及 DefaultFuture 这个 Future 实现。本课时，我们将继续讲解 Exchange 层其他接口的实现逻辑。</p><h3 id="headerexchangeclient" tabindex="-1">HeaderExchangeClient <a class="header-anchor" href="#headerexchangeclient" aria-label="Permalink to &quot;HeaderExchangeClient&quot;">​</a></h3><p>HeaderExchangeClient 是 Client 装饰器，主要为其装饰的 Client 添加两个功能：</p><ul><li><p>维持与 Server 的长连状态，这是通过<strong>定时发送心跳消息</strong>实现的；</p></li><li><p>在因故障掉线之后，进行重连，这是通过<strong>定时检查连接状态</strong>实现的。</p></li></ul><p>因此，HeaderExchangeClient 侧重定时轮资源的分配、定时任务的创建和取消。</p><p>HeaderExchangeClient 实现的是 ExchangeClient 接口，如下图所示，间接实现了 ExchangeChannel 和 Client 接口，ExchangeClient 接口是个空接口，没有定义任何方法。</p>',7),E=s(`<p>HeaderExchangeClient 继承关系图</p><p>HeaderExchangeClient 中有以下两个核心字段。</p><ul><li><p>client（Client 类型）：被修饰的 Client 对象。HeaderExchangeClient 中对 Client 接口的实现，都会委托给该对象进行处理。</p></li><li><p>channel（ExchangeChannel 类型）：Client 与服务端建立的连接，HeaderExchangeChannel 也是一个装饰器，在前面我们已经详细介绍过了，这里就不再展开介绍。HeaderExchangeClient 中对 ExchangeChannel 接口的实现，都会委托给该对象进行处理。</p></li></ul><p>HeaderExchangeClient 构造方法的第一个参数封装 Transport 层的 Client 对象，第二个参数 startTimer参与控制是否开启心跳定时任务和重连定时任务，如果为 true，才会进一步根据其他条件，最终决定是否启动定时任务。这里我们以心跳定时任务为例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">startHeartBeatTask</span><span style="color:#E1E4E8;">(URL url) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">client.</span><span style="color:#B392F0;">canHandleIdle</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// Client的具体实现决定是否启动该心跳任务</span></span>
<span class="line"><span style="color:#E1E4E8;">        AbstractTimerTask.ChannelProvider cp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> Collections.</span><span style="color:#B392F0;">singletonList</span><span style="color:#E1E4E8;">(HeaderExchangeClient.this);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 计算心跳间隔，最小间隔不能低于1s</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> heartbeat </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getHeartbeat</span><span style="color:#E1E4E8;">(url); </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> heartbeatTick </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">calculateLeastDuration</span><span style="color:#E1E4E8;">(heartbeat);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 创建心跳任务</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.heartBeatTimerTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HeartbeatTimerTask</span><span style="color:#E1E4E8;">(cp, heartbeatTick, heartbeat);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 提交到IDLE_CHECK_TIMER这个时间轮中等待执行</span></span>
<span class="line"><span style="color:#E1E4E8;">        IDLE_CHECK_TIMER.</span><span style="color:#B392F0;">newTimeout</span><span style="color:#E1E4E8;">(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">startHeartBeatTask</span><span style="color:#24292E;">(URL url) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">client.</span><span style="color:#6F42C1;">canHandleIdle</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// Client的具体实现决定是否启动该心跳任务</span></span>
<span class="line"><span style="color:#24292E;">        AbstractTimerTask.ChannelProvider cp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> Collections.</span><span style="color:#6F42C1;">singletonList</span><span style="color:#24292E;">(HeaderExchangeClient.this);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 计算心跳间隔，最小间隔不能低于1s</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> heartbeat </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getHeartbeat</span><span style="color:#24292E;">(url); </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> heartbeatTick </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">calculateLeastDuration</span><span style="color:#24292E;">(heartbeat);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 创建心跳任务</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.heartBeatTimerTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HeartbeatTimerTask</span><span style="color:#24292E;">(cp, heartbeatTick, heartbeat);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 提交到IDLE_CHECK_TIMER这个时间轮中等待执行</span></span>
<span class="line"><span style="color:#24292E;">        IDLE_CHECK_TIMER.</span><span style="color:#6F42C1;">newTimeout</span><span style="color:#24292E;">(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>重连定时任务是在 startReconnectTask() 方法中启动的，其中会根据 URL 中的参数决定是否启动任务。重连定时任务最终也是提交到 IDLE_CHECK_TIMER 这个时间轮中，时间轮定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> HashedWheelTimer IDLE_CHECK_TIMER </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HashedWheelTimer</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">NamedThreadFactory</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;dubbo-client-idleCheck&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">), </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, TimeUnit.SECONDS, TICKS_PER_WHEEL);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> HashedWheelTimer IDLE_CHECK_TIMER </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HashedWheelTimer</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">NamedThreadFactory</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;dubbo-client-idleCheck&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">), </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, TimeUnit.SECONDS, TICKS_PER_WHEEL);</span></span></code></pre></div><p>其实，startReconnectTask() 方法的具体实现与前面展示的 startHeartBeatTask() 方法类似，这里就不再赘述。</p><p>下面我们继续回到心跳定时任务进行分析，你可以回顾第 20 课时介绍的 NettyClient 实现，其 canHandleIdle() 方法返回 true，表示该实现可以自己发送心跳请求，无须 HeaderExchangeClient 再启动一个定时任务。NettyClient 主要依靠 IdleStateHandler 中的定时任务来触发心跳事件，依靠 NettyClientHandler 来发送心跳请求。</p><p>对于无法自己发送心跳请求的 Client 实现，HeaderExchangeClient 会为其启动 HeartbeatTimerTask 心跳定时任务，其继承关系如下图所示：</p>`,10),y=s(`<p>TimerTask 继承关系图</p><p>我们先来看 AbstractTimerTask 这个抽象类，它有三个字段。</p><ul><li><p>channelProvider（ChannelProvider类型）：ChannelProvider 是 AbstractTimerTask 抽象类中定义的内部接口，定时任务会从该对象中获取 Channel。</p></li><li><p>tick（Long类型）：任务的过期时间。</p></li><li><p>cancel（boolean类型）：任务是否已取消。</p></li></ul><p>AbstractTimerTask 抽象类实现了 TimerTask 接口的 run() 方法，首先会从 ChannelProvider 中获取此次任务相关的 Channel 集合（在 Client 端只有一个 Channel，在 Server 端有多个 Channel），然后检查 Channel 的状态，针对未关闭的 Channel 执行 doTask() 方法处理，最后通过 reput() 方法将当前任务重新加入时间轮中，等待再次到期执行。</p><p>AbstractTimerTask.run() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">(Timeout timeout) throws Exception {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从ChannelProvider中获取任务要操作的Channel集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    Collection&lt;</span><span style="color:#F97583;">Channel</span><span style="color:#E1E4E8;">&gt; c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> channelProvider.</span><span style="color:#B392F0;">getChannels</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Channel channel </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> c) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (channel.</span><span style="color:#B392F0;">isClosed</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 检测Channel状态</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">doTask</span><span style="color:#E1E4E8;">(channel); </span><span style="color:#6A737D;">// 执行任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">reput</span><span style="color:#E1E4E8;">(timeout, tick); </span><span style="color:#6A737D;">// 将当前任务重新加入时间轮中，等待执行</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">(Timeout timeout) throws Exception {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从ChannelProvider中获取任务要操作的Channel集合</span></span>
<span class="line"><span style="color:#24292E;">    Collection&lt;</span><span style="color:#D73A49;">Channel</span><span style="color:#24292E;">&gt; c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> channelProvider.</span><span style="color:#6F42C1;">getChannels</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Channel channel </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> c) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (channel.</span><span style="color:#6F42C1;">isClosed</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 检测Channel状态</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">doTask</span><span style="color:#24292E;">(channel); </span><span style="color:#6A737D;">// 执行任务</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">reput</span><span style="color:#24292E;">(timeout, tick); </span><span style="color:#6A737D;">// 将当前任务重新加入时间轮中，等待执行</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>doTask() 是一个 AbstractTimerTask 留给子类实现的抽象方法，不同的定时任务执行不同的操作。例如，HeartbeatTimerTask.doTask() 方法中会读取最后一次读写时间，然后计算距离当前的时间，如果大于心跳间隔，就会发送一个心跳请求，核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doTask</span><span style="color:#E1E4E8;">(Channel channel) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取最后一次读写时间</span></span>
<span class="line"><span style="color:#E1E4E8;">    Long lastRead </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lastRead</span><span style="color:#E1E4E8;">(channel);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Long lastWrite </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">lastWrite</span><span style="color:#E1E4E8;">(channel);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((lastRead </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> lastRead </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> heartbeat)</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (lastWrite </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> lastWrite </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> heartbeat)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 最后一次读写时间超过心跳时间，就会发送心跳请求</span></span>
<span class="line"><span style="color:#E1E4E8;">        Request req </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Request</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        req.</span><span style="color:#B392F0;">setVersion</span><span style="color:#E1E4E8;">(Version.</span><span style="color:#B392F0;">getProtocolVersion</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">        req.</span><span style="color:#B392F0;">setTwoWay</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        req.</span><span style="color:#B392F0;">setEvent</span><span style="color:#E1E4E8;">(HEARTBEAT_EVENT);</span></span>
<span class="line"><span style="color:#E1E4E8;">        channel.</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(req);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doTask</span><span style="color:#24292E;">(Channel channel) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取最后一次读写时间</span></span>
<span class="line"><span style="color:#24292E;">    Long lastRead </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lastRead</span><span style="color:#24292E;">(channel);</span></span>
<span class="line"><span style="color:#24292E;">    Long lastWrite </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">lastWrite</span><span style="color:#24292E;">(channel);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((lastRead </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">now</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> lastRead </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> heartbeat)</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (lastWrite </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">now</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> lastWrite </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> heartbeat)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 最后一次读写时间超过心跳时间，就会发送心跳请求</span></span>
<span class="line"><span style="color:#24292E;">        Request req </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Request</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        req.</span><span style="color:#6F42C1;">setVersion</span><span style="color:#24292E;">(Version.</span><span style="color:#6F42C1;">getProtocolVersion</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">        req.</span><span style="color:#6F42C1;">setTwoWay</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        req.</span><span style="color:#6F42C1;">setEvent</span><span style="color:#24292E;">(HEARTBEAT_EVENT);</span></span>
<span class="line"><span style="color:#24292E;">        channel.</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(req);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里 lastRead 和 lastWrite 时间戳，都是从要待处理 Channel 的附加属性中获取的，对应的 Key 分别是：KEY_READ_TIMESTAMP、KEY_WRITE_TIMESTAMP。你可以回顾前面课程中介绍的 HeartbeatHandler，它属于 Transport 层，是一个 ChannelHandler 的装饰器，在其 connected() 、sent() 方法中会记录最后一次写操作时间，在其 connected()、received() 方法中会记录最后一次读操作时间，在其 disconnected() 方法中会清理这两个时间戳。</p><p>在 ReconnectTimerTask 中会检测待处理 Channel 的连接状态，以及读操作的空闲时间，对于断开或是空闲时间较长的 Channel 进行重连，具体逻辑这里就不再展开了。</p><p>HeaderExchangeClient 最后要关注的是它的关闭流程，具体实现在 close() 方法中，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> timeout) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">startClose</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 将closing字段设置为true</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">doClose</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 关闭心跳定时任务和重连定时任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    channel.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(timeout); </span><span style="color:#6A737D;">// 关闭HeaderExchangeChannel</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> timeout) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">startClose</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 将closing字段设置为true</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">doClose</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 关闭心跳定时任务和重连定时任务</span></span>
<span class="line"><span style="color:#24292E;">    channel.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(timeout); </span><span style="color:#6A737D;">// 关闭HeaderExchangeChannel</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 HeaderExchangeChannel.close(timeout) 方法中首先会将自身的 closed 字段设置为 true，这样就不会继续发送请求。如果当前 Channel 上还有请求未收到响应，会循环等待至收到响应，如果超时未收到响应，会自己创建一个状态码将连接关闭的 Response 交给 DefaultFuture 处理，与收到 disconnected 事件相同。然后会关闭 Transport 层的 Channel，以 NettyChannel 为例，NettyChannel.close() 方法会先将自身的 closed 字段设置为 true，清理 CHANNEL_MAP 缓存中的记录，以及 Channel 的附加属性，最后才是关闭 io.netty.channel.Channel。</p><h3 id="headerexchangeserver" tabindex="-1">HeaderExchangeServer <a class="header-anchor" href="#headerexchangeserver" aria-label="Permalink to &quot;HeaderExchangeServer&quot;">​</a></h3><p>下面再来看 HeaderExchangeServer，其继承关系如下图所示，其中 Endpoint、RemotingServer、Resetable 这三个接口我们在前面已经详细介绍过了，这里不再重复。</p>`,15),i=s(`<p>HeaderExchangeServer 的继承关系图</p><p>与前面介绍的 HeaderExchangeClient 一样，HeaderExchangeServer 是 RemotingServer 的装饰器，实现自 RemotingServer 接口的大部分方法都委托给了所修饰的 RemotingServer 对象。</p><p>在 HeaderExchangeServer 的构造方法中，会启动一个 CloseTimerTask 定时任务，定期关闭长时间空闲的连接，具体的实现方式与 HeaderExchangeClient 中的两个定时任务类似，这里不再展开分析。</p><p>需要注意的是，前面课时介绍的 NettyServer 并没有启动该定时任务，而是靠 NettyServerHandler 和 IdleStateHandler 实现的，原理与 NettyClient 类似，这里不再展开，你若感兴趣的话，可以回顾第 20课时或是查看 CloseTimerTask 的具体实现。</p><p>在 19 课时介绍 Transport Server 的时候，我们并没有过多介绍其关闭流程，这里我们就通过 HeaderExchangeServer 自顶向下梳理整个 Server 端关闭流程。先来看 HeaderExchangeServer.close() 方法的关闭流程：</p><ol><li><p>将被修饰的 RemotingServer 的 closing 字段设置为 true，表示这个 Server 端正在关闭，不再接受新 Client 的连接。你可以回顾第 19 课时中介绍的 AbstractServer.connected() 方法，会发现 Server 正在关闭或是已经关闭时，则直接关闭新建的 Client 连接。</p></li><li><p>向 Client 发送一个携带 ReadOnly 事件的请求（根据 URL 中的配置决定是否发送，默认为发送）。在接收到该请求之后，Client 端的 HeaderExchangeHandler 会在 Channel 上添加 Key 为 &quot;channel.readonly&quot; 的附加信息，上层调用方会根据该附加信息，判断该连接是否可写。</p></li><li><p>循环去检测是否还存在 Client 与当前 Server 维持着长连接，直至全部 Client 断开连接或超时。</p></li><li><p>更新 closed 字段为 true，之后 Client 不会再发送任何请求或是回复响应了。</p></li><li><p>取消 CloseTimerTask 定时任务。</p></li><li><p>调用底层 RemotingServer 对象的 close() 方法。以 NettyServer 为例，其 close() 方法会先调用 AbstractPeer 的 close() 方法将自身的 closed 字段设置为 true；然后调用 doClose() 方法关闭 boss Channel（即用来接收客户端连接的 Channel），关闭 channels 集合中记录的 Channel（这些 Channel 是与 Client 之间的连接），清理 channels 集合；最后，关闭 bossGroup 和 workerGroup 两个线程池。</p></li></ol><p>HeaderExchangeServer.close() 方法的核心逻辑如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> timeout) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">startClose</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 将底层RemotingServer的closing字段设置为true，表示当前Server正在关闭，不再接收连接</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (timeout </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> max </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;">) timeout;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> start </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(Constants.CHANNEL_SEND_READONLYEVENT_KEY, </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 发送ReadOnly事件请求通知客户端</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">sendChannelReadOnlyEvent</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (HeaderExchangeServer.this.</span><span style="color:#B392F0;">isRunning</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> System.</span><span style="color:#B392F0;">currentTimeMillis</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> start </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> max) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            Thread.</span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">10</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 循环等待客户端断开连接</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">doClose</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 将自身closed字段设置为true，取消CloseTimerTask定时任务</span></span>
<span class="line"><span style="color:#E1E4E8;">    server.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(timeout); </span><span style="color:#6A737D;">// 关闭Transport层的Server</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> timeout) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">startClose</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 将底层RemotingServer的closing字段设置为true，表示当前Server正在关闭，不再接收连接</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (timeout </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> max </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">long</span><span style="color:#24292E;">) timeout;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> start </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(Constants.CHANNEL_SEND_READONLYEVENT_KEY, </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 发送ReadOnly事件请求通知客户端</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">sendChannelReadOnlyEvent</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (HeaderExchangeServer.this.</span><span style="color:#6F42C1;">isRunning</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> System.</span><span style="color:#6F42C1;">currentTimeMillis</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> start </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> max) {</span></span>
<span class="line"><span style="color:#24292E;">            Thread.</span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">10</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 循环等待客户端断开连接</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">doClose</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 将自身closed字段设置为true，取消CloseTimerTask定时任务</span></span>
<span class="line"><span style="color:#24292E;">    server.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(timeout); </span><span style="color:#6A737D;">// 关闭Transport层的Server</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过对上述关闭流程的分析，你就可以清晰地知道 HeaderExchangeServer 优雅关闭的原理。</p><h3 id="headerexchanger" tabindex="-1">HeaderExchanger <a class="header-anchor" href="#headerexchanger" aria-label="Permalink to &quot;HeaderExchanger&quot;">​</a></h3><p>对于上层来说，Exchange 层的入口是 Exchangers 这个门面类，其中提供了多个 bind() 以及 connect() 方法的重载，这些重载方法最终会通过 SPI 机制，获取 Exchanger 接口的扩展实现，这个流程与第 17 课时介绍的 Transport 层的入口------ Transporters 门面类相同。</p><p>我们可以看到 Exchanger 接口的定义与前面介绍的 Transporter 接口非常类似，同样是被 @SPI 接口修饰（默认扩展名为&quot;header&quot;，对应的是 HeaderExchanger 这个实现），bind() 方法和 connect() 方法也同样是被 @Adaptive 注解修饰，可以通过 URL 参数中的 exchanger 参数值指定扩展名称来覆盖默认值。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span><span style="color:#E1E4E8;">(HeaderExchanger.NAME)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Exchanger</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span><span style="color:#E1E4E8;">({Constants.EXCHANGER_KEY})</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExchangeServer </span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">, ExchangeHandler </span><span style="color:#FFAB70;">handler</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RemotingException;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span><span style="color:#E1E4E8;">({Constants.EXCHANGER_KEY})</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExchangeClient </span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;">(URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">, ExchangeHandler </span><span style="color:#FFAB70;">handler</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RemotingException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span><span style="color:#24292E;">(HeaderExchanger.NAME)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Exchanger</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span><span style="color:#24292E;">({Constants.EXCHANGER_KEY})</span></span>
<span class="line"><span style="color:#24292E;">    ExchangeServer </span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">, ExchangeHandler </span><span style="color:#E36209;">handler</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RemotingException;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span><span style="color:#24292E;">({Constants.EXCHANGER_KEY})</span></span>
<span class="line"><span style="color:#24292E;">    ExchangeClient </span><span style="color:#6F42C1;">connect</span><span style="color:#24292E;">(URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">, ExchangeHandler </span><span style="color:#E36209;">handler</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RemotingException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Dubbo 只为 Exchanger 接口提供了 HeaderExchanger 这一个实现，其中 connect() 方法创建的是 HeaderExchangeClient 对象，bind() 方法创建的是 HeaderExchangeServer 对象，如下图所示：</p>`,14),d=s(`<p>HeaderExchanger 门面类</p><p>从 HeaderExchanger 的实现可以看到，它会在 Transport 层的 Client 和 Server 实现基础之上，添加前文介绍的 HeaderExchangeClient 和 HeaderExchangeServer 装饰器。同时，为上层实现的 ExchangeHandler 实例添加了 HeaderExchangeHandler 以及 DecodeHandler 两个修饰器：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HeaderExchanger</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Exchanger</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> String NAME </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;header&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> ExchangeClient </span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;">(URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">, ExchangeHandler </span><span style="color:#FFAB70;">handler</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RemotingException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HeaderExchangeClient</span><span style="color:#E1E4E8;">(Transporters.</span><span style="color:#B392F0;">connect</span><span style="color:#E1E4E8;">(url, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DecodeHandler</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HeaderExchangeHandler</span><span style="color:#E1E4E8;">(handler))), </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> ExchangeServer </span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(URL </span><span style="color:#FFAB70;">url</span><span style="color:#E1E4E8;">, ExchangeHandler </span><span style="color:#FFAB70;">handler</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RemotingException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HeaderExchangeServer</span><span style="color:#E1E4E8;">(Transporters.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(url, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DecodeHandler</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">HeaderExchangeHandler</span><span style="color:#E1E4E8;">(handler))));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HeaderExchanger</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Exchanger</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> String NAME </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;header&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> ExchangeClient </span><span style="color:#6F42C1;">connect</span><span style="color:#24292E;">(URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">, ExchangeHandler </span><span style="color:#E36209;">handler</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RemotingException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HeaderExchangeClient</span><span style="color:#24292E;">(Transporters.</span><span style="color:#6F42C1;">connect</span><span style="color:#24292E;">(url, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DecodeHandler</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HeaderExchangeHandler</span><span style="color:#24292E;">(handler))), </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> ExchangeServer </span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(URL </span><span style="color:#E36209;">url</span><span style="color:#24292E;">, ExchangeHandler </span><span style="color:#E36209;">handler</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RemotingException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HeaderExchangeServer</span><span style="color:#24292E;">(Transporters.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(url, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DecodeHandler</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">HeaderExchangeHandler</span><span style="color:#24292E;">(handler))));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="再谈-codec2" tabindex="-1">再谈 Codec2 <a class="header-anchor" href="#再谈-codec2" aria-label="Permalink to &quot;再谈 Codec2&quot;">​</a></h3><p>在前面第 17 课时介绍 Dubbo Remoting 核心接口的时候提到，Codec2 接口提供了 encode() 和 decode() 两个方法来实现消息与字节流之间的相互转换。需要注意与 DecodeHandler 区分开来，<strong>DecodeHandler 是对请求体和响应结果的解码，Codec2 是对整个请求和响应的编解码</strong>。</p><p>这里重点介绍 Transport 层和 Exchange 层对 Codec2 接口的实现，涉及的类如下图所示：</p>`,6),h=s("<p><strong>AbstractCodec</strong>抽象类并没有实现 Codec2 中定义的接口方法，而是提供了几个给子类用的基础方法，下面简单说明这些方法的功能。</p><ul><li><p>getSerialization() 方法：通过 SPI 获取当前使用的序列化方式。</p></li><li><p>checkPayload() 方法：检查编解码数据的长度，如果数据超长，会抛出异常。</p></li><li><p>isClientSide()、isServerSide() 方法：判断当前是 Client 端还是 Server 端。</p></li></ul><p>接下来看<strong>TransportCodec</strong>，我们可以看到这类上被标记了 @Deprecated 注解，表示已经废弃。TransportCodec 的实现非常简单，其中根据 getSerialization() 方法选择的序列化方法对传入消息或 ChannelBuffer 进行序列化或反序列化，这里就不再介绍 TransportCodec 实现了。</p><p><strong>TelnetCodec</strong>继承了 TransportCodec 序列化和反序列化的基本能力，同时还提供了对 Telnet 命令处理的能力。</p><p>最后来看<strong>ExchangeCodec</strong>，它在 TelnetCodec 的基础之上，添加了处理协议头的能力。下面是 Dubbo 协议的格式，能够清晰地看出协议中各个数据所占的位数：</p>",5),C=s(`<p>Dubbo 协议格式</p><p>结合上图，我们来深入了解一下 Dubbo 协议中各个部分的含义：</p><ul><li><p>0~7 位和 8~15 位分别是 Magic High 和 Magic Low，是固定魔数值（0xdabb），我们可以通过这两个 Byte，快速判断一个数据包是否为 Dubbo 协议，这也类似 Java 字节码文件里的魔数。</p></li><li><p>16 位是 Req/Res 标识，用于标识当前消息是请求还是响应。</p></li><li><p>17 位是 2Way 标识，用于标识当前消息是单向还是双向。</p></li><li><p>18 位是 Event 标识，用于标识当前消息是否为事件消息。</p></li><li><p>19~23 位是序列化类型的标志，用于标识当前消息使用哪一种序列化算法。</p></li><li><p>24~31 位是 Status 状态，用于记录响应的状态，仅在 Req/Res 为 0（响应）时有用。</p></li><li><p>32~95 位是 Request ID，用于记录请求的唯一标识，类型为 long。</p></li><li><p>96~127 位是序列化后的内容长度，该值是按字节计数，int 类型。</p></li><li><p>128 位之后是可变的数据，被特定的序列化算法（由序列化类型标志确定）序列化后，每个部分都是一个 byte [] 或者 byte。如果是请求包（Req/Res = 1），则每个部分依次为：Dubbo version、Service name、Service version、Method name、Method parameter types、Method arguments 和 Attachments。如果是响应包（Req/Res = 0），则每个部分依次为：①返回值类型（byte），标识从服务器端返回的值类型，包括返回空值（RESPONSE_NULL_VALUE 2）、正常响应值（RESPONSE_VALUE 1）和异常（RESPONSE_WITH_EXCEPTION 0）三种；②返回值，从服务端返回的响应 bytes。</p></li></ul><p>可以看到 Dubbo 协议中前 128 位是协议头，之后的内容是具体的负载数据。协议头就是通过 ExchangeCodec 实现编解码的。</p><p>ExchangeCodec 的核心字段有如下几个。</p><ul><li><p>HEADER_LENGTH（int 类型，值为 16）：协议头的字节数，16 字节，即 128 位。</p></li><li><p>MAGIC（short 类型，值为 0xdabb）：协议头的前 16 位，分为 MAGIC_HIGH 和 MAGIC_LOW 两个字节。</p></li><li><p>FLAG_REQUEST（byte 类型，值为 0x80）：用于设置 Req/Res 标志位。</p></li><li><p>FLAG_TWOWAY（byte 类型，值为 0x40）：用于设置 2Way 标志位。</p></li><li><p>FLAG_EVENT（byte 类型，值为 0x20）：用于设置 Event 标志位。</p></li><li><p>SERIALIZATION_MASK（int 类型，值为 0x1f）：用于获取序列化类型的标志位的掩码。</p></li></ul><p>在 ExchangeCodec 的 encode() 方法中会根据需要编码的消息类型进行分类，其中 encodeRequest() 方法专门对 Request 对象进行编码，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">encodeRequest</span><span style="color:#E1E4E8;">(Channel channel, ChannelBuffer buffer, Request req) throws IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Serialization serialization </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getSerialization</span><span style="color:#E1E4E8;">(channel);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] header </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[HEADER_LENGTH]; </span><span style="color:#6A737D;">// 该数组用来暂存协议头</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 在header数组的前两个字节中写入魔数</span></span>
<span class="line"><span style="color:#E1E4E8;">    Bytes.</span><span style="color:#B392F0;">short2bytes</span><span style="color:#E1E4E8;">(MAGIC, header);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据当前使用的序列化设置协议头中的序列化标志位</span></span>
<span class="line"><span style="color:#E1E4E8;">    header[</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">) (FLAG_REQUEST </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> serialization.</span><span style="color:#B392F0;">getContentTypeId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (req.</span><span style="color:#B392F0;">isTwoWay</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 设置协议头中的2Way标志位</span></span>
<span class="line"><span style="color:#E1E4E8;">        header[</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">|=</span><span style="color:#E1E4E8;"> FLAG_TWOWAY;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (req.</span><span style="color:#B392F0;">isEvent</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 设置协议头中的Event标志位</span></span>
<span class="line"><span style="color:#E1E4E8;">        header[</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">|=</span><span style="color:#E1E4E8;"> FLAG_EVENT;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将请求ID记录到请求头中</span></span>
<span class="line"><span style="color:#E1E4E8;">    Bytes.</span><span style="color:#B392F0;">long2bytes</span><span style="color:#E1E4E8;">(req.</span><span style="color:#B392F0;">getId</span><span style="color:#E1E4E8;">(), header, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 下面开始序列化请求，并统计序列化后的字节数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 首先使用savedWriteIndex记录ChannelBuffer当前的写入位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> savedWriteIndex </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> buffer.</span><span style="color:#B392F0;">writerIndex</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将写入位置后移16字节</span></span>
<span class="line"><span style="color:#E1E4E8;">    buffer.</span><span style="color:#B392F0;">writerIndex</span><span style="color:#E1E4E8;">(savedWriteIndex </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> HEADER_LENGTH);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据选定的序列化方式对请求进行序列化</span></span>
<span class="line"><span style="color:#E1E4E8;">    ChannelBufferOutputStream bos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ChannelBufferOutputStream</span><span style="color:#E1E4E8;">(buffer);</span></span>
<span class="line"><span style="color:#E1E4E8;">    ObjectOutput out </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> serialization.</span><span style="color:#B392F0;">serialize</span><span style="color:#E1E4E8;">(channel.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), bos);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (req.</span><span style="color:#B392F0;">isEvent</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 对事件进行序列化</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">encodeEventData</span><span style="color:#E1E4E8;">(channel, out, req.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 对Dubbo请求进行序列化，具体在DubboCodec中实现</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">encodeRequestData</span><span style="color:#E1E4E8;">(channel, out, req.</span><span style="color:#B392F0;">getData</span><span style="color:#E1E4E8;">(), req.</span><span style="color:#B392F0;">getVersion</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    out.</span><span style="color:#B392F0;">flushBuffer</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (out </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> Cleanable) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ((Cleanable) out).</span><span style="color:#B392F0;">cleanup</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    bos.</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    bos.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 完成序列化</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> len </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bos.</span><span style="color:#B392F0;">writtenBytes</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 统计请求序列化之后，得到的字节数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">checkPayload</span><span style="color:#E1E4E8;">(channel, len); </span><span style="color:#6A737D;">// 限制一下请求的字节长度</span></span>
<span class="line"><span style="color:#E1E4E8;">    Bytes.</span><span style="color:#B392F0;">int2bytes</span><span style="color:#E1E4E8;">(len, header, </span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 将字节数写入header数组中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 下面调整ChannelBuffer当前的写入位置，并将协议头写入Buffer中</span></span>
<span class="line"><span style="color:#E1E4E8;">    buffer.</span><span style="color:#B392F0;">writerIndex</span><span style="color:#E1E4E8;">(savedWriteIndex);</span></span>
<span class="line"><span style="color:#E1E4E8;">    buffer.</span><span style="color:#B392F0;">writeBytes</span><span style="color:#E1E4E8;">(header); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 最后，将ChannelBuffer的写入位置移动到正确的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">    buffer.</span><span style="color:#B392F0;">writerIndex</span><span style="color:#E1E4E8;">(savedWriteIndex </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> HEADER_LENGTH </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> len);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">encodeRequest</span><span style="color:#24292E;">(Channel channel, ChannelBuffer buffer, Request req) throws IOException {</span></span>
<span class="line"><span style="color:#24292E;">    Serialization serialization </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getSerialization</span><span style="color:#24292E;">(channel);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] header </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[HEADER_LENGTH]; </span><span style="color:#6A737D;">// 该数组用来暂存协议头</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 在header数组的前两个字节中写入魔数</span></span>
<span class="line"><span style="color:#24292E;">    Bytes.</span><span style="color:#6F42C1;">short2bytes</span><span style="color:#24292E;">(MAGIC, header);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据当前使用的序列化设置协议头中的序列化标志位</span></span>
<span class="line"><span style="color:#24292E;">    header[</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">) (FLAG_REQUEST </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> serialization.</span><span style="color:#6F42C1;">getContentTypeId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (req.</span><span style="color:#6F42C1;">isTwoWay</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 设置协议头中的2Way标志位</span></span>
<span class="line"><span style="color:#24292E;">        header[</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">|=</span><span style="color:#24292E;"> FLAG_TWOWAY;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (req.</span><span style="color:#6F42C1;">isEvent</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 设置协议头中的Event标志位</span></span>
<span class="line"><span style="color:#24292E;">        header[</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">|=</span><span style="color:#24292E;"> FLAG_EVENT;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将请求ID记录到请求头中</span></span>
<span class="line"><span style="color:#24292E;">    Bytes.</span><span style="color:#6F42C1;">long2bytes</span><span style="color:#24292E;">(req.</span><span style="color:#6F42C1;">getId</span><span style="color:#24292E;">(), header, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 下面开始序列化请求，并统计序列化后的字节数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 首先使用savedWriteIndex记录ChannelBuffer当前的写入位置</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> savedWriteIndex </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> buffer.</span><span style="color:#6F42C1;">writerIndex</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将写入位置后移16字节</span></span>
<span class="line"><span style="color:#24292E;">    buffer.</span><span style="color:#6F42C1;">writerIndex</span><span style="color:#24292E;">(savedWriteIndex </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> HEADER_LENGTH);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据选定的序列化方式对请求进行序列化</span></span>
<span class="line"><span style="color:#24292E;">    ChannelBufferOutputStream bos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ChannelBufferOutputStream</span><span style="color:#24292E;">(buffer);</span></span>
<span class="line"><span style="color:#24292E;">    ObjectOutput out </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> serialization.</span><span style="color:#6F42C1;">serialize</span><span style="color:#24292E;">(channel.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), bos);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (req.</span><span style="color:#6F42C1;">isEvent</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 对事件进行序列化</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">encodeEventData</span><span style="color:#24292E;">(channel, out, req.</span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 对Dubbo请求进行序列化，具体在DubboCodec中实现</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">encodeRequestData</span><span style="color:#24292E;">(channel, out, req.</span><span style="color:#6F42C1;">getData</span><span style="color:#24292E;">(), req.</span><span style="color:#6F42C1;">getVersion</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    out.</span><span style="color:#6F42C1;">flushBuffer</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (out </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Cleanable) {</span></span>
<span class="line"><span style="color:#24292E;">        ((Cleanable) out).</span><span style="color:#6F42C1;">cleanup</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    bos.</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    bos.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 完成序列化</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> len </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bos.</span><span style="color:#6F42C1;">writtenBytes</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 统计请求序列化之后，得到的字节数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">checkPayload</span><span style="color:#24292E;">(channel, len); </span><span style="color:#6A737D;">// 限制一下请求的字节长度</span></span>
<span class="line"><span style="color:#24292E;">    Bytes.</span><span style="color:#6F42C1;">int2bytes</span><span style="color:#24292E;">(len, header, </span><span style="color:#005CC5;">12</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 将字节数写入header数组中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 下面调整ChannelBuffer当前的写入位置，并将协议头写入Buffer中</span></span>
<span class="line"><span style="color:#24292E;">    buffer.</span><span style="color:#6F42C1;">writerIndex</span><span style="color:#24292E;">(savedWriteIndex);</span></span>
<span class="line"><span style="color:#24292E;">    buffer.</span><span style="color:#6F42C1;">writeBytes</span><span style="color:#24292E;">(header); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 最后，将ChannelBuffer的写入位置移动到正确的位置</span></span>
<span class="line"><span style="color:#24292E;">    buffer.</span><span style="color:#6F42C1;">writerIndex</span><span style="color:#24292E;">(savedWriteIndex </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> HEADER_LENGTH </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> len);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>encodeResponse() 方法编码响应的方式与 encodeRequest() 方法编码请求的方式类似，这里就不再展开介绍了，感兴趣的同学可以参考源码进行学习。对于既不是 Request，也不是 Response 的消息，ExchangeCodec 会使用从父类继承下来的能力来编码，例如对 telnet 命令的编码。</p><p>ExchangeCodec 的 decode() 方法是 encode() 方法的逆过程，会先检查魔数，然后读取协议头和后续消息的长度，最后根据协议头中的各个标志位构造相应的对象，以及反序列化数据。在了解协议头结构的前提下，再去阅读这段逻辑就十分轻松了，这就留给你自己尝试分析一下。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时我们重点介绍了 Dubbo Exchange 层中对 Client 和 Server 接口的实现。</p><p>我们首先介绍了 HeaderExchangeClient 对 ExchangeClient 接口的实现，以及 HeaderExchangeServer 对 ExchangeServer 接口的实现，这两者是在 Transport 层 Client 和 Server 的基础上，添加了新的功能。接下来，又讲解了 HeaderExchanger 这个用来创建 HeaderExchangeClient 和 HeaderExchangeServer 的门面类。最后，分析了 Dubbo 协议的格式，以及处理 Dubbo 协议的 ExchangeCodec 实现。</p><p>关于Dubbo 的 Exchange层，你若还有什么疑问或想法，欢迎你留言跟我分享。</p>`,14);function F(g,A,u,D,b,T){const n=e("Image");return o(),t("div",null,[c,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/5B/D7/Ciqc1F-AF6OAT7YOAAAw9BR-aXg961.png"}),l(),E,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/5B/E3/CgqCHl-AF7eAHJWXAABGVZRbaEE743.png"}),l(),y,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/5B/E3/CgqCHl-AF8eAUB8nAACKkTpW9nc845.png"}),l(),i,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/5B/E3/CgqCHl-AF9aANkhOAAB5TgtrSDg780.png"}),l(),d,a(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/5B/E3/CgqCHl-AF9-AQVPBAAByBFYPxkE786.png"}),l(),h,a(n,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/5B/E3/CgqCHl-AF-eAdTmiAADznCJnMrw389.png"}),l(),C])}const x=p(r,[["render",F]]);export{v as __pageData,x as default};
