import{_ as p,j as o,o as e,g as t,k as a,Q as l,s}from"./chunks/framework.4e7d56ce.js";const m=JSON.parse('{"title":"Go 的 MPG 线程模型 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Go 微服务实战 38 讲_文档/(3805) 07  如何使用 Go 更好地开发并发程序？.md","filePath":"posts/backEnd/Go 微服务实战 38 讲_文档/(3805) 07  如何使用 Go 更好地开发并发程序？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Go 微服务实战 38 讲_文档/(3805) 07  如何使用 Go 更好地开发并发程序？.md"},r=l("",14),E=s("ul",null,[s("li",null,[s("p",null,"M，即 machine，相当于内核线程在 Go 进程中的映射，它与内核线程一一对应，代表真正执行计算的资源。在 M 的生命周期内，它只会与一个内核线程关联。")]),s("li",null,[s("p",null,"P，即 processor，代表 Go 代码片段执行所需的上下文环境。M 和 P 的结合能够为 G 提供有效的运行环境，它们之间的结合关系不是固定的。P 的最大数量决定了 Go 程序的并发规模，由 runtime.GOMAXPROCS 变量决定。")]),s("li",null,[s("p",null,"G，即 goroutine，是一种轻量级的用户线程，是对代码片段的封装，拥有执行时的栈、状态和代码片段等信息。")])],-1),y=s("p",null,"在实际执行过程中，M 和 P 共同为 G 提供有效的运行环境（如下图），多个可执行的 G 顺序挂载在 P 的可执行 G 队列下面，等待调度和执行。当 G 中存在一些 I/O 系统调用阻塞了 M 时，P 将会断开与 M 的联系，从调度器空闲 M 队列中获取一个 M 或者创建一个新的 M 组合执行， 保证 P 中可执行 G 队列中其他 G 得到执行，且由于程序中并行执行的 M 数量没变，保证了程序 CPU 的高利用率。",-1),i=l("",39);function F(u,C,d,h,g,D){const n=o("Image");return e(),t("div",null,[r,a(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/36/9A/Ciqc1F8X5ymAf7NvAAE_PDbjFtw120.png"}),E,y,a(n,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/36/9A/Ciqc1F8X5zuAQrDLAAEpRhFm8n4546.png"}),i])}const B=p(c,[["render",F]]);export{m as __pageData,B as default};
