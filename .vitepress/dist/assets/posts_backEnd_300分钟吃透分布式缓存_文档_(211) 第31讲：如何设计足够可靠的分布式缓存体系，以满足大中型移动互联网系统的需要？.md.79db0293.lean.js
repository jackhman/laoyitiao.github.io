import{_ as n,j as o,o as _,g as i,k as e,s as a,h as l,Q as s}from"./chunks/framework.b3d8e22e.js";const J=JSON.parse('{"title":"传统 CAP 的突破 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(211) 第31讲：如何设计足够可靠的分布式缓存体系，以满足大中型移动互联网系统的需要？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(211) 第31讲：如何设计足够可靠的分布式缓存体系，以满足大中型移动互联网系统的需要？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(211) 第31讲：如何设计足够可靠的分布式缓存体系，以满足大中型移动互联网系统的需要？.md"},r=a("br",null,null,-1),p=a("p",null,"上一课时我们了解了为什么不能设计出同时满足一致性、可用性、分区容错性的分布式系统，本课时我们来具体看下，工作中应该如何设计分布式系统，以满足大中型互联网系统的需求。",-1),h=a("h2",{id:"传统-cap-的突破",tabindex:"-1"},[l("传统 CAP 的突破 "),a("a",{class:"header-anchor",href:"#传统-cap-的突破","aria-label":'Permalink to "传统 CAP 的突破"'},"​")],-1),d=a("p",null,"随着分布式系统的不断演进，会不断遇到各种问题，特别是当前，在大中型互联网系统的演进中，私有云、公有云并行发展且相互融合，互联网系统的部署早已突破单个区域，系统拓扑走向全国乃至全球的多区域部署。在践行传统的经典 CAP 理论的同时，需要认识到 CAP 三要素的复杂性，不能简单的对 CAP 理论进行三选二，需要根据业务特点、部署特点，对 CAP 理论进行创新、修正及突破。",-1),u=a("p",null,"甚至 CAP 理论的提出者 Eric Brewer 自己也在 CAP 理论提出的 12 年后，即在 2012 年，对 CAP 理论，特别是 CAP 使用中的一些误区，进一步进行修正、拓展及演进说明。Brewer 指出，CAP 理论中经典的三选二公式存在误导性，CAP 理论的经典实践存在过于简化三种要素，以及三要素之间的相互关系的问题。他同时把 CAP 与 ACID、BASE 进行比较，分析了 CAP 与延迟的关系，最后还重点分析了分布式系统如何应对分区异常的问题。",-1),b=a("br",null,null,-1),A=a("p",null,"要突破经典的 CAP 理论和实践，要认识到 CAP 三要素都不是非黑即白，而是存在一系列的可能性，要在实际业务场景中对分布式系统，进行良好的架构设计，这是一个很大的挑战。",-1),m=a("br",null,null,-1),C=a("p",null,"在系统实际运行过程中，大部分时间，分区异常不会发生，此时可以提供良好的一致性和可用性。同时，我们需要在系统架构设计中，在分析如何实现业务功能、系统 SLA 指标实现等之外，还要考虑整个系统架构中，各个业务、模块、功能、系统部署如何处理潜在的分区问题。",-1),P=a("p",null,"要良好处理潜在的分区问题，可以采用如下步骤。",-1),B=a("br",null,null,-1),f=a("p",null,"首先，要考虑如何感知分区的发生，可以通过主动探测、状态汇报、特殊时间/特殊事件预警、历史数据预测等方式及时发现分区。",-1),g=a("br",null,null,-1),x=a("p",null,"其次，如果发现分区，如何在分区模式下进行业务处理。可以采用内存缓冲、队列服务保存数据后，继续服务，也可以对敏感功能直接停止服务，还可以对分区进行进一步细分，如果是短时间延迟，可以部分功能或请求阻塞等待结果，其他功能和请求快速返回本地老数据；如果分区时长超过一定阀值，进行部分功能下线，只提供部分核心功能。",-1),S=a("p",null,"最后，在分区异常恢复后，如何同步及修复数据，建立补偿机制应对分区模式期间的错误。如系统设计中引入消息队列，在分区模式期间，变更的数据用消息队列进行保存，分区恢复后，消息处理机从消息队列中进行数据读取及修复。也可以设计为同步机制，分区异常时，记录最后同步的位置点，分区恢复后，从记录的位置点继续同步数据。还可以在分区时，分布式系统的各区记录自己没有同步出去的数据，然后在分区恢复后，主动进行异地数据比较及合并。最后，还可以在故障恢复后通过数据扫描，对比分区数据，进行比较及修复。",-1),q=a("h2",{id:"base-理论",tabindex:"-1"},[l("BASE 理论 "),a("a",{class:"header-anchor",href:"#base-理论","aria-label":'Permalink to "BASE 理论"'},"​")],-1),E=a("p",null,"BASE 理论最初由 Brewer 及他的同事们提出。虽然比较久远，但在当前的互联网界活力更盛。各大互联网企业，在构建大中型规模的分布式互联网系统，包括各种基于私有云、公有云及多云结合的分布式系统时，在尽力借鉴 CAP 理论与实践的同时，还充分验证和实践了 BASE 理论，并将其作为 CAP 理论的一种延伸，很好的应用在互联网各种系统中。",-1),k=a("br",null,null,-1),D=a("p",null,"BASE 理论及实践是分布式系统对一致性和可用性权衡后的结果。其基本思想是分布式系统各个功能要适当权衡，尽力保持整个系统稳定可用，即便在出现局部故障和异常时，也确保系统的主体功能可用，确保系统的最终一致性。",-1),v=s("",14),y=s("",18),T=a("p",null,"如图所示，是微博进行多区数据一致性保障案例。消息是通过消息中间件 wmb 进行分发的。wmb 两边分别为分布式系统的 2 个区域。每个区域所有的用户写操作，都会封装成一条消息，业务消息会首先写入消息队列服务，然后消息队列处理机读取消息队列，并进行缓存和 DB 的更新。在业务消息写入消息队列服务时，wmb 会同时将这条消息分发给其他所有异地区子系统。分发的方式是，wmb 本地组件先将消息写入本地队列，然后 wmb 异地组件 Client 再读取。当分区故障发生时，异地读取失败，消息仍然在各区的消息队列中，不会丢失。分区故障过程中，系统的各区子系统只处理本地事件。在分区故障排除后，wmb Client 继续读取异地消息，然后由消息处理机执行，最终实现数据的一致性。",-1),w=a("br",null,null,-1),N=a("p",null,"由于 wmb 通过消息队列机方式从业务层面进行同步，分区故障发生时，各区都是先执行本地，分区恢复后再执行异地，所有事件在各区的执行顺序可能会有差异，在某些极端场景下，可能会导致数据不一致。所以，微博只用 wmb 来更新缓存，DB 层仍然采用主从复制的方式进行强一致保障。这样即便故障恢复期间，可能存在少量缓存数据暂时不一致，由于恢复数据时采用了更短的过期时间，这部分数据在从 DB 重新加载后，仍然能保持数据的最终一致性。同时，微博不用 DB 数据更新缓存，是由于缓存数据结构过于复杂，而且经常需要根据业务需要进行扩展，一条缓存记录会涉及众多 DB，以及 Redis 中多项纪录，通过 DB 同步数据触发更新缓存涉及因素太多，不可控。所以微博在尝试 DB 驱动缓存更新方案失败后，就改为 wmb 消息队列方式进行缓存更新。",-1),I=a("br",null,null,-1),V=a("br",null,null,-1);function M(R,Z,z,L,F,Q){const t=o("Image");return _(),i("div",null,[r,p,h,d,e(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/57/85/Cgq2xl3zZ2CANfnKAADx20uIQl0460.png"}),u,b,A,m,C,e(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/57/85/Cgq2xl3zZ3CAbkqsAABzsMxLE94667.png"}),P,B,f,g,x,S,q,E,k,D,e(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/57/85/CgpOIF3zZ3yAFW3FAACQv-4BBXE880.png"}),v,e(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/57/85/Cgq2xl3zZ46AdsYJAABHQ_eVLKo877.png"}),y,e(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/57/85/Cgq2xl3zZ56AahLWAACRvuF74Ak314.png"}),T,w,N,I,V])}const K=n(c,[["render",M]]);export{J as __pageData,K as default};
