import{_ as o,j as e,o as t,g as c,k as n,h as s,Q as l,s as p}from"./chunks/framework.4e7d56ce.js";const x=JSON.parse('{"title":"20从Redux中间件实现原理切入，理解“面向切面编程”","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/046_深入浅出搞定 React/(4867) 20  从 Redux 中间件实现原理切入，理解“面向切面编程”.md","filePath":"posts/frontEnd/046_深入浅出搞定 React/(4867) 20  从 Redux 中间件实现原理切入，理解“面向切面编程”.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/046_深入浅出搞定 React/(4867) 20  从 Redux 中间件实现原理切入，理解“面向切面编程”.md"},E=l(`<h1 id="_20从redux中间件实现原理切入-理解-面向切面编程" tabindex="-1">20从Redux中间件实现原理切入，理解“面向切面编程” <a class="header-anchor" href="#_20从redux中间件实现原理切入-理解-面向切面编程" aria-label="Permalink to &quot;20从Redux中间件实现原理切入，理解“面向切面编程”&quot;">​</a></h1><p>本讲我们将结合 Redux 应用实例与 applyMiddleware 源码，对 Redux 中间件的实现原理进行分析。在此基础上，我会帮助你对&quot;面向切面&quot;这一经典的编程思想建立初步的认识。</p><h3 id="认识-redux-中间件" tabindex="-1">认识 Redux 中间件 <a class="header-anchor" href="#认识-redux-中间件" aria-label="Permalink to &quot;认识 Redux 中间件&quot;">​</a></h3><p>在分析中间件实现原理之前，我们先来认识一下中间件的用法。</p><h4 id="中间件的引入" tabindex="-1">中间件的引入 <a class="header-anchor" href="#中间件的引入" aria-label="Permalink to &quot;中间件的引入&quot;">​</a></h4><p>在第 05 讲介绍 createStore 函数时，已经简单地提过中间件------<strong>中间件相关的信息将作为 createStore 函数的一个 function 类型的入参被传入</strong>。这里我们简单复习一下 createStore 的调用规则，示例代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 引入 redux</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { createStore, applyMiddleware } from &#39;redux&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">.</span><span style="color:#FDAEB7;font-style:italic;">.....</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 store</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> store = createStore(</span></span>
<span class="line"><span style="color:#E1E4E8;">    reducer,</span></span>
<span class="line"><span style="color:#E1E4E8;">    initial_state,</span></span>
<span class="line"><span style="color:#E1E4E8;">    applyMiddleware(middleware1, middleware2, .</span><span style="color:#FDAEB7;font-style:italic;">..</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 引入 redux</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { createStore, applyMiddleware } from &#39;redux&#39;</span></span>
<span class="line"><span style="color:#24292E;">.</span><span style="color:#B31D28;font-style:italic;">.....</span></span>
<span class="line"><span style="color:#6A737D;">// 创建 store</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> store = createStore(</span></span>
<span class="line"><span style="color:#24292E;">    reducer,</span></span>
<span class="line"><span style="color:#24292E;">    initial_state,</span></span>
<span class="line"><span style="color:#24292E;">    applyMiddleware(middleware1, middleware2, .</span><span style="color:#B31D28;font-style:italic;">..</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">);</span></span></code></pre></div><p>可以看到，redux 对外暴露了 applyMiddleware 这个方法。applyMiddleware 接受任意个中间件作为入参，而它的返回值将会作为参数传入 createStore，这就是中间件的引入过程。</p><h4 id="中间件的工作模式" tabindex="-1">中间件的工作模式 <a class="header-anchor" href="#中间件的工作模式" aria-label="Permalink to &quot;中间件的工作模式&quot;">​</a></h4><p>中间件的引入，会为 Redux 工作流带来什么样的改变呢？这里我们以 redux-thunk 为例，从经典的&quot;异步 Action&quot;场景切入，一起看看中间件是如何帮我们解决问题的。</p><h5 id="redux-thunk-经典的异步-action-解决方案" tabindex="-1">redux-thunk------经典的异步 Action 解决方案 <a class="header-anchor" href="#redux-thunk-经典的异步-action-解决方案" aria-label="Permalink to &quot;redux-thunk------经典的异步 Action 解决方案&quot;">​</a></h5><p>在针对 Redux 源码主流程的分析中，我们不难看出这样一个规律------<strong>Redux 源码中只有同步操作</strong>，也就是说当我们 dispatch action 时，state 会被立即更新。</p><p>那如果想要在 Redux 中引入异步数据流，该怎么办呢？<a href="https://www.redux.org.cn/docs/advanced/AsyncFlow.html" target="_blank" rel="noreferrer">Redux 官方给出的建议</a>是使用中间件来增强 createStore。支持异步数据流的 Redux 中间件有很多，其中最适合用来快速上手的应该就是 <a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noreferrer">redux-thunk</a>了。</p><p>redux-thunk 的引入和普通中间件无异，可以参考以下示例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 引入 redux-thunk</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> thunkMiddleware from &#39;redux</span><span style="color:#FDAEB7;font-style:italic;">-</span><span style="color:#E1E4E8;">thunk&#39;</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">import</span><span style="color:#E1E4E8;"> reducer from &#39;./reducers&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 将中间件用 applyMiddleware 包装后传入</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> store = createStore(reducer, applyMiddleware(thunkMiddleware))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 引入 redux-thunk</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> thunkMiddleware from &#39;redux</span><span style="color:#B31D28;font-style:italic;">-</span><span style="color:#24292E;">thunk&#39;</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">import</span><span style="color:#24292E;"> reducer from &#39;./reducers&#39;</span></span>
<span class="line"><span style="color:#6A737D;">// 将中间件用 applyMiddleware 包装后传入</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> store = createStore(reducer, applyMiddleware(thunkMiddleware))</span></span></code></pre></div><p>这里帮大家复习一个小小的知识点，在第 18 讲我们分析 createStore 整体源码时，曾经在 createStore 逻辑的开头见过这样一段代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof preloadedState </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> typeof enhancer </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 此时第二个参数会被认为是 enhancer（中间件）</span></span>
<span class="line"><span style="color:#E1E4E8;">  enhancer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> preloadedState;</span></span>
<span class="line"><span style="color:#E1E4E8;">  preloadedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> undefined;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof preloadedState </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> typeof enhancer </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 此时第二个参数会被认为是 enhancer（中间件）</span></span>
<span class="line"><span style="color:#24292E;">  enhancer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> preloadedState;</span></span>
<span class="line"><span style="color:#24292E;">  preloadedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> undefined;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这段代码告诉我们，在只传入两个参数的情况下，createStore 会去检查第二个参数是否是 function 类型，若是，则认为第二个参数是&quot;enhancer&quot;。这里的&quot;enhancer&quot;是&quot;增强器&quot;的意思，而 applyMiddleware 包装过的中间件，正是&quot;增强器&quot;的一种。这也就解释了为什么上面 redux-thunk 的调用示例中，applyMiddleware 调用明明是作为 createStore 的第二个参数被传入的，却仍然能够被识别为中间件信息。</p><p>redux-thunk 带来的改变非常好理解，<strong>它允许我们以函数的形式派发一个 action</strong>，像这样（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// axios 是一个用于发起异步请求的库</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> axios from &#39;axios&#39; </span></span>
<span class="line"><span style="color:#6A737D;">// 引入 createStore 和 applyMiddleware</span></span>
<span class="line"><span style="color:#FDAEB7;font-style:italic;">import</span><span style="color:#E1E4E8;"> { createStore, applyMiddleware } from &#39;redux&#39;;</span></span>
<span class="line"><span style="color:#6A737D;">// 引入 redux-thunk</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> thunk from &#39;redux</span><span style="color:#FDAEB7;font-style:italic;">-</span><span style="color:#E1E4E8;">thunk&#39;;</span></span>
<span class="line"><span style="color:#6A737D;">// 引入 reducer</span></span>
<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> reducer from &#39;./reducers&#39;;</span></span>
<span class="line"><span style="color:#6A737D;">// 创建一个有 thunk 中间件加持的 store 对象</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> store </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createStore</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  reducer,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">applyMiddleware</span><span style="color:#E1E4E8;">(thunk)</span></span>
<span class="line"><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 用于发起付款请求，并处理请求结果。由于涉及资金，我们希望感知请求的发送和响应的返回</span></span>
<span class="line"><span style="color:#6A737D;">// 入参是付款相关的信息（包括用户账密、金额等）</span></span>
<span class="line"><span style="color:#6A737D;">// 注意 payMoney 的返回值仍然是一个函数</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> payMoney </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (payInfo) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (dispatch) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 付款前发出准备信号</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">({ type</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;payStart&#39;</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(res </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> { </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">()})</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> axios.</span><span style="color:#B392F0;">post</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/api/payMoney&#39;</span><span style="color:#E1E4E8;">, {</span></span>
<span class="line"><span style="color:#E1E4E8;">    payInfo</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> (response) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(response);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 付款成功信号</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">({ type</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;paySuccess&#39;</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">  .</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(error);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 付款失败信号</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">({ type</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;payError&#39;</span><span style="color:#E1E4E8;"> })</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 支付信息，入参</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> payInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  userName</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> xxx,</span></span>
<span class="line"><span style="color:#E1E4E8;">  password</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> xxx,</span></span>
<span class="line"><span style="color:#E1E4E8;">  count</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> xxx,</span></span>
<span class="line"><span style="color:#E1E4E8;">  ......</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// dispatch 一个 action，注意这个 action 是一个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">store.</span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">payMoney</span><span style="color:#E1E4E8;">(payInfo));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// axios 是一个用于发起异步请求的库</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> axios from &#39;axios&#39; </span></span>
<span class="line"><span style="color:#6A737D;">// 引入 createStore 和 applyMiddleware</span></span>
<span class="line"><span style="color:#B31D28;font-style:italic;">import</span><span style="color:#24292E;"> { createStore, applyMiddleware } from &#39;redux&#39;;</span></span>
<span class="line"><span style="color:#6A737D;">// 引入 redux-thunk</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> thunk from &#39;redux</span><span style="color:#B31D28;font-style:italic;">-</span><span style="color:#24292E;">thunk&#39;;</span></span>
<span class="line"><span style="color:#6A737D;">// 引入 reducer</span></span>
<span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> reducer from &#39;./reducers&#39;;</span></span>
<span class="line"><span style="color:#6A737D;">// 创建一个有 thunk 中间件加持的 store 对象</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> store </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createStore</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  reducer,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">applyMiddleware</span><span style="color:#24292E;">(thunk)</span></span>
<span class="line"><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 用于发起付款请求，并处理请求结果。由于涉及资金，我们希望感知请求的发送和响应的返回</span></span>
<span class="line"><span style="color:#6A737D;">// 入参是付款相关的信息（包括用户账密、金额等）</span></span>
<span class="line"><span style="color:#6A737D;">// 注意 payMoney 的返回值仍然是一个函数</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> payMoney </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (payInfo) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (dispatch) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 付款前发出准备信号</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">({ type</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;payStart&#39;</span><span style="color:#24292E;"> })</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">fetch</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(res </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> { </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">()})</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> axios.</span><span style="color:#6F42C1;">post</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;/api/payMoney&#39;</span><span style="color:#24292E;">, {</span></span>
<span class="line"><span style="color:#24292E;">    payInfo</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> (response) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(response);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 付款成功信号</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">({ type</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;paySuccess&#39;</span><span style="color:#24292E;"> })</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">  .</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> (error) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(error);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 付款失败信号</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">({ type</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;payError&#39;</span><span style="color:#24292E;"> })</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 支付信息，入参</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> payInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  userName</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> xxx,</span></span>
<span class="line"><span style="color:#24292E;">  password</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> xxx,</span></span>
<span class="line"><span style="color:#24292E;">  count</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> xxx,</span></span>
<span class="line"><span style="color:#24292E;">  ......</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// dispatch 一个 action，注意这个 action 是一个函数</span></span>
<span class="line"><span style="color:#24292E;">store.</span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">payMoney</span><span style="color:#24292E;">(payInfo));</span></span></code></pre></div><p>这里我尝试用 redux-thunk 模拟了一个付款请求的发起 → 响应过程。</p><p>这个过程单从表面上看，和普通 Redux 调用最大的不同就是 <strong>dispatch 的入参从 action 对象变成了一个函数</strong> 。这就不由得让人对 thunk 中间件加持下的 Redux 工作流心生好奇------<strong>action 入参必须是一个对象</strong> ，这一点我们在第 19 讲分析 dispatch 源码时，可是亲眼见过 action 相关的数据格式强校验逻辑的！<strong>而 thunk 中间件似乎巧妙地&quot;绕开&quot;了这层校验，这背后到底藏着什么玄机呢</strong>？</p><p>要想搞清楚这个问题，你除了需要理解 thunk 的执行逻辑，更重要的是要知道 Redux 中间件是如何工作的。</p><h5 id="redux-中间件是如何与-redux-主流程相结合的" tabindex="-1">Redux 中间件是如何与 Redux 主流程相结合的？ <a class="header-anchor" href="#redux-中间件是如何与-redux-主流程相结合的" aria-label="Permalink to &quot;Redux 中间件是如何与 Redux 主流程相结合的？&quot;">​</a></h5><p>Redux 中间件将会在 action 被分发之后、到达 reducer 之前执行，对应到工作流中，它的执行时机如下图所示：</p>`,25),y=p("p",null,'若有多个中间件，那么 Redux 会结合它们被"安装"的先后顺序，依序调用这些中间件，这个过程如下图所示：',-1),i=l(`<p>中间件的执行时机，允许它在状态真正发生变化之前，结合 action 的信息做一些它想做的事情。</p><p>那么中间件又是如何&quot;绕过&quot; dispatch 的校验逻辑的呢？其实，&quot;绕过&quot;dispatch 只是咱们主观上的一个使用感受。<strong>dispatch 并非被&quot;绕过&quot;了，而是被&quot;改写&quot;了，改写它的不是别人，正是 applyMiddleware</strong>。关于这点，我会在本文后续的源码分析环节为你深入讲解。</p><p>读到这里，对于 Redux 中间件的工作模式，你需要牢牢把握以下两点：</p><ol><li><p>中间件的执行时机，即 action 被分发之后、reducer 触发之前；</p></li><li><p>中间件的执行前提，即 <strong>applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用</strong>。</p></li></ol><p>结合这两点，再来看 redux-thunk 的源码，一切就会豁然开朗了。</p><h5 id="thunk-中间件到底做了什么" tabindex="-1">thunk 中间件到底做了什么？ <a class="header-anchor" href="#thunk-中间件到底做了什么" aria-label="Permalink to &quot;thunk 中间件到底做了什么？&quot;">​</a></h5><p>redux-thunk 的源码其实非常简洁，我第一次接触时还是在 2016 年，这么多年过去了，很多事情都变了，唯一不变的是 redux-thunk，它仍然那么好懂。既然这么好懂，我们不如直接来读读看，请看 redux-thunk 的源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// createThunkMiddleware 用于创建 thunk</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">createThunkMiddleware</span><span style="color:#E1E4E8;">(extraArgument) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 返回值是一个 thunk，它是一个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ({ dispatch, getState }) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (next) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (action) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// thunk 若感知到 action 是一个函数，就会执行 action</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof action </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">action</span><span style="color:#E1E4E8;">(dispatch, getState, extraArgument);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若 action 不是一个函数，则不处理，直接放过</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(action);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> thunk </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createThunkMiddleware</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">thunk.withExtraArgument </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> createThunkMiddleware;</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> thunk;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// createThunkMiddleware 用于创建 thunk</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">createThunkMiddleware</span><span style="color:#24292E;">(extraArgument) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 返回值是一个 thunk，它是一个函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ({ dispatch, getState }) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (next) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (action) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// thunk 若感知到 action 是一个函数，就会执行 action</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof action </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">action</span><span style="color:#24292E;">(dispatch, getState, extraArgument);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若 action 不是一个函数，则不处理，直接放过</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(action);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> thunk </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createThunkMiddleware</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">thunk.withExtraArgument </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> createThunkMiddleware;</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> thunk;</span></span></code></pre></div><p>redux-thunk 主要做的事情，就是在拦截到 action 以后，会去检查它是否是一个函数。<strong>若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next</strong>，告诉 Redux &quot;我这边的工作做完了&quot;，工作流就可以继续往下走了。</p><p>到这里，你已经在使用层面对 Redux 中间件有了足够的认知。接下来，我们就要进入源码的世界啦。</p><h3 id="redux-中间件机制是如何实现的" tabindex="-1">Redux 中间件机制是如何实现的 <a class="header-anchor" href="#redux-中间件机制是如何实现的" aria-label="Permalink to &quot;Redux 中间件机制是如何实现的&quot;">​</a></h3><p>Redux 中间件是通过调用 applyMiddleware 来引入的，因此我们先看看 applyMiddleware 的源码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// applyMiddlerware 会使用&quot;...&quot;运算符将入参收敛为一个数组</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">applyMiddleware</span><span style="color:#E1E4E8;">(...middlewares) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 它返回的是一个接收 createStore 为入参的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> createStore </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 首先调用 createStore，创建一个 store</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> store </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createStore</span><span style="color:#E1E4E8;">(...args)</span></span>
<span class="line"><span style="color:#E1E4E8;">    let dispatch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">        \`Dispatching </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> constructing your middleware is not allowed. \` </span><span style="color:#F97583;">+</span></span>
<span class="line"><span style="color:#E1E4E8;">          \`Other middleware would not be applied to </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;"> dispatch.\`</span></span>
<span class="line"><span style="color:#E1E4E8;">      )</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// middlewareAPI 是中间件的入参</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> middlewareAPI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      getState</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> store.getState,</span></span>
<span class="line"><span style="color:#E1E4E8;">      dispatch</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(...args)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> chain </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middlewares.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(middleware </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">middleware</span><span style="color:#E1E4E8;">(middlewareAPI))</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 改写原有的 dispatch：将 chain 中的函数按照顺序&quot;组合&quot;起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span>
<span class="line"><span style="color:#E1E4E8;">    dispatch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(...chain)(store.dispatch)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      ...store,</span></span>
<span class="line"><span style="color:#E1E4E8;">      dispatch</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// applyMiddlerware 会使用&quot;...&quot;运算符将入参收敛为一个数组</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">applyMiddleware</span><span style="color:#24292E;">(...middlewares) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 它返回的是一个接收 createStore 为入参的函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> createStore </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 首先调用 createStore，创建一个 store</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> store </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createStore</span><span style="color:#24292E;">(...args)</span></span>
<span class="line"><span style="color:#24292E;">    let dispatch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">        \`Dispatching </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> constructing your middleware is not allowed. \` </span><span style="color:#D73A49;">+</span></span>
<span class="line"><span style="color:#24292E;">          \`Other middleware would not be applied to </span><span style="color:#005CC5;">this</span><span style="color:#24292E;"> dispatch.\`</span></span>
<span class="line"><span style="color:#24292E;">      )</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// middlewareAPI 是中间件的入参</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> middlewareAPI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      getState</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> store.getState,</span></span>
<span class="line"><span style="color:#24292E;">      dispatch</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(...args)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> chain </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middlewares.</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">(middleware </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">middleware</span><span style="color:#24292E;">(middlewareAPI))</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 改写原有的 dispatch：将 chain 中的函数按照顺序&quot;组合&quot;起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span>
<span class="line"><span style="color:#24292E;">    dispatch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(...chain)(store.dispatch)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      ...store,</span></span>
<span class="line"><span style="color:#24292E;">      dispatch</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这段源码中，我们着重需要搞清楚的是以下几个问题：</p><ol><li><p>applyMiddleware 返回了一个什么样的函数？这个函数是如何与 createStore 配合工作的？</p></li><li><p>dispatch 函数是如何被改写的？</p></li><li><p>compose 函数是如何组合中间件的？</p></li></ol><h4 id="_1-applymiddleware-是如何与-createstore-配合工作的" tabindex="-1">1. applyMiddleware 是如何与 createStore 配合工作的？ <a class="header-anchor" href="#_1-applymiddleware-是如何与-createstore-配合工作的" aria-label="Permalink to &quot;1. applyMiddleware 是如何与 createStore 配合工作的？&quot;">​</a></h4><p><strong>先来看看 applyMiddleware 的返回值</strong>。在源码的注释中，我已经标明，它返回的是一个接收 createStore 为入参的函数。这个函数将会作为入参传递给 createStore，那么 createStore 会如何理解它呢？这里就要带你复习一下 createStore 中，enhancer 相关的逻辑了，请看下面代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">createStore</span><span style="color:#E1E4E8;">(reducer, preloadedState, enhancer) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof preloadedState </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> typeof enhancer </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 此时第二个参数会被认为是 enhancer（中间件）</span></span>
<span class="line"><span style="color:#E1E4E8;">        enhancer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> preloadedState;</span></span>
<span class="line"><span style="color:#E1E4E8;">        preloadedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> undefined;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof enhancer </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">enhancer</span><span style="color:#E1E4E8;">(createStore)(reducer, preloadedState);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ......</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">createStore</span><span style="color:#24292E;">(reducer, preloadedState, enhancer) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof preloadedState </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> typeof enhancer </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 此时第二个参数会被认为是 enhancer（中间件）</span></span>
<span class="line"><span style="color:#24292E;">        enhancer </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> preloadedState;</span></span>
<span class="line"><span style="color:#24292E;">        preloadedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> undefined;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof enhancer </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">enhancer</span><span style="color:#24292E;">(createStore)(reducer, preloadedState);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    ......</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>从这个代码片段中我们可以看出，一旦发现 enhancer 存在（对应到中间件场景下，enhancer 指的是 applyMiddleware 返回的函数），那么 createStore 内部就会直接 return 一个针对 enhancer 的调用。在这个调用中，第一层入参是 createStore，第二层入参是 reducer 和 preloadedState。</p><p>我们可以尝试将这个逻辑在 applyMiddleware 中对号入座一下。下面我从出入参角度简单提取了一下 applyMiddleware 的源码框架：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// applyMiddlerware 会使用&quot;...&quot;运算符将入参收敛为一个数组</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">applyMiddleware</span><span style="color:#E1E4E8;">(...middlewares) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 它返回的是一个接收 createStore 为入参的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> createStore </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ......</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// applyMiddlerware 会使用&quot;...&quot;运算符将入参收敛为一个数组</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">applyMiddleware</span><span style="color:#24292E;">(...middlewares) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 它返回的是一个接收 createStore 为入参的函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> createStore </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    ......</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>结合 createStore 中对 enhancer 的处理，我们可以知道，在 applyMiddleware return 出的这个函数中，createStore 这个入参对应的是 createStore 函数本身，而 args 入参则对应的是 reducer、preloadedState，这两个参数均为 createStore 函数的约定入参。</p><p>前面我们讲过，applyMiddleware 是 enhancer 的一种，而 enhancer 的意思是&quot;增强器&quot;，它增强的正是 createStore 的能力。因此调用 enhancer 时，传入 createStore 及其相关的入参信息是非常必要的。</p><h4 id="_2-dispatch-函数是如何被改写的" tabindex="-1">2.dispatch 函数是如何被改写的？ <a class="header-anchor" href="#_2-dispatch-函数是如何被改写的" aria-label="Permalink to &quot;2.dispatch 函数是如何被改写的？&quot;">​</a></h4><p>dispatch 函数的改写，是由下面这个代码片段完成的：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// middlewareAPI 是中间件的入参</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> middlewareAPI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  getState</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> store.getState,</span></span>
<span class="line"><span style="color:#E1E4E8;">  dispatch</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(...args)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> chain </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middlewares.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(middleware </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">middleware</span><span style="color:#E1E4E8;">(middlewareAPI))</span></span>
<span class="line"><span style="color:#6A737D;">// 改写原有的 dispatch：将 chain 中的函数按照顺序&quot;组合&quot;起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span>
<span class="line"><span style="color:#E1E4E8;">dispatch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(...chain)(store.dispatch)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// middlewareAPI 是中间件的入参</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> middlewareAPI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  getState</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> store.getState,</span></span>
<span class="line"><span style="color:#24292E;">  dispatch</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(...args)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> chain </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middlewares.</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">(middleware </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">middleware</span><span style="color:#24292E;">(middlewareAPI))</span></span>
<span class="line"><span style="color:#6A737D;">// 改写原有的 dispatch：将 chain 中的函数按照顺序&quot;组合&quot;起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span>
<span class="line"><span style="color:#24292E;">dispatch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(...chain)(store.dispatch)</span></span></code></pre></div><p>这个代码片段做了两件事：首先以 middlewareAPI 作为入参，逐个调用传入的 middleware，获取一个由&quot;内层函数&quot;组成的数组 chain；然后调用 compose 函数，将 chain 中的&quot;内层函数&quot;逐个组合起来，并调用最终组合出来的函数。</p><p>在上面这段描述中，有两个点可能对你的理解构成障碍：</p><ol><li><p>什么是&quot;内层函数&quot;？</p></li><li><p>compose 函数到底是怎么组合函数的？它组合出来的又是个什么东西？</p></li></ol><p>关于第 2 点，我们需要到 compose 源码中去看，这里先按下不表，咱们来说说&quot;内层函数&quot;在这里的含义。</p><p>首先我们需要站在函数的视角，来观察一下 thunk 中间件的源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// createThunkMiddleware 用于创建 thunk</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">createThunkMiddleware</span><span style="color:#E1E4E8;">(extraArgument) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 返回值是一个 thunk，它是一个函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ({ dispatch, getState }) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (next) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (action) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// thunk 若感知到 action 是一个函数，就会执行 action</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof action </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">action</span><span style="color:#E1E4E8;">(dispatch, getState, extraArgument);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 若 action 不是一个函数，则不处理，直接放过</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(action);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> thunk </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createThunkMiddleware</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// createThunkMiddleware 用于创建 thunk</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">createThunkMiddleware</span><span style="color:#24292E;">(extraArgument) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 返回值是一个 thunk，它是一个函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ({ dispatch, getState }) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (next) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (action) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// thunk 若感知到 action 是一个函数，就会执行 action</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof action </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">action</span><span style="color:#24292E;">(dispatch, getState, extraArgument);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 若 action 不是一个函数，则不处理，直接放过</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(action);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> thunk </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createThunkMiddleware</span><span style="color:#24292E;">();</span></span></code></pre></div><p>thunk 中间件是 createThunkMiddleware 的返回值，createThunkMiddleware 返回的是这样的一个函数：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">({ dispatch, getState }) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (next) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (action) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// thunk 若感知到 action 是一个函数，就会执行 action</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (typeof action </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;function&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">action</span><span style="color:#E1E4E8;">(dispatch, getState, extraArgument);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 若 action 不是一个函数，则不处理，直接放过</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(action);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">({ dispatch, getState }) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (next) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (action) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// thunk 若感知到 action 是一个函数，就会执行 action</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (typeof action </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;function&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">action</span><span style="color:#24292E;">(dispatch, getState, extraArgument);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 若 action 不是一个函数，则不处理，直接放过</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(action);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>该函数的返回值仍然是一个函数，显然它是一个<strong>高阶函数</strong>。事实上，按照约定，所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为&quot;外层函数&quot;，将 return 出来的函数称为&quot;内层函数&quot;。</p><p>而 apply 中遍历 middlewares 数组，逐个调用 middleware(middlewareAPI)，无非是为了获取中间件的内层函数。</p><p>以 thunk 的源码为例，不难看出，外层函数的主要作用是获取 dispatch、getState 这两个 API，而<strong>真正的中间件逻辑是在内层函数中包裹的</strong> 。待<code>middlewares.map(middleware =&gt; middleware(middlewareAPI))</code>执行完毕后，内层函数会被悉数提取至 chain 数组。接下来，我们直接拿 chain 数组开刀就行了。</p><p>提取出 chain 数组之后，applyMiddleware 做的第一件事就是将数组中的中间件逻辑 compose 起来。</p><p>那么 compose 函数又是如何工作的呢？</p><h4 id="_3-compose-源码解读-函数的合成" tabindex="-1">3. compose 源码解读：函数的合成 <a class="header-anchor" href="#_3-compose-源码解读-函数的合成" aria-label="Permalink to &quot;3. compose 源码解读：函数的合成&quot;">​</a></h4><p>函数合成（组合函数）并不是 Redux 的专利，而是函数式编程中一个通用的概念。因此在 Redux 源码中，compose 函数是作为一个独立文件存在的，它具备较强的工具属性。</p><p>我们还是先通过阅读源码，来弄清楚 compose 到底都做了什么。以下是 compose 的源码（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// compose 会首先利用&quot;...&quot;运算符将入参收敛为数组格式</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(...funcs) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 处理数组为空的边界情况</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (funcs.length </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> arg </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> arg</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 若只有一个函数，也就谈不上组合，直接返回</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (funcs.length </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> funcs[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> funcs.</span><span style="color:#B392F0;">reduce</span><span style="color:#E1E4E8;">((a, b) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">b</span><span style="color:#E1E4E8;">(...args)))</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// compose 会首先利用&quot;...&quot;运算符将入参收敛为数组格式</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(...funcs) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 处理数组为空的边界情况</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (funcs.length </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> arg </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> arg</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 若只有一个函数，也就谈不上组合，直接返回</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (funcs.length </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> funcs[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> funcs.</span><span style="color:#6F42C1;">reduce</span><span style="color:#24292E;">((a, b) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">a</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">b</span><span style="color:#24292E;">(...args)))</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其实整段源码中值得你细细品味的只有最后这一行代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> funcs.</span><span style="color:#B392F0;">reduce</span><span style="color:#E1E4E8;">((a, b) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">b</span><span style="color:#E1E4E8;">(...args)))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> funcs.</span><span style="color:#6F42C1;">reduce</span><span style="color:#24292E;">((a, b) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">a</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">b</span><span style="color:#24292E;">(...args)))</span></span></code></pre></div><p>这行代码告诉我们，函数组合是通过调用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noreferrer">数组的 reduce 方法</a>来实现的。</p><p>reduce 方法是 JS 数组中一个相对基础的概念，这里我们不再展开讲解，需要复习的同学请狠狠地<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="noreferrer">点击这里</a>。</p><p>reducer 方法的特点是，会对数组中的每个元素执行我们指定的函数逻辑，并将其结果汇总为单个返回值。因此对于这样的一个 compose 调用来说：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(f1, f2, f3, f4)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(f1, f2, f3, f4)</span></span></code></pre></div><p>它会把函数组合为这种形式：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">(...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">f1</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">f2</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">f3</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">f4</span><span style="color:#E1E4E8;">(...args))))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">(...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;">  </span><span style="color:#6F42C1;">f1</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">f2</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">f3</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">f4</span><span style="color:#24292E;">(...args))))</span></span></code></pre></div><p>如此一来，f1、f2、f3、f4 这 4 个中间件的内层逻辑就会被组合到一个函数中去，当这个函数被调用时，f1、f2、f3、f4 将会按照顺序被依次调用。这就是&quot;函数组合&quot;在此处的含义。</p><h3 id="加餐-中间件与面向切面编程" tabindex="-1">加餐：中间件与面向切面编程 <a class="header-anchor" href="#加餐-中间件与面向切面编程" aria-label="Permalink to &quot;加餐：中间件与面向切面编程&quot;">​</a></h3><p>中间件这个概念并非 Redux 的专利，它在软件领域由来已久，大家所熟知的 Koa、Express 这些 Node 框架中也都不乏对中间件的应用。那么为什么中间件可以流行？为什么我们的应用需要中间件呢？这里，我就以 Redux 中间件机制为例，简单和你聊聊中间件背后的&quot;面向切面&quot;编程思想。</p><p>AOP（面向切面）这个概念可能很多同学都不太了解，大家相对熟悉的应该是 OOP（面向对象）。而 AOP 的存在，恰恰是为了解决 OOP 的局限性，我们可以将 AOP 看作是对 OOP 的一种补充。</p><p>在 OOP 模式下，当我们想要拓展一个类的逻辑时，最常见的思路就是继承：class A 继承 class B，class B 继承 class C......这样一层一层将逻辑向下传递。</p><p>当我们想要为某几个类追加一段共同的逻辑时，可以通过修改它们共同的父类来实现，这无疑会使得公共类越来越臃肿，可我们也确实没有什么更好的办法------总不能任这些公共逻辑散落在不同的业务逻辑里吧？那将会引发更加严重的代码冗余及耦合问题。</p><p>怎么办呢？&quot;面向切面&quot;来救场！</p><p>既然是面向&quot;切面&quot;，那么首先我们要搞清楚什么是&quot;切面&quot;。切面是一个相对于执行流程来说的概念，以 Redux 为例，它的工作流自上而下应该是这样的，如下图所示：</p>`,59),d=p("p",null,[s('此时考虑这样一个需求：要求在每个 Action 被派发之后，打出一个 console.log 记录"action 被派发了"这个动作，也就是我们常说的"日志追溯"。这个需求的'),p("strong",null,"通用性很强、业务属性很弱"),s(" ，因此不适合与任何的业务逻辑耦合在一起。那我们就可以以 "),p("strong",null,'"切面"这种形式，把它与业务逻辑剥离开来'),s('：扩展功能在工作流中的执行节点，可以视为一个单独"切点"；我们把扩展功能的逻辑放到这个"切点"上来，形成的就是一个可以拦截前序逻辑的"切面"，如下图所示：')],-1),u=l('<p>&quot;切面&quot;与业务逻辑是分离的，因此 AOP 是一种典型的 <strong>&quot;非侵入式&quot;的逻辑扩充思路</strong>。</p><p>在日常开发中，像&quot;日志追溯&quot;&quot;异步工作流处理&quot;&quot;性能打点&quot;这类和业务逻辑关系不大的功能，我们都可以考虑把它们抽到&quot;切面&quot;中去做。</p><p>面向切面编程带来的利好是非常明显的。从 Redux 中间件机制中，不难看出，面向切面思想在很大程度上提升了我们组织逻辑的灵活度与干净度，帮助我们规避掉了逻辑冗余、逻辑耦合这类问题。通过将&quot;切面&quot;与业务逻辑剥离，开发者能够专注于业务逻辑的开发，并通过&quot;<strong>即插即用</strong>&quot;的方式自由地组织自己想要的扩展功能。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>在这一讲，我们首先以 redux-thunk 中间件为例，从&quot;异步工作流&quot;场景切入，认识了 Redux 中间件的工作模式。随后，结合 applyMiddleware 源码，对 Redux 中间件的整个执行机制进行了细致深入的分析，并在文末引入了对&quot;面向切面&quot;这一编程思想的介绍。</p><p>行文至此，整个由 Redux 所牵出的核心知识体系也已经一览无余地呈现在你面前，相信你对 Redux 的理解又上了一个台阶。</p><p>专栏的下一讲，我将以 React 的另一个&quot;好帮手&quot; React-Router 为切入点，为你讲解前端路由相关的知识，不见不散。</p>',7);function h(g,A,F,D,f,m){const a=e("Image");return t(),c("div",null,[E,n(a,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image2/M01/01/67/Cip5yF_Yk0yAUFNqAABk6No-RiM734.png"}),s(),y,n(a,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image2/M01/01/68/CgpVE1_Yk1aAA-MbAACcWI3Jg2Q249.png"}),s(),i,n(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image2/M01/01/49/CgpVE1_YZC-AKwdJAACTdBArWEQ782.png"}),s(),d,n(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image2/M01/01/49/CgpVE1_YZEGAPHOaAACpc9ZgOG0409.png"}),s(),u])}const w=o(r,[["render",h]]);export{x as __pageData,w as default};
