import{_ as o,j as t,o as e,g as r,k as n,h as s,Q as p,s as l}from"./chunks/framework.4e7d56ce.js";const I=JSON.parse('{"title":"08案例分析：Redi如何助力秒杀业务","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Java 性能优化实战 21 讲_文档/(4185) 08  案例分析：Redi 如何助力秒杀业务.md","filePath":"posts/backEnd/Java 性能优化实战 21 讲_文档/(4185) 08  案例分析：Redi 如何助力秒杀业务.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Java 性能优化实战 21 讲_文档/(4185) 08  案例分析：Redi 如何助力秒杀业务.md"},E=p('<h1 id="_08案例分析-redi如何助力秒杀业务" tabindex="-1">08案例分析：Redi如何助力秒杀业务 <a class="header-anchor" href="#_08案例分析-redi如何助力秒杀业务" aria-label="Permalink to &quot;08案例分析：Redi如何助力秒杀业务&quot;">​</a></h1><p>在上一课时，我们以 Guava 的 LoadingCache 为例，介绍了堆内缓存的特点以及一些注意事项。同时，还了解了缓存使用的场景，这对分布式缓存来说，同样适用。</p><p>那什么叫<strong>分布式缓存</strong> 呢？它其实是一种<strong>集中管理</strong>的思想。如果我们的服务有多个节点，堆内缓存在每个节点上都会有一份；而分布式缓存，所有的节点，共用一份缓存，既节约了空间，又减少了管理成本。</p><p>在分布式缓存领域，使用最多的就是 Redis。<strong>Redis</strong> 支持非常丰富的数据类型，包括字符串（string）、列表（list）、集合（set）、有序集合（zset）、哈希表（hash）等常用的数据结构。当然，它也支持一些其他的比如位图（bitmap）一类的数据结构。</p><p>说到 Redis，就不得不提一下另外一个分布式缓存 <strong>Memcached</strong> （以下简称 MC）。MC 现在已经很少用了，但<strong>面试的时候经常会问到它们之间的区别</strong>，这里简单罗列一下：</p>',5),y=p(`<p>Redis 在互联网中，几乎是标配。我们接下来，先简单看一下 Redis 在 Spring 中是如何使用的，然后，再介绍一下在秒杀业务中，Redis是如何帮助我们承接瞬时流量的。</p><h3 id="springboot-如何使用-redis" tabindex="-1">SpringBoot 如何使用 Redis <a class="header-anchor" href="#springboot-如何使用-redis" aria-label="Permalink to &quot;SpringBoot 如何使用 Redis&quot;">​</a></h3><p>使用 SpringBoot 可以很容易地对 Redis 进行操作（<a href="https://gitee.com/xjjdog/tuning-lagou-res/tree/master/tuning-008/cache-redis" target="_blank" rel="noreferrer">完整代码见仓库</a>）。Java 的 Redis的客户端，常用的有三个：jedis、redisson 和 lettuce，Spring 默认使用的是 lettuce。</p><p><strong>lettuce</strong> 是使用 netty 开发的，操作是异步的，性能比常用的 jedis 要高；<strong>redisson</strong> 也是异步的，但它对常用的业务操作进行了封装，适合书写有业务含义的代码。</p><p>通过加入下面的 jar 包即可方便地使用 Redis。</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">dependency</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;org.springframework.boot&lt;/</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;spring-boot-starter-data-redis&lt;/</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">dependency</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">groupId</span><span style="color:#24292E;">&gt;org.springframework.boot&lt;/</span><span style="color:#22863A;">groupId</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">artifactId</span><span style="color:#24292E;">&gt;spring-boot-starter-data-redis&lt;/</span><span style="color:#22863A;">artifactId</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">dependency</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>上面这种方式，我们主要是使用 RedisTemplate 这个类。它针对不同的数据类型，抽象了相应的方法组。</p>`,7),i=p(`<p>另外一种方式，就是使用 Spring 抽象的缓存包 spring-cache。它使用注解，采用 AOP的方式，对 Cache 层进行了抽象，可以在各种堆内缓存框架和分布式框架之间进行切换。这是它的 maven 坐标：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">dependency</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt;org.springframework.boot&lt;/</span><span style="color:#85E89D;">groupId</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt;spring-boot-starter-cache&lt;/</span><span style="color:#85E89D;">artifactId</span><span style="color:#E1E4E8;">&gt; </span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">dependency</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">dependency</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">groupId</span><span style="color:#24292E;">&gt;org.springframework.boot&lt;/</span><span style="color:#22863A;">groupId</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">artifactId</span><span style="color:#24292E;">&gt;spring-boot-starter-cache&lt;/</span><span style="color:#22863A;">artifactId</span><span style="color:#24292E;">&gt; </span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">dependency</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><blockquote><p>与 spring-cache 类似的，还有阿里的 jetcache，都是比较好用的。</p></blockquote><p>使用 spring-cache 有三个步骤：</p><ul><li><p>在启动类上加入 @EnableCaching 注解；</p></li><li><p>使用 CacheManager 初始化要使用的缓存框架，使用 @CacheConfig 注解注入要使用的资源；</p></li><li><p>使用 @Cacheable 等注解对资源进行缓存。</p></li></ul><p>我们这里使用的是 RedisCacheManager，由于现在只有这一个初始化实例，第二个步骤是可以省略的。</p><p>针对缓存操作的注解，有三个：</p><ul><li><p><strong>@Cacheable</strong> 表示如果缓存系统里没有这个数值，就将方法的返回值缓存起来；</p></li><li><p><strong>@CachePut</strong> 表示每次执行该方法，都把返回值缓存起来；</p></li><li><p><strong>@CacheEvict</strong> 表示执行方法的时候，清除某些缓存值。</p></li></ul><p>对于秒杀系统来说，仅仅使用这三个注解是有局限性的，需要使用更加底层的 API，比如 RedisTemplate，来完成逻辑开发，下面就来介绍一些比较重要的功能。</p><h3 id="秒杀业务介绍" tabindex="-1">秒杀业务介绍 <a class="header-anchor" href="#秒杀业务介绍" aria-label="Permalink to &quot;秒杀业务介绍&quot;">​</a></h3><p>秒杀，是对正常业务流程的考验。因为它会产生突发流量，平常一天的请求，可能就集中在几秒内就要完成。比如，京东的某些抢购，可能库存就几百个，但是瞬时进入的流量可能是几十上百万。</p>`,11),g=p('<p>如果参与秒杀的人，等待很长时间，体验就非常差，想象一下拥堵的高速公路收费站，就能理解秒杀者的心情。同时，被秒杀的资源会成为热点，发生并发争抢的后果。比如 12306 的抢票，如果单纯使用数据库来接受这些请求，就会产生严重的锁冲突，这也是秒杀业务难的地方。</p><p>大家可以回忆一下上一课时的内容，此时，秒杀前端需求与数据库之间的速度是严重不匹配的，而且秒杀的资源是热点资源。这种场景下，采用缓存是非常合适的。</p><p><strong>处理秒杀业务有三个绝招：</strong></p><ul><li><p>第一，选择速度最快的内存作为数据写入；</p></li><li><p>第二，使用异步处理代替同步请求；</p></li><li><p>第三，使用分布式横向扩展。</p></li></ul><p>下面，我们就来看一下 Redis 是如何助力秒杀的。</p><h3 id="lua-脚本完成秒杀" tabindex="-1">Lua 脚本完成秒杀 <a class="header-anchor" href="#lua-脚本完成秒杀" aria-label="Permalink to &quot;Lua 脚本完成秒杀&quot;">​</a></h3><p>一个秒杀系统是非常复杂的，一般来说，秒杀可以分为一下三个阶段：</p><ul><li><p><strong>准备阶段</strong>，会提前载入一些必需的数据到缓存中，并提前预热业务数据，用户会不断刷新页面，来查看秒杀是否开始；</p></li><li><p><strong>抢购阶段</strong>，就是我们通常说的秒杀，会产生瞬时的高并发流量，对资源进行集中操作；</p></li><li><p><strong>结束清算</strong>，主要完成数据的一致性，处理一些异常情况和回仓操作。</p></li></ul>',8),d=p(`<p>下面，我将介绍一下最重要的秒杀阶段。</p><p>我们可以设计一个 Hash 数据结构，来支持库存的扣减。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">seckill</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">goods</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">\${goodsId}{ </span></span>
<span class="line"><span style="color:#E1E4E8;">    total</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">    start</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">    alloc</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">seckill</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">goods</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">\${goodsId}{ </span></span>
<span class="line"><span style="color:#24292E;">    total</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">    start</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">    alloc</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在这个 Hash 数据结构中，有以下三个重要部分：</p><ul><li><p><strong>total</strong> 是一个静态值，表示要秒杀商品的数量，在秒杀开始前，会将这个数值载入到缓存中。</p></li><li><p><strong>start</strong> 是一个布尔值。秒杀开始前的值为 0；通过后台或者定时，将这个值改为 1，则表示秒杀开始。</p></li><li><p>此时，<strong>alloc</strong> 将会记录已经被秒杀的商品数量，直到它的值达到 total 的上限。</p></li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> String goodsId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;seckill:goods:%s&quot;</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">String </span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">(String id) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> String.</span><span style="color:#B392F0;">format</span><span style="color:#E1E4E8;">(goodsId, id); </span></span>
<span class="line"><span style="color:#E1E4E8;">} </span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">prepare</span><span style="color:#E1E4E8;">(String id, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> total) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    String key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">(id); </span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; goods </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashMap&lt;&gt;(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    goods.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;total&quot;</span><span style="color:#E1E4E8;">, total); </span></span>
<span class="line"><span style="color:#E1E4E8;">    goods.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;start&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">); </span></span>
<span class="line"><span style="color:#E1E4E8;">    goods.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;alloc&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">); </span></span>
<span class="line"><span style="color:#E1E4E8;">    redisTemplate.</span><span style="color:#B392F0;">opsForHash</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">putAll</span><span style="color:#E1E4E8;">(key, goods); </span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> String goodsId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;seckill:goods:%s&quot;</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">String </span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">(String id) { </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> String.</span><span style="color:#6F42C1;">format</span><span style="color:#24292E;">(goodsId, id); </span></span>
<span class="line"><span style="color:#24292E;">} </span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">prepare</span><span style="color:#24292E;">(String id, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> total) { </span></span>
<span class="line"><span style="color:#24292E;">    String key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">(id); </span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; goods </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;(); </span></span>
<span class="line"><span style="color:#24292E;">    goods.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;total&quot;</span><span style="color:#24292E;">, total); </span></span>
<span class="line"><span style="color:#24292E;">    goods.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;start&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">); </span></span>
<span class="line"><span style="color:#24292E;">    goods.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;alloc&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">); </span></span>
<span class="line"><span style="color:#24292E;">    redisTemplate.</span><span style="color:#6F42C1;">opsForHash</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">putAll</span><span style="color:#24292E;">(key, goods); </span></span>
<span class="line"><span style="color:#24292E;"> }</span></span></code></pre></div><p>秒杀的时候，首先需要判断库存，才能够对库存进行锁定。这两步动作并不是原子的，在分布式环境下，多台机器同时对 Redis 进行操作，就会发生同步问题。</p><p>为了<strong>解决同步问题</strong>，一种方式就是使用 Lua 脚本，把这些操作封装起来，这样就能保证原子性；另外一种方式就是使用分布式锁，分布式锁我们将在 13、14 课时介绍。</p><p>下面是一个调试好的 Lua 脚本，可以看到一些关键的比较动作，和 HINCRBY 命令，能够成为一个原子操作。</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> falseRet </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;0&quot; </span></span>
<span class="line"><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">tonumber</span><span style="color:#E1E4E8;">(ARGV[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) </span></span>
<span class="line"><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> KEYS[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span></span>
<span class="line"><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> goodsInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> redis.</span><span style="color:#79B8FF;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;HMGET&quot;</span><span style="color:#E1E4E8;">,key,</span><span style="color:#9ECBFF;">&quot;total&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;alloc&quot;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">tonumber</span><span style="color:#E1E4E8;">(goodsInfo[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">]) </span></span>
<span class="line"><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> alloc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">tonumber</span><span style="color:#E1E4E8;">(goodsInfo[</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">]) </span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">not</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">then</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> falseRet </span></span>
<span class="line"><span style="color:#F97583;">end</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> alloc </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> n  </span><span style="color:#F97583;">then</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">local</span><span style="color:#E1E4E8;"> ret </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> redis.</span><span style="color:#79B8FF;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;HINCRBY&quot;</span><span style="color:#E1E4E8;">,key,</span><span style="color:#9ECBFF;">&quot;alloc&quot;</span><span style="color:#E1E4E8;">,n) </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">tostring</span><span style="color:#E1E4E8;">(ret) </span></span>
<span class="line"><span style="color:#F97583;">end</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> falseRet</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">local</span><span style="color:#24292E;"> falseRet </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;0&quot; </span></span>
<span class="line"><span style="color:#D73A49;">local</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">tonumber</span><span style="color:#24292E;">(ARGV[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) </span></span>
<span class="line"><span style="color:#D73A49;">local</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> KEYS[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span></span>
<span class="line"><span style="color:#D73A49;">local</span><span style="color:#24292E;"> goodsInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> redis.</span><span style="color:#005CC5;">call</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;HMGET&quot;</span><span style="color:#24292E;">,key,</span><span style="color:#032F62;">&quot;total&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;alloc&quot;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#D73A49;">local</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">tonumber</span><span style="color:#24292E;">(goodsInfo[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">]) </span></span>
<span class="line"><span style="color:#D73A49;">local</span><span style="color:#24292E;"> alloc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">tonumber</span><span style="color:#24292E;">(goodsInfo[</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">]) </span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">not</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">then</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> falseRet </span></span>
<span class="line"><span style="color:#D73A49;">end</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> alloc </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> n  </span><span style="color:#D73A49;">then</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">local</span><span style="color:#24292E;"> ret </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> redis.</span><span style="color:#005CC5;">call</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;HINCRBY&quot;</span><span style="color:#24292E;">,key,</span><span style="color:#032F62;">&quot;alloc&quot;</span><span style="color:#24292E;">,n) </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">tostring</span><span style="color:#24292E;">(ret) </span></span>
<span class="line"><span style="color:#D73A49;">end</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> falseRet</span></span></code></pre></div><p>对应的秒杀代码如下，由于我们使用的是 String 的序列化方式，所以会把库存的扣减数量先转化为字符串，然后再调用 Lua 脚本。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">secKill</span><span style="color:#E1E4E8;">(String id, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> number) { </span></span>
<span class="line"><span style="color:#E1E4E8;">    String key </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getKey</span><span style="color:#E1E4E8;">(id); </span></span>
<span class="line"><span style="color:#E1E4E8;">    Object alloc </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  redisTemplate.</span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(script, Arrays.</span><span style="color:#B392F0;">asList</span><span style="color:#E1E4E8;">(key), String.</span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;">(number)); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Integer.</span><span style="color:#B392F0;">valueOf</span><span style="color:#E1E4E8;">(alloc.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">()); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">secKill</span><span style="color:#24292E;">(String id, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> number) { </span></span>
<span class="line"><span style="color:#24292E;">    String key </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getKey</span><span style="color:#24292E;">(id); </span></span>
<span class="line"><span style="color:#24292E;">    Object alloc </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  redisTemplate.</span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(script, Arrays.</span><span style="color:#6F42C1;">asList</span><span style="color:#24292E;">(key), String.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">(number)); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Integer.</span><span style="color:#6F42C1;">valueOf</span><span style="color:#24292E;">(alloc.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">()); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>执行仓库里的 testSeckill 方法。启动 1000 个线程对 100 个资源进行模拟秒杀，可以看到生成了 100 条记录，同时其他的线程返回的是 0，表示没有秒杀到。</p>`,13),u=l("h3",{id:"缓存穿透、击穿和雪崩",tabindex:"-1"},[s("缓存穿透、击穿和雪崩 "),l("a",{class:"header-anchor",href:"#缓存穿透、击穿和雪崩","aria-label":'Permalink to "缓存穿透、击穿和雪崩"'},"​")],-1),_=l("p",null,"抛开秒杀场景，我们再来看一下分布式缓存系统会存在的三大问题： 缓存穿透、缓存击穿和缓存雪崩 。",-1),h=l("h4",{id:"_1-缓存穿透",tabindex:"-1"},[s("1.缓存穿透 "),l("a",{class:"header-anchor",href:"#_1-缓存穿透","aria-label":'Permalink to "1.缓存穿透"'},"​")],-1),F=l("p",null,"第一个比较大的问题就是缓存穿透。这个概念比较好理解，和我们上一课时提到的命中率有关。如果命中率很低，那么压力就会集中在数据库持久层。",-1),C=l("p",null,[s("假如能找到相关数据，我们就可以把它缓存起来。但问题是，"),l("strong",null,"本次请求，在缓存和持久层都没有命中，这种情况就叫缓存的穿透。")],-1),A=p('<p>举个例子，如上图，在一个登录系统中，有外部攻击，一直尝试使用不存在的用户进行登录，这些用户都是虚拟的，不能有效地被缓存起来，每次都会到数据库中查询一次，最后就会造成服务的性能故障。</p><p>解决这个问题有多种方案，我们来简单介绍一下。</p><p><strong>第一种</strong>就是把空对象缓存起来。不是持久层查不到数据吗？那么我们就可以把本次请求的结果设置为 null，然后放入到缓存中。通过设置合理的过期时间，就可以保证后端数据库的安全。</p><p>缓存空对象会占用额外的缓存空间，还会有数据不一致的时间窗口，所以<strong>第二种</strong>方法就是针对大数据量的、有规律的键值，使用布隆过滤器进行处理。</p><p>一条记录存在与不存在，是一个 Bool 值，只需要使用 1 比特就可存储。<strong>布隆过滤器</strong>就可以把这种是、否操作，压缩到一个数据结构中。比如手机号，用户性别这种数据，就非常适合使用布隆过滤器。</p><h4 id="_2-缓存击穿" tabindex="-1">2.缓存击穿 <a class="header-anchor" href="#_2-缓存击穿" aria-label="Permalink to &quot;2.缓存击穿&quot;">​</a></h4><p>缓存击穿，指的也是用户请求落在数据库上的情况，大多数情况，是由于缓存时间批量过期引起的。</p><p>我们一般会对缓存中的数据，设置一个过期时间。如果在某个时刻从数据库获取了大量数据，并设置了同样的过期时间，它们将会在同一时刻失效，造成和缓存的击穿。</p><p>对于比较热点的数据，我们就可以设置它不过期；或者在访问的时候，更新它的过期时间；批量入库的缓存项，也尽量分配一个比较平均的过期时间，避免同一时间失效。</p><h4 id="_3-缓存雪崩" tabindex="-1">3.缓存雪崩 <a class="header-anchor" href="#_3-缓存雪崩" aria-label="Permalink to &quot;3.缓存雪崩&quot;">​</a></h4><p>雪崩这个词看着可怕，实际情况也确实比较严重。缓存是用来对系统加速的，后端的数据库只是数据的备份，而不是作为高可用的备选方案。</p><p>当缓存系统出现故障，流量会瞬间转移到后端的数据库。过不了多久，数据库将会被大流量压垮挂掉，这种级联式的服务故障，可以形象地称为雪崩。</p>',12),D=p('<p>缓存的高可用建设是非常重要的。Redis 提供了主从和 Cluster 的模式，其中 Cluster 模式使用简单，每个分片也能单独做主从，可以保证极高的可用性。</p><p>另外，我们对数据库的性能瓶颈有一个大体的评估。如果缓存系统当掉，那么流向数据库的请求，就可以使用限流组件，将请求拦截在外面。</p><h3 id="缓存一致性" tabindex="-1">缓存一致性 <a class="header-anchor" href="#缓存一致性" aria-label="Permalink to &quot;缓存一致性&quot;">​</a></h3><p>引入缓存组件后，另外一个老大难的问题，就是缓存的一致性。</p><p>我们首先来看问题是怎么发生的。对于一个缓存项来说，常用的操作有四个：写入、更新、读取、删除。</p><ul><li><p><strong>写入</strong>：缓存和数据库是两个不同的组件，只要涉及双写，就存在只有一个写成功的可能性，造成数据不一致。</p></li><li><p><strong>更新</strong>：更新的情况类似，需要更新两个不同的组件。</p></li><li><p><strong>读取</strong>：读取要保证从缓存中读到的信息是最新的，是和数据库中的是一致的。</p></li><li><p><strong>删除</strong>：当删除数据库记录的时候，如何把缓存中的数据也删掉？</p></li></ul><p>由于业务逻辑大多数情况下，是比较复杂的。其中的更新操作，就非常昂贵，比如一个用户的余额，就是通过计算一系列的资产算出来的一个数。如果这些关联的资产，每个地方改动的时候，都去刷新缓存，那代码结构就会非常混乱，以至于无法维护。</p><p>我推荐使用<strong>触发式的缓存一致性方式</strong>，使用懒加载的方式，可以让缓存的同步变得非常简单：</p><ul><li><p>当读取缓存的时候，如果缓存里没有相关数据，则执行相关的业务逻辑，构造缓存数据存入到缓存系统；</p></li><li><p>当与缓存项相关的资源有变动，则先删除相应的缓存项，然后再对资源进行更新，这个时候，即使是资源更新失败，也是没有问题的。</p></li></ul><p>这种操作，除了编程模型简单，有一个明显的好处。我只有在用到这个缓存的时候，才把它加载到缓存系统中。如果每次修改 都创建、更新资源，那缓存系统中就会存在非常多的冷数据。</p><p>但这样还是有问题。<strong>接下来介绍的场景，也是面试中经常提及的问题。</strong></p><p>我们上面提到的缓存删除动作，和数据库的更新动作，明显是不在一个事务里的。如果一个请求删除了缓存，同时有另外一个请求到来，此时发现没有相关的缓存项，就从数据库里加载了一份到缓存系统。接下来，数据库的更新操作也完成了，此时数据库的内容和缓存里的内容，就产生了不一致。</p><p>下面这张图，直观地解释了这种不一致的情况，此时，缓存读取 B 操作以及之后的读取操作，都会读到错误的缓存值。</p>',13),b=p('<p><strong>在面试中，只要你把这个问题给点出来，面试官都会跷起大拇指。</strong></p><p>可以使用分布式锁来解决这个问题，将缓存操作和数据库删除操作，与其他的缓存读操作，使用锁进行资源隔离即可。一般来说，读操作是不需要加锁的，它会在遇到锁的时候，重试等待，直到超时。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>本课时的内容有点多，但是非常重要，如果你参加过大型互联网公司的面试，会发现本课时有很多高频面试点，值得你反复揣摩。</p><p>本课时和上一课时，都是围绕着缓存展开的，它们之间有很多知识点也比较相似。对于分布式缓存来说，Redis 是现在使用最广泛的。我们先简单介绍了一下它和 Memcached 的一些区别，介绍了 SpringBoot 项目中 Redis 的使用方式，然后以秒杀场景为主，学习了库存扣减这一个核心功能的 Lua 代码。这段代码主要是把条件判断和扣减命令做成了原子性操作。</p><p>Redis 的 API 使用非常简单，速度也很快，但同时它也引入了很多问题。如果不能解决这些异常场景，那么 Redis 的价值就大打折扣，所以我们主要谈到了缓存的穿透、击穿以及雪崩的场景，并着重介绍了一下缓存的一致性和解决的思路。</p><p><strong>课后题：上面提到的缓存一致性，有更好的方式去解决，你知道该怎么做么（提示：Cache Aside Pattern）？</strong></p><p>下一小节，我将介绍一个与缓存非常类似的优化方法------对象的池化，用复用来增加运行效率，我们下节课见。</p>',8);function m(q,k,S,T,f,B){const a=t("Image");return e(),r("div",null,[E,n(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/3D/AF/CgqCHl8qaxiATTH1AAB10CrXXk8295.png"}),s(),y,n(a,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/3D/AF/CgqCHl8qa0CAF6eCAAHpRwXu93w738.png"}),s(),i,n(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/3D/AF/CgqCHl8qa06AXwgiAABlE7P5SV4914.png"}),s(),g,n(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/3D/A4/Ciqc1F8qa1eAfW9ZAADONsLsuh4160.png"}),s(),d,n(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/3D/B0/CgqCHl8qa3KAHrjzAACfVjTuQ9c533.png"}),s(),u,_,h,F,C,n(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/3D/B0/CgqCHl8qa32AXy2GAACsgw1i8As520.png"}),s(),A,n(a,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image/M00/3D/B0/CgqCHl8qa5CAd61nAAG3-zdlhRw552.png"}),s(),D,n(a,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/3D/B0/CgqCHl8qa5-AWDbqAACK1Itu_Wc954.png"}),s(),b])}const R=o(c,[["render",m]]);export{I as __pageData,R as default};
