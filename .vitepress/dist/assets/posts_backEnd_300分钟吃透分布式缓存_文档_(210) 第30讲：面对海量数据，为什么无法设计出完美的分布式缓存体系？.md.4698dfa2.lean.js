import{_ as i,j as l,o as n,g as c,k as s,h as a,s as e,Q as o}from"./chunks/framework.b3d8e22e.js";const U=JSON.parse('{"title":"CAP 定理的诞生 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(210) 第30讲：面对海量数据，为什么无法设计出完美的分布式缓存体系？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(210) 第30讲：面对海量数据，为什么无法设计出完美的分布式缓存体系？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(210) 第30讲：面对海量数据，为什么无法设计出完美的分布式缓存体系？.md"},_=e("p",null,"随着互联网的发展，分布式系统变得越来越重要，当前的大中型互联网系统几乎都向着分布式方向发展。分布式系统简单说就是一个软硬件分布在不同机房、不同区域的网络计算机上，彼此之间仅仅通过消息传递进行通信及协调的系统。分布式系统需要利用分布的服务，在确保数据一致的基础上，对外提供稳定的服务。",-1),d=e("h2",{id:"cap-定理的诞生",tabindex:"-1"},[a("CAP 定理的诞生 "),e("a",{class:"header-anchor",href:"#cap-定理的诞生","aria-label":'Permalink to "CAP 定理的诞生"'},"​")],-1),h=e("p",null,"在分布式系统的发展中，影响最大最广泛的莫过于 CAP 理论了，可以说 CAP 理论是分布式系统发展的理论基石。早在 1998 年，加州大学的计算机科学家 Eric Brewer ，就提出分布式系统的三个指标。在此基础上，2 年后，Eric Brewer 进一步提出了 CAP 猜想。又过了 2 年，到了 2002 年，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP 猜想。CAP 猜想成为了 CAP 定理，也称为布鲁尔定理。从此，CAP 定理成为分布式系统发展的理论基石，广泛而深远的影响着分布式系统的发展。",-1),p=e("h2",{id:"cap-定理指标",tabindex:"-1"},[a("CAP 定理指标 "),e("a",{class:"header-anchor",href:"#cap-定理指标","aria-label":'Permalink to "CAP 定理指标"'},"​")],-1),A=e("p",null,"CAP 定理，简单的说就是分布式系统不可能同时满足 Consistency 一致性、Availability 可用性、Partition Tolerance 分区容错性三个要素。因为 Consistency、Availability 、Partition Tolerance 这三个单词的首字母分别是 C、A、P，所以这个结论被称为 CAP 定理。",-1),P=e("h3",{id:"consistency-一致性",tabindex:"-1"},[a("Consistency 一致性 "),e("a",{class:"header-anchor",href:"#consistency-一致性","aria-label":'Permalink to "Consistency 一致性"'},"​")],-1),C=e("p",null,'CAP 定理的第一个要素是 Consistency 一致性。一致性的英文含义是指"all nodes see the same data at the same time"。即所有节点在任意时间，被访问返回的数据完全一致。CAP 作者 Brewer 的另外一种解释是在写操作之后的读指令，必须得到的是写操作写入的值，或者写操作之后新更新的值。从服务端的视角来看，就是在 Client 写入一个更新后，Server 端如何同步这个新值到整个系统，从而保证整个系统的这个数据都相同。而从客户端的视角来看，则是并发访问时，在变更数据后，如何获取到最新值。',-1),b=e("h3",{id:"availability-可用性",tabindex:"-1"},[a("Availability 可用性 "),e("a",{class:"header-anchor",href:"#availability-可用性","aria-label":'Permalink to "Availability 可用性"'},"​")],-1),m=e("p",null,'CAP 定理的第二个要素是 Availability 可用性。可用性的英文含义是指"Reads and writes always succeed"。即服务集群总能够对用户的请求给予响应。Brewer 的另外一个种解释是对于一个没有宕机或异常的节点，总能响应用户的请求。也就是说当用户访问一个正常工作的节点时，系统保证该节点必须给用户一个响应，可以是正确的响应，也可以是一个老的甚至错误的响应，但是不能没有响应。从服务端的视角来看，就是服务节点总能响应用户请求，不会吞噬、阻塞请求。而从客户端视角来看，发出的请求总有响应，不会出现整个服务集群无法连接、超时、无响应的情况。',-1),g=e("h3",{id:"partition-tolerance-分区容错性",tabindex:"-1"},[a("Partition Tolerance 分区容错性 "),e("a",{class:"header-anchor",href:"#partition-tolerance-分区容错性","aria-label":'Permalink to "Partition Tolerance 分区容错性"'},"​")],-1),N=e("p",null,'第三个要素是 Partition Tolerance 分区容错性。分区容错的英文含义是指"The system continues to operate despite arbitrary message loss or failure of part of the system"。即出现分区故障或分区间通信异常时，系统仍然要对外提供服务。在分布式环境，每个服务节点都不是可靠的，不同服务节点之间的通信有可能出现问题。当某些节点出现异常，或者某些节点与其他节点之间的通信出现异常时，整个系统就产生了分区问题。从服务端的视角来看，出现节点故障、网络异常时，服务集群仍然能对外提供稳定服务，就是具有较好的分区容错性。从客户端视角来看，就是服务端的各种故障对自己透明。',-1),u=e("h2",{id:"正常服务场景",tabindex:"-1"},[a("正常服务场景 "),e("a",{class:"header-anchor",href:"#正常服务场景","aria-label":'Permalink to "正常服务场景"'},"​")],-1),x=e("p",null,"根据CAP定理，在分布式系统中这三个要素不可能三者兼顾，最多只能同时满足两点。接下来，我们用 最简单的2 个服务节点场景，简要证明一下 CAP 定理。",-1),B=e("br",null,null,-1),y=e("p",null,"如图所示，网络上有 2 个服务节点 Node1 和 Node2，它们之间通过网络连通组成一个分布式系统。在正常工作的业务场景，Node1 和 Node2 始终正常运行，且网络一直良好连通。",-1),f=e("p",null,"假设某初始时刻，两个节点中的数据相同，都是 V0，用户访问 Nodel 和 Node2 都会立即得到 V0 的响应。当用户向 Node1 更新数据，将 V0 修改为 V1时，分布式系统会构建一个数据同步操作 M，将 V1 同步给 Node2，由于 Node1 和 Node2 都正常工作，且相互之间通信良好，Node2 中的 V0 也会被修改为 V1。此时，用户分别请求 Node1 和 Node2，得到的都是 V1，数据保持一致性，且总可以都得到响应。",-1),v=e("h2",{id:"网络异常场景",tabindex:"-1"},[a("网络异常场景 "),e("a",{class:"header-anchor",href:"#网络异常场景","aria-label":'Permalink to "网络异常场景"'},"​")],-1),V=o("",9),k=e("p",null,"根据 CAP 理论和前面的分析，我们知道分布式系统无法同时满足一致性、可用性、分区容错性三个要素，那我们在构建分布式系统时，应该如何选择呢？",-1),T=e("br",null,null,-1),M=e("p",null,"由于这三个要素对分布式系统都非常重要，既然三个不能同时满足，那就先尽量满足两个，只舍弃其中的一个元素。",-1),I=e("br",null,null,-1),S=e("p",null,"第一种方案选择是 CA，即不支持分区容错，只支持一致性和可用性。不支持分区容错性，也就意味着不允许分区异常，设备、网络永远处于理想的可用状态，从而让整个分布式系统满足一致性和可用性。",-1),q=e("br",null,null,-1),E=e("p",null,"但由于分布式系统是由众多节点通过网络通信连接构建的，设备故障、网络异常是客观存在的，而且分布的节点越多，范围越广，出现故障和异常的概率也越大，因此，对于分布式系统而言，分区容错 P 是无法避免的，如果避免了 P，只能把分布式系统回退到单机单实例系统。",-1),Y=e("h3",{id:"cp",tabindex:"-1"},[a("CP "),e("a",{class:"header-anchor",href:"#cp","aria-label":'Permalink to "CP"'},"​")],-1),w=e("p",null,"第二种方案选择是 CP，因为分区容错 P 客观存在，即相当于放弃系统的可用性，换取一致性。那么系统在遇到分区异常时，会持续阻塞整个服务，直到分区问题解决，才恢复对外服务，这样可以保证数据的一致性。选择 CP 的业务场景比较多，特别是对数据一致性特别敏感的业务最为普遍。比如在支付交易领域，Hbase 等分布式数据库领域，都要优先保证数据的一致性，在出现网络异常时，系统就会暂停服务处理。分布式系统中，用来分发及订阅元数据的 Zookeeper，也是选择优先保证 CP 的。因为数据的一致性是这些系统的基本要求，否则，银行系统0 余额大量取现，数据库系统访问，随机返回新老数据都会引发一系列的严重问题。",-1),O=e("h3",{id:"ap",tabindex:"-1"},[a("AP "),e("a",{class:"header-anchor",href:"#ap","aria-label":'Permalink to "AP"'},"​")],-1),Z=e("p",null,"第三种方案选择是 AP，由于分区容错 P 客观存在，即相当于放弃系统数据的一致性，换取可用性。这样，在系统遇到分区异常时，节点之间无法通信，数据处于不一致的状态，为了保证可用性，服务节点在收到用户请求后立即响应，那只能返回各自新老不同的数据。这种舍弃一致性，而保证系统在分区异常下的可用性，在互联网系统中非常常见。比如微博多地部署，如果不同区域的网络中断，区域内的用户仍然发微博、相互评论和点赞，但暂时无法看到其他区域用户发布的新微博和互动状态。对于微信朋友圈也是类似。还有如 12306 的火车购票系统，在节假日高峰期抢票时，偶尔也会遇到，反复看到某车次有余票，但每次真正点击购买时，却提示说没有余票。这样，虽然很小一部分功能受限，但系统整体服务稳定，影响非常有限，相比 CP，用户体验会更佳。",-1),F=e("h2",{id:"cap-问题及误区",tabindex:"-1"},[a("CAP 问题及误区 "),e("a",{class:"header-anchor",href:"#cap-问题及误区","aria-label":'Permalink to "CAP 问题及误区"'},"​")],-1),W=o("",16);function H(D,Q,$,G,J,K){const t=l("Image");return n(),c("div",null,[_,d,h,p,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/CgpOIF3vcYSAMqOZAABvnmKZkwc008.png"}),A,P,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/Cgq2xl3vcYSAdBslAABylkevii4101.png"}),C,b,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/CgpOIF3vcYWAT94EAABuz7E4yN8709.png"}),m,g,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/Cgq2xl3vcYWAUbX2AAB7bsXILGM706.png"}),N,u,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/CgpOIF3vcYWAHWxUAABP-muON70725.png"}),x,B,y,f,v,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/Cgq2xl3vcYWAHtgcAABMlxt6rrs881.png"}),V,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/CgpOIF3vcYaAHQy2AACx74l7-J4773.png"}),k,T,M,I,S,q,E,Y,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/Cgq2xl3vcYaAKw0SAACyCQZZxQo593.png"}),w,O,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/CgpOIF3vcYaAcHh1AACFKbW4siA522.png"}),Z,F,s(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/56/5B/Cgq2xl3vcYaAZGNJAAC1X1BrlZA576.png"}),a(),W])}const X=i(r,[["render",H]]);export{U as __pageData,X as default};
