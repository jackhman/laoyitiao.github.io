import{_ as a,j as o,o as p,g as c,k as l,s as e,h as t,Q as s}from"./chunks/framework.e0c66c3f.js";const O=JSON.parse('{"title":"Redis 事件驱动模型 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(200) 第20讲：Redi如何处理文件事件和时间事件？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(200) 第20讲：Redi如何处理文件事件和时间事件？.md","lastUpdated":1696338709000}'),n={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(200) 第20讲：Redi如何处理文件事件和时间事件？.md"},d=e("p",null,"上一课时，我们学习了 Redis 的系统架构，接下来的几个课时我将带你一起对这些模块和设计进行详细分析。首先，我将分析 Redis 的事件驱动模型。",-1),r=e("h6",{id:"redis-事件驱动模型",tabindex:"-1"},[t("Redis 事件驱动模型 "),e("a",{class:"header-anchor",href:"#redis-事件驱动模型","aria-label":'Permalink to "Redis 事件驱动模型"'},"​")],-1),_=e("h6",{id:"事件驱动模型",tabindex:"-1"},[t("事件驱动模型 "),e("a",{class:"header-anchor",href:"#事件驱动模型","aria-label":'Permalink to "事件驱动模型"'},"​")],-1),h=e("p",null,"Redis 是一个事件驱动程序，但和 Memcached 不同的是，Redis 并没有采用 libevent 或 libev 这些开源库，而是直接开发了一个新的事件循环组件。Redis 作者给出的理由是，尽量减少外部依赖，而自己开发的事件模型也足够简洁、轻便、高效，也更易控制。Redis 的事件驱动模型机制封装在 aeEventLoop 等相关的结构体中，网络连接、命令读取执行回复，数据的持久化、淘汰回收 key 等，几乎所有的核心操作都通过 ae 事件模型进行处理。",-1),u=e("p",null,"Redis 的事件驱动模型处理 2 类事件：",-1),R=e("ul",null,[e("li",null,[e("p",null,"文件事件，如连接建立、接受请求命令、发送响应等；")]),e("li",null,[e("p",null,"时间事件，如 Redis 中定期要执行的统计、key 淘汰、缓冲数据写出、rehash等。")])],-1),m=e("h6",{id:"文件事件处理",tabindex:"-1"},[t("文件事件处理 "),e("a",{class:"header-anchor",href:"#文件事件处理","aria-label":'Permalink to "文件事件处理"'},"​")],-1),k=s("",19),P=s("",12);function E(A,I,v,b,T,C){const i=o("Image");return p(),c("div",null,[d,r,_,h,l(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/9F/BF/CgotOV2yv6iAHosMAAAaut5-Ziw997.png"}),u,R,m,l(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/9F/9F/CgoB5l2yv6iAb3V5AACx5LFCsHM346.png"}),k,l(i,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/9F/BF/CgotOV2yv6iAclj-AABDYMWUBqc161.png"}),P])}const f=a(n,[["render",E]]);export{O as __pageData,f as default};
