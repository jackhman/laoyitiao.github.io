import{_ as a,j as l,o as p,g as o,k as e,h as t,Q as c,s}from"./chunks/framework.4e7d56ce.js";const D=JSON.parse('{"title":"22引擎进阶（下）：如何理解Proce.nextTick的原理？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/JavaScript 核心原理精讲_文档/(6195) 22  引擎进阶（下）：如何理解 Proce.nextTick 的原理？.md","filePath":"posts/frontEnd/JavaScript 核心原理精讲_文档/(6195) 22  引擎进阶（下）：如何理解 Proce.nextTick 的原理？.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/JavaScript 核心原理精讲_文档/(6195) 22  引擎进阶（下）：如何理解 Proce.nextTick 的原理？.md"},E=c(`<h1 id="_22引擎进阶-下-如何理解proce-nexttick的原理" tabindex="-1">22引擎进阶（下）：如何理解Proce.nextTick的原理？ <a class="header-anchor" href="#_22引擎进阶-下-如何理解proce-nexttick的原理" aria-label="Permalink to &quot;22引擎进阶（下）：如何理解Proce.nextTick的原理？&quot;">​</a></h1><p>上一讲我们讨论了宏任务和微任务的运行机制和原理，我在最后提到了 Process.nextTick 是微任务的其中一个，那么这一讲我们就来深挖一下 Process.nextTick 的相关知识。</p><p>这一讲我除了结合上一讲说的究宏任务和微任务的运行机制外，还将通过一些代码片段来带你研究 Process.nextick 的执行逻辑，帮你把这块知识点重新梳理。在日常开发中，Process.nextick 在浏览器端代码中很少使用，但在 Node.js 开发种却极为常见，所以你要好好掌握。</p><p>那么，为了方便你更好地理解本讲的内容，在课程开始前请你先思考：</p><ol><li><p>Process.nextick 和其他微任务方法在一起的时候，执行顺序是怎么样的？</p></li><li><p>Vue 也有个 nextick，它的逻辑又是什么样的？</p></li></ol><p>带着疑问，我们先来了解一下 Process.nextick。</p><h3 id="基本语法" tabindex="-1">基本语法 <a class="header-anchor" href="#基本语法" aria-label="Permalink to &quot;基本语法&quot;">​</a></h3><p>Process.nextick 的语法有两个参数：</p><blockquote><p>process.nextTick(callback[, ...args])</p></blockquote><p>其中，第一个参数是 callback 回调函数，第二个参数是 args 调用 callback 时额外传的参数，是可选参数。</p><p>再来看下 Process.nextick 的运行逻辑：</p><ol><li><p>Process.nextick 会将 callback 添加到&quot;next tick queue&quot;；</p></li><li><p>&quot;next tick queue&quot;会在当前 JavaScript stack 执行完成后，下一次 event loop 开始执行前按照 FIFO 出队；</p></li><li><p>如果递归调用 Process.nextick 可能会导致一个无限循环，需要去适时终止递归。</p></li></ol><p>可能你已经注意到 Process.nextick 其实是微任务，同时也是异步 API 的一部分。但是从技术上来说 Process.nextick 并不是事件循环（eventloop）的一部分，相反地，&quot;next tick queue&quot;将会在当前操作完成之后立即被处理，而不管当前处于事件循环的哪个阶段。</p><p>思考一下上面的逻辑，如果任何时刻你在一个给定的阶段调用 Process.nextick，则所有被传入 Process.nextick 的回调将在事件循环继续往下执行前被执行。这可能会导致一些很糟的情形，因为它允许用户递归调用 Process.nextick 来挂起 I/O 进程的进行，这会导致事件循环永远无法到达轮询阶段。</p><h3 id="为什么使用-process-nexttick" tabindex="-1">为什么使用 Process.nextTick() <a class="header-anchor" href="#为什么使用-process-nexttick" aria-label="Permalink to &quot;为什么使用 Process.nextTick()&quot;">​</a></h3><p>那么为什么 Process.nextick 这样的 API 会被允许出现在 Node.js 中呢？一部分原因是设计理念，Node.js 中的 API 应该总是异步的，即使是那些不需要异步的地方。下面的代码片段展示了一个例子：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">apiCall</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arg</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> arg </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;string&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> process.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(callback, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TypeError</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;argument should be     string&#39;</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">apiCall</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arg</span><span style="color:#24292E;">, </span><span style="color:#E36209;">callback</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> arg </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;string&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> process.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(callback, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TypeError</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;argument should be     string&#39;</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过上面的代码检查参数，如果检查不通过，它将一个错误对象传给回调。Node.js API 最近进行了更新，其已经允许向 Process.nextick 中传递参数来作为回调函数的参数，而不必写嵌套函数。</p><p>我们所做的就是将一个错误传递给用户，但这只允许在用户代码被执行完毕后执行。使用 Process.nextick 我们可以保证 apicall() 的回调总是在用户代码被执行后，且在事件循环继续工作前被执行。为了达到这一点，JS 调用栈被允许展开，然后立即执行所提供的回调。该回调允许用户对 Process.nextick 进行递归调用，而不会达到 RangeError，即 V8 调用栈的最大值。</p><p>这种设计理念会导致一些潜在的问题，观察下面的代码片段：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> bar;</span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">someAsyncApiCall</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) { </span><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">(); }</span></span>
<span class="line"><span style="color:#B392F0;">someAsyncApiCall</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;bar&#39;</span><span style="color:#E1E4E8;">, bar);   </span><span style="color:#6A737D;">// undefined</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">bar </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> bar;</span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">someAsyncApiCall</span><span style="color:#24292E;">(</span><span style="color:#E36209;">callback</span><span style="color:#24292E;">) { </span><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">(); }</span></span>
<span class="line"><span style="color:#6F42C1;">someAsyncApiCall</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;bar&#39;</span><span style="color:#24292E;">, bar);   </span><span style="color:#6A737D;">// undefined</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">bar </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><p>用户定义函数 someAsyncApiCall() 有一个异步签名，但实际上它是同步执行的。当它被调用时，提供给 someAsyncApiCall() 的回调函数会在执行 someAsyncApiCall() 本身的同一个事件循环阶段被执行，因为 someAsyncApiCall() 实际上并未执行任何异步操作。结果就是，即使回调函数尝试引用变量 bar，但此时在作用域中并没有改变量。因为程序还没运行到对 bar 赋值的部分。</p><p>将回调放到 Process.nextick 中，程序依然可以执行完毕，且所有的变量、函数等都在执行回调之前被初始化，它还具有不会被事件循环打断的优点。以下是将上面的例子改用 Process.nextick 的代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> bar;</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">someAsyncApiCall</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">callback</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  process.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(callback);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#B392F0;">someAsyncApiCall</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;bar&#39;</span><span style="color:#E1E4E8;">, bar); </span><span style="color:#6A737D;">// 1</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">bar </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> bar;</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">someAsyncApiCall</span><span style="color:#24292E;">(</span><span style="color:#E36209;">callback</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  process.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(callback);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6F42C1;">someAsyncApiCall</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;bar&#39;</span><span style="color:#24292E;">, bar); </span><span style="color:#6A737D;">// 1</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">bar </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span></code></pre></div><p>通过这个例子，你就可以体会到 Process.nextick 的作用了。其实在日常的 Node.js 开发中，这样的情况也经常会遇见，之前在&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=601#/detail/pc?id=6189&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">16 | 进阶练习（上）：怎样轻松实现一个 EventEmitter</a>&quot;中我有讲过 EventEmitter，那么我们看下 EventEmitter 在 Node.js 的使用的一个例子。</p><p>因为 Node.js 直接有 event 模块，其实就是一个 EventEmitter，下面代码是在造函数中触发一个事件：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">EventEmitter</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;events&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">util</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;util&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyEmitter</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">EventEmitter.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">emit</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;event&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">util.</span><span style="color:#B392F0;">inherits</span><span style="color:#E1E4E8;">(MyEmitter, EventEmitter);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">myEmitter</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyEmitter</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">myEmitter.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;event&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;an event occurred!&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">EventEmitter</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;events&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">util</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;util&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyEmitter</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">EventEmitter.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">emit</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;event&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">util.</span><span style="color:#6F42C1;">inherits</span><span style="color:#24292E;">(MyEmitter, EventEmitter);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">myEmitter</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyEmitter</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">myEmitter.</span><span style="color:#6F42C1;">on</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;event&#39;</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;an event occurred!&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>你无法在构造函数中立即触发一个事件，因为此时程序还未运行到将回调赋值给事件的那段代码。因此，在构造函数内部，你可以使用 Process.nextick 设置一个回调以在构造函数执行完毕后触发事件，下面的代码满足了我们的预期。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">EventEmitter</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;events&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">util</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;util&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyEmitter</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">EventEmitter.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">process.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">emit</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;event&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">util.</span><span style="color:#B392F0;">inherits</span><span style="color:#E1E4E8;">(MyEmitter, EventEmitter);</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">myEmitter</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MyEmitter</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  myEmitter.</span><span style="color:#B392F0;">on</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;event&#39;</span><span style="color:#E1E4E8;">, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;an event occurred!&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">EventEmitter</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;events&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">util</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;util&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyEmitter</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">EventEmitter.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">process.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">emit</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;event&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">util.</span><span style="color:#6F42C1;">inherits</span><span style="color:#24292E;">(MyEmitter, EventEmitter);</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">myEmitter</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MyEmitter</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  myEmitter.</span><span style="color:#6F42C1;">on</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;event&#39;</span><span style="color:#24292E;">, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;an event occurred!&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>通过上面的改造可以看出，使用 Process.nextick 就可以解决问题了，即使 event 事件还没进行绑定，但也可以让代码在前面进行触发，因为根据代码执行顺序，Process.nextick 是在每一次的事件循环最后执行的。因此这样写，代码也不会报错，同样又保持了代码的逻辑。</p><p>通过这两个例子你应该对 Process.nextick 这个知识有了更好的理解了吧？下面我们再来看看浏览器端 Vue 框架的 nextick 是干什么用的，注意不要将二者混淆了，前面讲的是 Node.js 服务端的事情，而下面要说的是浏览器端 Vue 框架的知识。</p><h3 id="vue-的-nextick-又是什么意思" tabindex="-1">Vue 的 nextick 又是什么意思？ <a class="header-anchor" href="#vue-的-nextick-又是什么意思" aria-label="Permalink to &quot;Vue 的 nextick 又是什么意思？&quot;">​</a></h3><p>我们看下 Vue 官网最直白的解释：</p><blockquote><p>Vue 异步执行 DOM 的更新。当数据发生变化时，Vue 会开启一个队列，用于缓冲在同一事件循环中发生的所有数据改变的情况。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后在下一个的事件循环&quot;tick&quot;中。例如：当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在事件循环队列清空时的下一个&quot;tick&quot;更新。多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。</p></blockquote><p>我们细细地根据 Vue 的官网理解一下，其实是不是有点像 EventLoop 的味道，这里只不过是 Vue 开启了一个队列，当你在 nextick 方法中改变数据的时候，视图层不会立马更新，而是要在下次的时间循环队列中更新。</p><p>这点是不是类似上面讲的 Node.js 的 Process.nextick 的意思？虽然运行的环境不一样，但是这个意思你可以细细品味一下。这里我们再来看一段 Vue 代码，让你理解 Vue 的 nextick 的作用。</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">class</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;app&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ref</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;msg&quot;</span><span style="color:#E1E4E8;">&gt;{ {msg}}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;msg1&quot;</span><span style="color:#E1E4E8;">&gt;Message got outside $nextTick: { {msg1}}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;msg2&quot;</span><span style="color:#E1E4E8;">&gt;Message got inside $nextTick: { {msg2}}&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;"> @click=</span><span style="color:#9ECBFF;">&quot;changeMsg&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      Change the Message</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">button</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">new Vue({</span></span>
<span class="line"><span style="color:#E1E4E8;">  el: &#39;.app&#39;,</span></span>
<span class="line"><span style="color:#E1E4E8;">  data: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    msg: &#39;Vue&#39;,</span></span>
<span class="line"><span style="color:#E1E4E8;">    msg1: &#39;&#39;,</span></span>
<span class="line"><span style="color:#E1E4E8;">    msg2: &#39;&#39;,</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    changeMsg() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      this.msg = &quot;Hello world.&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">      this.msg1 = this.$refs.msg.innerHTML</span></span>
<span class="line"><span style="color:#E1E4E8;">      this.$nextTick(() =&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">        this.msg2 = this.$refs.msg.innerHTML</span></span>
<span class="line"><span style="color:#E1E4E8;">      })</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">class</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;app&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ref</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;msg&quot;</span><span style="color:#24292E;">&gt;{ {msg}}&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-if</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;msg1&quot;</span><span style="color:#24292E;">&gt;Message got outside $nextTick: { {msg1}}&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">div</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-if</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;msg2&quot;</span><span style="color:#24292E;">&gt;Message got inside $nextTick: { {msg2}}&lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">button</span><span style="color:#24292E;"> @click=</span><span style="color:#032F62;">&quot;changeMsg&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      Change the Message</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">button</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;/</span><span style="color:#22863A;">div</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">new Vue({</span></span>
<span class="line"><span style="color:#24292E;">  el: &#39;.app&#39;,</span></span>
<span class="line"><span style="color:#24292E;">  data: {</span></span>
<span class="line"><span style="color:#24292E;">    msg: &#39;Vue&#39;,</span></span>
<span class="line"><span style="color:#24292E;">    msg1: &#39;&#39;,</span></span>
<span class="line"><span style="color:#24292E;">    msg2: &#39;&#39;,</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  methods: {</span></span>
<span class="line"><span style="color:#24292E;">    changeMsg() {</span></span>
<span class="line"><span style="color:#24292E;">      this.msg = &quot;Hello world.&quot;</span></span>
<span class="line"><span style="color:#24292E;">      this.msg1 = this.$refs.msg.innerHTML</span></span>
<span class="line"><span style="color:#24292E;">      this.$nextTick(() =&gt; {</span></span>
<span class="line"><span style="color:#24292E;">        this.msg2 = this.$refs.msg.innerHTML</span></span>
<span class="line"><span style="color:#24292E;">      })</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">script</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><p>你可以将这一段代码放到自己的 Vue 的项目里执行一下，看看通过按钮点击之后，div 里面的 msg1 和 msg2 的变化情况。你会发现第一次点击按钮调用 changeMsg 方法时，其实 msg2 并没有变化，因为 msg2 的变化是在下一个 tick 才进行执行的。</p><p>最后我们再来看下 Vue 中 nextick 的源码。在 Vue 2.5+ 之后的版本中，有一个单独的 JS 文件来维护，路径是在 src/core/util/next-tick.js 中，源码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">/* @flow */</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">/* globals MutationObserver */</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { noop } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;shared/util&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { handleError } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;./error&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { isIE, isIOS, isNative } </span><span style="color:#F97583;">from</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;./env&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> isUsingMicroTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">callbacks</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> pending </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">flushCallbacks</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  pending </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">copies</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> callbacks.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  callbacks.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> copies.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    copies[i]()</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// Here we have async deferring wrappers using microtasks.</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// In 2.5 we used (macro) tasks (in combination with microtasks).</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// However, it has subtle problems when state is changed right before repaint</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// (e.g. #6813, out-in transitions).</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// Also, using (macro) tasks in event handler would cause some weird behaviors</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// So we now use microtasks everywhere, again.</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// A major drawback of this tradeoff is that there are some scenarios</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// where microtasks have too high a priority and fire in between supposedly</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// sequential events (e.g. #4521, #6690, which have workarounds)</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// or even between bubbling of the same event (#6566).</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> timerFunc</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// via either native Promise.then or MutationObserver.</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// MutationObserver has wider support, however it is seriously bugged in</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// completely stops working after triggering a few times... so, if native</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// Promise is available, we will use it:</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">/* istanbul ignore next, $flow-disable-line */</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isNative</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">p</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#B392F0;">timerFunc</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    p.</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(flushCallbacks)</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// In problematic UIWebViews, Promise.then doesn&#39;t completely break, but</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// it can get stuck in a weird state where callbacks are pushed into the</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// microtask queue but the queue isn&#39;t being flushed, until the browser</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span>
<span class="line"><span style="color:#E1E4E8;">	     </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (isIOS) </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(noop)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	  isUsingMicroTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">	} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">isIE </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> MutationObserver </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#B392F0;">isNative</span><span style="color:#E1E4E8;">(MutationObserver) </span><span style="color:#F97583;">||</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// PhantomJS and iOS 7.x</span></span>
<span class="line"><span style="color:#E1E4E8;">	  MutationObserver.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;[object MutationObserverConstructor]&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">	)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// Use MutationObserver where native Promise is not available,</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// e.g. PhantomJS, iOS7, Android 4.4</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// (#6466 MutationObserver is unreliable in IE11)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> counter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">observer</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">MutationObserver</span><span style="color:#E1E4E8;">(flushCallbacks)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">textNode</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createTextNode</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(counter))</span></span>
<span class="line"><span style="color:#E1E4E8;">	  observer.</span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;">(textNode, {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    characterData: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">	  })</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#B392F0;">timerFunc</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    counter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (counter </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#E1E4E8;">	    textNode.data </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(counter)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	  isUsingMicroTask </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">	} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> setImmediate </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isNative</span><span style="color:#E1E4E8;">(setImmediate)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// Fallback to setImmediate.</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// Technically it leverages the (macro) task queue,</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// but it is still a better choice than setTimeout.</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#B392F0;">timerFunc</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#B392F0;">setImmediate</span><span style="color:#E1E4E8;">(flushCallbacks)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// Fallback to setTimeout.</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#B392F0;">timerFunc</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(flushCallbacks, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">export</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">cb</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Function</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">ctx</span><span style="color:#F97583;">?:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> _resolve</span></span>
<span class="line"><span style="color:#E1E4E8;">	  callbacks.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (cb) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	      </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	        cb.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(ctx)</span></span>
<span class="line"><span style="color:#E1E4E8;">	      } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (e) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	        </span><span style="color:#B392F0;">handleError</span><span style="color:#E1E4E8;">(e, ctx, </span><span style="color:#9ECBFF;">&#39;nextTick&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">	      }</span></span>
<span class="line"><span style="color:#E1E4E8;">	    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (_resolve) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	      </span><span style="color:#B392F0;">_resolve</span><span style="color:#E1E4E8;">(ctx)</span></span>
<span class="line"><span style="color:#E1E4E8;">	    }</span></span>
<span class="line"><span style="color:#E1E4E8;">	  })</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">pending) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    pending </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#B392F0;">timerFunc</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#6A737D;">// $flow-disable-line</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">cb </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;undefined&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Promise</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">resolve</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	      _resolve </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> resolve</span></span>
<span class="line"><span style="color:#E1E4E8;">	    })</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">/* @flow */</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">/* globals MutationObserver */</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { noop } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;shared/util&#39;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { handleError } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;./error&#39;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { isIE, isIOS, isNative } </span><span style="color:#D73A49;">from</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;./env&#39;</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> isUsingMicroTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">callbacks</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> pending </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">flushCallbacks</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">	  pending </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">copies</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> callbacks.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">	  callbacks.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> copies.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	    copies[i]()</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// Here we have async deferring wrappers using microtasks.</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// In 2.5 we used (macro) tasks (in combination with microtasks).</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// However, it has subtle problems when state is changed right before repaint</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// (e.g. #6813, out-in transitions).</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// Also, using (macro) tasks in event handler would cause some weird behaviors</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// So we now use microtasks everywhere, again.</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// A major drawback of this tradeoff is that there are some scenarios</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// where microtasks have too high a priority and fire in between supposedly</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// sequential events (e.g. #4521, #6690, which have workarounds)</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// or even between bubbling of the same event (#6566).</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> timerFunc</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// via either native Promise.then or MutationObserver.</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// MutationObserver has wider support, however it is seriously bugged in</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// completely stops working after triggering a few times... so, if native</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// Promise is available, we will use it:</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">/* istanbul ignore next, $flow-disable-line */</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isNative</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">p</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6F42C1;">timerFunc</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    p.</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(flushCallbacks)</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// In problematic UIWebViews, Promise.then doesn&#39;t completely break, but</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// it can get stuck in a weird state where callbacks are pushed into the</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// microtask queue but the queue isn&#39;t being flushed, until the browser</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span>
<span class="line"><span style="color:#24292E;">	     </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (isIOS) </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(noop)</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	  isUsingMicroTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">	} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">isIE </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> MutationObserver </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6F42C1;">isNative</span><span style="color:#24292E;">(MutationObserver) </span><span style="color:#D73A49;">||</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// PhantomJS and iOS 7.x</span></span>
<span class="line"><span style="color:#24292E;">	  MutationObserver.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;[object MutationObserverConstructor]&#39;</span></span>
<span class="line"><span style="color:#24292E;">	)) {</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// Use MutationObserver where native Promise is not available,</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// e.g. PhantomJS, iOS7, Android 4.4</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// (#6466 MutationObserver is unreliable in IE11)</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> counter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">observer</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">MutationObserver</span><span style="color:#24292E;">(flushCallbacks)</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">textNode</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> document.</span><span style="color:#6F42C1;">createTextNode</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(counter))</span></span>
<span class="line"><span style="color:#24292E;">	  observer.</span><span style="color:#6F42C1;">observe</span><span style="color:#24292E;">(textNode, {</span></span>
<span class="line"><span style="color:#24292E;">	    characterData: </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">	  })</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6F42C1;">timerFunc</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    counter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (counter </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span></span>
<span class="line"><span style="color:#24292E;">	    textNode.data </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(counter)</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	  isUsingMicroTask </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">	} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> setImmediate </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isNative</span><span style="color:#24292E;">(setImmediate)) {</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// Fallback to setImmediate.</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// Technically it leverages the (macro) task queue,</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// but it is still a better choice than setTimeout.</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6F42C1;">timerFunc</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6F42C1;">setImmediate</span><span style="color:#24292E;">(flushCallbacks)</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// Fallback to setTimeout.</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6F42C1;">timerFunc</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6F42C1;">setTimeout</span><span style="color:#24292E;">(flushCallbacks, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">export</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">cb</span><span style="color:#D73A49;">?:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Function</span><span style="color:#24292E;">, </span><span style="color:#E36209;">ctx</span><span style="color:#D73A49;">?:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> _resolve</span></span>
<span class="line"><span style="color:#24292E;">	  callbacks.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (cb) {</span></span>
<span class="line"><span style="color:#24292E;">	      </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	        cb.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(ctx)</span></span>
<span class="line"><span style="color:#24292E;">	      } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (e) {</span></span>
<span class="line"><span style="color:#24292E;">	        </span><span style="color:#6F42C1;">handleError</span><span style="color:#24292E;">(e, ctx, </span><span style="color:#032F62;">&#39;nextTick&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">	      }</span></span>
<span class="line"><span style="color:#24292E;">	    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (_resolve) {</span></span>
<span class="line"><span style="color:#24292E;">	      </span><span style="color:#6F42C1;">_resolve</span><span style="color:#24292E;">(ctx)</span></span>
<span class="line"><span style="color:#24292E;">	    }</span></span>
<span class="line"><span style="color:#24292E;">	  })</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">pending) {</span></span>
<span class="line"><span style="color:#24292E;">	    pending </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6F42C1;">timerFunc</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#6A737D;">// $flow-disable-line</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">cb </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;undefined&#39;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Promise</span><span style="color:#24292E;">(</span><span style="color:#E36209;">resolve</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	      _resolve </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> resolve</span></span>
<span class="line"><span style="color:#24292E;">	    })</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span></code></pre></div><p>整体代码不是太多，注释比较多，其核心部分代码比较精简，主要在 40~80 行之间，核心在于 timerFunc 这个函数的逻辑实现，timerFunc 这个函数采用了好几种处理方式，主要是针对系统以及 Promise 的支持几个情况同时进行兼容性处理。处理逻辑情况是这样的：</p><ol><li><p>首先判断是否原生支持 Promise，支持的话，利用 promise 来触发执行回调函数；</p></li><li><p>如果不支持 Promise，再判断是否支持 MutationObserver，如果支持，那么生成一个对象来观察文本节点发生的变化，从而实现触发执行所有回调函数；</p></li><li><p>如果 Promise 和 MutationObserver 都不支持，那么使用 setTimeout 设置延时为 0。</p></li></ol><p>关于 Promise 以及 MutationObserver 的相关知识我已经在前面的课时中都讲过，因此这些方法你只要理解的话，那么再去理解这一讲 nextick 的 timerFunc 这个函数的逻辑就会比较轻松了。这里主要是一些兼容性的判断，即使你之前不清楚，但是看一下源码也就能很容易理解了，只要你的基础知识足够牢靠，学习这些并不复杂。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>最后，针对 Process.nextick() 和 Vue 的 nextick 这两种不同的 tick ，我总结了下面这个表格，方便你深入理解。</p>`,45),y=s("p",null,"那么关于这部分知识，你如果有不理解的地方可以多学习几遍。我们的专栏主课内容到这里也就告一段落了，很高兴你能坚持到最后，也希望我的分享可以为你带来帮助。",-1),i=s("p",null,"别着急走开，之后我们将进入彩蛋环节，一来是帮你梳理前端面试中经常考察的知识点，二来要给你传递学习算法的思路，我想这些也是你前端进阶的必要内容，我们下一讲再见。",-1);function F(u,m,d,g,h,A){const n=l("Image");return p(),o("div",null,[E,e(n,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image6/M01/25/22/CioPOWBZZXWAct2kAAFSwK67cM8982.png"}),t(),y,i])}const b=a(r,[["render",F]]);export{D as __pageData,b as default};
