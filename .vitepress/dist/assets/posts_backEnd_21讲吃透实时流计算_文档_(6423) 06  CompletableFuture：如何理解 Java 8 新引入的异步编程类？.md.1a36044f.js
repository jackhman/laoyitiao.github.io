import{_ as o,j as e,o as t,g as c,k as p,h as a,Q as n,s}from"./chunks/framework.4e7d56ce.js";const f=JSON.parse('{"title":"06CompletableFuture：如何理解Java8新引入的异步编程类？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/21讲吃透实时流计算_文档/(6423) 06  CompletableFuture：如何理解 Java 8 新引入的异步编程类？.md","filePath":"posts/backEnd/21讲吃透实时流计算_文档/(6423) 06  CompletableFuture：如何理解 Java 8 新引入的异步编程类？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/21讲吃透实时流计算_文档/(6423) 06  CompletableFuture：如何理解 Java 8 新引入的异步编程类？.md"},E=n(`<h1 id="_06completablefuture-如何理解java8新引入的异步编程类" tabindex="-1">06CompletableFuture：如何理解Java8新引入的异步编程类？ <a class="header-anchor" href="#_06completablefuture-如何理解java8新引入的异步编程类" aria-label="Permalink to &quot;06CompletableFuture：如何理解Java8新引入的异步编程类？&quot;">​</a></h1><p>今天，我们一起来看下如何理解 Java8 引入的新异步编程类，CompletableFuture。</p><p>在第 05 时，我们直接用&quot;线程&quot;和&quot;阻塞队列&quot;构建实现了一个简单的流计算框架。这个框架帮助我们理解了流计算系统的基本实现原理，但是它用起来不是非常方便，需要配合框架写一些业务无关的代码。</p><p>所以，今天我们的目标就是对这个框架进行改造。我们不再用原始的&quot;线程&quot;和&quot;阻塞队列&quot;，而是使用 Java 8 中引入的 CompletableFuture 类。你将看到，用 CompletableFuture 这个异步编程类，实现的流计算框架是多么灵活好用。</p><h3 id="java-8-为啥引入-completablefuture-类" tabindex="-1">Java 8 为啥引入 CompletableFuture 类 <a class="header-anchor" href="#java-8-为啥引入-completablefuture-类" aria-label="Permalink to &quot;Java 8 为啥引入 CompletableFuture 类&quot;">​</a></h3><p>在 Java 8 之前，我们写异步代码的时候，主要还是依靠 ExecutorService 类和 Future 类。Future 类提供了 get 方法，用于在任务完成时获取任务结果。但是，Future 类的 get 方法有个缺点，它是阻塞的，需要同步等待结果返回。这就在事实上让原本异步执行的过程，重新退化成了同步的过程，失去了异步的作用。</p><p>为了避免这种问题，不同的第三方库提供了不同的解决方案，比如 Guava 库中的SettableFuture/ListenableFuture、Netty 中的 Future 和 ChannelFuture 等。这些解决方案都是通过注册监听或回调的方式，形成回调链，从而实现了真正意义上的异步执行。</p><p>与此形成鲜明对比的是，JDK 自己却一直没有真正的异步编程工具类。</p><p>所以，在被 JavaScript、C# 等诸多语言嫌弃后，Java 8 终于推出了自己的异步编程方案，这就是 CompletableFuture 类。</p><p>CompletableFuture 类采用回调的方式实现异步执行，并提供了大量有关构建异步调用链的API。这些 API 使得 Java 异步编程变得无比灵活和方便，极大程度地解放了 Java 异步编程的生产力。可以说，<strong>CompletableFuture 类仅凭一己之力，将 Java 异步编程提升到了一个全新的境界</strong>。</p><p>所以，接下来我们就先看看 CompletableFuture 类都有哪些神奇的方法。</p><h3 id="常用的-completablefuture-类方法" tabindex="-1">常用的 CompletableFuture 类方法 <a class="header-anchor" href="#常用的-completablefuture-类方法" aria-label="Permalink to &quot;常用的 CompletableFuture 类方法&quot;">​</a></h3><p>如果你查看 Java 8 中 CompletableFuture 类的源码，你会发现这个类有 80 多个可以公共访问的方法。并且这些方法中，很多方法的名字相似，它们的注释说明也似乎大同小异。再加上本身这个类是新引入的异步编程工具类。所以，对于初次接触这个类，以及对异步编程并不熟悉的开发人员来说，很容易没有头绪，不知道具体怎么使用这些方法，也不知道从哪个方法开始。</p><p>但爽哥想说的是，不用担心，当你理解这个类后，你会发现 CompletableFuture 类的所有这些方法之间，是有非常强的逻辑性的。通过这些方法，你可以构建出各种各样的异步调用链过程。</p><p>所以，为了帮助你更具逻辑性地理解 CompletableFuture 类。我将通过&quot;产品在流水线上被一步一步加工，直到产品加工完成后被装入仓库&quot;的过程，来依次讲解 CompletableFuture 类中最主要的几个类的使用逻辑。在模块一时，我们已经讲过&quot;流&quot;和&quot;异步&quot;是相通的，所以这里借助流水线的方式来讲解 CompletableFuture 类也是十分合适的。</p><p><strong>1</strong>. 既然要生产产品，那么首先就是将毛坯产品放在流水线的&quot;起点&quot;处。这个过程，是通过 supplyAsync 方法来完成的。supplyAsync 方法的定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Supplier</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> supplier, Executor executor)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    Supplier</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> supplier, Executor executor)</span></span></code></pre></div><p>supplyAsync 是开启 CompletableFuture 异步调用链的方法之一。使用这个方法，会将supplier 封装为一个任务提交给 executor 执行，然后返回一个记录任务执行状态和结果的 CompletableFuture 对象。之后可以在这个 CompletableFuture 对象上挂接各种回调动作。</p><p>所以说，supplyAsync 可以作为&quot;流&quot;的起点。</p><p><strong>2</strong>. 当毛坯产品放在流水线上后，它就在流水线上传动起来。之后，当毛坯产品传动到加工位置时，就需要对其进行&quot;加工&quot;了。而&quot;加工&quot;就是通过 thenApplyAsync 方法来完成的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T,</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn, Executor executor)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T,</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn, Executor executor)</span></span></code></pre></div><p>thenApplyAsync 用于在 CompletableFuture 对象上挂接一个转化函数。当 CompletableFuture 对象完成时，将它的结果作为输入参数调用转化函数。转化函数在执行各种逻辑后，返回另一种类型的数据作为输出。</p><p>这么一看，thenApplyAsync 的作用就是对&quot;流&quot;上的数据进行处理。</p><p><strong>3</strong>. 当毛坯产品在流水线上最终被加工完成后，就变成了一个成品。所以，接下来我们就需要将这个成品装箱入库。而&quot;装箱入库&quot;的动作，就是通过 thenAcceptAsync 方法来完成的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Consumer</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> action, Executor executor)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    Consumer</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> action, Executor executor)</span></span></code></pre></div><p>thenAcceptAsync 用于在 CompletableFuture 对象上挂接一个接收函数。当CompletableFuture 对象完成时，将它的结果作为输入参数调用接收函数。与 thenApplyAsync 类似，接收函数可以执行各种逻辑，但不同的是，接收函数不会返回任何类型数据，或者说返回类型是 void。</p><p>所以，thenAcceptAsync可以作为&quot;流&quot;的终点。</p><p><strong>4</strong>. 现在需要对流水线进行升级改造，将流水线的其中一段，改造成&quot;另外一条&quot;流水线。那这个工作，就是通过 thenComposeAsync 方法来实现的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">thenComposeAsync</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends CompletionStage</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> fn, Executor executor)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">thenComposeAsync</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends CompletionStage</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> fn, Executor executor)</span></span></code></pre></div><p>thenComposeAsync 理解起来会复杂些，但它真的是一个非常重要的方法，请你务必理解它。</p><p>thenComposeAsync 在 API 形式上与 thenApplyAsync 类似，但是它的转化函数返回的不是一般类型的对象，而是一个 CompletionStage 对象，或者说得更具体点，实际中通常就是一个 CompletableFuture 对象。这意味着，我们可以在原来的 CompletableFuture 调用链上，插入另外一个调用链，从而形成一个新的调用链。这正是 compose(组成、构成)的含义所在。</p><p>所以，thenComposeAsync 的作用，就像是在&quot;流&quot;的某个地方，插入了另外一条&quot;流&quot;。</p><p><strong>5</strong>. 现在老板为了鼓励工人更加努力的工作，就告诉大家谁先完成作业就给谁发奖金。那这个&quot;谁先完成就由谁领奖金&quot;的机制，是通过 applyToEither 方法来实现的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">applyToEither</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    CompletionStage</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> other, Function</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;"> T, U</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">applyToEither</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    CompletionStage</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> other, Function</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">super</span><span style="color:#24292E;"> T, U</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn)</span></span></code></pre></div><p>使用 applyToEither 可以实现两个 CompletableFuture 谁先完成，就由谁执行回调函数的功能。这也是一个非常有用的方法，爽哥经常用它来实现定时超期的功能。</p><p><strong>6</strong>. 有一天车间运来了一个大货箱，一个人搬不动，所以老板就让&quot;大家忙完手头的事后一起来搬运这个大货箱&quot;。那这种&quot;大家一起完成后再执行某个动作&quot;的过程，就是由 allOf 方法来实现的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Void</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">allOf</span><span style="color:#E1E4E8;">(CompletableFuture</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;">... cfs)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Void</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">allOf</span><span style="color:#24292E;">(CompletableFuture</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;">... cfs)</span></span></code></pre></div><p>CompletableFuture.allOf 的作用是将多个 CompletableFuture 合并成一个CompletableFuture。这又是一个非常有用的方法，我们可以用它实现类似于 Map/Reduce 或 Fork/Join 的功能。</p><p><strong>7</strong>. 流水线上工人在加工产品时，总会时不时地发生些意外情况，那发生意外情况后该怎么办呢？这就是由 exceptionally 方法来处理的。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">exceptionally</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">        Function</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Throwable, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">exceptionally</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">        Function</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Throwable, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn)</span></span></code></pre></div><p>相比同步编程方式，异步程序发生异常时的问题会更加复杂。使用 exceptionally 方法，可以对异步调用链在执行过程中抛出的异常进行处理。</p><p>所以，通过这种&quot;流水线上加工商品&quot;的过程，我们很容易将 CompletableFuture 类中最主要的几个方法的功能和使用逻辑串起来。</p><p>后面你在使用 CompletableFuture 类构建异步调用链时，遇到难以理解的地方，可以时不时地联想下上面的流水线场景。</p><h3 id="completablefuture-工作原理" tabindex="-1">CompletableFuture 工作原理 <a class="header-anchor" href="#completablefuture-工作原理" aria-label="Permalink to &quot;CompletableFuture 工作原理&quot;">​</a></h3><p>前面介绍了 CompletableFuture 的几个常用 API，但光知道这些 API 还不足以体会到 CompletableFuture 的奥义和乐趣所在。我们最好还需要理解 CompletableFuture 类的内部工作原理。</p><p>所以接下来，我们借助于下面这段代码（<a href="https://github.com/alain898/realtime_stream_computing_course/blob/main/course06/src/main/java/com/alain898/course/realtimestreaming/course06/cftests/Tests.java" target="_blank" rel="noreferrer">完整代码参考</a>）来详细分析下CompletableFuture类的工作原理：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; cf1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(Tests</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">source, executor1);</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; cf2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cf1.</span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(Tests</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">echo, executor2);</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; cf3_1 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cf2.</span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(Tests</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">echo1, executor3);</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; cf3_2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cf2.</span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(Tests</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">echo2, executor3);</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; cf3_3 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cf2.</span><span style="color:#B392F0;">thenApplyAsync</span><span style="color:#E1E4E8;">(Tests</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">echo3, executor3);</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; cf3 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CompletableFuture.</span><span style="color:#B392F0;">allOf</span><span style="color:#E1E4E8;">(cf3_1, cf3_2, cf3_3);</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture&lt;</span><span style="color:#F97583;">Void</span><span style="color:#E1E4E8;">&gt; cf4 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cf3.</span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(x </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">print</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;world&quot;</span><span style="color:#E1E4E8;">), executor4);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; cf1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(Tests</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">source, executor1);</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; cf2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cf1.</span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(Tests</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">echo, executor2);</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; cf3_1 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cf2.</span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(Tests</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">echo1, executor3);</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; cf3_2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cf2.</span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(Tests</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">echo2, executor3);</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; cf3_3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cf2.</span><span style="color:#6F42C1;">thenApplyAsync</span><span style="color:#24292E;">(Tests</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">echo3, executor3);</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; cf3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CompletableFuture.</span><span style="color:#6F42C1;">allOf</span><span style="color:#24292E;">(cf3_1, cf3_2, cf3_3);</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture&lt;</span><span style="color:#D73A49;">Void</span><span style="color:#24292E;">&gt; cf4 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cf3.</span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(x </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">print</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;world&quot;</span><span style="color:#24292E;">), executor4);</span></span></code></pre></div><p>通过阅读 JDK 源码，并借助于 IDE 的断点（比如 Mac 环境下 IntelliJ IDEA 的 F7 和 F8 功能键逐步调试）调试功能，可以追踪出以上代码生成 CompletableFuture 异步调用链的过程，如下图 1 所示。</p>`,48),y=n(`<p>具体来说，CompletableFuture 的异步调用链是这样形成的。</p><p>首先，通过 CompletableFuture.supplyAsync 创建了一个任务 Tests::source，并交给executor1 异步执行。用 cf1 来记录该任务在执行过程中的状态和结果。</p><p>然后，通过 cf1.thenApplyAsync，指定当 cf1(Tests::source) 完成时，需要回调的任务Tests::echo。cf1 使用 stack 来管理这个后续要回调的任务Tests::echo。用 cf2 来记录回调任务 Tests::echo 的执行状态和结果。</p><p>再然后，通过连续三次调用 cf2.thenApplyAsync，指定当 cf2(Tests::echo) 完成时，需要回调的后续三个任务：Tests::echo1、Tests::echo2 和 Tests::echo3。cf2 也是用 stack 来管理这三个后续需要执行的任务。</p><p>接着，通过 CompletableFuture.allOf，创建一个合并 cf3_1、cf3_2、cf3_3 的 cf3。这也意味着 cf3 只有在 cf3_1、cf3_2、cf3_3 都完成时才能完成。在 cf3 内部，是用一个<strong>树（Tree）结构</strong>来记录它和 cf3_1、cf3_2、cf3_3 的依赖关系。</p><p>最后，通过 cf3.thenAcceptAsync，指定了当 cf3 完成时，需要回调的任务，即 print。用 cf4来记录 print 任务的状态和结果。</p><p>所以总的来说，就是 CompletableFuture 用 stack 来管理它在完成时后续需要回调的任务。当任务完成时，再通过依赖关系，找到后续需要处理的 CompletableFuture，并继续调用执行。这样，就构成了一个调用链，所有任务将按照该调用链依次执行。</p><h3 id="采用-completablefuture-实现流计算框架" tabindex="-1">采用 CompletableFuture 实现流计算框架 <a class="header-anchor" href="#采用-completablefuture-实现流计算框架" aria-label="Permalink to &quot;采用 CompletableFuture 实现流计算框架&quot;">​</a></h3><p>现在，我们已经对 CompletableFuture 的功能、API 和工作原理都有了一定认识。接下来就是实践了，这里，我们用 CompletableFuture 对 05 课时中的流计算框架进行改进。</p><p>闲话少叙，咱们先直接上代码（<a href="https://github.com/alain898/realtime_stream_computing_course/blob/main/course06/src/main/java/com/alain898/course/realtimestreaming/course06/cftests/completablefuturestream/FeatureExtractor.java" target="_blank" rel="noreferrer">完整代码参考</a>）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ExecutorService decoderExecutor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BackPressureExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;decoderExecutor&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ExecutorService extractExecutor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BackPressureExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;extractExecutor&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ExecutorService senderExecutor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BackPressureExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;senderExecutor&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ExecutorService extractService </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">BackPressureExecutor</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;extractService&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">16</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] event </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> receiver.</span><span style="color:#B392F0;">receive</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">CompletableFuture</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">supplyAsync</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> decoder.</span><span style="color:#B392F0;">decode</span><span style="color:#E1E4E8;">(event), decoderExecutor)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">thenComposeAsync</span><span style="color:#E1E4E8;">(extractor</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">extract, extractExecutor)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">thenAcceptAsync</span><span style="color:#E1E4E8;">(sender</span><span style="color:#F97583;">::</span><span style="color:#E1E4E8;">send, senderExecutor)</span></span>
<span class="line"><span style="color:#E1E4E8;">        .</span><span style="color:#B392F0;">exceptionally</span><span style="color:#E1E4E8;">(e </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            logger.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;unexpected exception&quot;</span><span style="color:#E1E4E8;">, e);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        });</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ExecutorService decoderExecutor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BackPressureExecutor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;decoderExecutor&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ExecutorService extractExecutor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BackPressureExecutor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;extractExecutor&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ExecutorService senderExecutor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BackPressureExecutor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;senderExecutor&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ExecutorService extractService </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">BackPressureExecutor</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;extractService&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">16</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] event </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> receiver.</span><span style="color:#6F42C1;">receive</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">CompletableFuture</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">supplyAsync</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> decoder.</span><span style="color:#6F42C1;">decode</span><span style="color:#24292E;">(event), decoderExecutor)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">thenComposeAsync</span><span style="color:#24292E;">(extractor</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">extract, extractExecutor)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">thenAcceptAsync</span><span style="color:#24292E;">(sender</span><span style="color:#D73A49;">::</span><span style="color:#24292E;">send, senderExecutor)</span></span>
<span class="line"><span style="color:#24292E;">        .</span><span style="color:#6F42C1;">exceptionally</span><span style="color:#24292E;">(e </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            logger.</span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;unexpected exception&quot;</span><span style="color:#24292E;">, e);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        });</span></span></code></pre></div><p>看，是不是非常简单！</p><p>上面的代码中，receiver 读取消息后，通过 supplyAsync 方法，将其交给 decoder 解码。消息在解码后，再交给 extractor 进行特征提取。</p><p>由于 extractor 内部有个独立的&quot;流&quot;用于特征的并行计算，故采用 thenComposeAsync 将这个内部&quot;流&quot;插入到整体的&quot;流&quot;中来。</p><p>&quot;流&quot;的最后一步是将消息发送到 Kafka，所以使用 thenAcceptAsync 作为&quot;流&quot;的终点。</p><p>另外，为了让整个异步调用链在执行过程中不会出现 OOM 问题，我们还使用了带反向压力功能的执行器 BackPressureExecutor。这个执行器的原理和实现方法，我们已经在 03 课时讨论过，这里重新提醒下，就不再赘述了。</p><p>从上面的改造过程可以看出，CompletableFuture 本身就是一个非常好用的流计算框架。短短几行代码，就实现了我们在 05 课时中的所有功能。</p><h3 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h3><p>今天，我们使用 CompletableFuture 这个异步编程框架，实现了一个流计算应用。</p><p>我们可以回顾下，在 05 课时中，我们实现的流计算框架，其主要工作原理是，线程从队列中读取数据进行处理，然后输出到下游队列。而在今天的课时中，我们使用 CompletableFuture 实现的流计算过程，也是使用队列在整个处理过程中传递数据。</p><p>这两种实现的工作原理在本质是完全一致的，但很明显，使用 CompletableFuture 更加灵活方便。令人开心的是，CompletableFuture 类的方法还在不断增强中。</p><p>所以在以后的开发中，当你遇到复杂的业务问题时，不妨从&quot;流&quot;的角度分析问题。这样你会发现自己的考虑重点，将更多地放在业务本身上。即使再复杂的业务流程，也只需要多分解几个步骤就可以了。</p><p>这时候你设计出的程序结构，将会变得更加直观清晰，性能提升也会变得更加容易。</p><p>所以，关于 CompletableFuture 类你还有什么疑问或想法呢？可以在课程的留言区将你的问题或想法写下来，我在看到后会进行分析和讲解，或者在后续的课程中进一步补充说明。</p><blockquote><p>本课时精华：</p></blockquote>`,25),u=s("p",null,[s("a",{href:"https://github.com/alain898/realtime_stream_computing_course",target:"_blank",rel:"noreferrer"},"点击此链接查看本课程所有课时的源码")],-1),i=s("hr",null,null,-1),F=s("p",null,"[",-1),C=s("p",null,[a("]("),s("a",{href:"https://kaiwu.lagou.com/data_enhancement.html?utm_source=lagouedu&utm_medium=zhuanlan&utm_campaign=%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E9%AB%98%E8%96%AA%E8%AE%AD%E7%BB%83%E8%90%A5#/index",target:"_blank",rel:"noreferrer"},"https://kaiwu.lagou.com/data_enhancement.html?utm_source=lagouedu&utm_medium=zhuanlan&utm_campaign=大数据开发高薪训练营#/index"),a(")"),s("br"),s("a",{href:"https://kaiwu.lagou.com/data_enhancement.html?utm_source=lagouedu&utm_medium=zhuanlan&utm_campaign=%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BC%80%E5%8F%91%E9%AB%98%E8%96%AA%E8%AE%AD%E7%BB%83%E8%90%A5#/index",target:"_blank",rel:"noreferrer"},"PB 级企业大数据项目实战 + 拉勾硬核内推，5 个月全面掌握大数据核心技能。点击链接，全面赋能！")],-1);function d(A,m,g,b,h,v){const l=e("Image");return t(),c("div",null,[E,p(l,{alt:"image.png",src:"https://s0.lgstatic.com/i/image6/M00/03/AF/CioPOWAfiwmAHcIUAAG_KuwEUzE583.png"}),a(),y,p(l,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image6/M00/03/AC/Cgp9HWAfhe6AfThAAAovbNRgJ50808.png"}),a(),u,i,F,p(l,{alt:"image (3).png",src:"https://s0.lgstatic.com/i/image2/M01/0C/98/CgpVE2AZCKKAa8TbAAUCrlmIuEw611.png"}),a(),C])}const x=o(r,[["render",d]]);export{f as __pageData,x as default};
