import{_ as o,j as t,o as e,g as c,k as n,h as a,Q as l,s}from"./chunks/framework.b3d8e22e.js";const H=JSON.parse('{"title":"分布式事务的解决方案 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/SpringCloud Alibaba 实战_文档/(6761) 16  分布式事务：Alibaba Seata 如何实现分布式事务.md","filePath":"posts/backEnd/SpringCloud Alibaba 实战_文档/(6761) 16  分布式事务：Alibaba Seata 如何实现分布式事务.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/SpringCloud Alibaba 实战_文档/(6761) 16  分布式事务：Alibaba Seata 如何实现分布式事务.md"},i=l("",6),E=l("",5),y=s("p",null,"2PC 阶段一：事务预处理阶段",-1),d=s("p",null,[a('可以看到，相比单点事务，分布式事务中增加了一个新的角色：事务协调者（Coordinator），它的职责就是协调各个分支事务的开启与提交、回滚的处理。以上图为例，当商城应用订单创建后，首先事务协调者会向各服务下达"处理本地事务"的通知，所谓本地事务就是每个服务应该做的事情，如订单服务中负责创建新的订单记录；会员服务负责增加会员的积分；库存服务负责减少库存数量。在这个阶段，被操作的所有数据都处于未提交（uncommit）的状态，会被排它锁锁定。当本地事务都处理完成后，会通知事务协调者"本地事务处理完毕"。当事务协调者陆续收到订单、会员、库存服务的处理完毕通知后，便进入"'),s("strong",null,"阶段二：提交阶段"),a('"。')],-1),_=s("p",null,"2PC 阶段二：提交阶段",-1),g=s("p",null,'在提交阶段，事务协调者会向每一个服务下达提交命令，每个服务收到提交命令后在本地事务中对阶段一未提交的数据执行 Commit 提交以完成数据最终的写入，之后服务便向事务协调者上报"提交成功"的通知。当事务协调者收到所有服务"提交成功"的通知后，就意味着一次分布式事务处理已完成。',-1),A=s("p",null,'这便是二阶段提交的正常执行过程，但假设在阶段一有任何一个服务因某种原因向事务协调者上报"事务处理失败"，就意味着整体业务处理出现问题，阶段二的操作就自动改为回滚（Rollback）处理，将所有未提交的数据撤销，使数据还原以保证完整性。',-1),h=s("p",null,"对于二阶段提交来说，它有一个致命问题，当阶段二某个服务因为网络原因无法收到协调者下达的提交命令，则未提交的数据就会被长时间阻塞，可能导致系统崩溃。",-1),C=s("p",null,"二阶段提交的缺陷",-1),u=s("p",null,'以上图为例，假如在提交阶段，库存服务实例与事务协调者之间断网。提交指令无法下达，这会导致库存中的"飞科剃须刀"商品库存记录会长期处于未提交的状态，因为这条记录被数据库排他锁长期独占，之后再有其他线程要访问"飞科剃须刀"库存数据，该线程就会长期处于阻塞状态，随着阻塞线程的不断增加，库存服务会面临崩溃的风险。',-1),S=s("p",null,'那这个问题要怎么解决呢？其实只要在服务这一侧增加超时机制，过一段时间被锁定的"飞科剃须刀"数据因超时自动执行提交操作，释放锁定资源。尽管这样做会导致数据不一致，但也比线程积压导致服务崩溃要好，出于此目的，三阶段提交（3PC）便应运而生。',-1),T=s("h4",{id:"三阶段提交",tabindex:"-1"},[a("三阶段提交 "),s("a",{class:"header-anchor",href:"#三阶段提交","aria-label":'Permalink to "三阶段提交"'},"​")],-1),b=s("p",null,[a('三阶段提交实质是将二阶段中的提交阶段拆分为"'),s("strong",null,"预提交阶段"),a(' "与"'),s("strong",null,"提交阶段"),a('"，同时在服务端都引入超时机制，保证数据库资源不会被长时间锁定。下面是三阶段提交的示意流程：')],-1),F=s("p",null,"3PC 阶段一：事务预处理阶段",-1),D=s("ul",null,[s("li",null,[s("strong",null,"阶段一：事务预处理阶段。")])],-1),m=s("p",null,"3PC 的事务预处理阶段与 2PC 是一样的，用于处理本地事务，锁定数据库资源，当所有服务返回成功后，进入阶段二。",-1),P=l("",9),q=s("p",null,"Seata 提供了多种分布式事务的解决方案，包含 AT 模式、TCC 模式、SAGA 模式以及 XA 模式。其中 AT 模式提供了最简单易用且无侵入的事务处理机制，通过自动生成反向 SQL 实现事务回滚。从 AT 模式入手使用，使我们理解分布式事务处理机制是非常好的学习办法。",-1),v=s("p",null,"Seata 的特色功能",-1),k=s("p",null,"AT 模式是 Seata 独创的模式，它是基于 2PC 的方案，核心理念是利用数据库 JDBC 加上 Oracle、MySQL 自带的事务方式来对我们分布式事务进行管理。说起来有点晦涩，下边我就结合这张 AT 模式方案图给大家介绍，在 Seata 中关于分布式事务到底需要哪些组件，以及他们都起到了什么样的职能。",-1),M=l("",5),R=l("",7),O=l("",23);function Q(B,L,W,N,f,V){const p=t("Image");return e(),c("div",null,[i,n(p,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image6/M00/31/3A/CioPOWBsQPKAN4wTAAEBb9VqWsQ374.png"}),a(),E,n(p,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image6/M00/31/3A/CioPOWBsQQCARCHWAAFYFUA6lfU789.png"}),a(),y,d,n(p,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image6/M01/31/32/Cgp9HWBsQQ-AO4-SAAEqPzPTZ7w364.png"}),a(),_,g,A,h,n(p,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image6/M00/31/3A/CioPOWBsQUSADeWqAAEyyNR7o8E788.png"}),a(),C,u,S,T,b,n(p,{alt:"图片5.png",src:"https://s0.lgstatic.com/i/image6/M01/31/32/Cgp9HWBsQVCAZH3SAAFYFUA6lfU014.png"}),a(),F,D,m,n(p,{alt:"图片6.png",src:"https://s0.lgstatic.com/i/image6/M00/31/3A/CioPOWBsQWqABC-IAAEeBWGqOLQ853.png"}),a(),P,n(p,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image6/M00/2C/C1/CioPOWBlidqAOQe-AASTbag_bO0476.png"}),q,n(p,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image6/M01/2C/C1/CioPOWBlieOAReN5AADg3SbfFhE124.png"}),a(),v,k,n(p,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image6/M01/2C/C1/CioPOWBlieyAWtXpAAF71Z7iu4s460.png"}),a(),M,n(p,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image6/M01/31/32/Cgp9HWBsQXmAElvTAAEBb9VqWsQ307.png"}),a(),R,n(p,{alt:"图片7.png",src:"https://s0.lgstatic.com/i/image6/M01/31/32/Cgp9HWBsQYmAcXTtAAFjr2n0qsc325.png"}),a(),O])}const U=o(r,[["render",Q]]);export{H as __pageData,U as default};
