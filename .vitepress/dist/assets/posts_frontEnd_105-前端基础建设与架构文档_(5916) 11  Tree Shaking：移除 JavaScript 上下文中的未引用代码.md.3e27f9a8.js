import{_ as o,j as e,o as t,g as c,k as a,h as n,Q as p,s as l}from"./chunks/framework.4e7d56ce.js";const v=JSON.parse('{"title":"Tree Shaking 必备理论 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/105-前端基础建设与架构文档/(5916) 11  Tree Shaking：移除 JavaScript 上下文中的未引用代码.md","filePath":"posts/frontEnd/105-前端基础建设与架构文档/(5916) 11  Tree Shaking：移除 JavaScript 上下文中的未引用代码.md","lastUpdated":1696417798000}'),r={name:"posts/frontEnd/105-前端基础建设与架构文档/(5916) 11  Tree Shaking：移除 JavaScript 上下文中的未引用代码.md"},E=p(`<p>时至今日，Tree Shaking 对于前端工程师来说，已经不是一个陌生的名词了。顾名思义：Tree Shaking 译为&quot;摇树&quot;，它通常用于描述移除 JavaScript 上下文中的未引用代码（dead-code）。</p><p>据我观察，Tree Shaking 也经常出现在诸多候选人的简历当中。然而可惜的是，大部分候选人都知道 Tree Shaking 的定义，但&quot;知其然不知其所以然&quot;，并没有在工程中真正实践过 Tree Shaking 技术，更没有深入理解 Tree Shaking 这个概念。社区上一些好的文章，比如<a href="https://github.com/wuomzfx/tree-shaking-test" target="_blank" rel="noreferrer">《你的 Tree-Shaking 并没什么卵用》</a>发布于 2018 年初，但就目前来看，其中内容也有些&quot;过期&quot;了。</p><p>这一节，就让我们真正深入学习 Tree Shaking 这个概念。</p><h3 id="tree-shaking-必备理论" tabindex="-1">Tree Shaking 必备理论 <a class="header-anchor" href="#tree-shaking-必备理论" aria-label="Permalink to &quot;Tree Shaking 必备理论&quot;">​</a></h3><p>Tree Shaking 概念很好理解，这个词最先在 Rollup 社区流行，后续蔓延到整个前端生态。Tree Shaking 背后的理论知识独成体系，我们先从其原理入手，试着分析并回答以下问题。</p><h4 id="问题一-tree-shaking-为什么要依赖-esm-规范" tabindex="-1">问题一：Tree Shaking 为什么要依赖 ESM 规范？ <a class="header-anchor" href="#问题一-tree-shaking-为什么要依赖-esm-规范" aria-label="Permalink to &quot;问题一：Tree Shaking 为什么要依赖 ESM 规范？&quot;">​</a></h4><p>事实上，Tree Shaking 是在编译时进行无用代码消除的，因此它<strong>需要在编译时确定依赖关系</strong>，进而确定哪些代码可以被&quot;摇掉&quot;，而 ESM 具备以下特点：</p><ul><li><p>import 模块名只能是字符串常量</p></li><li><p>import 一般只能在模块的最顶层出现</p></li><li><p>import binding 是 immutable 的</p></li></ul><p>这些特点使得 ESM 具有静态分析能力。而<strong>CommonJS 定义的模块化规范，只有在执行代码后，才能动态确定依赖模块</strong>，因此不具备 Tree Shaking 的先天条件。</p><p>在传统编译型语言中，一般由编译器将无用代码在 AST（抽象语法树）中删除，而前端 JavaScript 并没有正统&quot;编译器&quot;这个概念，那么 Tree Shaking 就需要在工程链中由工程化工具完成。</p><h4 id="问题二-什么是副作用模块-如何对副作用模块进行-tree-shaking" tabindex="-1">问题二：什么是副作用模块，如何对副作用模块进行 Tree Shaking? <a class="header-anchor" href="#问题二-什么是副作用模块-如何对副作用模块进行-tree-shaking" aria-label="Permalink to &quot;问题二：什么是副作用模块，如何对副作用模块进行 Tree Shaking?&quot;">​</a></h4><p>如果你熟悉函数式开发理念，可能听说过&quot;副作用函数&quot;，但什么是&quot;副作用模块&quot;呢？它又和 Tree Shaking 有什么关联呢？很多人清楚的 Tree Shaking 只是皮毛，而并不清楚 Tree Shaking 并不能&quot;摇掉&quot;副作用模块，具体我们看这样一段代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">export function </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(a, b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> memoizedAdd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> window.</span><span style="color:#B392F0;">memoize</span><span style="color:#E1E4E8;">(add)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">export function </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(a, b) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> memoizedAdd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> window.</span><span style="color:#6F42C1;">memoize</span><span style="color:#24292E;">(add)</span></span></code></pre></div><p>当该模块被 import 时，<code>window.memoize</code>方法会被执行，那么对于工程化工具（比如 Webpack）来说，分析思路是这样的：</p><ul><li><p>创建一个纯函数<code>add</code>，如果没有其他模块引用<code>add</code>函数，那么<code>add</code>函数可以被 Tree Shaking 掉；</p></li><li><p>接着调用<code>window.memoize</code>方法，并传入<code>add</code>函数作为其参数；</p></li><li><p>工程化工具（比如 Webpack）并不知道<code>window.memoize</code>方法会做什么事情，也许<code>window.memoize</code>方法会调用<code>add</code>函数，并触发某些副作用（比如维护一个全局的 Cache Map）；</p></li><li><p>工程化工具（比如 Webpack）为了安全起见，即便没有其他模块依赖的<code>add</code>函数，那么也要将<code>add</code>函数打包到最后的 bundle 中。</p></li></ul><p>因此，具有副作用的模块难以被 Tree Shaking 优化，即便开发者知道<code>window.memoize</code>方法是无副作用的。</p><p>为了解决&quot;具有副作用的模块难以被 Tree Shaking 优化&quot;这个问题，Webpack 给出了自己的方案，我们可以利用 package.json 的<code>sideEffects</code>属性来告诉工程化工具哪些模块具有副作用，哪些剩余模块没有副作用，可以被 Tree Shaking 优化：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;your-project&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;sideEffects&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;your-project&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;sideEffects&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>表示全部代码均无副作用，告知 webpack，它可以安全地删除未用到的 export 导出。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;your-project&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;sideEffects&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;./src/some-side-effectful-file.js&quot;</span><span style="color:#E1E4E8;">，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;*.css&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  ]</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;your-project&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;sideEffects&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;./src/some-side-effectful-file.js&quot;</span><span style="color:#24292E;">，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;*.css&quot;</span></span>
<span class="line"><span style="color:#24292E;">  ]</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过数组表示，<code>./src/some-side-effectful-file.js</code>和所有<code>.css</code>文件模块都有副作用。对于 Webpack 工具，<strong>开发者可以在</strong> <a href="https://github.com/webpack/webpack/issues/6065#issuecomment-351060570" target="_blank" rel="noreferrer">module.rule</a><strong>配置中声明副作用模块</strong>。</p><p>事实上，仅对上面<code>add</code>函数，即便不通过声明 sideEffects，Webpack 也足够智能，能够分析出可 Tree Shaking 掉的部分，不过这需要我们对上述代码进行重构：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { memoize } from &#39;./util&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">export function add(a, b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#FDAEB7;font-style:italic;">return</span><span style="color:#E1E4E8;"> a + b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#FDAEB7;font-style:italic;">const</span><span style="color:#E1E4E8;"> memoizedAdd = memoize(add)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { memoize } from &#39;./util&#39;</span></span>
<span class="line"><span style="color:#24292E;">export function add(a, b) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#B31D28;font-style:italic;">return</span><span style="color:#24292E;"> a + b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#B31D28;font-style:italic;">const</span><span style="color:#24292E;"> memoizedAdd = memoize(add)</span></span></code></pre></div><p>此时 Webpack 的分析逻辑：</p><ul><li><p><code>memoize</code>函数是一个 ESM 模块，我们去<code>util.js</code>中检查一下<code>memoize</code>函数内容；</p></li><li><p>在<code>util.js</code>中，发现<code>memoize</code>函数是一个纯函数，因此如果<code>add</code>函数没有被其他模块依赖，可以被安全 Tree Shaking 掉。</p></li></ul><p>所以，我们能得出一个 Tree Shaking 友好的最佳实践------在业务项目中，设置最小化副作用范围，同时通过合理的配置，给工程化工具最多的副作用信息。</p><p>下面，我们再来看一个 Tree Shaking 友好的实践案例。</p><h4 id="一个-tree-shaking-友好的导出模式" tabindex="-1">一个 Tree Shaking 友好的导出模式 <a class="header-anchor" href="#一个-tree-shaking-友好的导出模式" aria-label="Permalink to &quot;一个 Tree Shaking 友好的导出模式&quot;">​</a></h4><p>参考以下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(a, b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">subtract</span><span style="color:#E1E4E8;">(a, b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(a, b) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">subtract</span><span style="color:#24292E;">(a, b) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>以及：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">num</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.num </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> num</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">otherNum</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.num </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> otherNum</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">subtract</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">otherNum</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.num </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> otherNum</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Number</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">num</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.num </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> num</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(</span><span style="color:#E36209;">otherNum</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.num </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> otherNum</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">subtract</span><span style="color:#24292E;">(</span><span style="color:#E36209;">otherNum</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.num </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> otherNum</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>对于上述情况，以 Webpack 为例，<strong>Webpack 将会趋向保留整个默认导出对象/class</strong>（Webpack 和 Rollup 只处理函数和顶层的 import/export 变量，不能把没用到的类或对象内部的方法消除掉）。</p><p>因此：</p><ul><li><p>导出一个包含多项属性和方法的对象</p></li><li><p>导出一个包含多项属性和方法的 class</p></li><li><p>使用<code>export default</code>导出</p></li></ul><p>都不利于 Tree Shaking。即便现代化工程工具或 Webpack 支持对于对象或 class 的方法属性剪裁（比如 webpack-deep-scope-plugin 这个插件的设计，或 Webpack 和 Rollup 新版本的跟进），这些都产生了不必要的成本，增加了编译时负担。</p><p>我们更加推荐的原则是：<strong>原子化和颗粒化导出</strong>。如下代码，就是一个更好的实践：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">export function </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(a, b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">export function </span><span style="color:#B392F0;">subtract</span><span style="color:#E1E4E8;">(a, b) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> b</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">export function </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(a, b) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">export function </span><span style="color:#6F42C1;">subtract</span><span style="color:#24292E;">(a, b) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> b</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这种方式可以让 Webpack 更好地在编译时掌控和分析 Tree Shaking 信息，取得一个更优的 bundle size。</p><h3 id="前端工程生态和-tree-shaking-实践" tabindex="-1">前端工程生态和 Tree Shaking 实践 <a class="header-anchor" href="#前端工程生态和-tree-shaking-实践" aria-label="Permalink to &quot;前端工程生态和 Tree Shaking 实践&quot;">​</a></h3><p>通过上述内容，我们可以看出 Tree Shaking 依托于 ESM 静态分析的理论技术，而真正的 Tree Shaking 过程，还需要依靠前端工程工具实现。Tree Shaking 链路当然也就和前端工程生态绑定在一起，我们继续从工程生态层面，分析 Tree Shaking 实践。</p><h4 id="babel-和-tree-shaking" tabindex="-1">Babel 和 Tree Shaking <a class="header-anchor" href="#babel-和-tree-shaking" aria-label="Permalink to &quot;Babel 和 Tree Shaking&quot;">​</a></h4><p>Babel 已经成为现代化工程和基建方案的必备工具，但是考虑到 Tree Shaking，需要开发者注意：<strong>如果使用 Babel 对代码进行编译，Babel 默认会将 ESM 编译为 CommonJS 模块规范</strong>。而我们从前面理论知识知道，Tree Shaking 必须依托于 ESM。</p><p>为此，我们需要配置 Babel 对于模块化的编译降级，具体配置项在 <a href="https://babeljs.io/docs/en/babel-preset-env#modules" target="_blank" rel="noreferrer">babel-preset-env#modules</a> 中可以找到。</p><p>但既然是&quot;前端工程生态&quot;，那问题就没这么好解决。事实上，如果我们不使用 Babel 将代码编译为 CommonJS 规范的代码，某些工程链上的工具可能就要罢工了。比如 Jest，Jest 是基于 Node.js 开发的，运行在 Node.js 环境。因此使用 Jest 进行测试时，也就需要模块符合 CommonJS 规范，那么如何处理这种&quot;模块死锁&quot;呢？</p><p>思路之一是<strong>根据不同的环境，采用不同的 Babel 配置</strong>。在 production 编译环境中，我们配置：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">production</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   presets</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#9ECBFF;">&#39;@babel/preset-env&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">     {</span></span>
<span class="line"><span style="color:#E1E4E8;">      modules</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span></span>
<span class="line"><span style="color:#E1E4E8;">     }</span></span>
<span class="line"><span style="color:#E1E4E8;">    ]</span></span>
<span class="line"><span style="color:#E1E4E8;">   ]</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">production</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   presets</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">    [</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#032F62;">&#39;@babel/preset-env&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">     {</span></span>
<span class="line"><span style="color:#24292E;">      modules</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span></span>
<span class="line"><span style="color:#24292E;">     }</span></span>
<span class="line"><span style="color:#24292E;">    ]</span></span>
<span class="line"><span style="color:#24292E;">   ]</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在测试环境中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">test</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">   presets</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">    [</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#9ECBFF;">&#39;@babel/preset-env&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">     {</span></span>
<span class="line"><span style="color:#E1E4E8;">      modules</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;commonjs</span></span>
<span class="line"><span style="color:#9ECBFF;">     }</span></span>
<span class="line"><span style="color:#9ECBFF;">    ]</span></span>
<span class="line"><span style="color:#9ECBFF;">   ]</span></span>
<span class="line"><span style="color:#9ECBFF;">  },</span></span>
<span class="line"><span style="color:#9ECBFF;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">test</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">   presets</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">    [</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#032F62;">&#39;@babel/preset-env&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">     {</span></span>
<span class="line"><span style="color:#24292E;">      modules</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;commonjs</span></span>
<span class="line"><span style="color:#032F62;">     }</span></span>
<span class="line"><span style="color:#032F62;">    ]</span></span>
<span class="line"><span style="color:#032F62;">   ]</span></span>
<span class="line"><span style="color:#032F62;">  },</span></span>
<span class="line"><span style="color:#032F62;">}</span></span></code></pre></div><p>但是在测试环境中，编译了业务代码为 CommonJS 规范并没有大功告成，我们还需要处理第三方模块代码。一些第三方模块代码为了方便进行 Tree Shaking，暴露出符合 ESM 模块的代码，对于这些模块，比如 Library1、Library2，我们还需要进行处理，这时候需要配置 Jest：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> path </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;path&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> librariesToRecompile </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Library1&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Library2&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;|&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> config </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> transformIgnorePatterns</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">  \`[\\\\</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">]node_modules[\\\\</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">](</span><span style="color:#F97583;">?!</span><span style="color:#E1E4E8;">(\${librariesToRecompile})).</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">$\`</span></span>
<span class="line"><span style="color:#E1E4E8;"> ],</span></span>
<span class="line"><span style="color:#E1E4E8;"> transform</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&#39;^.+</span><span style="color:#79B8FF;">\\.</span><span style="color:#9ECBFF;">jsx?$&#39;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> path.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">(__dirname, </span><span style="color:#9ECBFF;">&#39;transformer.js&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> path </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;path&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> librariesToRecompile </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;Library1&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;Library2&#39;</span></span>
<span class="line"><span style="color:#24292E;">].</span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;|&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> config </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> transformIgnorePatterns</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">  \`[\\\\</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">]node_modules[\\\\</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">](</span><span style="color:#D73A49;">?!</span><span style="color:#24292E;">(\${librariesToRecompile})).</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">$\`</span></span>
<span class="line"><span style="color:#24292E;"> ],</span></span>
<span class="line"><span style="color:#24292E;"> transform</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&#39;^.+</span><span style="color:#005CC5;">\\.</span><span style="color:#032F62;">jsx?$&#39;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> path.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(__dirname, </span><span style="color:#032F62;">&#39;transformer.js&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>transformIgnorePatterns</code>是 Jest 的一个配置项，默认值为<code>node_modules</code>，它表示：<code>node_modules</code>中的第三方模块代码，都不需要经过<code>babel-jest</code>编译。因此，<strong>我们自定义 <code>transformIgnorePatterns</code>的值为一个包含了 Library1、Library2 的正则表达式即可</strong>。</p><h4 id="webpack-和-tree-shaking" tabindex="-1">Webpack 和 Tree Shaking <a class="header-anchor" href="#webpack-和-tree-shaking" aria-label="Permalink to &quot;Webpack 和 Tree Shaking&quot;">​</a></h4><p>上面我们已经讲解了很多关于 Webpack 处理 Tree Shaking 的内容了，这里我们进一步补充。事实上，<strong>Webpack4.0 以上版本在 mode 为 production 时，会自动开启 Tree Shaking 能力</strong>。默认 production mode 的配置如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> config </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;"> mode</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;production&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;"> optimization</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  usedExports</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  minimizer</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">TerserPlugin</span><span style="color:#E1E4E8;">({...}) </span><span style="color:#6A737D;">// 支持删除死代码的压缩器</span></span>
<span class="line"><span style="color:#E1E4E8;">  ]</span></span>
<span class="line"><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> config </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;"> mode</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;production&#39;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;"> optimization</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  usedExports</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  minimizer</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">TerserPlugin</span><span style="color:#24292E;">({...}) </span><span style="color:#6A737D;">// 支持删除死代码的压缩器</span></span>
<span class="line"><span style="color:#24292E;">  ]</span></span>
<span class="line"><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其实，Webpack 真正执行模块去除，是依赖了 TerserPlugin、UglifyJS 等压缩插件。<strong>Webpack 负责对模块进行分析和标记，而这些压缩插件负责根据标记结果，进行代码删除</strong>。Webpack 在分析时，有三类相关的标记：</p><ul><li><p>harmony export，被使用过的 export 会被标记为 harmony export；</p></li><li><p>unused harmony export，没被使用过的 export 标记为 unused harmony export；</p></li><li><p>harmony import，所有 import 标记为 harmony import。</p></li></ul><p>上述标记实现的 Webpack 源码在<code>lib/dependencies/</code>文件中，这里不再进行源码解读了。具体过程主要是：</p><ul><li><p>Webpack 在编译分析阶段，将每一个模块放入 ModuleGraph 中维护；</p></li><li><p>依靠 HarmonyExportSpecifierDependency 和 HarmonyImportSpecifierDependency 分别识别和处理 import 以及 export；</p></li><li><p>依靠 HarmonyExportSpecifierDependency 识别 used export 和 unused export。</p></li></ul><p>至此，我们理解了使用 Webpack 进行 Tree Shaking 的原理。接下来，我们再看看著名的公共库都是如何处理 Tree Shaking 的。</p><h4 id="vue-和-tree-shaking" tabindex="-1">Vue 和 Tree Shaking <a class="header-anchor" href="#vue-和-tree-shaking" aria-label="Permalink to &quot;Vue 和 Tree Shaking&quot;">​</a></h4><p>在 Vue 2.0 版本中，Vue 对象会存在一些全局 API，比如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> Vue from &#39;vue&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">Vue.nextTick(() =&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> Vue from &#39;vue&#39;</span></span>
<span class="line"><span style="color:#24292E;">Vue.nextTick(() =&gt; {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre></div><p>如果我们没有使用<code>Vue.nextTick</code>方法，那么<code>nextTick</code>这样的全局 API 就成了 dead code，且不容易被 Tree Shaking 掉。为此，在 Vue 3 中，Vue 团队考虑了 Tree Shaking 兼容，进行了重构，<strong>全局 API 需要通过原生 ES Module 的引用方式进行具名引用</strong>，对应前面的代码，需要：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { nextTick } from &#39;vue&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">nextTick(() =&gt; {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { nextTick } from &#39;vue&#39;</span></span>
<span class="line"><span style="color:#24292E;">nextTick(() =&gt; {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre></div><p>除了这些全局 API ，Vue 3.0 也实现了很多内置的组件以及工具的具名导出。这些都是前端生态中，公共库拥抱 Tree Shaking 的表现。</p><p>此外，我们也可以灵活使用 build-time flags 来帮助构建工具实现 Tree Shaking。以 Webpack<a href="https://webpack.js.org/plugins/define-plugin/" target="_blank" rel="noreferrer">DefinePlugin</a>为例，下面代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { validateoptions } from &#39;./validation&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">function init(options) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#FDAEB7;font-style:italic;">if</span><span style="color:#E1E4E8;"> (!__PRODUCTION__) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		validateoptions(options)</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> { validateoptions } from &#39;./validation&#39;</span></span>
<span class="line"><span style="color:#24292E;">function init(options) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#B31D28;font-style:italic;">if</span><span style="color:#24292E;"> (!__PRODUCTION__) {</span></span>
<span class="line"><span style="color:#24292E;">		validateoptions(options)</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过<code>__PRODUCTION__</code>变量，在 production 环境下，我们可以将<code>validateoptions</code>函数进行删除。</p><h4 id="如何设计一个兼顾-tree-shaking-和易用性的公共库" tabindex="-1">如何设计一个兼顾 Tree Shaking 和易用性的公共库 <a class="header-anchor" href="#如何设计一个兼顾-tree-shaking-和易用性的公共库" aria-label="Permalink to &quot;如何设计一个兼顾 Tree Shaking 和易用性的公共库&quot;">​</a></h4><p>上面我们分析了 Vue 拥抱 Tree Shaking 的例子，下面我们应该从另一个更宏观的角度看待这个问题。作为一个公共库的设计者，我们应该如何兼顾 Tree Shaking 和易用性的公共库呢？</p><p>试想，如果我们以 ESM 的方式对外暴露代码，那么就很难直接兼容 CommonJS 规范，也就是说<strong>在 Node.js 环境中，使用者如果直接以 require 方式引用的话，就会得到报错</strong> 。<strong>如果以 CommonJS 规范对外暴露代码，又不利于 Tree Shaking</strong>。</p><p>因此，如果想要一个 npm 包既能向外提供 ESM 规范的代码，又能向外提供 CommonJS 规范的代码，我们就只能通过&quot;协约&quot;来定义清楚。实际上，npm<code>package.json</code>以及社区工程化规范，解决了这个问题：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;Library&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;main&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;dist/index.cjs.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;module&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;dist/index.esm.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;Library&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;main&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;dist/index.cjs.js&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;module&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;dist/index.esm.js&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其实，标准 package.json 语法中，只有一个入口<code>main</code>。作为公共库设计者，我们通过<code>main</code>来暴露 CommonJS 规范打包的代码<code>dist/index.cjs.js</code>；在 Webpack 等构建工具中，又支持了<code>module</code>------这个新的入口字段。因此，<code>module</code>并非 package.json 的标准字段，而是打包工具专用的字段，用来指定符合 ESM 标准的入口文件。</p><p>这样一来，当<code>require(&#39;Library&#39;)</code>时，Webpack 会找到：<code>dist/index.cjs.js</code>；当<code>import Library from &#39;Library&#39;</code>时，Webpack 会找到：<code>dist/index.esm.js</code>。</p><p>这里我们不妨举一个著名的公共库例子，那就是 Lodash。Lodash 其实并不支持 Tree Shaking，其<code>package.json</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;lodash&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;version&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;5.0.0&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;license&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MIT&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;private&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;main&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;lodash.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;engines&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;node&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&gt;=4.0.0&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;lodash&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;version&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;5.0.0&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;license&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MIT&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;private&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;main&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;lodash.js&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;engines&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;node&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&gt;=4.0.0&quot;</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>只有一个<code>main</code>入口，且<code>lodash.js</code>是 UMD 形式的代码，不利于做到 Tree Shaking。为了支持 Tree shakibng，lodash 打包出来专门的 <a href="https://www.npmjs.com/package/lodash-es" target="_blank" rel="noreferrer">lodash-es</a>，其<code>package.json</code>：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;main&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;lodash.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;module&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;lodash.js&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;name&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;lodash-es&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;sideEffects&quot;</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;main&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;lodash.js&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;module&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;lodash.js&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;name&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;lodash-es&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;sideEffects&quot;</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>由上述代码可知，lodash-es<code>main</code>、<code>module</code>、<code>sideEffects</code>三字段齐全，通过 ESM 导出，天然支持了 Tree Shaking。</p><p>总之，万变不离其宗，只要我们掌握了 Tree Shaking 的原理，那么在涉及公共库时，就能做到游刃有余，以各种形式支持到 Tree Shaking。当然，普遍做法是在第三方库打包构建时，参考 antd，一般都会构建出 lib/ 和 es/ 两个文件夹，并配置<code>package.json</code>的<code>main</code>、<code>module</code>字段即可。</p><h4 id="css-和-tree-shaking" tabindex="-1">CSS 和 Tree Shaking <a class="header-anchor" href="#css-和-tree-shaking" aria-label="Permalink to &quot;CSS 和 Tree Shaking&quot;">​</a></h4><p>以上内容都是针对 JavaScript 代码的 Tree Shaking，作为前端工程师，我们当然也要考虑对 CSS 文件做 Tree Shaking。</p><p>实现思路也很简单，<strong>CSS 的 Tree Shaking 要在样式表中，找出没有被应用到选择器样式，进行删除</strong>。那么我们只需要：</p><ul><li><p>遍历所有 CSS 文件的选择器；</p></li><li><p>根据所有 CSS 文件的选择器，在 JavaScript 代码中进行选择器匹配；</p></li><li><p>如果没有匹配到，则删除对应选择器的样式代码。</p></li></ul><p>如何遍历所有 CSS 文件的选择器呢？Babel 依靠 AST 技术，完成了对 JavaScript 代码的遍历分析，而在样式世界中，PostCSS 就起到了 Babel 的作用。PostCSS 提供了一个解析器，它能够将 CSS 解析成 AST 抽象语法树，<strong>我们可以通过 PostCSS 插件对 CSS 对应的 AST 进行操作，达到 Tree Shaking 的目的</strong>。</p><p>PostCSS 原理如下图：</p>`,88),y=p(`<p>PostCSS 原理图</p><p>这里给大家推荐 <a href="https://github.com/FullHuman/purgecss/tree/master/packages/purgecss-webpack-plugin" target="_blank" rel="noreferrer">purgecss-webpack-plugin</a>，其原理也很简单：</p><ul><li>监听 Webpack compilation 完成阶段，从 compilation 中找到所有的 CSS 文件（对应源码）：</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PurgeCSSPlugin</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  options</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> UserDefinedOptions;</span></span>
<span class="line"><span style="color:#E1E4E8;">  purgedStats</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> PurgedStats </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {};</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">options</span><span style="color:#E1E4E8;">: </span><span style="color:#FFAB70;">UserDefinedOptions</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.options </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> options;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">compiler</span><span style="color:#E1E4E8;">: </span><span style="color:#FFAB70;">Compiler</span><span style="color:#E1E4E8;">): void {</span></span>
<span class="line"><span style="color:#E1E4E8;">    compiler.hooks.compilation.</span><span style="color:#B392F0;">tap</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">      pluginName,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.initializePlugin.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    );</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PurgeCSSPlugin</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  options</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> UserDefinedOptions;</span></span>
<span class="line"><span style="color:#24292E;">  purgedStats</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> PurgedStats </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {};</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">options</span><span style="color:#24292E;">: </span><span style="color:#E36209;">UserDefinedOptions</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.options </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> options;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#E36209;">compiler</span><span style="color:#24292E;">: </span><span style="color:#E36209;">Compiler</span><span style="color:#24292E;">): void {</span></span>
<span class="line"><span style="color:#24292E;">    compiler.hooks.compilation.</span><span style="color:#6F42C1;">tap</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">      pluginName,</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.initializePlugin.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    );</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//...</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>将所有的 CSS 文件交给 PostCss 处理（<a href="https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L274" target="_blank" rel="noreferrer">源码</a>关键部分，对 CSS AST 应用规则）：</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">walkThroughCSS</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    root</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> postcss.Root,</span></span>
<span class="line"><span style="color:#E1E4E8;">    selectors</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> ExtractorResultSets</span></span>
<span class="line"><span style="color:#E1E4E8;">  )</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    root.</span><span style="color:#B392F0;">walk</span><span style="color:#E1E4E8;">((node) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;rule&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">evaluateRule</span><span style="color:#E1E4E8;">(node, selectors);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;atrule&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">evaluateAtRule</span><span style="color:#E1E4E8;">(node);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.type </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;comment&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isIgnoreAnnotation</span><span style="color:#E1E4E8;">(node, </span><span style="color:#9ECBFF;">&quot;start&quot;</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.ignore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// remove ignore annotation</span></span>
<span class="line"><span style="color:#E1E4E8;">          node.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isIgnoreAnnotation</span><span style="color:#E1E4E8;">(node, </span><span style="color:#9ECBFF;">&quot;end&quot;</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.ignore </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// remove ignore annotation</span></span>
<span class="line"><span style="color:#E1E4E8;">          node.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">walkThroughCSS</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    root</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> postcss.Root,</span></span>
<span class="line"><span style="color:#24292E;">    selectors</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> ExtractorResultSets</span></span>
<span class="line"><span style="color:#24292E;">  )</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    root.</span><span style="color:#6F42C1;">walk</span><span style="color:#24292E;">((node) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;rule&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">evaluateRule</span><span style="color:#24292E;">(node, selectors);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;atrule&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">evaluateAtRule</span><span style="color:#24292E;">(node);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.type </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;comment&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isIgnoreAnnotation</span><span style="color:#24292E;">(node, </span><span style="color:#032F62;">&quot;start&quot;</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.ignore </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// remove ignore annotation</span></span>
<span class="line"><span style="color:#24292E;">          node.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isIgnoreAnnotation</span><span style="color:#24292E;">(node, </span><span style="color:#032F62;">&quot;end&quot;</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.ignore </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// remove ignore annotation</span></span>
<span class="line"><span style="color:#24292E;">          node.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span></code></pre></div><ul><li>利用 PostCss 插件能力，基于 AST 技术，找出无用代码并进行删除。</li></ul><p>核心删除未使用 CSS 代码的逻辑在<a href="https://github.com/FullHuman/purgecss/blob/84da7ca98872bae29317f88c4295b400a6c02d06/packages/purgecss/src/index.ts#L617" target="_blank" rel="noreferrer"><code>purge</code> 方法中</a>，这里我们不再展开。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本小节，我们分析了 Tree Shaking 相关知识，我们发现这一理论内容还需要配合构建工具完成落地，而这一系列过程不只是想象中那样简单。</p>`,10),i=l("p",null,"这里我想给你留一个思考题，Rollup 是如何实现 Tree Shaking 的呢？欢迎在留言区和我分享你的观点。",-1),d=l("p",null,'更多内容，我们会结合下一讲"如何理解 AST 实现和编译原理？"，带你实现一个真实的 AST 的落地场景，完成一个简易版 Tree Shaking 实现。我们下一讲再见！',-1);function u(h,g,F,m,k,b){const s=e("Image");return t(),c("div",null,[E,a(s,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image2/M01/05/E0/Cip5yGABPraACuJCAAGHB98AwXg855.png"}),n(),a(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABPsGAfsSVAAGgxx7GqrU331.png"}),n(),y,a(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/8D/F3/Ciqc1GABPt6AAFyMAAGLjLOlwJM945.png"}),i,d])}const C=o(r,[["render",u]]);export{v as __pageData,C as default};
