import{_ as p,j as o,o as e,g as t,k as a,h as l,Q as s}from"./chunks/framework.4e7d56ce.js";const q=JSON.parse('{"title":"18 单词接龙：如何巧用深搜与广搜的变形？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6707) 18  单词接龙：如何巧用深搜与广搜的变形？.md","filePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6707) 18  单词接龙：如何巧用深搜与广搜的变形？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/数据结构与算法面试宝典_文档/(6707) 18  单词接龙：如何巧用深搜与广搜的变形？.md"},c=s(`<h1 id="_18-单词接龙-如何巧用深搜与广搜的变形" tabindex="-1">18 单词接龙：如何巧用深搜与广搜的变形？ <a class="header-anchor" href="#_18-单词接龙-如何巧用深搜与广搜的变形" aria-label="Permalink to &quot;18 单词接龙：如何巧用深搜与广搜的变形？&quot;">​</a></h1><p>今天，我们继续尝试从不同的角度（方法）来求解一个题目，通过&quot;一题多解&quot;的训练，拓展我们的思维。&quot;<strong>搜索类型</strong>&quot;的题目一直是面试考察的重点，其变形非常广，不过万变不离其宗，大部分解题方法仍然逃不开 BFS/DFS 这两个框架。</p><p>所以在本讲，我们将以一道经典的搜索题目为引，串联和使用前面学习过的各种知识点，比如：</p><ul><li><p>BFS/双向 BFS</p></li><li><p>DFS</p></li><li><p>Dijkstra</p></li></ul><p>具体介绍这类题目的分析和处理技巧，让你的面试得心应手。让我们马上开始。</p><h3 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h3><p>字典 wordList 中单词 beginWord 和 endWord 的转换序列是一个按下述规则形成的序列：</p><ul><li><p>序列中第一个单词是 beginWord ；</p></li><li><p>序列中最后一个单词是 endWord，endWord 需要在 wordList 中；</p></li><li><p>每次转换只能改变一个字母；</p></li><li><p>转换过程中的中间单词必须是字典 wordList 中的单词。</p></li></ul><p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的最短转换序列中的单词数目 。如果不存在这样的转换序列，返回 0。</p><p>输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</p><p>输出：5</p><p>解释：一个最短转换序列是 &quot;hit&quot; → &quot;hot&quot; → &quot;dot&quot; → &quot;dog&quot; → &quot;cog&quot;，返回它的长度 5。</p><p>首先，这里需要重点说一下条件：</p><ul><li><p>beginWord != endWord；</p></li><li><p>beginWord 可以不在 wordList 中；</p></li><li><p>endWord 必须要在 wordList 中，如果不在 wordList 中，那么需要返回 0；</p></li><li><p>所有的单词长度都一样。</p></li></ul><h3 id="预处理" tabindex="-1">预处理 <a class="header-anchor" href="#预处理" aria-label="Permalink to &quot;预处理&quot;">​</a></h3><p>拿到题目，我们要做的第一件事，应该是去<strong>挖掘题目中的隐含条件</strong>。我们看到题目中有如下条件：</p><ul><li><p>每次转换只能改变一个字母；</p></li><li><p>转换过程中的中间单词必须是 wordList 里面的单词。</p></li></ul><p>如果将每一次的转换，看成是图中两个点的连接，题目的最终问题就是希望我们找到图中给定两个点的<strong>最短距离</strong>。</p><p>如果把单词看成图的点，那么对应图的边又是什么呢？</p><blockquote><p>注意：这里提到的图，都是指算法中的图 Graph，而不是图画 Picture。</p></blockquote><h4 id="边的由来" tabindex="-1">边的由来 <a class="header-anchor" href="#边的由来" aria-label="Permalink to &quot;边的由来&quot;">​</a></h4><p>当我们有 word = &quot;hit&quot;，如果改变其中一个字母，就可以生成 &quot;hat&quot;。但是，我们立马发现 wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;] 并不存在单词 &quot;hat&quot;。</p><p>如果从图的角度来看，可以认为 &lt;&quot;hit&quot;, &quot;hat&quot;&gt; 这条边不存在。那么接下来，我们再看一下成功的情况。</p><p>当我们有 word = &quot;hit&quot;，如果改变一个字母，生成 &quot;hot&quot;，由于 wordList[0] == &quot;hot&quot;，因此，这种转换 &quot;hit&quot; ←→ &quot;hot&quot; 是合法的，那么，可以认为边 &lt;&quot;hit&quot;, &quot;hot&quot;&gt; 是存在的。</p><h4 id="边的无向性" tabindex="-1">边的无向性 <a class="header-anchor" href="#边的无向性" aria-label="Permalink to &quot;边的无向性&quot;">​</a></h4><p>对于单词转换来说，当 word=&quot;hit&quot; 可以转换成 &quot;hot&quot; 的时候，那么反过来 &quot;hot&quot; 也可以转换为 &quot;hit&quot;。因此，当我们得到一条边的时候，这条边就是一条无向边。</p><p>接下来我们再分析一下这类题的考点。</p><h4 id="考点" tabindex="-1">考点 <a class="header-anchor" href="#考点" aria-label="Permalink to &quot;考点&quot;">​</a></h4><p>在&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a>&quot;中，我们学习的大部分关于&quot;<strong>图</strong>&quot;的题目，都是明确地知道图的边，或者题目中给出了图的边。</p><p>但是，在这个题中，并没有明确地给出图的边。所有的边都需要依赖一定的条件动态生成。我们可以利用伪代码，表示边的生成，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> word in Graph</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">    startPoint </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> word </span><span style="color:#6A737D;">// 图中边起始点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> c in word</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">        oldChar </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> c</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> toChar in </span><span style="color:#9ECBFF;">&#39;a&#39;</span><span style="color:#F97583;">~</span><span style="color:#9ECBFF;">&#39;z&#39;</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">             c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> toChar</span></span>
<span class="line"><span style="color:#E1E4E8;">             endPoint </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> word</span></span>
<span class="line"><span style="color:#E1E4E8;">             </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> endPoint in wordList</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">                 </span><span style="color:#6A737D;">// 于是得到一条无向边 &lt;startPoint, endPoint&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        c </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> oldChar</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> word in Graph</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">    startPoint </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> word </span><span style="color:#6A737D;">// 图中边起始点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> c in word</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">        oldChar </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> c</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> toChar in </span><span style="color:#032F62;">&#39;a&#39;</span><span style="color:#D73A49;">~</span><span style="color:#032F62;">&#39;z&#39;</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">             c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> toChar</span></span>
<span class="line"><span style="color:#24292E;">             endPoint </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> word</span></span>
<span class="line"><span style="color:#24292E;">             </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> endPoint in wordList</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">                 </span><span style="color:#6A737D;">// 于是得到一条无向边 &lt;startPoint, endPoint&gt;</span></span>
<span class="line"><span style="color:#24292E;">        c </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldChar</span></span></code></pre></div><p>有了图的重建，再给定输入，代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">beginWord </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;hit&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">endWord </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;cog&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">wordList </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#9ECBFF;">&quot;hot&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;dot&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;dog&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;lot&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;log&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#9ECBFF;">&quot;cog&quot;</span><span style="color:#E1E4E8;">]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">beginWord </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;hit&quot;</span></span>
<span class="line"><span style="color:#24292E;">endWord </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;cog&quot;</span></span>
<span class="line"><span style="color:#24292E;">wordList </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#032F62;">&quot;hot&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;dot&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;dog&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;lot&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;log&quot;</span><span style="color:#24292E;">,</span><span style="color:#032F62;">&quot;cog&quot;</span><span style="color:#24292E;">]</span></span></code></pre></div><p>经过上述操作，就可以得到题目中图的表示：</p>`,34),E=s(`<h4 id="转换" tabindex="-1">转换 <a class="header-anchor" href="#转换" aria-label="Permalink to &quot;转换&quot;">​</a></h4><p>如何利用字符串表示图中的点，就需要两个字符串来表示一条边。为了压缩这部分信息，我们采用整数来表示字符串。优点有以下几个方面。</p><ul><li><p>字符串的处理不方便，必须使用哈希表。如果是整数表示图中的点，那么我们可以使用数组记录点的信息。</p></li><li><p>字符串的运算速度没有整数快。</p></li><li><p>我们在学习图算法的时候，大部分时候都是使用整数来表示图中的点，相对来说，对代码更加熟悉。</p></li></ul><p>基于以上三个原因，我们决定将 String 表示一个点，转换为用整数表示一个点。转换的思想也比较简单：<strong>利用哈希表将不同的字符串映射到不同的整数上即可</strong>。</p><p>这里我们直接给出&quot;建图&quot;+&quot;转换&quot;的代码，如下所示（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; wordID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; Graph[] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                       String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                       List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 首先如果单词一样：题目中给出了条件，这两个单词必须不一样</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (beginWord.</span><span style="color:#B392F0;">compareTo</span><span style="color:#E1E4E8;">(endWord) </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 需要记录每个单词的ID</span></span>
<span class="line"><span style="color:#E1E4E8;">        wordID </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (String word</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> wordList) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">wordID.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(word)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                wordID.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(word, id</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 根据题意：如果我们在wordList中找不到endWord必须要</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 返回0</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">wordID.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(endWord)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果wordID中没有beginWord</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 那么把beginWord添加到wordID &amp; wordList中</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">wordID.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(beginWord)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            wordID.</span><span style="color:#B392F0;">put</span><span style="color:#E1E4E8;">(beginWord, id</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            wordList.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(beginWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 构建图</span></span>
<span class="line"><span style="color:#E1E4E8;">        Graph </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">ArrayList</span><span style="color:#E1E4E8;">[wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">(); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">Graph</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (String word</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> wordList) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 边的起始点 from</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> from </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(word);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 看一下from能转变成什么</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] wordBytes </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> word.</span><span style="color:#B392F0;">getBytes</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> wordBytes.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> old </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordBytes[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 改变成其他byte</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> toByte </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;a&#39;</span><span style="color:#E1E4E8;">; toByte </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;z&#39;</span><span style="color:#E1E4E8;">; toByte</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    wordBytes[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> toByte;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    String toWord </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(wordBytes);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (wordID.</span><span style="color:#B392F0;">containsKey</span><span style="color:#E1E4E8;">(toWord)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 边的终点to</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> to </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(toWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 把这条边加到Graph中</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#F97583;">Graph</span><span style="color:#E1E4E8;">[from].</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(to);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span></span>
<span class="line"><span style="color:#E1E4E8;">                wordBytes[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> old;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ladderLength</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                            String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                            List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 我们要写的核心代码在这里。</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果建图失败，说明无法找到有效解，依照题意，无解的时候</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 我们需要返回0</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 接下来我们要讨论的重点代码，还没有写!</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; wordID </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; Graph[] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                       String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                       List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 首先如果单词一样：题目中给出了条件，这两个单词必须不一样</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (beginWord.</span><span style="color:#6F42C1;">compareTo</span><span style="color:#24292E;">(endWord) </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 需要记录每个单词的ID</span></span>
<span class="line"><span style="color:#24292E;">        wordID </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashMap&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (String word</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> wordList) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">wordID.</span><span style="color:#6F42C1;">containsKey</span><span style="color:#24292E;">(word)) {</span></span>
<span class="line"><span style="color:#24292E;">                wordID.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(word, id</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 根据题意：如果我们在wordList中找不到endWord必须要</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 返回0</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">wordID.</span><span style="color:#6F42C1;">containsKey</span><span style="color:#24292E;">(endWord)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果wordID中没有beginWord</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 那么把beginWord添加到wordID &amp; wordList中</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">wordID.</span><span style="color:#6F42C1;">containsKey</span><span style="color:#24292E;">(beginWord)) {</span></span>
<span class="line"><span style="color:#24292E;">            wordID.</span><span style="color:#6F42C1;">put</span><span style="color:#24292E;">(beginWord, id</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            wordList.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(beginWord);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 构建图</span></span>
<span class="line"><span style="color:#24292E;">        Graph </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">ArrayList</span><span style="color:#24292E;">[wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">(); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">Graph</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (String word</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> wordList) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 边的起始点 from</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> from </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(word);</span></span>
<span class="line"><span style="color:#24292E;">            </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 看一下from能转变成什么</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] wordBytes </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> word.</span><span style="color:#6F42C1;">getBytes</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">            </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> wordBytes.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> old </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordBytes[i];</span></span>
<span class="line"><span style="color:#24292E;">                </span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 改变成其他byte</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> toByte </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;a&#39;</span><span style="color:#24292E;">; toByte </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;z&#39;</span><span style="color:#24292E;">; toByte</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    wordBytes[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> toByte;</span></span>
<span class="line"><span style="color:#24292E;">                    String toWord </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(wordBytes);</span></span>
<span class="line"><span style="color:#24292E;">                    </span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (wordID.</span><span style="color:#6F42C1;">containsKey</span><span style="color:#24292E;">(toWord)) {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 边的终点to</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> to </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(toWord);</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 把这条边加到Graph中</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#D73A49;">Graph</span><span style="color:#24292E;">[from].</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(to);</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">                </span></span>
<span class="line"><span style="color:#24292E;">                wordBytes[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> old;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ladderLength</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                            String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                            List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 我们要写的核心代码在这里。</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果建图失败，说明无法找到有效解，依照题意，无解的时候</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 我们需要返回0</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 接下来我们要讨论的重点代码，还没有写!</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>注意：在后文的代码中，我不再罗列 buildGraph 函数的详细代码，所有引用到 buildGraph 代码的地方，都是指这里的 buildGraph() 函数。</p></blockquote><p>当我们建好图之后，问题就变成：</p><ul><li><p>给定一个无向图；</p></li><li><p>如何求图中两个点的最短距离。</p></li></ul><p>不过，根据题意，还需要注意题目要求输出的是&quot;最短转换序列&quot;：</p><blockquote><p>一个最短转换序列是 &quot;hit&quot; → &quot;hot&quot; → &quot;dot&quot; → &quot;dog&quot; → &quot;cog&quot;，返回它的长度 5。</p></blockquote><p>因此，最短序列等价于<strong>最短路径上的点的个数。<strong>而我们平时求的最短路径实际上是最短路径上</strong>边的数目</strong>。因此：</p><blockquote><p>最短转换序列长度 = 最短路径长度 + 1</p></blockquote><p>那么，到这里，我们已经将陌生的题目成功转变成非常熟悉的问题：<strong>求图中两个点的最短距离</strong>。</p><p>接下来，我们看一下具体如何破解&quot;最短路径&quot;问题，其实我们在&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a>&quot;的&quot;例 2 和例 4&quot;都学习过，你可以返回去再复习一下，以便加深对这个经典问题的理解。</p><h3 id="bfs-算法" tabindex="-1">BFS 算法 <a class="header-anchor" href="#bfs-算法" aria-label="Permalink to &quot;BFS 算法&quot;">​</a></h3><p>求两个点的最短路径的时候，我们可以直接用 BFS。为什么呢？</p><p>你应该还记得，我们在&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a>&quot;中提到过 BFS 的特点：</p><blockquote><p>在搜索的时候，若想知道一些关于&quot;最近/最快/最少&quot;之类问题的答案，往往采用 BFS 更加适合。</p></blockquote><p>因此，在这里，我们直接使用 BFS 算法。如果从 beginWord 开始搜索，那么 BFS 的搜索过程可以表达成一个&quot;雷达波搜索&quot;的样子------每一轮搜索都会往外扩散一圈。</p><p>你可以结合下图展示的BFS 的搜索过程示意图进一步思考，我们从 beginWord = &quot;hit&quot; 开始搜索，直接到找到 endWord = &quot;cog&quot; 时停止。</p>`,21),y=s(`<blockquote><p>注：这里第 1 圈就是 hit 自身，蓝色圈表示 1 次搜索。</p></blockquote><p>那么在写代码的时候，我们可以使用类似的技巧进行 BFS。在每一层，我们都使用一个 ArrayList 来表示。那么，可以写出基于 BFS 的代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// buildGraph的代码 ... 略...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ladderLength</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果建图失败，那么返回0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 接下来，我们就是在一个图中找到两个点的最近距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里采用BFS的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(beginWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dst </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(endWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里我们采用&quot;两段击&quot;的BFS的方式进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    cur.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(src);</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 记录哪些点被访问过了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;">[] vis </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;">[wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">    vis[src] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始步数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> step </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">cur.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      next.</span><span style="color:#B392F0;">clear</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      step</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 遍历当前层的点，然后放到next中</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Integer curNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> cur) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果走到终点</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (curNode </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> dst) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> step;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Integer nextNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Graph</span><span style="color:#E1E4E8;">[curNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 遍历边curNode -&gt; nextNode</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 如果这个点还没有被访问过</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">vis[nextNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 那么放到next中</span></span>
<span class="line"><span style="color:#E1E4E8;">            next.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(nextNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">            vis[nextNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// swap the 2 list</span></span>
<span class="line"><span style="color:#E1E4E8;">      List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cur;</span></span>
<span class="line"><span style="color:#E1E4E8;">      cur </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">      next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tmp;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// buildGraph的代码 ... 略...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ladderLength</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果建图失败，那么返回0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 接下来，我们就是在一个图中找到两个点的最近距离</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里采用BFS的方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(beginWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dst </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(endWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里我们采用&quot;两段击&quot;的BFS的方式进行处理</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    cur.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(src);</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 记录哪些点被访问过了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;">[] vis </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;">[wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">    vis[src] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始步数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> step </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">cur.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">      next.</span><span style="color:#6F42C1;">clear</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      step</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 遍历当前层的点，然后放到next中</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Integer curNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> cur) {</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果走到终点</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (curNode </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> dst) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> step;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Integer nextNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Graph</span><span style="color:#24292E;">[curNode]) {</span></span>
<span class="line"><span style="color:#24292E;">        </span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 遍历边curNode -&gt; nextNode</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 如果这个点还没有被访问过</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">vis[nextNode]) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 那么放到next中</span></span>
<span class="line"><span style="color:#24292E;">            next.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(nextNode);</span></span>
<span class="line"><span style="color:#24292E;">            vis[nextNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// swap the 2 list</span></span>
<span class="line"><span style="color:#24292E;">      List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cur;</span></span>
<span class="line"><span style="color:#24292E;">      cur </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">      next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tmp;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：（假设我们有 N 个单词，每个单词的长度为 M。每个单词需要更改每个位置的字母来生成新的单词）这里时间复杂度需要分为两步。</p><p><strong>第一步：预处理建图</strong></p><h4 id="_1-时间复杂度" tabindex="-1">1. 时间复杂度 <a class="header-anchor" href="#_1-时间复杂度" aria-label="Permalink to &quot;1. 时间复杂度&quot;">​</a></h4><p>1）一共需要处理 N * M 个字母，每个字母要替换 26 次。替换之后生成的长度为 M 的新单词需要去哈希表中检验，每次去哈希表中检查一个单词需要的时间复杂度为 O(M)。</p><p>2）建图<strong>时间复杂度</strong>为 O(N * M * M * 26)，我们可以把常数 26 去掉，因此时间复杂度为 O(N * M * M)。</p><h4 id="_2-空间复杂度" tabindex="-1">2. 空间复杂度 <a class="header-anchor" href="#_2-空间复杂度" aria-label="Permalink to &quot;2. 空间复杂度&quot;">​</a></h4><p>1）建图时需要建立一个有 N 个 Item，并且每个 Item 长度为 M 的哈希表。因此，哈希表空间复杂度为 O(N * M)。</p><p>2）Graph 需要占用 O(N * N) 的空间。</p><p><strong>第二步：BFS</strong></p><h4 id="_1-时间复杂度-1" tabindex="-1">1. 时间复杂度 <a class="header-anchor" href="#_1-时间复杂度-1" aria-label="Permalink to &quot;1. 时间复杂度&quot;">​</a></h4><p>在后面 BFS 搜索的过程中，由于<strong>不会访问</strong>已访问过的点，相当于所有的点被遍历一遍，所以时间复杂度为 O(N)。</p><h4 id="_2-空间复杂度-1" tabindex="-1">2. 空间复杂度 <a class="header-anchor" href="#_2-空间复杂度-1" aria-label="Permalink to &quot;2. 空间复杂度&quot;">​</a></h4><p>最差情况下，需要把所有的点都放到 Array 中，此时空间复杂度为 O(N)。</p><p>综上，整个问题的时间复杂度为 O(N * M * M)，空间复杂度为 O(max(N^2^, N * M))。</p><h3 id="双向-bfs" tabindex="-1">双向 BFS <a class="header-anchor" href="#双向-bfs" aria-label="Permalink to &quot;双向 BFS&quot;">​</a></h3><p>如果说前面的 BFS 是&quot;一个人&quot;苦苦地用雷达搜索（后文中称为单向 BFS），那么会不会存在从两个方向进行搜索的情况呢？我们尝试分析一下。如果要找的目标也用雷达开启搜索，那么当两者有交互的时候，就可以认为找到了最短路径。</p><p>这种方法我们称为<strong>双向 BFS</strong>。两者的搜索过程如下图所示：</p>`,21),i=s(`<p>实际上，我们在写双向 BFS 的时候，两边不会同时开启搜索。而是<strong>采用一种策略：优先搜索范围更小的</strong>。</p><p>主要原因在于：</p><ul><li><p>我们写算法的时候，往往不需要多线程；</p></li><li><p>优先搜索范围更小的，可以节省更多的内存，因为要存放的信息变少了。</p></li></ul><p>基于这种双向 BFS 的想法，可以写出代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 省略 buildGraph的代码 ... </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ladderLength</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果建图失败，那么返回0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 接下来，我们就是在一个图中找到两个点的最近距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里采用BFS的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> srcNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(beginWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dstNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(endWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里我们采用&quot;两段击&quot;的</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 双向BFS的方式来进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里正向出发</span></span>
<span class="line"><span style="color:#E1E4E8;">    Set&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    src.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(srcNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里逆向出发</span></span>
<span class="line"><span style="color:#E1E4E8;">    Set&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; dst </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">    dst.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(dstNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> srcVisTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dstVisTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 记录哪些点被访问过了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] vis </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过不同的标号来标记点是被前序遍历过</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 还是被后序遍历过</span></span>
<span class="line"><span style="color:#E1E4E8;">    vis[srcNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> srcVisTag;</span></span>
<span class="line"><span style="color:#E1E4E8;">    vis[dstNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> dstVisTag;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始步数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> step </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">src.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">dst.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      step</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 查看src与set是否相遇</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Integer node </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dst) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (src.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(node)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> step;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 哪边点更少，就更新哪一边</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> visTag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> src.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dst.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span></span>
<span class="line"><span style="color:#E1E4E8;">            srcVisTag </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dstVisTag;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#E1E4E8;">      Set&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; tmp </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> src.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dst.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> src </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dst;</span></span>
<span class="line"><span style="color:#E1E4E8;">      Set&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> startNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> tmp) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Graph</span><span style="color:#E1E4E8;">[startNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (vis[nextNode] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> visTag) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            vis[nextNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> visTag;</span></span>
<span class="line"><span style="color:#E1E4E8;">            next.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(nextNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (src.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dst.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        dst </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 省略 buildGraph的代码 ... </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ladderLength</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果建图失败，那么返回0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 接下来，我们就是在一个图中找到两个点的最近距离</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里采用BFS的方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> srcNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(beginWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dstNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(endWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里我们采用&quot;两段击&quot;的</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 双向BFS的方式来进行处理</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里正向出发</span></span>
<span class="line"><span style="color:#24292E;">    Set&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    src.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(srcNode);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里逆向出发</span></span>
<span class="line"><span style="color:#24292E;">    Set&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; dst </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">    dst.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(dstNode);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> srcVisTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dstVisTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 记录哪些点被访问过了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] vis </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过不同的标号来标记点是被前序遍历过</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 还是被后序遍历过</span></span>
<span class="line"><span style="color:#24292E;">    vis[srcNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> srcVisTag;</span></span>
<span class="line"><span style="color:#24292E;">    vis[dstNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> dstVisTag;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始步数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> step </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">src.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">dst.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">      step</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 查看src与set是否相遇</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Integer node </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dst) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (src.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(node)) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> step;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 哪边点更少，就更新哪一边</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> visTag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> src.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dst.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">            srcVisTag </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dstVisTag;</span></span>
<span class="line"><span style="color:#24292E;">            </span></span>
<span class="line"><span style="color:#24292E;">      Set&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; tmp </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> src.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dst.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> src </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dst;</span></span>
<span class="line"><span style="color:#24292E;">      Set&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> HashSet&lt;&gt;();</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> startNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> tmp) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Graph</span><span style="color:#24292E;">[startNode]) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (vis[nextNode] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> visTag) {</span></span>
<span class="line"><span style="color:#24292E;">            vis[nextNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> visTag;</span></span>
<span class="line"><span style="color:#24292E;">            next.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(nextNode);</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (src.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dst.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">      } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        dst </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">：Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C+</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">+/Python</a></p></blockquote><p>这里，我们将双向 BFS 与单向 BFS 进行一个比较，如下表所示：</p>`,7),d=s(`<p>那么，双向 BFS 主要的优化在于：</p><ul><li><p>搜索时需要存放的信息更小了（因为搜索范围更小的优先），因此更加<strong>节省内存</strong>；</p></li><li><p>由于要处理的信息变少了，那么查找起来也会<strong>更快</strong>一些。</p></li></ul><p>不过双向 BFS 还是在单向 BFS 上做常数上的优化。最差情况下，时间复杂度与空间复杂度仍然是在一个数量级的。</p><h3 id="dijkstra-算法" tabindex="-1">Dijkstra 算法 <a class="header-anchor" href="#dijkstra-算法" aria-label="Permalink to &quot;Dijkstra 算法&quot;">​</a></h3><p>一般而言，最短路径问题，有三种：</p><ul><li><p>两点之间的最短路径（BFS 算法/Dijkstra 算法/BF 算法，即Bellman-Ford 算法）；</p></li><li><p>一个点到其他所有点的最短路径（Dijkstra 算法/BF 算法）；</p></li><li><p><strong>每两点</strong>之间的最短路径（Floyd 算法）。</p></li></ul><p>现在，我们先讨论一下，在计算两点间的最短路径的时候，什么时候应该使用 BFS 算法，什么时候应该使用 Dijkstra 算法？</p><ul><li><p>当图中边的权重都是 1 的时候，最好的办法是使用 BFS 算法。</p></li><li><p>当图中边的权重非负的时候，最好的办法是使用 Dijkstra 算法。</p></li><li><p>当图中的边的权重存在负值的时候，最好的办法是采用 BF 算法。</p></li></ul><p>实际上，我们可以将权重为 1 的时候，看成权重不同的特例。那么，这里我们应该也可以使用 Dijkstra 算法。根据 Dijkstra 算法的思路（&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6692&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">03 | 优先级队列：堆与优先级队列，筛选最优元素</a>&quot;的&quot;练习题 7&quot;用到了 Dijkstra，以及&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6702&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">13 | 搜索：如何掌握 DFS 与 BFS 的解题套路？</a>&quot;的&quot;例 5&quot;），我们可以写出代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// .. 省略 buildGraph函数代码 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ladderLength</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果建图失败，那么返回0</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 接下来，我们就是在一个图中找到两个点的最近距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里采用BFS的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(beginWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> target </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(endWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 记录从src到各个点的距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] dist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dist.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      dist[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    dist[src] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// java小堆</span></span>
<span class="line"><span style="color:#E1E4E8;">    Queue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; Q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityQueue&lt;&gt;(</span></span>
<span class="line"><span style="color:#E1E4E8;">            (v1, v2) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> dist[v1] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> dist[v2]);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span></span>
<span class="line"><span style="color:#E1E4E8;">    Q.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(src);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">Q.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> startNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Q.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> startDist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> dist[startNode];</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Graph</span><span style="color:#E1E4E8;">[startNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextDist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> startDist </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (dist[nextNode] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> nextDist) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          dist[nextNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextDist;</span></span>
<span class="line"><span style="color:#E1E4E8;">          Q.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(nextNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> dist[target] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dist[target] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// .. 省略 buildGraph函数代码 ...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ladderLength</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果建图失败，那么返回0</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 接下来，我们就是在一个图中找到两个点的最近距离</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里采用BFS的方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(beginWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> target </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(endWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 记录从src到各个点的距离</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] dist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dist.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      dist[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    dist[src] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// java小堆</span></span>
<span class="line"><span style="color:#24292E;">    Queue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; Q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityQueue&lt;&gt;(</span></span>
<span class="line"><span style="color:#24292E;">            (v1, v2) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> dist[v1] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> dist[v2]);</span></span>
<span class="line"><span style="color:#24292E;">            </span></span>
<span class="line"><span style="color:#24292E;">    Q.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(src);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">Q.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> startNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Q.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> startDist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> dist[startNode];</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Graph</span><span style="color:#24292E;">[startNode]) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextDist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> startDist </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (dist[nextNode] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> nextDist) {</span></span>
<span class="line"><span style="color:#24292E;">          dist[nextNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextDist;</span></span>
<span class="line"><span style="color:#24292E;">          Q.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(nextNode);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">   </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> dist[target] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">?</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dist[target] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度，由于 Dijkstra 算法的时间复杂度在有 N 个点的情况下，复杂度为 O(NlgN)。但是，整个题目的时间复杂度与空间复杂度仍然由 buildGraph 函数主导。与 BFS 的时间复杂度相同。</p><p>我们再对 Dijkstra 算法做个小小的总结，在使用 Dijkstra 算法的时候，有以下特点：</p><ul><li><p>并没有使用 vis 数组来进行标记；</p></li><li><p>而是当发现一个点的最小距离变得更小的时候，就需要放到优先级队列中，然后重新展开搜索。</p></li></ul><p>本讲中，我们提到了 BF 算法。不过 BF 算法在有 N 个点，E 条边的情况下，时间复杂度会达到 O(N x E)。在本题中，当单词长度为 M 时，最差情况下，一个单词可以有 M x 26 条边。一个图中的边可以达到 N x M x 26。此时，时间复杂度达到 O(N x N x M x 26)，会出现超时的情况。关于这种情况，你可以自己求解一下下面这道练习题，本讲不再详细讨论。</p><p><strong>练习题 1</strong>：有 N 个网络结点，标记为 1 到 N。给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源结点，v 是目标结点，w 是一个信号从源结点传递到目标结点的时间。</p><p>现在，我们从某个结点 K 发出一个信号。需要多久才能使所有结点都收到信号？如果不能使所有结点收到信号，则返回 -1。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="dfs-算法" tabindex="-1">DFS 算法 <a class="header-anchor" href="#dfs-算法" aria-label="Permalink to &quot;DFS 算法&quot;">​</a></h3><p>不知道你有没有从 Dijkstra 的算法中找到灵感？<strong>在遍历的时候，我们不再使用 vis 数组来记录一个点是否被访问，而是利用最小距离是否被更新作为条件</strong>。</p><p>那么在 DFS 的时候，是不是也可以这样操作？比如：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">(List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Integer</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> start, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] dist)</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[start]) { </span><span style="color:#6A737D;">// 边：&lt;startNode-&gt;nextNode&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextDist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> dist[start] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextDist </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dist[nextNode]) { </span><span style="color:#6A737D;">// 如果发现距离被更新了</span></span>
<span class="line"><span style="color:#E1E4E8;">        dist[nextNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextDist;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">(G, nextNode, dist);        </span><span style="color:#6A737D;">// 那么就从nextNode重新展开搜索</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">(List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Integer</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[], </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> start, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] dist)</span></span>
<span class="line"><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[start]) { </span><span style="color:#6A737D;">// 边：&lt;startNode-&gt;nextNode&gt;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextDist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> dist[start] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextDist </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dist[nextNode]) { </span><span style="color:#6A737D;">// 如果发现距离被更新了</span></span>
<span class="line"><span style="color:#24292E;">        dist[nextNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextDist;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">(G, nextNode, dist);        </span><span style="color:#6A737D;">// 那么就从nextNode重新展开搜索</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span></code></pre></div><p>那么，基于这种距离更新，就重新展开 DFS 的搜索方法，我们也可以写出新的 DFS 算法来解决这道题，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">(List&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[], </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">start</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">dist</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[start]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextDist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> dist[start] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextDist </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dist[nextNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        dist[nextNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextDist;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">(G, nextNode, dist);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// .. 省略 buildGraph函数的代码 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ladderLength</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里构图</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 分别设置好源点，终点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(beginWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dst </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(endWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 数组记录src点出发到其他点的最短距离</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] dist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设置一个最大距离，表示无解</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> maxPathLength </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化dist数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dist.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      dist[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> maxPathLength;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    dist[src] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// dfs搜索最优解</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">(Graph, src, dist);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> dist[dst] </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> maxPathLength </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dist[dst] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">(List&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[], </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#E36209;">start</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">dist</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[start]) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextDist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> dist[start] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextDist </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dist[nextNode]) {</span></span>
<span class="line"><span style="color:#24292E;">        dist[nextNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextDist;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">(G, nextNode, dist);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// .. 省略 buildGraph函数的代码 ...</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ladderLength</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里构图</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 分别设置好源点，终点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(beginWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dst </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(endWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 数组记录src点出发到其他点的最短距离</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] dist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设置一个最大距离，表示无解</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> maxPathLength </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化dist数组</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dist.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      dist[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> maxPathLength;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    dist[src] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// dfs搜索最优解</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">(Graph, src, dist);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> dist[dst] </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> maxPathLength </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dist[dst] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong> ：假设一共有 N 个点，那么最差情况下，每个点会被其他点最多更新 N 次。因此，最差时间复杂度为 O(N^2^)。但是就整个题目而言，时间复杂度由构建图 buildGraph 的部分主导。综上，时间复杂度为 O(N * M * M)，空间复杂度为 O(max(N^2^N * M))。</p><p>那么，接下来，我们考虑一下，Dijkstra 算法与 DFS 算法不同的地方。</p><p>虽然 Dijkstra 与 DFS 都不会再用到 vis 数组，并且都在点 nextNode 的距离被更新，然后重新展开搜索。但是依然存在不同的地方。</p><ul><li><p>Dijkstra 算法是从<strong>优先级队列中拿出最优的点重新</strong>展开搜索。而且Dijkstra 算法在用一个点更新的时候，会把这个点相邻的所有点更新之后，再重新展开搜索。</p></li><li><p>而 DFS 算法却是立马从点 nextNode 重新展开搜索。</p></li></ul><p>那么，有没有可能将 DFS 也改成Dijkstra这样呢？我们是不是发明了 DFS 也可以实现 Dijkstra 算法呢？基于这种思路，对 DFS 算法进行一下改写，代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// .... 省略了 buildGraph() 函数的代码 ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] dist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 优先级队列</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Queue&lt;</span><span style="color:#F97583;">Integer</span><span style="color:#E1E4E8;">&gt; Q </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> dist[v1] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> dist[v2]);</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// DFS + priorityQueue</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Q.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> startNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Q.</span><span style="color:#B392F0;">poll</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextNode </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Graph</span><span style="color:#E1E4E8;">[startNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> nextDist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> dist[startNode] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (nextDist </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dist[nextNode]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        dist[nextNode] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextDist;</span></span>
<span class="line"><span style="color:#E1E4E8;">        Q.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(nextNode);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 注意：我们要用startNode把所有的点都更新完之后</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 再重新展开DFS</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ladderLength</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">beginWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          String </span><span style="color:#FFAB70;">endWord</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                          List&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">wordList</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#B392F0;">buildGraph</span><span style="color:#E1E4E8;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> src </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(beginWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> dst </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(endWord);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化距离数组</span></span>
<span class="line"><span style="color:#E1E4E8;">    dist </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">()];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> maxPathLength </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> wordID.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1024</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> dist.length; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      dist[i] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> maxPathLength;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    dist[src] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 优先级队列中放入src</span></span>
<span class="line"><span style="color:#E1E4E8;">    Q.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(src);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 进行dfs</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">dfs</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> dist[dst] </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> maxPathLength </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> dist[dst] </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// .... 省略了 buildGraph() 函数的代码 ...</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] dist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 优先级队列</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Queue&lt;</span><span style="color:#D73A49;">Integer</span><span style="color:#24292E;">&gt; Q </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> PriorityQueue&lt;&gt;((v1, v2) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> dist[v1] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> dist[v2]);</span></span>
<span class="line"><span style="color:#24292E;">       </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// DFS + priorityQueue</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Q.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> startNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Q.</span><span style="color:#6F42C1;">poll</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextNode </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Graph</span><span style="color:#24292E;">[startNode]) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> nextDist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> dist[startNode] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (nextDist </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dist[nextNode]) {</span></span>
<span class="line"><span style="color:#24292E;">        dist[nextNode] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextDist;</span></span>
<span class="line"><span style="color:#24292E;">        Q.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(nextNode);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 注意：我们要用startNode把所有的点都更新完之后</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 再重新展开DFS</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ladderLength</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">beginWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          String </span><span style="color:#E36209;">endWord</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                          List&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">wordList</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#6F42C1;">buildGraph</span><span style="color:#24292E;">(beginWord, endWord, wordList)) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> src </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(beginWord);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> dst </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(endWord);</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化距离数组</span></span>
<span class="line"><span style="color:#24292E;">    dist </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">()];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> maxPathLength </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> wordID.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1024</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> dist.length; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      dist[i] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> maxPathLength;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    dist[src] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 优先级队列中放入src</span></span>
<span class="line"><span style="color:#24292E;">    Q.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(src);</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 进行dfs</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">dfs</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> dist[dst] </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> maxPathLength </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> dist[dst] </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>我们发现，经过上述处理的 DFS，本质上与 Dijkstra 算法是一样的。在这里，我们将不同的算法的特点加以迁移（从原本是 Dijkstra 的特点，迁移到 DFS 算法），让不同的算法可以取得同样的效果。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲中，我们再次通过一个题目，挖掘了题目的信息+考点。</p><ul><li><p>信息：需要通过一定的条件生成边。</p></li><li><p>考点：两点的最短路径。</p></li></ul><p>当拿到这两部分信息之后，我们首先进行<strong>题目的预处理：建图</strong> 。通过建图，让题目回到了一个我们非常熟悉的知识点：两点最短路径。接来下就是<strong>匹配到了已经学过的各种知识点</strong>，轮番上阵，也就展开了不同的破题方法。最后，我把这个题目中用到的知识点整理在下面这张思维导图中，你可以参考下图梳理一遍今天学到的重点知识。</p>`,37),F=s('<h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h3><p>我再给你留一道思考题：在本讲介绍的题目基础上，我们找到<strong>最短的转换序列的长度</strong> 之后。如果要输出<strong>所有</strong>的最短转换序列，应该怎么办呢？</p><p>输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</p><p>输出：[[&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;],[&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]]</p><p>解释：存在 2 种最短的转换序列：</p><p>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;</p><p>&quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;lot&quot; -&gt; &quot;log&quot; -&gt; &quot;cog&quot;</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>你可以自己尝试求解这道题目，把答案写在留言区，我们一起讨论。关于单词转换的题目就介绍到这里。接下来，下一讲介绍&quot;19 | 最小体力消耗路径：如何突破经典题型，掌握解题模板&quot;，让我们继续前进。</p><h3 id="附录-题目出处和代码汇总" tabindex="-1">附录：题目出处和代码汇总 <a class="header-anchor" href="#附录-题目出处和代码汇总" aria-label="Permalink to &quot;附录：题目出处和代码汇总&quot;">​</a></h3><table><thead><tr><th style="text-align:center;">题目</th><th><a href="https://leetcode-cn.com/problems/word-ladder/?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">测试链接</a></th><th style="text-align:center;">BFS代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.BFS.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a> 双向 BFS代码<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">：Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C+</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.D.BFS.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">+/Python</a> Dijkstra代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.Dijstra.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a> DFS + Q代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99.DFS.Q.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></th></tr></thead><tbody><tr><td style="text-align:center;">练习题 1</td><td><a href="https://leetcode-cn.com/problems/network-delay-time/?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">测试链接</a></td><td style="text-align:center;">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/743.%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></td></tr><tr><td style="text-align:center;">思考题</td><td><a href="https://leetcode-cn.com/problems/word-ladder-ii/?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">测试链接</a></td><td style="text-align:center;">代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/18.Words/126.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99-ii.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></td></tr></tbody></table>',11);function D(A,u,g,h,b,B){const n=o("Image");return e(),t("div",null,[c,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image6/M01/3B/FB/Cgp9HWCHz-KAVAogAADx9Asf9G0216.png"}),l(),E,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M01/3B/FB/Cgp9HWCHz_6AAxR5AAE6U53LZ3U453.png"}),l(),y,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M00/3C/03/CioPOWCHz_iAeJHUAAE70Bz7hFs200.png"}),l(),i,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M00/3C/03/CioPOWCH0CuAddFeAABSuMkK5zs509.png"}),l(),d,a(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image6/M00/3B/FB/Cgp9HWCH0ESATdYbAAH54J1eIGc572.png"}),l(),F])}const C=p(r,[["render",D]]);export{q as __pageData,C as default};
