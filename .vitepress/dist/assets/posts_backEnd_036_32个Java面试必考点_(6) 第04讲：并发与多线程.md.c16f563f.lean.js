import{_ as i,j as n,o as s,g as c,s as l,k as t,h as o,Q as a}from"./chunks/framework.b3d8e22e.js";const ml=JSON.parse('{"title":"多线程知识点 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/036_32个Java面试必考点/(6) 第04讲：并发与多线程.md","filePath":"posts/backEnd/036_32个Java面试必考点/(6) 第04讲：并发与多线程.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/036_32个Java面试必考点/(6) 第04讲：并发与多线程.md"},p=l("p",null,"本课时的主要内容是 Java 的多线程和并发。重点知识有线程的状态转换、线程的同步与互斥、线程池的运作机制详解，以及 JUC 中常用的工具类。",-1),_=l("h6",{id:"多线程知识点",tabindex:"-1"},[o("多线程知识点 "),l("a",{class:"header-anchor",href:"#多线程知识点","aria-label":'Permalink to "多线程知识点"'},"​")],-1),h={id:"",tabindex:"-1"},d=l("a",{class:"header-anchor",href:"#","aria-label":'Permalink to "<Image alt="" src="http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI2Aa7QeAAEskU8MCuc505.png"/>"'},"​",-1),u=l("br",null,null,-1),A=l("p",null,"多线程协作时，因为对资源的锁定与等待会产生死锁，这里需要了解产生死锁的四个基本条件，要明白竞争条件与临界区的概念，知道可以通过破坏造成死锁的 4 个条件来防止死锁。",-1),g=l("p",null,"前面讲过进程间的通信方式，这里还要知道线程间的通信方式，通信主要指线程之间的协作机制，例如 wait、notify 等。",-1),b=l("p",null,"还需要知道 Java 为多线程提供的一些机制，例如 ThreadLocal 用来保存线程独享的数据， Fork/Join 机制用于大任务的分割与汇总，Volatile 对多线程数据可见性的保证，以及线程的中断机制。",-1),m=l("p",null,"其他还有：ThreadLocal 的实现机制。Fork/Join 的工作窃取算法等内容。",-1),C=l("h6",{id:"详解线程状态转换",tabindex:"-1"},[o("详解线程状态转换 "),l("a",{class:"header-anchor",href:"#详解线程状态转换","aria-label":'Permalink to "详解线程状态转换"'},"​")],-1),T=l("p",null,"线程是 JVM 执行任务的最小单元，理解线程的状态转换是理解后续多线程问题的基础。在 JVM 运行中，线程一共有 NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 六种状态，这些状态对应 Thread.State 枚举类中的状态。",-1),k=l("p",null,"如下图所示，当创建一个线程时，线程处在 NEW 状态，运行 Thread 的 start 方法后，线程进入 RUNNABLE 可运行状态。",-1),S=l("br",null,null,-1),E=a("",10),B=l("br",null,null,-1),L=l("p",null,"比较并写回的操作是通过操作系统原语实现的，保证执行过程中不会被中断。",-1),I=l("h2",{id:"aba",tabindex:"-1"},[o("ABA "),l("a",{class:"header-anchor",href:"#aba","aria-label":'Permalink to "ABA"'},"​")],-1),M=l("p",null,"CAS 容易出现 ABA 问题，就是如下面时序图所示，如果线程 T1 读取值 A 之后，发生两次写入，先由线程 T2 写回了 B，又由 T3 写回了 A，此时 T1 在写回比较时，值还是 A，就无法判断是否发生过修改。",-1),f=l("br",null,null,-1),P=l("p",null,"ABA 问题不一定会影响结果，但还是需要防范，解决的办法可以增加额外的标志位或者时间戳。JUC 工具包中提供了这样的类。",-1),D=l("h6",{id:"详解-synchronized",tabindex:"-1"},[o("详解 synchronized "),l("a",{class:"header-anchor",href:"#详解-synchronized","aria-label":'Permalink to "详解 synchronized"'},"​")],-1),J=l("p",null,"synchronized 是最常用的线程同步手段之一，它是如何保证同一时刻只有一个线程可以进入临界区呢？",-1),V=l("p",null,"synchronized 对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：对象头、实例数据和对齐填充。在对象头中保存了锁标志位和指向 monitor 对象的起始地址，如下图所示，右侧就是对象对应的 Monitor 对象。当 Monitor 被某个线程持有后，就会处于锁定状态，如图中的 Owner 部分，会指向持有 Monitor 对象的线程。另外 Monitor 中还有两个队列，用来存放进入及等待获取锁的线程。",-1),N=l("br",null,null,-1),y=l("p",null,"synchronized 应用在方法上时，在字节码中是通过方法的 ACC_SYNCHRONIZED 标志来实现的，synchronized 应用在同步块上时，在字节码中是通过 monitorenter 和 monitorexit 实现的。",-1),R=l("p",null,"针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁。",-1),x=l("h6",{id:"详解-aqs-与-lock",tabindex:"-1"},[o("详解 AQS 与 Lock "),l("a",{class:"header-anchor",href:"#详解-aqs-与-lock","aria-label":'Permalink to "详解 AQS 与 Lock"'},"​")],-1),O=l("p",null,"在介绍 Lock 前，先介绍 AQS，也就是队列同步器，这是实现 Lock 的基础。下图就是 AQS 的结构图，从图中可以看出，AQS 有一个 state 标记位，值为1 时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。",-1),U=l("br",null,null,-1),q=l("br",null,null,-1),w=l("p",null,"当获得锁的线程需要等待某个条件时，会进入 condition 的等待队列，等待队列可以有多个。当 condition 条件满足时，线程会从等待队列重新进入同步队列进行获取锁的竞争。ReentrantLock 就是基于 AQS 实现的，如下图所示，ReentrantLock 内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。",-1),Q=l("br",null,null,-1),j=l("p",null,"和 ReentrantLock 实现方式类似，Semaphore 也是基于 AQS 的，差别在于 ReentrantLock 是独占锁，Semaphore 是共享锁。",-1),v=l("br",null,null,-1),z=l("br",null,null,-1),W=l("h6",{id:"详解线程池",tabindex:"-1"},[o("详解线程池 "),l("a",{class:"header-anchor",href:"#详解线程池","aria-label":'Permalink to "详解线程池"'},"​")],-1),K=l("p",null,"线程池通过复用线程，避免线程频繁地创建和销毁。Java 的 Executors 工具类中提供了 5 种类型的线程池创建方法，如下图所示，来看它们的特点和适用场景。",-1),F=l("br",null,null,-1),Y=a("",5),H=a("",8),G=a("",6),X=l("br",null,null,-1),$=l("p",null,"如上图所示，第一行的类都是基本数据类型的原子类，包括 AtomicBoolean、AtomicLong、AtomicInteger 类。",-1),Z=l("ul",null,[l("li",null,[l("p",null,"AtomicLong 通过 unsafe 类实现，基于CAS。unsafe 类是底层工具类，JUC 中很多类的底层都使用到了 unsafe 包中的功能。unsafe 类提供了类似 C 的指针操作，提供 CAS 等功能。unsafe 类中的所有方法都是 native 修饰的。")]),l("li",null,[l("p",null,"LongAdder等 4 个类是 JDK1.8 中提供的更高效的操作类。LongAdder 基于 Cell 实现，使用分段锁思想，是一种空间换时间的策略，更适合高并发场景；LongAccumulator 提供了比 LongAdder 更强大的功能，能够指定对数据的操作规则，例如可以把对数据的相加操作改成相乘操作。")])],-1),ll=l("br",null,null,-1),el=l("p",null,"第二行中的类提供了对对象的原子读写功能，后两个类 AtomicStampedReference 和 AtomicMarkableReference 用于解决前面提到的 ABA 问题，分别基于时间戳和标记位来解决问题。",-1),tl=l("p",null,"再看下图。",-1),ol=a("",7),al=a("",18),il=a("",4),nl=l("ul",null,[l("li",null,[l("p",null,"第 7 题，线程之间如何通信？主要可以介绍一下 wait/notify 机制，共享变量的 synchronized 或者 Lock 同步机制等。")]),l("li",null,[l("p",null,"第 8 题，保证线程安全的方法有哪些？可以提 CAS、synchronized、Lock，以及 ThreadLocal 等机制。")]),l("li",null,[l("p",null,"第 9 题，如何尽可能提高多线程并发性能？可以从尽量减少临界区范围，使用 ThreadLocal，减少线程切换、使用读写锁或 copyonwrite 等机制这些方面来回答。")]),l("li",null,[l("p",null,"第 10 题，ThreadLocal 用来解决什么问题？ThreadLocal 是如何实现的？可以重点回答 ThreadLocal 不是用来解决多线程共享变量的问题，而是用来解决线程数据隔离的问题。")])],-1),sl=l("br",null,null,-1),cl=l("p",null,"本课时内容就到这里，下一课时会讲解基础知识模块中的数据结构与算法。",-1),rl=l("br",null,null,-1);function pl(_l,hl,dl,ul,Al,gl){const e=n("Image");return s(),c("div",null,[p,_,l("h6",h,[t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI2Aa7QeAAEskU8MCuc505.png"}),o(),d]),u,A,g,b,m,C,T,k,S,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI2Ab8rJAACvTREK08g324.png"}),E,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI6AM2T_AAAblRNWyOU110.png"}),B,L,I,M,f,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6AB5XwAAAWMnENBjk562.png"}),P,D,J,V,N,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI6AGOs9AABK2UOTXYM742.png"}),y,R,x,O,U,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ANLfHAAA3fj0S8po403.png"}),q,w,Q,j,v,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI6AHi8EAAAmrb0oKYY337.png"}),z,W,K,F,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ARRYYAACMegWL29o977.png"}),Y,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI6AYuywAABjUwbc6lw080.png"}),H,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ABd8rAABJ5DF7U78658.png"}),G,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI6ALbKbAABsWQ4Nsws755.png"}),X,$,Z,ll,el,tl,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ADBHyAABidDn7gt4688.png"}),ol,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI6AXuPCAABiZsTbtrs036.png"}),al,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/BE/CgoB5l14nI6ASj5CAABnpj1enwM108.png"}),il,t(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/DE/CgotOV14nI-AOlGmAABc2tbFdwU647.png"}),nl,sl,cl,rl])}const Cl=i(r,[["render",pl]]);export{ml as __pageData,Cl as default};
