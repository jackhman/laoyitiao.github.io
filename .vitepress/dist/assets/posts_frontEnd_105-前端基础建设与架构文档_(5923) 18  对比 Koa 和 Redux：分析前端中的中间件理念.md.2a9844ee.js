import{_ as p,D as o,o as e,g as c,J as n,h as a,Q as l,m as t}from"./chunks/framework.f67d7268.js";const x=JSON.parse('{"title":"18对比Koa和Redux：分析前端中的中间件理念","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/105-前端基础建设与架构文档/(5923) 18  对比 Koa 和 Redux：分析前端中的中间件理念.md","filePath":"posts/frontEnd/105-前端基础建设与架构文档/(5923) 18  对比 Koa 和 Redux：分析前端中的中间件理念.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/105-前端基础建设与架构文档/(5923) 18  对比 Koa 和 Redux：分析前端中的中间件理念.md"},E=l(`<h1 id="_18对比koa和redux-分析前端中的中间件理念" tabindex="-1">18对比Koa和Redux：分析前端中的中间件理念 <a class="header-anchor" href="#_18对比koa和redux-分析前端中的中间件理念" aria-label="Permalink to &quot;18对比Koa和Redux：分析前端中的中间件理念&quot;">​</a></h1><p>上一讲，我们通过分析 axios 源码，延伸了&quot;如何设计一个请求公共库&quot;，其中提到了不同层次级别的分层理念。这一讲，我们继续讨论代码设计这一话题，聚焦中间件化和插件化理念。并通过实现一个中间件化的请求库和上一节内容融会贯通。</p><h3 id="以-koa-为代表的-node-js-中间件化设计" tabindex="-1">以 Koa 为代表的 Node.js 中间件化设计 <a class="header-anchor" href="#以-koa-为代表的-node-js-中间件化设计" aria-label="Permalink to &quot;以 Koa 为代表的 Node.js 中间件化设计&quot;">​</a></h3><p>说到中间件，很多开发者都会想到 Koa.js，其中间件设计无疑是前端中间件思想的典型代表之一。我们先来剖析 Koa.js 的设计和实现。</p><p>先来看一下 Koa.js 中间件的实现和应用：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 最外层中间件，可以用于兜底 Koa 全局错误</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">use</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">async</span><span style="color:#E1E4E8;"> (ctx, next) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// console.log(&#39;中间件 1 开始执行&#39;)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 执行下一个中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">    await </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// console.log(&#39;中间件 1 执行结束&#39;)</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(\`[koa error]</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> \${error.message}\`)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#6A737D;">// 第二层中间件，可以用于日志记录</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">use</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">async</span><span style="color:#E1E4E8;"> (ctx, next) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// console.log(&#39;中间件 2 开始执行&#39;)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> { req } </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctx;</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(\`req is \${JSON.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(req)}\`);</span></span>
<span class="line"><span style="color:#E1E4E8;">  await </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(\`res is \${JSON.</span><span style="color:#B392F0;">stringify</span><span style="color:#E1E4E8;">(ctx.res)}\`);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// console.log(&#39;中间件 2 执行结束&#39;)</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 最外层中间件，可以用于兜底 Koa 全局错误</span></span>
<span class="line"><span style="color:#24292E;">app.</span><span style="color:#6F42C1;">use</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">async</span><span style="color:#24292E;"> (ctx, next) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// console.log(&#39;中间件 1 开始执行&#39;)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 执行下一个中间件</span></span>
<span class="line"><span style="color:#24292E;">    await </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// console.log(&#39;中间件 1 执行结束&#39;)</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (error) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(\`[koa error]</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> \${error.message}\`)</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#6A737D;">// 第二层中间件，可以用于日志记录</span></span>
<span class="line"><span style="color:#24292E;">app.</span><span style="color:#6F42C1;">use</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">async</span><span style="color:#24292E;"> (ctx, next) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// console.log(&#39;中间件 2 开始执行&#39;)</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> { req } </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctx;</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(\`req is \${JSON.</span><span style="color:#6F42C1;">stringify</span><span style="color:#24292E;">(req)}\`);</span></span>
<span class="line"><span style="color:#24292E;">  await </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(\`res is \${JSON.</span><span style="color:#6F42C1;">stringify</span><span style="color:#24292E;">(ctx.res)}\`);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// console.log(&#39;中间件 2 执行结束&#39;)</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>如上代码，我们看 Koa 实例，通过<code>use</code>方法注册和串联中间件，其源码实现部分精简表述为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">use</span><span style="color:#E1E4E8;">(fn) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.middleware.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(fn);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">use</span><span style="color:#24292E;">(fn) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.middleware.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(fn);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如上代码，我们的中间件被存储进<code>this.middleware</code>数组中，那么中间件是如何被执行的呢？参考下面源码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 通过 createServer 方法启动一个 Node.js 服务</span></span>
<span class="line"><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(...args) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> server </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> http.</span><span style="color:#B392F0;">createServer</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> server.</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(...args);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 通过 createServer 方法启动一个 Node.js 服务</span></span>
<span class="line"><span style="color:#6F42C1;">listen</span><span style="color:#24292E;">(...args) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> server </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> http.</span><span style="color:#6F42C1;">createServer</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> server.</span><span style="color:#6F42C1;">listen</span><span style="color:#24292E;">(...args);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>Koa 框架通过 <code>http</code> 模块的 <code>createServer</code> 方法创建一个 Node.js 服务，并传入 this.callback() 方法， this.callback() 方法源码精简实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">callback</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从 this.middleware 数组中，组合中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.middleware);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// handleRequest 方法作为 \`http\` 模块的 \`createServer\` 方法参数，该方法通过 \`createContext\` 封装了 \`http.createServer\` 中的 \`request\` 和 \`response\`对象，并将这两个对象放到 ctx 中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> handleRequest </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (req, res) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> ctx </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">createContext</span><span style="color:#E1E4E8;">(req, res);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 将 ctx 和组合后的中间件函数 fn 传递给 this.handleRequest 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">handleRequest</span><span style="color:#E1E4E8;">(ctx, fn);</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> handleRequest;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">handleRequest</span><span style="color:#E1E4E8;">(ctx, fnMiddleware) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> res </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ctx.res;</span></span>
<span class="line"><span style="color:#E1E4E8;">    res.statusCode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">404</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> onerror </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> err </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> ctx.</span><span style="color:#B392F0;">onerror</span><span style="color:#E1E4E8;">(err);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> handleResponse </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">respond</span><span style="color:#E1E4E8;">(ctx);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// on-finished npm 包提供的方法，该方法在一个 HTTP 请求 closes，finishes 或者 errors 时执行</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">onFinished</span><span style="color:#E1E4E8;">(res, onerror);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 ctx 对象传递给中间件函数 fnMiddleware</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fnMiddleware</span><span style="color:#E1E4E8;">(ctx).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(handleResponse).</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(onerror);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">callback</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从 this.middleware 数组中，组合中间件</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.middleware);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// handleRequest 方法作为 \`http\` 模块的 \`createServer\` 方法参数，该方法通过 \`createContext\` 封装了 \`http.createServer\` 中的 \`request\` 和 \`response\`对象，并将这两个对象放到 ctx 中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> handleRequest </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (req, res) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> ctx </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">createContext</span><span style="color:#24292E;">(req, res);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 将 ctx 和组合后的中间件函数 fn 传递给 this.handleRequest 方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">handleRequest</span><span style="color:#24292E;">(ctx, fn);</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> handleRequest;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6F42C1;">handleRequest</span><span style="color:#24292E;">(ctx, fnMiddleware) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> res </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ctx.res;</span></span>
<span class="line"><span style="color:#24292E;">    res.statusCode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">404</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> onerror </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> err </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> ctx.</span><span style="color:#6F42C1;">onerror</span><span style="color:#24292E;">(err);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> handleResponse </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">respond</span><span style="color:#24292E;">(ctx);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// on-finished npm 包提供的方法，该方法在一个 HTTP 请求 closes，finishes 或者 errors 时执行</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">onFinished</span><span style="color:#24292E;">(res, onerror);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 ctx 对象传递给中间件函数 fnMiddleware</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fnMiddleware</span><span style="color:#24292E;">(ctx).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(handleResponse).</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">(onerror);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如上代码，我们将 Koa 一个中间件组合和执行流程梳理为以下步骤。</p><ol><li><p>通过<code>compose</code>方法组合各种中间件，返回一个中间件组合函数<code>fnMiddleware</code></p></li><li><p>请求过来时，会先调用<code>handleRequest</code>方法，该方法完成：</p><ul><li><p>调用<code>createContext</code>方法，对该次请求封装出一个<code>ctx</code>对象；</p></li><li><p>接着调用<code>this.handleRequest(ctx, fnMiddleware)</code>处理该次请求。</p></li></ul></li><li><p>通过<code>fnMiddleware(ctx).then(handleResponse).catch(onerror)</code>执行中间件。</p></li></ol><p>其中，一个核心过程就是使用<code>compose</code>方法组合各种中间件，其源码实现精简为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(middleware) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里返回的函数，就是上文中的 fnMiddleware</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> (context, next) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        let index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">        function </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(i) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        	  </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> index) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">reject</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;next() called multiple times&#39;</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#E1E4E8;">            index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 取出第 i 个中间件为 fn</span></span>
<span class="line"><span style="color:#E1E4E8;">            let fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middleware[i]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> middleware.length) fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">fn) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(context, dispatch.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">, i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)));</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">reject</span><span style="color:#E1E4E8;">(err)</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(middleware) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里返回的函数，就是上文中的 fnMiddleware</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> (context, next) {</span></span>
<span class="line"><span style="color:#24292E;">        let index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">        function </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(i) {</span></span>
<span class="line"><span style="color:#24292E;">        	  </span><span style="color:#6A737D;">// </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> index) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;next() called multiple times&#39;</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">            index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 取出第 i 个中间件为 fn</span></span>
<span class="line"><span style="color:#24292E;">            let fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middleware[i]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> middleware.length) fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">fn) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(context, dispatch.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">, i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)));</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (err) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(err)</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>源码实现中我已加入了相关注释，如果对于你来说还是晦涩难懂，不妨看一下下面这个 hard coding 的例子，通过下面代码，表示三个 Koa 中间件的执行情况：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">async function </span><span style="color:#B392F0;">middleware1</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;"> (async function </span><span style="color:#B392F0;">middleware2</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">await</span><span style="color:#E1E4E8;"> (async function </span><span style="color:#B392F0;">middleware3</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">      ...</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">    ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  });</span></span>
<span class="line"><span style="color:#E1E4E8;">  ...</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">async function </span><span style="color:#6F42C1;">middleware1</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  ...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;"> (async function </span><span style="color:#6F42C1;">middleware2</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">await</span><span style="color:#24292E;"> (async function </span><span style="color:#6F42C1;">middleware3</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">      ...</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">    ...</span></span>
<span class="line"><span style="color:#24292E;">  });</span></span>
<span class="line"><span style="color:#24292E;">  ...</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里我们来做一个简单的总结：</p><ul><li>Koa 的中间件机制被社区形象地总结为洋葱模型；</li></ul><blockquote><p>所谓洋葱模型，就是指每一个 Koa 中间件都是一层洋葱圈，它即可以掌管请求进入，也可以掌管响应返回。换句话说：外层的中间件可以影响内层的请求和响应阶段，内层的中间件只能影响外层的响应阶段。</p></blockquote><ul><li><code>dispatch(n)</code>对应第 n 个中间件的执行，第 n 个中间件可以通过<code>await next()</code>来执行下一个中间件，同时在最后一个中间件执行完成后，依然有恢复执行的能力。即，通过洋葱模型，<code>await next()</code>控制调用 &quot;下游&quot;中间件，直到 &quot;下游&quot;没有中间件且堆栈执行完毕，最终流回&quot;上游&quot;中间件。这种方式有个优点，特别是<strong>对于日志记录以及错误处理等需要非常友好</strong>。</li></ul><p>这里我们稍微做一下扩展，引申出 Koa v1 版本中中间件的实现，Koa1 的中间件实现利用了 <strong>Generator 函数 + co 库</strong> （一种基于 Promise 的 Generator 函数流程管理工具），来实现协程运行。本质上，Koa v1 版本中间件和 Koa v2 版本中间件思想是类似的，只不过 Koa v2 主要是用了 <strong>Async/Await</strong> 来替换 Generator 函数 + co 库，整体实现更加巧妙，代码更加优雅、简易。</p><h3 id="对比-express-再谈-koa-中间件" tabindex="-1">对比 Express，再谈 Koa 中间件 <a class="header-anchor" href="#对比-express-再谈-koa-中间件" aria-label="Permalink to &quot;对比 Express，再谈 Koa 中间件&quot;">​</a></h3><p>说起 Node.js 框架，我们自然忘不了 Express.js。它的中间件机制同样值得我们学习、比对。Express 不同于 Koa，它继承了<strong>路由、静态服务器和模板引擎等功能</strong> ，因此看上去比 Koa 更像是一个框架。通过学习 <a href="https://github.com/expressjs/express" target="_blank" rel="noreferrer">Express 源码</a>，我们可以总结出它的工作机制。</p><ol><li><p>通过<code>app.use</code>方法注册中间件。</p></li><li><p>一个中间件可以理解为一个 Layer 对象，其中包含了当前路由匹配的正则信息以及 handle 方法。</p></li><li><p>所有中间件（Layer 对象）使用<code>stack</code>数组存储起来。</p></li><li><p>因此，每个 Router 对象都是通过一个<code>stack</code>数组，存储了相关中间件函数。</p></li><li><p>当一个请求过来时，会从 REQ 中获取请求 path，根据 path 从<code>stack</code>中找到匹配的 Layer，具体匹配过程由<code>router.handle</code>函数实现。</p></li><li><p><code>router.handle</code>函数通过<code>next()</code>方法遍历每一个 layer 进行比对：</p><ol><li><p><code>next()</code>方法通过闭包维持了对于 Stack Index 游标的引用，当调用<code>next()</code>方法时，就会从下一个中间件开始查找；</p></li><li><p>如果比对结果为 true，则调用<code>layer.handle_request</code>方法，<code>layer.handle_request</code>方法中会调用<code>next()</code>方法 ，实现中间件的执行。</p></li></ol></li></ol><p>我们将上述过程总结为下图，帮助你理解：</p>`,27),y=l(`<p>Express 工作机制</p><p>通过上述内容，我们可以看到，Express 的<code>next()</code>方法维护了遍历中间件列表的 Index 游标，中间件每次调用<code>next()</code>方法时，会通过<strong>增加 Index 游标的方式</strong>找到下一个中间件并执行。我们采用类似的 hard coding 形式帮助大家理解 Express 插件作用机制：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">((req, res) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;第一个中间件&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  ((req, res) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;第二个中间件&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    (</span><span style="color:#B392F0;">async</span><span style="color:#E1E4E8;">(req, res) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;第三个中间件 =&gt; 是一个 route 中间件，处理 /api/test1&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">      await </span><span style="color:#B392F0;">sleep</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">2000</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">      res.</span><span style="color:#B392F0;">status</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">200</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;hello&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    })(req, res)</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;第二个中间件调用结束&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  })(req, res)</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;第一个中间件调用结束&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">})(req, res)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">((req, res) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;第一个中间件&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  ((req, res) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;第二个中间件&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    (</span><span style="color:#6F42C1;">async</span><span style="color:#24292E;">(req, res) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;第三个中间件 =&gt; 是一个 route 中间件，处理 /api/test1&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">      await </span><span style="color:#6F42C1;">sleep</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">2000</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">      res.</span><span style="color:#6F42C1;">status</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">200</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;hello&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    })(req, res)</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;第二个中间件调用结束&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  })(req, res)</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;第一个中间件调用结束&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">})(req, res)</span></span></code></pre></div><p>如上代码，Express 中间件设计并不是一个洋葱模型，它是基于回调实现的线形模型，不利于组合，不利于互操，在设计上并不像 Koa 一样简单。如果想实现一个记录请求响应的中间件，就需要：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> express </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;express&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> app </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">express</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> requestTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> (req, res, next) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  req.requestTime </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Date.</span><span style="color:#B392F0;">now</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">use</span><span style="color:#E1E4E8;">(requestTime)</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;/&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;"> (req, res) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> responseText </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Hello World!&lt;br&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#9ECBFF;">&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  responseText </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&lt;small&gt;Requested at: &#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> req.requestTime </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&lt;/small&gt;&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">  res.</span><span style="color:#B392F0;">send</span><span style="color:#E1E4E8;">(responseText)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">listen</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3000</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> express </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;express&#39;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> app </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">express</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> requestTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> (req, res, next) {</span></span>
<span class="line"><span style="color:#24292E;">  req.requestTime </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Date.</span><span style="color:#6F42C1;">now</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">app.</span><span style="color:#6F42C1;">use</span><span style="color:#24292E;">(requestTime)</span></span>
<span class="line"><span style="color:#24292E;">app.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;/&#39;</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;"> (req, res) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> responseText </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;Hello World!&lt;br&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#032F62;">&#39;</span></span>
<span class="line"><span style="color:#24292E;">  responseText </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&lt;small&gt;Requested at: &#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> req.requestTime </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&lt;/small&gt;&#39;</span></span>
<span class="line"><span style="color:#24292E;">  res.</span><span style="color:#6F42C1;">send</span><span style="color:#24292E;">(responseText)</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"><span style="color:#24292E;">app.</span><span style="color:#6F42C1;">listen</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3000</span><span style="color:#24292E;">)</span></span></code></pre></div><p>我们可以看到，上述实现就对业务代码有一定程度的侵扰，甚至会造成不同中间件间的耦合。</p><p>我们回退到&quot;上帝视角&quot;发现，毫无疑问 Koa 的洋葱模型更加先进，而<strong>Express 的线形机制不容易实现拦截处理逻辑</strong>：比如异常处理和统计响应时间------这在 Koa 里，一般只需要一个中间件就能全部搞定。</p><p>当然，Koa 本身只提供了 HTTP 模块和洋葱模型的最小封装，Express 是一种更高形式的抽象，其设计思路和面向目标也有不同。</p><h3 id="redux-中间件设计和实现" tabindex="-1">Redux 中间件设计和实现 <a class="header-anchor" href="#redux-中间件设计和实现" aria-label="Permalink to &quot;Redux 中间件设计和实现&quot;">​</a></h3><p>通过前文，我们了解了 Node.js 两个当红框架的中间件设计，我们再换一个角度：从 Redux 这个状态管理方案的中间件设计，了解更全面的中间件系统。</p><p>类似 Koa 中的 koa-compose 实现，Redux 也实现了一个<code>compose</code>方法，完成中间件的注册和串联：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(...funcs</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Function</span><span style="color:#E1E4E8;">[]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> funcs.</span><span style="color:#B392F0;">reduce</span><span style="color:#E1E4E8;">((a, b) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (...args</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> any) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">a</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">b</span><span style="color:#E1E4E8;">(...args)));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(...funcs</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Function</span><span style="color:#24292E;">[]) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> funcs.</span><span style="color:#6F42C1;">reduce</span><span style="color:#24292E;">((a, b) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (...args</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> any) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">a</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">b</span><span style="color:#24292E;">(...args)));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><code>compose</code>方法的执行效果如下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">([fn1, fn2, fn3])(args)</span></span>
<span class="line"><span style="color:#F97583;">=&gt;</span></span>
<span class="line"><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(fn1, fn2, fn3) (...args) </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn1</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn2</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn3</span><span style="color:#E1E4E8;">(...args)))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">([fn1, fn2, fn3])(args)</span></span>
<span class="line"><span style="color:#D73A49;">=&gt;</span></span>
<span class="line"><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(fn1, fn2, fn3) (...args) </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn1</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">fn2</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">fn3</span><span style="color:#24292E;">(...args)))</span></span></code></pre></div><p>简单来说，<code>compose</code>方法是一种高阶聚合，先执行 fn3，并将执行结果作为参数传给 fn2，以此类推。我们使用 Redux 创建一个 store 时，完成对<code>compose</code>方法的调用，Redux 精简源码类比为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 这是一个简单的打日志中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">logger</span><span style="color:#E1E4E8;">({ getState, dispatch }) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// next 代表下一个中间件包装过后的 dispatch 方法，action 表示当前接收到的动作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> next </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> action </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;before change&quot;</span><span style="color:#E1E4E8;">, action);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 调用下一个中间件包装的 dispatch </span></span>
<span class="line"><span style="color:#E1E4E8;">        let val </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(action);</span></span>
<span class="line"><span style="color:#E1E4E8;">        console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;after change&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">getState</span><span style="color:#E1E4E8;">(), val);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> val;</span></span>
<span class="line"><span style="color:#E1E4E8;">    };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 使用 logger 中间件，创建一个增强的 store</span></span>
<span class="line"><span style="color:#E1E4E8;">let createStoreWithMiddleware </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Redux.</span><span style="color:#B392F0;">applyMiddleware</span><span style="color:#E1E4E8;">(logger)(Redux.createStore)</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">applyMiddleware</span><span style="color:#E1E4E8;">(...middlewares) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// middlewares 为中间件列表，返回一个接受原始 createStore 方法（Redux.createStore）作为参数的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> createStore </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建原始的 store</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> store </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createStore</span><span style="color:#E1E4E8;">(...args)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 每个中间件都会被传入 middlewareAPI 对象，作为中间件参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> middlewareAPI </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      getState</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> store.getState,</span></span>
<span class="line"><span style="color:#E1E4E8;">      dispatch</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (...args) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(...args)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 给每个中间件传入 middlewareAPI 参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 中间件的统一模板为 next =&gt; action =&gt; next(action) 格式</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// chain 中保存的都是 next =&gt; action =&gt; {next(action)} 的方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> chain </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middlewares.</span><span style="color:#B392F0;">map</span><span style="color:#E1E4E8;">(middleware </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">middleware</span><span style="color:#E1E4E8;">(middlewareAPI))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 传入最原始 store.dispatch 方法，作为 compose 二级参数，compose 方法最终返回一个增强的dispatch 方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    dispatch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(...chain)(store.dispatch)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      ...store,</span></span>
<span class="line"><span style="color:#E1E4E8;">      dispatch  </span><span style="color:#6A737D;">// 返回一个增强版的 dispatch</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 这是一个简单的打日志中间件</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">logger</span><span style="color:#24292E;">({ getState, dispatch }) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// next 代表下一个中间件包装过后的 dispatch 方法，action 表示当前接收到的动作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> next </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> action </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;before change&quot;</span><span style="color:#24292E;">, action);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 调用下一个中间件包装的 dispatch </span></span>
<span class="line"><span style="color:#24292E;">        let val </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(action);</span></span>
<span class="line"><span style="color:#24292E;">        console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;after change&quot;</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">getState</span><span style="color:#24292E;">(), val);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> val;</span></span>
<span class="line"><span style="color:#24292E;">    };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 使用 logger 中间件，创建一个增强的 store</span></span>
<span class="line"><span style="color:#24292E;">let createStoreWithMiddleware </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Redux.</span><span style="color:#6F42C1;">applyMiddleware</span><span style="color:#24292E;">(logger)(Redux.createStore)</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">applyMiddleware</span><span style="color:#24292E;">(...middlewares) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// middlewares 为中间件列表，返回一个接受原始 createStore 方法（Redux.createStore）作为参数的函数</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> createStore </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建原始的 store</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> store </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createStore</span><span style="color:#24292E;">(...args)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 每个中间件都会被传入 middlewareAPI 对象，作为中间件参数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> middlewareAPI </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      getState</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> store.getState,</span></span>
<span class="line"><span style="color:#24292E;">      dispatch</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (...args) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(...args)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 给每个中间件传入 middlewareAPI 参数</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 中间件的统一模板为 next =&gt; action =&gt; next(action) 格式</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// chain 中保存的都是 next =&gt; action =&gt; {next(action)} 的方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> chain </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middlewares.</span><span style="color:#6F42C1;">map</span><span style="color:#24292E;">(middleware </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">middleware</span><span style="color:#24292E;">(middlewareAPI))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 传入最原始 store.dispatch 方法，作为 compose 二级参数，compose 方法最终返回一个增强的dispatch 方法</span></span>
<span class="line"><span style="color:#24292E;">    dispatch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(...chain)(store.dispatch)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      ...store,</span></span>
<span class="line"><span style="color:#24292E;">      dispatch  </span><span style="color:#6A737D;">// 返回一个增强版的 dispatch</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如上代码，我们将 Redux 中间件特点总结为：</p><ul><li><p>Redux 中间件接收<code>getState</code>和<code>dispatch</code>两个方法组成的对象作为参数；</p></li><li><p>Redux 中间件返回一个函数，该函数接收下一个<code>next</code>方法作为参数，并返回一个接收 action 的新的<code>dispatch</code>方法；</p></li><li><p>Redux 中间件通过手动调用<code>next(action)</code>方法，执行下一个中间件。</p></li></ul><p>我们将 Redux 的中间件作用机制总结为下图：</p>`,19),i=l(`<p>Redux 的中间件作用机制</p><p>看上去也像是一个洋葱圈模型，但是对于同步调用和异步调用稍有不同，以三个中间件为例。</p><ul><li><p>三个中间件均是正常同步调用<code>next(action)</code>，则执行顺序为：中间件 1 before next → 中间件 2 before next → 中间件 3 before next → dispatch 方法调用 → 中间件 3 after next → 中间件 2 after next → 中间件 1 after next。</p></li><li><p>第二个中间件没有调用<code>next(action)</code>，则执行顺序为：中间件 1 befoe next → 中间件 2 逻辑 → 中间件 1 after next，注意<strong>此时中间件 3 没有被执行</strong>。</p></li><li><p>第二个中间件异步调用<code>next(action)</code>，其他中间件均是正常同步调用<code>nextt(action)</code>，则执行顺序为：中间件 1 before next → 中间件 2 同步代码部分 → 中间件 1 after next → 中间件 2 异步代码部分 before next → 中间件 3 before next → dispatch 方法调用 → 中间件 3 after next → 中间件 2 异步代码部分 after next。</p></li></ul><h3 id="利用中间件思想-实现一个中间件化的-fetch-库" tabindex="-1">利用中间件思想，实现一个中间件化的 Fetch 库 <a class="header-anchor" href="#利用中间件思想-实现一个中间件化的-fetch-库" aria-label="Permalink to &quot;利用中间件思想，实现一个中间件化的 Fetch 库&quot;">​</a></h3><p>上面我们分析了前端中的中间件化思想，这一部分，我们活学活用，利用中间件思路，结合上一讲内容，实现一个中间件化的 Fetch 库。</p><p>我们先来思考一个中间件化的 Fetch 库有哪些优点呢？Fetch 库的核心实现请求的发送，而各种业务逻辑以中间件化的插件模式进行增强，这样一来，实现了特定业务需求和请求库的解耦，更加灵活，也是一种分层思想的体现。具体来说，一个中间件化的 Fetch 库：</p><ul><li><p>支持业务方递归扩展底层 Fetch API 能力；</p></li><li><p>方便测试；</p></li><li><p>一个中间件化的 Fetch 库，天然支持各类型的 Fetch 封装（比如 Native Fetch、fetch-ponyfill、fetch-polyfill 等）。</p></li></ul><p>我们给这个中间件化的 Fetch 库取名为：fetch-wrap，借助 <a href="https://github.com/benjamine/fetch-wrap" target="_blank" rel="noreferrer">fetch-wrap</a> 的实现，预期使用方式为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> fetchWrap </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;fetch-wrap&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 这里可以接入自己的核心 Fetch 底层实现，比如使用原生 Fetch，或同构的 isomorphic-fetch 等</span></span>
<span class="line"><span style="color:#E1E4E8;">let fetch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;isomorphic-fetch&#39;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 扩展 Fetch 中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">fetch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fetchWrap</span><span style="color:#E1E4E8;">(fetch, [</span></span>
<span class="line"><span style="color:#E1E4E8;">  middleware1,</span></span>
<span class="line"><span style="color:#E1E4E8;">  middleware2,</span></span>
<span class="line"><span style="color:#E1E4E8;">  middleware3,</span></span>
<span class="line"><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#6A737D;">// 一个典型的中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">middleware1</span><span style="color:#E1E4E8;">(url, options, innerFetch) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 业务扩展</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">innerFetch</span><span style="color:#E1E4E8;">(url, options);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 一个更改 URL 的中间件</span></span>
<span class="line"><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(url, options, fetch) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// modify url or options</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(url.</span><span style="color:#B392F0;">replace</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">/^</span><span style="color:#E1E4E8;">(http</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">?/</span><span style="color:#E1E4E8;">, </span><span style="color:#9ECBFF;">&#39;https:&#39;</span><span style="color:#E1E4E8;">), options);</span></span>
<span class="line"><span style="color:#E1E4E8;">},</span></span>
<span class="line"><span style="color:#6A737D;">// 一个修改返回结果的中间件</span></span>
<span class="line"><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(url, options, fetch) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(url, options).</span><span style="color:#B392F0;">then</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(response) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">response.ok) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Error</span><span style="color:#E1E4E8;">(result.status </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39; &#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> result.statusText);</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">application\\</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">json</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">test</span><span style="color:#E1E4E8;">(result.headers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;content-type&#39;</span><span style="color:#E1E4E8;">))) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	  }</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">text</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">	});</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 一个做错误处理的中间件</span></span>
<span class="line"><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(url, options, fetch) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// catch errors</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fetch</span><span style="color:#E1E4E8;">(url, options).</span><span style="color:#B392F0;">catch</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(err) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	  console.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(err);</span></span>
<span class="line"><span style="color:#E1E4E8;">	  </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> err;</span></span>
<span class="line"><span style="color:#E1E4E8;">	});</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> fetchWrap </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;fetch-wrap&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 这里可以接入自己的核心 Fetch 底层实现，比如使用原生 Fetch，或同构的 isomorphic-fetch 等</span></span>
<span class="line"><span style="color:#24292E;">let fetch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;isomorphic-fetch&#39;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#6A737D;">// 扩展 Fetch 中间件</span></span>
<span class="line"><span style="color:#24292E;">fetch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fetchWrap</span><span style="color:#24292E;">(fetch, [</span></span>
<span class="line"><span style="color:#24292E;">  middleware1,</span></span>
<span class="line"><span style="color:#24292E;">  middleware2,</span></span>
<span class="line"><span style="color:#24292E;">  middleware3,</span></span>
<span class="line"><span style="color:#24292E;">]);</span></span>
<span class="line"><span style="color:#6A737D;">// 一个典型的中间件</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">middleware1</span><span style="color:#24292E;">(url, options, innerFetch) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 业务扩展</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">innerFetch</span><span style="color:#24292E;">(url, options);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 一个更改 URL 的中间件</span></span>
<span class="line"><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(url, options, fetch) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// modify url or options</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fetch</span><span style="color:#24292E;">(url.</span><span style="color:#6F42C1;">replace</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">/^</span><span style="color:#24292E;">(http</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">?/</span><span style="color:#24292E;">, </span><span style="color:#032F62;">&#39;https:&#39;</span><span style="color:#24292E;">), options);</span></span>
<span class="line"><span style="color:#24292E;">},</span></span>
<span class="line"><span style="color:#6A737D;">// 一个修改返回结果的中间件</span></span>
<span class="line"><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(url, options, fetch) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fetch</span><span style="color:#24292E;">(url, options).</span><span style="color:#6F42C1;">then</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(response) {</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">response.ok) {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Error</span><span style="color:#24292E;">(result.status </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39; &#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> result.statusText);</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">application\\</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">json</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">test</span><span style="color:#24292E;">(result.headers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;content-type&#39;</span><span style="color:#24292E;">))) {</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> response.</span><span style="color:#6F42C1;">json</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">	  }</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> response.</span><span style="color:#6F42C1;">text</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">	});</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">// 一个做错误处理的中间件</span></span>
<span class="line"><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(url, options, fetch) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// catch errors</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fetch</span><span style="color:#24292E;">(url, options).</span><span style="color:#6F42C1;">catch</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(err) {</span></span>
<span class="line"><span style="color:#24292E;">	  console.</span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(err);</span></span>
<span class="line"><span style="color:#24292E;">	  </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> err;</span></span>
<span class="line"><span style="color:#24292E;">	});</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>核心实现也不困难，观察<code>fetchWrap</code>使用方式，我们实现源码为：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 接受第一个参数为基础 Fetch，第二个参数为中间件数组或单个中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">module.exports </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">fetchWrap</span><span style="color:#E1E4E8;">(fetch, middleware) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 没有使用中间件，则返回原生 fetch</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">middleware </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> middleware.length </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> fetch;</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">// 递归调用 extend 方法，每次递归时剔除出 middleware 数组中的首项</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> innerFetch </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middleware.length </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> fetch </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fetchWrap</span><span style="color:#E1E4E8;">(fetch, middleware.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">));</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middleware[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">extendedFetch</span><span style="color:#E1E4E8;">(url, options) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		  </span><span style="color:#6A737D;">// 每一个 Fetch 中间件通过 Promsie 来串联</span></span>
<span class="line"><span style="color:#E1E4E8;">		  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">(url, options </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> {}, innerFetch));</span></span>
<span class="line"><span style="color:#E1E4E8;">		} </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (err) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">reject</span><span style="color:#E1E4E8;">(err);</span></span>
<span class="line"><span style="color:#E1E4E8;">		}</span></span>
<span class="line"><span style="color:#E1E4E8;">	};</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 接受第一个参数为基础 Fetch，第二个参数为中间件数组或单个中间件</span></span>
<span class="line"><span style="color:#24292E;">module.exports </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">fetchWrap</span><span style="color:#24292E;">(fetch, middleware) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 没有使用中间件，则返回原生 fetch</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">middleware </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> middleware.length </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> fetch;</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">// 递归调用 extend 方法，每次递归时剔除出 middleware 数组中的首项</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> innerFetch </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middleware.length </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> fetch </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fetchWrap</span><span style="color:#24292E;">(fetch, middleware.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">));</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middleware[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">extendedFetch</span><span style="color:#24292E;">(url, options) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		  </span><span style="color:#6A737D;">// 每一个 Fetch 中间件通过 Promsie 来串联</span></span>
<span class="line"><span style="color:#24292E;">		  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">(url, options </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> {}, innerFetch));</span></span>
<span class="line"><span style="color:#24292E;">		} </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (err) {</span></span>
<span class="line"><span style="color:#24292E;">		  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">reject</span><span style="color:#24292E;">(err);</span></span>
<span class="line"><span style="color:#24292E;">		}</span></span>
<span class="line"><span style="color:#24292E;">	};</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们可以看到，每一个中间件都接收一个<code>url</code>和<code>options</code>参数，因此具有了改写<code>url</code>和<code>options</code>的能力；同时接收一个<code>innerFetch</code>方法，<code>innerFetch</code>为上一个中间件包装过的<code>fetch</code>方法，而每一个中间件也都返回一个包装过的<code>fetch</code>方法，将各个中间件依次调用串联。</p><p>另外，社区上的 <a href="https://www.npmjs.com/package/umi-request" target="_blank" rel="noreferrer">umi-request</a> 的中间件机制也是类似的，其核心代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Onion</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.middlewares </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [];</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 存储中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">use</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newMiddleware</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.middlewares.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(newMiddleware);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 执行中间件</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">execute</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">params</span><span style="color:#E1E4E8;"> = </span><span style="color:#FFAB70;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.middlewares);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(params);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">compose</span><span style="color:#E1E4E8;">(middlewares) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">wrapMiddlewares</span><span style="color:#E1E4E8;">(params) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    let index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    function </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(i) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> fn </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> middlewares[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">fn) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Promise.</span><span style="color:#B392F0;">resolve</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(params, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)));</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">dispatch</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">  };</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Onion</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.middlewares </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [];</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 存储中间件</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">use</span><span style="color:#24292E;">(</span><span style="color:#E36209;">newMiddleware</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.middlewares.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(newMiddleware);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 执行中间件</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">execute</span><span style="color:#24292E;">(</span><span style="color:#E36209;">params</span><span style="color:#24292E;"> = </span><span style="color:#E36209;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.middlewares);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(params);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">compose</span><span style="color:#24292E;">(middlewares) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">wrapMiddlewares</span><span style="color:#24292E;">(params) {</span></span>
<span class="line"><span style="color:#24292E;">    let index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    function </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(i) {</span></span>
<span class="line"><span style="color:#24292E;">      index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> fn </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> middlewares[i];</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">fn) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Promise.</span><span style="color:#6F42C1;">resolve</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(params, () </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)));</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">dispatch</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">  };</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们可以看到，上述源码更像 Koa 的实现了，但其实道理和上面的 fetch-wrap 大同小异。至此，相信你已经了解了中间件的思想，也能够体会洋葱模型的精妙设计。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲，我们通过分析前端不同框架的中间件设计，剖析了中间件化这一重要思想。中间件化意味着插件化，这也是上一讲提到的分层思想的一种实现，同时，这种实现思路灵活且扩展能力强，能够和核心逻辑相解耦，需要你细心体会。</p><p>本讲主要内容如下：</p>`,18),d=t("p",null,"在下一讲中，我们将继续围绕着代码设计中的灵活性和定制性这一话题展开，同时也给大家留一个思考题：你在平时开发中，见过或者使用过哪些插件化的工程或技术呢？欢迎在留言区和我分享你的观点，我们下一讲再见。",-1);function F(h,u,A,g,D,C){const s=o("Image");return e(),c("div",null,[E,n(s,{alt:"202127-92025.png",src:"https://s0.lgstatic.com/i/image6/M00/03/C9/Cgp9HWAfsPuAMXAzAAIE4xCY0WY258.png"}),a(),y,n(s,{alt:"202127-92020.png",src:"https://s0.lgstatic.com/i/image6/M00/03/C9/Cgp9HWAfsQuABGmXAAGNk0fcn-c946.png"}),a(),i,n(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/94/A4/CgqCHmAY-AqAIZqkAAO1O62z-y4965.png"}),a(),d])}const m=p(r,[["render",F]]);export{x as __pageData,m as default};
