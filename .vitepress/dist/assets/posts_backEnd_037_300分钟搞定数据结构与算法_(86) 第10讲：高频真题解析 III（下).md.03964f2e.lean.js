import{_ as e,j as t,o,g as i,k as a,h as l,s,Q as p}from"./chunks/framework.b3d8e22e.js";const us=JSON.parse('{"title":"例题分析二 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/037_300分钟搞定数据结构与算法/(86) 第10讲：高频真题解析 III（下).md","filePath":"posts/backEnd/037_300分钟搞定数据结构与算法/(86) 第10讲：高频真题解析 III（下).md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/037_300分钟搞定数据结构与算法/(86) 第10讲：高频真题解析 III（下).md"},r=s("h6",{id:"例题分析二",tabindex:"-1"},[l("例题分析二 "),s("a",{class:"header-anchor",href:"#例题分析二","aria-label":'Permalink to "例题分析二"'},"​")],-1),E=s("p",null,"LeetCode 第 84 题：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出来的矩形的最大面积。",-1),h=s("p",null,"说明：下图是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。",-1),y=p("",7),d=p("",7),_=s("ol",{start:"2"},[s("li",null,"遇到 1 的时候，由于 1 的高度低，造成以 2 为高度的矩形无法延伸到高度为 1 的柱子，即，可以计算高度为 2 的矩形面积。每当遇到一个下降的高度时，就可以开始计算以之前高度作为矩形高度的面积。")],-1),g=s("ol",{start:"3"},[s("li",null,"遇到更高的高度时，也不急计算以 1 为高度的矩形面积，因为 5 的下一个是 6，面积还能继续扩大。")],-1),u=s("ol",{start:"4"},[s("li",null,"再次遇到 2 时，按照之前的策略，可以计算以 6 为高度的矩形面积。")],-1),A=s("ol",{start:"5"},[s("li",null,"是否要计算以 5 作为高度的矩形面积呢？是的，因为 2 比 5 低，以 5 作为高度的矩形无法包含 2 这个点。该宽度如何计算呢？是不是就是 2 的下标减去 5 的下标就可以呢？")],-1),m=s("ol",{start:"6"},[s("li",null,"当计算完高度为 6 的矩形面积时，立即知道下一个高度是 5，以及 5 所对应的下标，可以利用一个 stack 来帮助记录。（注意：此处在整个算法里都很重要。）")],-1),k=s("ol",{start:"7"},[s("li",null,"计算完了以 5 作为高度的矩形面积后，还剩下 1，由于 2 比 1 高，表明后面可能还有更高的点，而以 1 为高度的矩形还能扩展。")],-1),C=s("ol",{start:"8"},[s("li",null,"下一个比 2 还高，于是继续保留它在 stack 里。")],-1),B=s("p",null,"到这里，所有的柱子都遍历完了，如何处理剩下的 3 根柱子呢？",-1),f=s("p",null,"以新的柱子高度为 0，由于 0 低于任何一根柱子的高度，那么对剩下的柱子计算，以它们的高度作为边的矩形的面积。",-1),P=s("ul",null,[s("li",null,[s("p",null,"指针停留在下标为 6 的地方，堆栈里记录的是三根柱子的下标：5，4，1。")]),s("li",null,[s("p",null,"跟之前计算其他柱子的情况一样，先将堆栈里的下标弹出，第一个弹出的是 5。")]),s("li",null,[s("p",null,"然后比它矮的那根柱子的下标一定是堆栈目前顶端的那个，也就是 4。")]),s("li",null,[s("p",null,"因此以 3 作为高度的矩形的宽度就是：i - 1 - 4 = 6 - 1 - 4 = 1，那么面积就是 3 x 1 = 3。")])],-1),S=s("p",null,"剩下的 2 根柱子，方法同样，目前 stack 里的值是：4，1。",-1),b=s("p",null,"把下标 4 弹出，得知比这根柱子还要矮的柱子的下标一定是 stack 顶端的值，也就是 1。",-1),q=s("p",null,"那么以高度 2 作为矩形高度的矩形宽度就是：i - 1 - 1 = 6 - 1 - 1 = 4，面积就是 2 x 4 = 8。",-1),I=s("p",null,"最后处理剩下 1 的柱子。",-1),D=p("",23),T=p("",14),M=p("",9),x=s("p",{"0000120":""},"LPS =",-1),j=p("",10),L=s("ol",null,[s("li",null,[s("p",null,"haystack 里面的空格和 needle 里的 D 不相等时，在 needle 里，D 前面的字符串 ABCDAB 与 haystack 中对应的字符串是相等的。")]),s("li",null,[s("p",null,"ABCDAB 的 LPS 为 2，即，对于 ABCDAB ，它最后两个字符一定与它最前面两个字符相等。")]),s("li",null,[s("p",null,"若把最前面的两个字符挪到最后两个字符的位置，可以保证 AB 位置绝对能和 haystack 配对。")])],-1),V=s("p",null,"那么，为什么不需要去比较前面的位置？",-1),v=s("p",null,"例如：",-1),O=s("p",null,"例如：",-1),w=s("p",null,"因为没有必要。下面通过反证法来证明。将下图所示情况用抽象成为方块图形来表示。",-1),N=s("p",null,"其中红色的方块表示不相同的字符，分别对应 haystack 中的空格以及 needle 当中的 D 字符；而绿色的方块表示相同的最大前缀和后缀，对应字符串里的 AB。",-1),K=s("p",null,"现在，假设向右挪动了，使得 needle 能与 haystack 完美地匹配，如下所示，可以标出 haystack 与 needle 完美匹配时的关系。即，在 haystack 和 needle 里，有一段区间 A，它们是相同的。",-1),Q=s("p",null,"那么，needle 里，红色方块前的一段区间其实和 needle 开头的一段区间是相同的，它们都是 A，如下所示。",-1),R=s("p",null,'即，红色方块前的 needle 字符串，A 是共同的前缀和后缀。而它比两个绿色的方块要长得多，这与之前定义的"两个绿色方块是最长的公共前缀和后缀"相互矛盾。',-1),F=s("p",null,"因此，当知道两个绿色的方块就是最大的公共前缀和后缀时，可以放心地进行跳跃操作，而不必担心会错过完全匹配的情况发生。完美匹配不可能在跳跃的区间内发生。",-1),G=s("p",null,"那么，具体在算法上如何进行跳跃操作呢？",-1),J=p("",17),Y=s("p",null,"当 i 扫描到这个位置的时候，len=4，表明在 i 之前的字符串里，最长的前缀和后缀长度是 4，也就是那 4 个绿色的方块。",-1),W=s("p",null,"现在 needle[i] 不等于 needle[4]，怎么计算 LPS[i] 呢？",-1),Z=s("p",null,"既然无法构成长度为5的最长前缀和后缀，那便尝试构成长度为 4，3，或者 2 的前缀和后缀，但做法并非像暴力法一样逐个尝试比较，而是通过 LPS[len - 1] 得知下一个最长的前缀和后缀的长度是什么。举例说明如下。",-1),H=p("",8),U=s("ol",null,[s("li",null,"一开始，初始化 LPS 数组全部为 0。")],-1),X=s("p",null,"规定前缀和后缀不能是同一个字符串，所以从第二个字符开始扫描，此时 len = 0，i = 1。AD 字符串的最长公共前缀和后缀为 0，因为 A 不等于 D，所以 LPS[1] = 0。",-1),z=s("ol",{start:"2"},[s("li",null,"移动到 C。同样，对于 ADC ，最长的公共前缀和后缀也是 0，所以 LPS[2] = 0，此时，len 变量一直是 0。")],-1),$=s("ol",{start:"3"},[s("li",null,"移动到 A，此时 i=3。")],-1),ss=s("p",null,"对于字符串 ADCA，因为 needle[len] = needle[3]，所以执行代码 lps[i++] = ++len，也就是把 len+1 赋给 lps[i]，然后 i + 1，len + 1，表明对于字符串 ADCA，最长的公共前缀和后缀的长度为 1。",-1),ns=s("ol",{start:"4"},[s("li",null,"接下来到 D，此时 i = 4，len = 1。")],-1),as=s("p",null,"同样，由于 needle[len] 等于 needle[i]，都是字符 D，所以再次执行代码 lps[i++] = ++len，这样一来，lps[4] 就等于 2，表明对于字符串 ADCAD，最长的公共前缀和后缀长度是 2。",-1),ls=s("ol",{start:"5"},[s("li",null,"接下来是 B，此时 i = 5，len = 2。")],-1),ps=s("p",null,"needle[len] ='C'，而 needle[i] ='B'，两者不相等，同时，len 大于 0，将 len 修改为 lps[len - 1]，取出字符串 AD 的最长公共前缀和后缀的长度，也就是 0。当循环再次进行，needle[len] 仍不等于 neele[i]，因此对于 ADCADB ，最长的公共前缀后缀长度为 0。",-1),es=s("p",null,[s("strong",null,"建议"),l("：以上基本概括了 KMP 的算法思想和精髓，其实 KMP 的代码实现是很精妙的，建议大家不要去死记硬背，通过理解去帮助记忆。")],-1),ts=s("h6",{id:"结语",tabindex:"-1"},[l("结语 "),s("a",{class:"header-anchor",href:"#结语","aria-label":'Permalink to "结语"'},"​")],-1),os=s("p",null,"这节课讲解了三道比较难的题目，其中正规表达式以及 KMP 算法是重中之重。",-1),is=s("br",null,null,-1);function cs(rs,Es,hs,ys,ds,_s){const n=t("Image");return o(),i("div",null,[r,E,h,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaBmANhiBAAAvRVLSdAM365.png"}),y,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaBqAT7fLAHGVT_G-HGE157.gif"}),d,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaBqAXPBJAA5Vx5kRvrI712.gif"}),_,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaBuAQ_G7AB8iyyFhsP8537.gif"}),g,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaBuAanh5ABOPEuDQKbE900.gif"}),u,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaByAHgaZABWZDxwJlTo840.gif"}),A,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaByAQjMCAByIrvLjjAM248.gif"}),m,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaByAfZyzAABI-qF4lwQ735.png"}),k,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaB2ACxD_AC1iHvcGTv8971.gif"}),C,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaB2AS6txACaMXIPm9-I299.gif"}),B,f,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaB6AZDoqAB3_QEbtXrY350.gif"}),l(),P,S,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaB6AWUQNACIE9DZQPyI414.gif"}),l(),b,q,I,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaB6AMiybAByyazYRVgg510.gif"}),l(),D,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaB-AZrqFAIWMuevJfbs428.gif"}),l(),T,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCCAEy-TABNB_IdI3Eg442.gif"}),M,x,j,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCCAJ39aAERYoGxb1p0088.gif"}),l(),L,V,v,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCGAZUF4AAAhUwmoEAc094.png"}),O,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCGAJrCpAAAk60Qcsyw360.png"}),l(),w,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCGACDXcAB5wm3NTrb4729.gif"}),l(),N,K,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCKAeEE4AI6KeO453eY927.gif"}),l(),Q,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCOAJzQ0ACMA3QOrN2A725.gif"}),R,F,G,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCOAcfWEAHw9WU7AYQY830.gif"}),J,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCSATVZPACdhTz792dg446.gif"}),l(),Y,W,Z,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCSAVpIQAFEf-VyP6-A314.gif"}),H,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCWAYemSAGbI_2HuWFE739.gif"}),U,X,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCaATxS8ABYXnYXhN1Y816.gif"}),z,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCaAEnHyACFGv5D5WL4879.gif"}),$,ss,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/91/04/CgotOV2IaCaAPe83ACKGclsUKCA865.gif"}),ns,as,a(n,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/90/E4/CgoB5l2IaCeAW6P4AEhZHBJ_UJQ849.gif"}),ls,ps,es,ts,os,is])}const As=e(c,[["render",cs]]);export{us as __pageData,As as default};
