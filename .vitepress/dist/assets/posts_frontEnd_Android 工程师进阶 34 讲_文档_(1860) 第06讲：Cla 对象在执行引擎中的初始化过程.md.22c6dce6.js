import{_ as o,j as i,o as e,g as c,k as t,h as s,s as l,Q as n}from"./chunks/framework.4e7d56ce.js";const Ll=JSON.parse('{"title":"第06讲：Cla对象在执行引擎中的初始化过程","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1860) 第06讲：Cla 对象在执行引擎中的初始化过程.md","filePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1860) 第06讲：Cla 对象在执行引擎中的初始化过程.md","lastUpdated":1696417798000}'),p={name:"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1860) 第06讲：Cla 对象在执行引擎中的初始化过程.md"},r=l("h1",{id:"第06讲-cla对象在执行引擎中的初始化过程",tabindex:"-1"},[s("第06讲：Cla对象在执行引擎中的初始化过程 "),l("a",{class:"header-anchor",href:"#第06讲-cla对象在执行引擎中的初始化过程","aria-label":'Permalink to "第06讲：Cla对象在执行引擎中的初始化过程"'},"​")],-1),_=l("p",null,"在上一课时我详细介绍了 ClassLoader 的使用，包括它的主要作用就是用来将 class 字节码加载到内存中。那 JVM 加载 class 文件的具体过程是怎样的呢？本课时我们就来了解一下这一详细过程以及当中存在的问题。",-1),h=l("br",null,null,-1),d=l("p",null,"一个 class 文件被加载到内存中需要经过 3 大步：装载、链接、初始化。其中链接又可以细分为：验证、准备、解析 3 小步。因此用一张图来描述 class 文件加载到内存的步骤如下所示。",-1),u=l("br",null,null,-1),g=n('<p><strong>装载</strong></p><h3 id="什么是装载" tabindex="-1">什么是装载 <a class="header-anchor" href="#什么是装载" aria-label="Permalink to &quot;什么是装载&quot;">​</a></h3><p>装载是指 Java 虚拟机查找 .class 文件并生成字节流，然后根据字节流创建 java.lang.Class 对象的过程。</p><p>这一过程主要完成以下 3 件事：</p><br><p>1）ClassLoader 通过一个类的全限定名（包名 + 类名）来查找 .class 文件，并生成二进制字节流：其中 class 字节码文件的来源不一定是 .class 文件，也可以是 jar 包、zip 包，甚至是来源于网络的字节流。</p><br><p>2）把 .class 文件的各个部分分别解析（parse）为 JVM 内部特定的数据结构，并存储在方法区。</p><p>还记得在课时 03 中介绍的 .class 文件结构吗？在这里 JVM 会将这些 .class 文件的结构转化为 JVM 内部的运行时数据结构。这点同 JSON 解析过程有点类似：如果你做过 Android 开发，应该都使用过 GsonFormat 将后端开发返回的 JSON 结构转化为一个运行时 Bean 类，当程序运行时使用这个 Bean 类去解析处理 JSON 数据。</p><br><p>3）在内存中创建一个 java.lang.Class 类型的对象：</p><p>接下来程序在运行过程中所有对该类的访问都通过这个类对象，也就是这个 Class 类型的类对象是提供给外界访问该类的接口。</p><h3 id="加载时机" tabindex="-1">加载时机 <a class="header-anchor" href="#加载时机" aria-label="Permalink to &quot;加载时机&quot;">​</a></h3><p>一个项目经过编译之后，往往会生成大量的 .class 文件。当程序运行时，JVM 并不会一次性的将这些 .class 文件全部加载到内存中。那 JVM 是什么时候加载某 .class 文件呢？对此，Java 虚拟机规范中并没有严格规定，不同的虚拟机实现会有不同实现。不过以下两种情况一般会对 class 进行装载操作。</p><ul><li><p>隐式装载：在程序运行过程中，当碰到通过 new 等方式生成对象时，系统会隐式调用 ClassLoader 去装载对应的 class 到内存中；</p></li><li><p>显示装载：在编写源代码时，主动调用 Class.forName() 等方法也会进行 class 装载操作，这种方式通常称为显示装载。</p></li></ul><h1 id="链接" tabindex="-1">链接 <a class="header-anchor" href="#链接" aria-label="Permalink to &quot;链接&quot;">​</a></h1><p>链接过程分为 3 步：验证、准备、解析。</p><h3 id="验证" tabindex="-1">验证： <a class="header-anchor" href="#验证" aria-label="Permalink to &quot;验证：&quot;">​</a></h3><p>验证是链接的第一步，目的是为了确保 .class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危及虚拟机本身的安全。主要包含以下几个方面的检验。</p><ol><li><p>文件格式检验：检验字节流是否符合 class 文件格式的规范，并且能被当前版本的虚拟机处理。</p></li><li><p>元数据检验：对字节码描述的信息进行语义分析，以保证其描述的内容符合 Java 语言规范的要求。</p></li><li><p>字节码检验：通过数据流和控制流分析，确定程序语义是合法、符合逻辑的。</p></li><li><p>符号引用检验：符号引用检验可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</p></li></ol><br><p>实例分析：</p><p>我使用以下 Foo.java 来演示验证阶段的几种情况：</p><br>',24),b=l("br",null,null,-1),A=l("p",null,"使用 javac 编译 Foo.java 生成 Foo.class 字节码文件，然后使用 16 进制编辑器打开 Foo.class 文件，部分如下：",-1),C=l("br",null,null,-1),m=l("br",null,null,-1),v=l("p",null,"正常情况下，使用 java Foo 执行结果如下：",-1),q=l("br",null,null,-1),M=l("br",null,null,-1),k=l("p",null,"如果使用 16 进制编辑器修改 class 文件中的魔数，如下所示：",-1),f=l("br",null,null,-1),T=l("br",null,null,-1),V=l("p",null,[s('将"cafe bab'),l("strong",null,"e"),s(' "修改为"cafe bab'),l("strong",null,"b"),s('"，重新运行则会报如下错误：')],-1),P=l("br",null,null,-1),E=l("br",null,null,-1),J=l("p",null,'class 文件中魔数后的"0034"为版本号，如果将其修改为"0035"则会报如下错误：',-1),x=l("br",null,null,-1),O=l("br",null,null,-1),j=l("p",null,'版本号"0034"之后的"0036"是常量池计数器，表示常量池中有 54 个常量。如果将这个值进行修改也有可能造成运行时错误，比如我将"0036"改为"0032"：',-1),F=l("br",null,null,-1),I=l("br",null,null,-1),S=l("p",null,"重新执行 java Foo，则会报如下错误：",-1),w=l("br",null,null,-1),y=l("br",null,null,-1),D=l("p",null,"虽说 JVM 会检查各种对 class 字节码文件的篡改行为，但是依然无法百分百保证 class 文件的安全性。比如我还是用 Foo.java 举例，在 Foo.java 中的 print 方法中，分别打印出父类的自身类的 hashCode 值，分别是：2018699554 和 111。我们可以在 class 字节码的基础上进行篡改，将父类的 hashCode 也返回 111。",-1),N=l("br",null,null,-1),B=l("p",null,"通过 javap -v Foo 命令可以查看Foo.class 中常量池的具体信息：",-1),X=l("br",null,null,-1),L=l("br",null,null,-1),G=l("p",null,"因为篇幅原因，我只截取了部分常量池的内容。图中 1 处指向了父类 Object的hashCode 方法，图中 2 处指向了 Foo 的 hashCode 方法。在课时 03 中，我们了解已经了解了 CONSTANT_Methodref_info 结构如下：",-1),R=l("br",null,null,-1),K=l("br",null,null,-1),U=l("p",null,"其中 class_index 就是指向方法的所属类（图中为 16，转化为 16 进制为 0X10），因此只需要使用 16 进制编辑器将指向 Object 的 class_index 改为执行 Foo 的 class_index 即可。具体修改如下：",-1),W=l("br",null,null,-1),z=l("br",null,null,-1),Y=l("p",null,"将图中 0X10 改为 0X02 并保存，重新运行 java Foo 效果如下：",-1),Z=l("br",null,null,-1),Q=n('<br><p>可以看出，虽然在 Java 源文件中调用的是 super.hashCode() 方法，但是经过篡改之后，Foo.class 文件成功通过 JVM 的校验，并成功执行最终打印出我们想要的结果。</p><br><blockquote><p><strong>注意</strong> ：上面的实例也说明即使没有 Java 源文件，在某种程度上，工程师还是可以对编译之后的 class 字节码文件进行篡改。这也是为什么我们在项目中经常会使用混淆，甚至是使用一些三方的加固软件，来保证我们所编写的代码的安全性。</p></blockquote><h3 id="准备" tabindex="-1">准备 <a class="header-anchor" href="#准备" aria-label="Permalink to &quot;准备&quot;">​</a></h3><p>准备是链接的第 2 步，这一阶段的主要目的是为类中的静态变量分配内存，并为其设置&quot;0值&quot;。比如：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">public static int value = 100;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">public static int value = 100;</span></span></code></pre></div><br><p>在准备阶段，JVM 会为 value 分配内存，并将其设置为 0。而真正的值 100 是在初始化阶段设置。并且此阶段进行内存分配的仅包括类变量，而不包括实例变量（实例变量将会在对象实例化时随着对象一起分配在 Java 堆中）。</p><br><p>有一种情况比较特殊--静态常量，比如：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">public static final int value = 100;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">public static final int value = 100;</span></span></code></pre></div><br><p>以上代码会在准备阶段就为 value 分配内存，并设置为 100。</p><br><p>Java 中基本类型的默认&quot;0值&quot;如下：</p><ul><li><p>基本类型（int、long、short、char、byte、boolean、float、double）的默认值为 0；</p></li><li><p>引用类型默认值是 null；</p></li></ul><h3 id="解析" tabindex="-1">解析 <a class="header-anchor" href="#解析" aria-label="Permalink to &quot;解析&quot;">​</a></h3><p>解析是链接的最后一步，这一阶段的任务是把常量池中的符号引用转换为直接引用，也就是具体的内存地址。在这一阶段，JVM 会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。</p><br><p>比如上面 Foo.java 中编译之后 main 方法的字节码如下：</p><br>',24),$=n('<br><p>在 main 方法中通过 invokevirtual 指令调用了 print 方法，&quot;Foo.print:()V&quot;就是一个<strong>符号引用</strong>，当</p><p>main 方法执行到此处时，会将<strong>符号引用</strong> &quot;Foo.print:()V&quot;解析（resolve）成<strong>直接引用</strong>，可以将直接引用理解为方法真正的内存地址。</p><blockquote><p>对于符号引用和直接引用，可以将其与生活中的微信聊天进行类比，在微信好友列表中，保存的是好友的名称或者别名（也就是符号引用），当我们真正给某个好友发消息时，计算机（JVM）会根据好友的名称找到对象计算机的 IP 地址（直接引用）并成功将消息发送给这一地址。</p></blockquote><h1 id="初始化" tabindex="-1"><strong>初始化</strong> <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;**初始化**&quot;">​</a></h1><p>这是 class 加载的最后一步，这一阶段是执行类构造器&lt;clinit&gt;方法的过程，并真正初始化类变量。比如：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">public static int value = 100;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">public static int value = 100;</span></span></code></pre></div><br><p>在准备阶段 value 被分配内存并设置为 0，在初始化阶段 value 就会被设置为 100。</p><h3 id="初始化的时机" tabindex="-1">初始化的时机 <a class="header-anchor" href="#初始化的时机" aria-label="Permalink to &quot;初始化的时机&quot;">​</a></h3><p>对于装载阶段，JVM 并没有规范何时具体执行。但是对于初始化，JVM 规范中严格规定了 class 初始化的时机，主要有以下几种情况会触发 class 的初始化：</p><ol><li><p>虚拟机启动时，初始化包含 main 方法的主类；</p></li><li><p>遇到 new 指令创建对象实例时，如果目标对象类没有被初始化则进行初始化操作；</p></li><li><p>当遇到访问静态方法或者静态字段的指令时，如果目标对象类没有被初始化则进行初始化操作；</p></li><li><p>子类的初始化过程如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；</p></li><li><p>使用反射 API 进行反射调用时，如果类没有进行过初始化则需要先触发其初始化；</p></li><li><p>第一次调用 java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。</p></li></ol><h3 id="初始化类变量" tabindex="-1">初始化类变量 <a class="header-anchor" href="#初始化类变量" aria-label="Permalink to &quot;初始化类变量&quot;">​</a></h3><p>在初始化阶段，只会初始化与类相关的静态赋值语句和静态语句，也就是有 static 关键字修饰的信息，而没有 static 修饰的语句块在实例化对象的时候才会执行。</p><br><p>比如以下代码：</p><br>',18),H=l("br",null,null,-1),ll=l("p",null,"然后在 ClassInitTest.java 中访问 ClassInit 的 value 值，如下：",-1),sl=l("br",null,null,-1),al=l("br",null,null,-1),tl=l("p",null,"执行上述代码，打印日志如下：",-1),nl=l("br",null,null,-1),ol=l("br",null,null,-1),il=l("p",null,"可以看出，非静态代码块并没有被执行。如果将 ClassInitTest.java 修改如下：",-1),el=l("br",null,null,-1),cl=l("br",null,null,-1),pl=l("p",null,"加了一行代码，使用 new 创建 ClassInit 对象实例。再次执行后非静态代码块也将会被执行，如下：",-1),rl=l("br",null,null,-1),_l=l("h3",{id:"被动引用",tabindex:"-1"},[s("被动引用 "),l("a",{class:"header-anchor",href:"#被动引用","aria-label":'Permalink to "被动引用"'},"​")],-1),hl=l("p",null,"上述的 6 种情况在 JVM 中被称为主动引用，除此 6 种情况之外所有引用类的方式都被称为被动引用。被动引用并不会触发 class 的初始化。",-1),dl=l("br",null,null,-1),ul=l("p",null,"最典型的就是在子类中调用父类的静态变量，比如有以下两个类：",-1),gl=l("br",null,null,-1),bl=l("br",null,null,-1),Al=l("p",null,"可以看出 Child 继承自 Parent 类，如果直接使用 Child 来访问 Parent 中的 value 值，则不会初始化 Child 类，比如如下代码：",-1),Cl=l("br",null,null,-1),ml=l("br",null,null,-1),vl=l("p",null,"执行上述代码，打印如下效果：",-1),ql=l("br",null,null,-1),Ml=n('<br><p>可以看出，Child 中的静态代码块并没有被执行。也就是说 JVM 并没有对 Child 执行初始化操作。</p><br><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类 Child 来引用父类 Parent 中定义的静态字段，只会触发父类 Parent 的初始化而不会触发子类 Child 的初始化。至于是否要触发子类的加载和验证，在虚拟机规范中并未明确规定，可以通过 XX:+TraceClassLoading 参数来查看，比如使用如下命令再次执行 NonInitTest：</p><br><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> java -XX:+TraceClassLoading NonInitTest</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> java -XX:+TraceClassLoading NonInitTest</span></span></code></pre></div><br><p>查看部分打印日志如下：</p><br>',9),kl=l("br",null,null,-1),fl=l("p",null,"可以看出，虽然只有 Parent 被初始化，但是 Parent 和 Child 都经过了装载和验证阶段，并被加载到内存中。",-1),Tl=l("h3",{id:"class-初始化和对象的创建顺序",tabindex:"-1"},[s("class 初始化和对象的创建顺序 "),l("a",{class:"header-anchor",href:"#class-初始化和对象的创建顺序","aria-label":'Permalink to "class 初始化和对象的创建顺序"'},"​")],-1),Vl=l("p",null,"关于 class 的初始化还有一点经常会在面试中被提及，那就是对象的初始化顺序。当我们在代码中使用 new 创建一个类的实例对象时，类中的静态代码块、非静态代码块、构造函数之间的执行顺序是怎样的。",-1),Pl=l("br",null,null,-1),El=l("p",null,"比如以下代码：",-1),Jl=l("br",null,null,-1),xl=l("br",null,null,-1),Ol=l("p",null,"在 main 方法中执行了 2 次 new Child() 的操作，执行上述代码结果如下：",-1),jl=l("br",null,null,-1),Fl=n('<br><p>总结一下对象的初始化顺序如下：</p><br><p>静态变量/静态代码块 -&gt; 普通代码块 -&gt; 构造函数</p><br><ol><li><p>父类静态变量和静态代码块；</p></li><li><p>子类静态变量和静态代码块；</p></li><li><p>父类普通成员变量和普通代码块；</p></li><li><p>父类的构造函数；</p></li><li><p>子类普通成员变量和普通代码块；</p></li><li><p>子类的构造函数。</p></li></ol><h1 id="更多参考链接" tabindex="-1">更多参考链接： <a class="header-anchor" href="#更多参考链接" aria-label="Permalink to &quot;更多参考链接：&quot;">​</a></h1><p><a href="https://www.zhihu.com/question/50258991" target="_blank" rel="noreferrer">JVM符号引用转换直接引用的过程?</a></p><p><a href="https://www.zhihu.com/question/30300585/answer/51335493" target="_blank" rel="noreferrer">JVM里的符号引用如何存储？</a></p><p><a href="https://mp.weixin.qq.com/s/fyvoraVu9yjgqX-xhn6EHQ" target="_blank" rel="noreferrer">大话Java对象在虚拟机中是什么样子？</a></p><p><a href="https://www.jianshu.com/p/252e27863822" target="_blank" rel="noreferrer">JVM源码分析之Java类的加载过程</a></p><h1 id="总结" tabindex="-1">总结： <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结：&quot;">​</a></h1><p>这节课主要介绍了 .class 文件被加载到内存中所经过的详细过程，主要分 3 大步：装载、链接、初始化。其中链接中又包含验证、准备、解析 3 小步。</p><ol><li><p>装载：指查找字节流，并根据此字节流创建类的过程。装载过程成功的标志就是在方法区中成功创建了类所对应的 Class 对象。</p></li><li><p>链接：指验证创建的类，并将其解析到 JVM 中使之能够被 JVM 执行。</p></li><li><p>初始化：则是将标记为 static 的字段进行赋值，并且执行 static 标记的代码语句 。</p></li></ol>',14);function Il(Sl,wl,yl,Dl,Nl,Bl){const a=i("Image");return e(),c("div",null,[r,_,h,d,u,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nSAXgX1AAAk3WIjy2w291.png"}),s(),g,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D1/Ciqah16O2nSAJocBAADgYuyGOFU999.png"}),s(),b,A,C,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nWANuvpAAApn9LjU8s780.png"}),s(),m,v,q,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D1/Ciqah16O2nWAG6BOAABEYPJ8hek260.png"}),s(),M,k,f,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nWAPl9cAAAs9S7kJ_c137.png"}),s(),T,V,P,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D1/Ciqah16O2naAQjT5AADGlnL5k7A260.png"}),s(),E,J,x,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2naAfq32AAB95xhaALs362.png"}),s(),O,j,F,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2naAUFkGAAA5qpcpOSM316.png"}),s(),I,S,w,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2naAULaGAACadz947b8809.png"}),s(),y,D,N,B,X,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2neAAOe1AAJwxaI8-S4783.png"}),s(),L,G,R,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0E/D8/Ciqah16UV3qAYt1KAABuPCIKTow208.png"}),s(),K,U,W,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2neAWnwhAAVg9nz8YBo810.png"}),s(),z,Y,Z,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2niAfLMnAABEpLbahOQ771.png"}),s(),Q,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2niAFbl-AAZKjAhPB7w610.png"}),s(),$,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2niACR1GAAC2wv7KhD0731.png"}),s(),H,ll,sl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2niAMOi0AABFdWfyf9s889.png"}),s(),al,tl,nl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2niAKdPPAAA_96Fc0k4956.png"}),s(),ol,il,el,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2nmAXN-MAABZ6A11FAM000.png"}),s(),cl,pl,rl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nmAFkfRAABMo8lXf2s110.png"}),s(),_l,hl,dl,ul,gl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2nmAIKBAAACF2GZgmfk860.png"}),s(),bl,Al,Cl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nmAVynGAABCPhsxYGo296.png"}),s(),ml,vl,ql,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2nqAfjh_AAA9zL-pVWk200.png"}),s(),Ml,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2nqAKlcRAAF9sRIloM8054.png"}),s(),kl,fl,Tl,Vl,Pl,El,Jl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/E8/Cgq2xl6O2nqAU3hkAAGuvZZy92w313.png"}),s(),xl,Ol,jl,t(a,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/D2/Ciqah16O2nqAVJwFAACr-a4rpis859.png"}),s(),Fl])}const Gl=o(p,[["render",Il]]);export{Ll as __pageData,Gl as default};
