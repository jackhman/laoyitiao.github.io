import{_ as l,j as t,o as e,g as c,k as a,h as n,Q as p,s}from"./chunks/framework.e0c66c3f.js";const T=JSON.parse('{"title":"xDS 概念介绍 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/微服务Service Mesh原理与实战_文档/(6008) 15  xDS：控制面和数据面的通信桥梁.md","filePath":"posts/backEnd/微服务Service Mesh原理与实战_文档/(6008) 15  xDS：控制面和数据面的通信桥梁.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/微服务Service Mesh原理与实战_文档/(6008) 15  xDS：控制面和数据面的通信桥梁.md"},E=p("",32),y=p("",17),u=s("p",null,"xDS 通信示例图",-1),i=s("h4",{id:"ack-和-nack",tabindex:"-1"},[n("ACK 和 NACK "),s("a",{class:"header-anchor",href:"#ack-和-nack","aria-label":'Permalink to "ACK 和 NACK"'},"​")],-1),q=s("p",null,"在收到 Management Server 推送的新版本数据后，Envoy 会响应 ACK 或者 NACK 告知 Management Server 是否更新版本成功。ACK 代表更新版本成功，这时会携带 Management Server 推送的最新版本号发送 ACK 信息；NACK 代表更新版本失败，这时会携带旧的版本号发送 NACK 信息。",-1),F=s("p",null,"xDS ACK 和 NACK",-1),_=s("h4",{id:"资源更新",tabindex:"-1"},[n("资源更新 "),s("a",{class:"header-anchor",href:"#资源更新","aria-label":'Permalink to "资源更新"'},"​")],-1),d=s("p",null,"如果发现的数据出现变化，依赖发现数据的其他配置就要及时更新。举个简单的例子，比如 CDS 的 Cluster 集群信息发生了变化，那就意味着用户要订阅的服务列表发生了变化，因此需要通过 EDS 的服务发现信息，传递新订阅的集群信息到 EDS。如下图所示 ，比如最早用户只订阅了 foo 这个服务，但是这时 CDS 传递了新的 bar 服务给到了 Envoy，这时就需要往 EDS 发送 foo 和 bar 两个服务的订阅信息。",-1),C=s("p",null,"xDS 资源更新图",-1),g=s("p",null,"我们来看一下上述例子在现实中是如何发生的。服务 A 原本依赖服务 foo，但经过了一次版本更新，服务 A 同时依赖服务 foo 和服务 bar，这个时候 CDS 就会推送 foo 和 bar 的信息给到 Envoy，Envoy 就会让 EDS 进行资源更新。",-1),h=s("p",null,"需要注意的是，Discovery Request 除了首次用来进行资源订阅，后面基本上都是用来做 ACK 或者 NACK 确认的。那么上面的资源更新操作是如何进行的呢？",-1),D=s("p",null,"Discovery Request 会在 ACK 之后用相同的 version_info 发送额外的 Discovery Request 信息，让 Management Server 更新资源信息。在上面的例子中，它会为版本 X 额外发送一个 resource_names，作为 {foo, bar} 数据的 Discovery Request 。",-1),A=s("p",null,"但是，你需要注意的是，这里可能会发生冲突。比如 Management Server 在收到 V=X 的确认消息后，foo 服务的 EndPoints 信息发生了变化，这时 Management Server 会推送一个新版本 V=Y 的消息给 Envoy，如果 Envoy 发送 V=X 的新资源订阅消息给 Management Server，Management Server 可能会误认为 Envoy 拒绝了 V=Y 的新版本推送。",-1),v=s("p",null,"那么如何解决这个问题呢？ Envoy 引入了 Nonce，每个请求和响应都对应唯一的 Nonce，因为 Envoy 的新订阅消息携带的 Nonce 是 A，而 Management Server 返回的 V=Y 的 Nonce 是 B，所以并不会误认为是 Envoy 拒绝了新数据的更新。",-1),B=s("p",null,"Envoy 的这个设计我觉得有点绕，实际上在 Istio 的控制面中，也就是这里的 Management Server，并没有完全遵守上面提到的 Nonce 和 version_info 的约定，而是采用了一种更简单、直白的方式解决上面提到的冲突问题。Istio 判断了传递的 resource_names 的 Clusters 信息是否发生变化，如果发生变化，则不认为是 ACK 或者 NACK，直接当作资源更新处理。显然这样的逻辑更易于理解。",-1),m=s("p",null,"xDS 资源更新冲突解决流程图",-1),S=s("h3",{id:"总结",tabindex:"-1"},[n("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),f=s("p",null,"这一讲我主要介绍了 Service Mesh 中数据面和控制面的通信桥梁------xDS 协议，通过 xDS 协议我们可以做到 discovery everything，所有配置都可以通过发现的方式解决，这是 Envoy xDS 架构为微服务世界带来的重大变革。",-1),b=s("p",null,"本讲内容总结如下：",-1),k=s("p",null,"今天内容到这里就结束了，下一讲我会讲解如何在 Istio 中实现 Ingress 和 Egress：入口流量和出口流量控制。",-1),x=s("p",null,"通过今天讲解的内容，我们了解到 xDS 协议定义了 CDS、RDS、EDS、LDS 以及 SDS 等协议，你觉得微服务架构中还有没有其他需要发现的配置呢? 欢迎在留言区和我分享你的观点，我们下一讲再见！",-1);function P(M,N,R,K,L,I){const o=t("Image");return e(),c("div",null,[E,a(o,{alt:"1.png",src:"https://s0.lgstatic.com/i/image6/M00/04/11/CioPOWAgaeGAV88FAABUD-WDbLo434.png"}),n(),y,a(o,{alt:"2.png",src:"https://s0.lgstatic.com/i/image6/M00/04/12/CioPOWAga4-Acz8JAAA5ANCS2mM316.png"}),n(),u,i,q,a(o,{alt:"3.png",src:"https://s0.lgstatic.com/i/image6/M00/04/14/Cgp9HWAga6WAZ6EKAABMxj-jcj0709.png"}),n(),F,_,d,a(o,{alt:"4.png",src:"https://s0.lgstatic.com/i/image6/M00/04/14/Cgp9HWAga7iAbk0kAABV1-Y8KRg664.png"}),n(),C,g,h,D,A,v,B,a(o,{alt:"5.png",src:"https://s0.lgstatic.com/i/image6/M00/04/12/CioPOWAga9GAZZU-AACOaIjoR34044.png"}),n(),m,S,f,b,a(o,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image6/M00/02/EB/Cgp9HWAePWSAZLGUAAGVKEXA-L4203.png"}),k,x])}const V=l(r,[["render",P]]);export{T as __pageData,V as default};
