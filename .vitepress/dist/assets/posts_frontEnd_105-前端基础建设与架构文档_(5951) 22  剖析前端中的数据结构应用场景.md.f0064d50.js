import{_ as a,j as l,o as p,g as o,k as e,Q as t,s}from"./chunks/framework.e0c66c3f.js";const A=JSON.parse('{"title":"堆栈和队列的应用 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/105-前端基础建设与架构文档/(5951) 22  剖析前端中的数据结构应用场景.md","filePath":"posts/frontEnd/105-前端基础建设与架构文档/(5951) 22  剖析前端中的数据结构应用场景.md","lastUpdated":1696338709000}'),c={name:"posts/frontEnd/105-前端基础建设与架构文档/(5951) 22  剖析前端中的数据结构应用场景.md"},r=t(`<p>上一讲我们使用 JavaScript 实现了几种常见的数据结构。事实上，前端领域到处体现着数据结构的应用，尤其随着需求的复杂度上升，前端工程师越来越离不开数据结构。React、Vue 这些设计精巧的框架，在线文档编辑系统、大型管理系统，甚至一个简单的检索需求，都离不开数据结构的支持。是否能够掌握这个难点内容，将是进阶的重要考量。</p><p>这一讲，我们就来解析数据结构在前端中的应用场景，以此来帮助大家加深理解，做到灵活应用。</p><h3 id="堆栈和队列的应用" tabindex="-1">堆栈和队列的应用 <a class="header-anchor" href="#堆栈和队列的应用" aria-label="Permalink to &quot;堆栈和队列的应用&quot;">​</a></h3><p>关于栈和队列的实际应用比比皆是：</p><ul><li><p>浏览器的历史记录，因为回退总是回退&quot;上一个&quot;最近的页面，它需要遵循栈的原则；</p></li><li><p>类似浏览器的历史记录，任何 Undo/Redo 都是一个栈的实现；</p></li><li><p>在代码中，广泛应用的递归产生的调用栈，同样也是栈思想的体现，想想我们常说的&quot;栈溢出&quot;就是这个道理；</p></li><li><p>同上，浏览器在抛出异常时，常规都会抛出调用栈信息；</p></li><li><p>在计算机科学领域应用广泛，如进制转换、括号匹配、栈混洗、表达式求值等；</p></li><li><p>队列的应用更为直观，我们常说的宏任务/微任务都是队列，不管是什么类型的任务，都是先进先执行；</p></li><li><p>后端也应用广泛，如消息队列、RabbitMQ、ActiveMQ 等，能起到延迟缓冲的功效。</p></li></ul><p>另外，与性能话题相关，HTTP 1.1 有一个队头阻塞的问题，而原因就在于队列这样的数据结构的特点。具体来说，在 HTTP 1.1 中，每一个链接都默认是长链接，因此对于同一个 TCP 链接，HTTP 1.1 规定：<strong>服务端的响应返回顺序需要遵循其接收到相应的顺序</strong>。但这样存在一个问题：如果第一个请求处理需要较长时间，响应较慢，将会&quot;拖累&quot;其他后续请求的响应，这是一种队头阻塞。</p><p>HTTP 2 采用了<strong>二进制分帧和多路复用</strong>等方法，同域名下的通信都在同一个连接上完成，在这个连接上可以并行请求和响应，而互不干扰。</p><p>在框架层面，堆栈和队列的应用更是比比皆是。比如 React 的 Context 特性，参考以下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> React from &quot;react&quot;;</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> ContextValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> React.</span><span style="color:#B392F0;">createContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">App</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ContextValue.Provider value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">}</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ContextValue.Consumer</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        {(value1) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ContextValue.Provider value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">{</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">}</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ContextValue.Consumer</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">              {(value2) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> (</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">span</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">                  {value1}</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">{value2}</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">span</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">              )}</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">ContextValue.Consumer</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">ContextValue.Provider</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        )}</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">ContextValue.Consumer</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">ContextValue.Provider</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> React from &quot;react&quot;;</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> ContextValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> React.</span><span style="color:#6F42C1;">createContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">App</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ContextValue.Provider value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">}</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ContextValue.Consumer</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        {(value1) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ContextValue.Provider value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">{</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">}</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ContextValue.Consumer</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">              {(value2) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> (</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">span</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">                  {value1}</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">{value2}</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">span</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">              )}</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">ContextValue.Consumer</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">ContextValue.Provider</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">        )}</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">ContextValue.Consumer</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">ContextValue.Provider</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>对于以上代码，React 内部就是通过一个栈结构，在构造 Fiber 树时的 beginWork 阶段，将 Context.Provider 数据状态入栈（此时 value1：1 和 value2：2 分别入栈），在 completeWork 阶段，将栈中的数据状态出栈，以供给 Context.Consumer 消费。关于 React 源码中，栈的实现，你可以参考<a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberStack.old.js" target="_blank" rel="noreferrer">这部分源码。</a></p><h3 id="链表的应用" tabindex="-1">链表的应用 <a class="header-anchor" href="#链表的应用" aria-label="Permalink to &quot;链表的应用&quot;">​</a></h3><p>React 的核心算法<strong>Fiber 的实现就是链表</strong> 。React 最早开始使用大名鼎鼎的 Stack Reconciler 调度算法，Stack Reconciler 调度算法最大的问题在于：它就像函数调用栈一样，递归地、自顶向下进行 diff 和 render 相关操作，在 Stack Reconciler 执行的过程中，该调度算法始终会占据浏览器主线程。也就是说<strong>在此期间，用户的交互所触发的布局行为、动画执行任务都不会得到立即响应，从而影响用户体验</strong>。</p><p>因此 React Fiber 将渲染和更新过程进行了拆解，简单来说，就是每次检查虚拟 DOM 的一小部分，在检查间隙会检查&quot;是否还有时间继续执行下一个虚拟 DOM 树上某个分支任务&quot;，同时观察是否有更优先的任务需要响应。如果&quot;没有时间执行下一个虚拟 DOM 树上某个分支任务&quot;，且某项任务有更高优先级，React 就会让出主线程，直到主线程&quot;不忙&quot;的时候继续执行任务。</p><p>React Fiber 的实现也很简单，它将 Stack Reconciler 过程分成块，一次执行一块，执行完一块需要将结果保存起来，根据是否还有空闲的响应时间（requestIdleCallback）来决定下一步策略。当所有的块都已经执行完，就进入提交阶段，这个阶段需要更新 DOM，它是一口气完成的。</p><p>以上是比较主观的介绍，下面我们来看更具体的实现。</p><p>为了达到&quot;随意中断调用栈并手动操作调用栈&quot;，React Fiber 专门用于 React 组件堆栈调用的重新实现，也就是说一个 Fiber 就是一个虚拟堆栈帧，一个 Fiber 的结构类似：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">FiberNode</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">  tag</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> WorkTag,</span></span>
<span class="line"><span style="color:#E1E4E8;">  pendingProps</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> mixed,</span></span>
<span class="line"><span style="color:#E1E4E8;">  key</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> string,</span></span>
<span class="line"><span style="color:#E1E4E8;">  mode</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> TypeOfMode,</span></span>
<span class="line"><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// Instance</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.tag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tag;                       </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// Fiber</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.return </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.sibling </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.ref </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.pendingProps </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> pendingProps;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.memoizedProps </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.updateQueue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.memoizedState </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.dependencies </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// Effects</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.alternate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">FiberNode</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">  tag</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> WorkTag,</span></span>
<span class="line"><span style="color:#24292E;">  pendingProps</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> mixed,</span></span>
<span class="line"><span style="color:#24292E;">  key</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> string,</span></span>
<span class="line"><span style="color:#24292E;">  mode</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> TypeOfMode,</span></span>
<span class="line"><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// Instance</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.tag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tag;                       </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// Fiber</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.return </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.sibling </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.ref </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.pendingProps </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> pendingProps;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.memoizedProps </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.updateQueue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.memoizedState </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.dependencies </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// Effects</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.alternate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这么看<strong>Fiber 就是一个对象，通过 parent、children、sibling 维护一个树形关系</strong> ，同时 parent、children、sibling 也都是一个 Fiber 结构，FiberNode.alternate 这个属性来存储上一次渲染过的结果，事实上<strong>整个 Fiber 模式就是一个链表</strong>。React 也借此，从依赖于内置堆栈的同步递归模型，变为具有链表和指针的异步模型了。</p><p>具体的渲染过程：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> function </span><span style="color:#B392F0;">renderNode</span><span style="color:#E1E4E8;">(node) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 判断是否需要渲染该节点，如果 props 发生变化，则调用 render</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.memoizedProps </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> node.pendingProps) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">render</span><span style="color:#E1E4E8;">(node)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 是否有子节点，进行子节点渲染</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.child </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node.child</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 是否有兄弟节点，进行兄弟点渲染</span></span>
<span class="line"><span style="color:#E1E4E8;">   } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.sibling </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node.sibling</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 没有子节点和兄弟节点</span></span>
<span class="line"><span style="color:#E1E4E8;">   } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (node.return </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node.return</span></span>
<span class="line"><span style="color:#E1E4E8;">   } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">workloop</span><span style="color:#E1E4E8;">(root) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   nextNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> root</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (nextNode </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (no other high priority task)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      nextNode </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">renderNode</span><span style="color:#E1E4E8;">(nextNode)</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> function </span><span style="color:#6F42C1;">renderNode</span><span style="color:#24292E;">(node) {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 判断是否需要渲染该节点，如果 props 发生变化，则调用 render</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.memoizedProps </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> node.pendingProps) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">render</span><span style="color:#24292E;">(node)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 是否有子节点，进行子节点渲染</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.child </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node.child</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 是否有兄弟节点，进行兄弟点渲染</span></span>
<span class="line"><span style="color:#24292E;">   } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.sibling </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node.sibling</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 没有子节点和兄弟节点</span></span>
<span class="line"><span style="color:#24292E;">   } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (node.return </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node.return</span></span>
<span class="line"><span style="color:#24292E;">   } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">workloop</span><span style="color:#24292E;">(root) {</span></span>
<span class="line"><span style="color:#24292E;">   nextNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> root</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (nextNode </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (no other high priority task)) {</span></span>
<span class="line"><span style="color:#24292E;">      nextNode </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">renderNode</span><span style="color:#24292E;">(nextNode)</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>注意在 Workloop 当中，while 条件<code>nextNode !== null &amp;&amp; (no other high priority task)</code>，这是<strong>描述 Fiber 工作原理的关键伪代码</strong>。</p><p>下面我们换个角度再次说明。</p><p>在 Fiber 之前，React 递归遍历虚拟 DOM，在遍历过程中找到前后两颗虚拟 DOM 的差异，并生成一个 Mutation。这种递归遍历有一个局限性：每次递归都会在栈中<strong>添加一个同步帧</strong>，因此无法将遍历过程拆分为粒度更小的工作单元，也就无法暂停组件的更新，并在未来的某段时间恢复更新。</p><p>如何不通过递归的形式去遍历呢？基于链表的 Fiber 模型应运而生。最早的原始模型你可以在 2016 年的 <a href="https://github.com/facebook/react/issues/7942?source=post_page---------------------------#issue-182373497" target="_blank" rel="noreferrer">issue</a> 中找到。另外，React 中的 Hooks，也是通过链表这个数据结构实现的。</p><h3 id="树的应用" tabindex="-1">树的应用 <a class="header-anchor" href="#树的应用" aria-label="Permalink to &quot;树的应用&quot;">​</a></h3><p>从应用上来看，我们前端开发离不开的 DOM 就是一个树状结构；同理，不管是 React 还是 Vue 的虚拟 DOM 也都是树。</p><p>上文中我们提到了 React Element 树和 Fiber 树，React Element 树其实就是各级组件渲染，调用 React.createElement 返回 React Element 之后（每一个 React 组件，不管是 class 组件或 functional 组件，调用一次 render 或执行一次 function，就会生成 React Element 节点）的总和。</p><p>React Element 树和 Fiber 树是在 reconciler 过程中，相互交替，逐级构造进行的。这个生成过程，就<strong>采用了 DFS 遍历</strong> ，主要源码位于 <a href="https://github.com/facebook/react/blob/v17.0.1/packages/react-reconciler/src/ReactFiberWorkLoop.old.js#L1558" target="_blank" rel="noreferrer">ReactFiberWorkLoop.js</a> 中。我这里进行简化，你可以清晰看到 DFS 过程：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">workLoopSync</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 开始循环</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (workInProgress </span><span style="color:#F97583;">!==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">(workInProgress);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">function </span><span style="color:#B392F0;">performUnitOfWork</span><span style="color:#E1E4E8;">(unitOfWork</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> Fiber)</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> current </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> unitOfWork.alternate;</span></span>
<span class="line"><span style="color:#E1E4E8;">  let next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// beginWork 阶段，向下遍历子孙组件</span></span>
<span class="line"><span style="color:#E1E4E8;">  next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">beginWork</span><span style="color:#E1E4E8;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (next </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// completeUnitOfWork 是向上回溯树阶段</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">completeUnitOfWork</span><span style="color:#E1E4E8;">(unitOfWork);</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    workInProgress </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> next;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">workLoopSync</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 开始循环</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (workInProgress </span><span style="color:#D73A49;">!==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">(workInProgress);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">function </span><span style="color:#6F42C1;">performUnitOfWork</span><span style="color:#24292E;">(unitOfWork</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Fiber)</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> current </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> unitOfWork.alternate;</span></span>
<span class="line"><span style="color:#24292E;">  let next;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// beginWork 阶段，向下遍历子孙组件</span></span>
<span class="line"><span style="color:#24292E;">  next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">beginWork</span><span style="color:#24292E;">(current, unitOfWork, subtreeRenderLanes);</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (next </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// completeUnitOfWork 是向上回溯树阶段</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">completeUnitOfWork</span><span style="color:#24292E;">(unitOfWork);</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    workInProgress </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> next;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>另外，React 中，当 context 数据状态改变时，需要<strong>找出依赖该 context 数据状态的所有子节点，以进行状态变更和渲染</strong> 。这个过程，也是一个 DFS，源码你可以参考 <a href="https://github.com/facebook/react/blob/v17.0.1/packages/react-reconciler/src/ReactFiberNewContext.old.js#L182-L295" target="_blank" rel="noreferrer">ReactFiberNewContext.js</a>。</p><p>继续树的应用这个话题，上一讲中我们介绍了二叉搜索树，这里我们来介绍字典树这个概念，并说明其应用场景。</p><p>字典树（Trie）是针对特定类型的搜索而优化的树数据结构。典型的例子是 AutoComplete（自动填充），也就是说它适合实现&quot;<strong>通过部分值得到完整值</strong>&quot;的场景。因此字典树也是一种搜索树，我们有时候也叫作前缀树，因为任意一个节点的后代都存在共同的前缀。当然，更多基础概念需要你提前了解。</p><p>我们总结一下它的特点：</p><ul><li><p>字典树能做到高效查询和插入，时间复杂度为 O(k)，k 为字符串长度；</p></li><li><p>但是如果大量字符串没有共同前缀，就很耗内存，你可以想象一下最极端的情况，所有单词都没有共同前缀时，这颗字典树会是什么样子；</p></li><li><p>字典树的核心就是<strong>减少不必要的字符比较，提高查询效率</strong>，也就是说用空间换时间，再利用共同前缀来提高查询效率。</p></li></ul><p>除了我们刚刚提到的 AutoComplete 自动填充的情况，字典树还有很多其他应用场景：</p><ul><li><p>搜索</p></li><li><p>分类</p></li><li><p>IP 地址检索</p></li><li><p>电话号码检索</p></li></ul><p>字典树的实现也不复杂，我们可以一步步来，首先实现一个字典树上的节点，如下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PrefixTreeNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 存储子节点</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.children </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {}</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.isEnd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> value</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PrefixTreeNode</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">(</span><span style="color:#E36209;">value</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 存储子节点</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.children </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {}</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.isEnd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.value </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> value</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>一个字典树继承 PrefixTreeNode 类，如下代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PrefixTree</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PrefixTreeNode</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">constructor</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PrefixTree</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PrefixTreeNode</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">constructor</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">null</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>我们可以通过下述方法实现：</p><ul><li>addWord：创建一个字典树节点，如下代码：</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">addWord</span><span style="color:#E1E4E8;">(str) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> addWordHelper </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (node, str) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 当前 node 不含当前 str 开头的目标</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">node.children[str[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例</span></span>
<span class="line"><span style="color:#E1E4E8;">            node.children[str[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]] </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PrefixTreeNode</span><span style="color:#E1E4E8;">(str[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">])</span></span>
<span class="line"><span style="color:#E1E4E8;">            if (str.length </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                node.children[str[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]].isEnd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (str.length </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">addWordHelper</span><span style="color:#E1E4E8;">(node.children[str[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]], str.</span><span style="color:#B392F0;">slice</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">addWordHelper</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, str)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">addWord</span><span style="color:#24292E;">(str) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> addWordHelper </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (node, str) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 当前 node 不含当前 str 开头的目标</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">node.children[str[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]]) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 以当前 str 开头的第一个字母，创建一个 PrefixTreeNode 实例</span></span>
<span class="line"><span style="color:#24292E;">            node.children[str[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]] </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PrefixTreeNode</span><span style="color:#24292E;">(str[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">])</span></span>
<span class="line"><span style="color:#24292E;">            if (str.length </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                node.children[str[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]].isEnd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">            } </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (str.length </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">addWordHelper</span><span style="color:#24292E;">(node.children[str[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]], str.</span><span style="color:#6F42C1;">slice</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">addWordHelper</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, str)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>predictWord：给定一个字符串，返回字典树中以该字符串开头的所有单词，如下代码：</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">predictWord</span><span style="color:#E1E4E8;">(str) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    let getRemainingTree </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(str, tree) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      let node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tree</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (str) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        node </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> node.children[str[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]]</span></span>
<span class="line"><span style="color:#E1E4E8;">        str </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> str.</span><span style="color:#B392F0;">substr</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> node</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 该数组维护所有以 str 开头的单词</span></span>
<span class="line"><span style="color:#E1E4E8;">    let allWords </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">    let allWordsHelper </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">function</span><span style="color:#E1E4E8;">(stringSoFar, tree) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (let k in tree.children) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> child </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> tree.children[k]</span></span>
<span class="line"><span style="color:#E1E4E8;">        let newString </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> stringSoFar </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> child.value</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (child.endWord) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          allWords.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(newString)</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">allWordsHelper</span><span style="color:#E1E4E8;">(newString, child)</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    let remainingTree </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getRemainingTree</span><span style="color:#E1E4E8;">(str, </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (remainingTree) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">allWordsHelper</span><span style="color:#E1E4E8;">(str, remainingTree)</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> allWords</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">predictWord</span><span style="color:#24292E;">(str) {</span></span>
<span class="line"><span style="color:#24292E;">    let getRemainingTree </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(str, tree) {</span></span>
<span class="line"><span style="color:#24292E;">      let node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tree</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (str) {</span></span>
<span class="line"><span style="color:#24292E;">        node </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> node.children[str[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]]</span></span>
<span class="line"><span style="color:#24292E;">        str </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> str.</span><span style="color:#6F42C1;">substr</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> node</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 该数组维护所有以 str 开头的单词</span></span>
<span class="line"><span style="color:#24292E;">    let allWords </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#24292E;">    let allWordsHelper </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">function</span><span style="color:#24292E;">(stringSoFar, tree) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (let k in tree.children) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> child </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> tree.children[k]</span></span>
<span class="line"><span style="color:#24292E;">        let newString </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> stringSoFar </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> child.value</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (child.endWord) {</span></span>
<span class="line"><span style="color:#24292E;">          allWords.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(newString)</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">allWordsHelper</span><span style="color:#24292E;">(newString, child)</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    let remainingTree </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getRemainingTree</span><span style="color:#24292E;">(str, </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (remainingTree) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">allWordsHelper</span><span style="color:#24292E;">(str, remainingTree)</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> allWords</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>至此，我们实现了一个字典树的数据结构。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲，我们针对上一讲中的经典数据结构，结合前端应用场景进行了逐一分析。我们能够看到，无论是框架还是业务代码，都离不开数据结构的支持。数据结构也是计算机编程领域中一个最基础也是最重要的概念，它既是重点，也是难点。</p><p>本讲内容总结如下：</p>`,49),E=s("p",null,"说到底，数据结构的真正意义在于应用，这里给大家留一个思考题，你还在哪些场景看见过数据结构呢？欢迎在留言区和我分享你的观点。",-1),y=s("p",null,"下一讲，我们就正式进入前端架构设计的实战部分，这也是本专栏的核心环节，是对之前所学知识的综合运用和设计，请继续保持学习！",-1);function i(d,F,u,g,C,h){const n=l("Image");return p(),o("div",null,[r,e(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image6/M01/04/F9/CioPOWAvaxqAbp7IAAFyTqrjeO4673.png"}),E,y])}const f=a(c,[["render",i]]);export{A as __pageData,f as default};
