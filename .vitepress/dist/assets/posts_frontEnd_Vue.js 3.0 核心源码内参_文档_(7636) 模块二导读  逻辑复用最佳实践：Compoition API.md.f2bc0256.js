import{_ as t,o as s,g as e,s as o,h as n}from"./chunks/framework.a0d18f64.js";const V=JSON.parse('{"title":"模块二导读逻辑复用最佳实践：CompoitionAPI","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Vue.js 3.0 核心源码内参_文档/(7636) 模块二导读  逻辑复用最佳实践：Compoition API.md","filePath":"posts/frontEnd/Vue.js 3.0 核心源码内参_文档/(7636) 模块二导读  逻辑复用最佳实践：Compoition API.md","lastUpdated":1696682708000}'),i={name:"posts/frontEnd/Vue.js 3.0 核心源码内参_文档/(7636) 模块二导读  逻辑复用最佳实践：Compoition API.md"},_=o("h1",{id:"模块二导读逻辑复用最佳实践-compoitionapi",tabindex:"-1"},[n("模块二导读逻辑复用最佳实践：CompoitionAPI "),o("a",{class:"header-anchor",href:"#模块二导读逻辑复用最佳实践-compoitionapi","aria-label":'Permalink to "模块二导读逻辑复用最佳实践：CompoitionAPI"'},"​")],-1),a=o("p",null,"你好，我是你的 Vue.js 老师，黄轶。",-1),p=o("p",null,"在课前导读《一文看懂 Vue.js 3.0 的优化》中，我们讲到 Vue.js 3.0 设计了一个很强大的 API ------ Composition API，它主要用来优化代码逻辑的组织和复用。",-1),r=o("p",null,"从语法上看，它提供了一个 setup 启动函数作为逻辑组织的入口，暴露了响应式 API 为用户所用，也提供了生命周期函数以及依赖注入的接口，这让我们不依托于 Options API 也可以完成一个组件的开发，并且更有利于代码逻辑的组织和复用。",-1),c=o("p",null,"但是我们要明确一点，Composition API 属于 API 的增强，它并不是 Vue.js 3.0 组件开发的范式，如果你的组件足够简单，你还是可以使用 Options API。",-1),d=o("p",null,"了解了 Composition API 的应用场景和使用方式后，我们需要进一步思考，这样一套 API 是如何设计出来的？它是怎么和组件配合的？在组件整个渲染过程中它又做了哪些事情？带着这些疑问，我们一起来学习这一模块的内容，探索 Composition API 的实现原理。",-1),l=[_,a,p,r,c,d];function m(P,u,A,I,h,f){return s(),e("div",null,l)}const j=t(i,[["render",m]]);export{V as __pageData,j as default};
