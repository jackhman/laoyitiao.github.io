import{_ as t,j as l,o,g as p,k as a,Q as e,s}from"./chunks/framework.b3d8e22e.js";const b=JSON.parse('{"title":"Tomcat 架构基础 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1734) 第15讲：Tomcat 插件原理精析，看 SkyWalking 如何增强这只 Cat（上）.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1734) 第15讲：Tomcat 插件原理精析，看 SkyWalking 如何增强这只 Cat（上）.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1734) 第15讲：Tomcat 插件原理精析，看 SkyWalking 如何增强这只 Cat（上）.md"},r=e("",6),i=s("p",null,"每个 Service 都会包含两个部分：Connector 和 Container，其中 Connector 用于处理连接相关的事情，并提供 Socket 与 Request 和 Response 相关的转化。Container 用于封装和管理Servlet，以及具体处理 Request 请求的业务。",-1),E=s("p",null,"一个 Service 可以有多个 Connector 连接器，这主要是因为一个服务可以支持多种网络协议，如下图所示的 HTTP、HTTPS 等，当然也可以在不同端口支持相同的协议。我们在工作中写 Spring MVC Controller 时用到的 HttpRequest 和 HttpResponse 对象就是由 Connector 创建的，这些 HTTP 请求的后续处理，则是由 Container 来负责的。",-1),y=s("p",null,"SkyWalking 提供的 tomcat-7.x-8.x-plugin 插件与 Tomcat Connector 组件没有任何关系，这里不再深入剖析 Connector 的原理，只要知道其功能是处理 Socket 网络连接与 Reques 和 Response 之间的转换即可。",-1),g=s("p",null,"Container 是容器的父接口，所有子容器都必须实现这个接口。Tomcat 中有四个子容器组件，分别是：Engine、Host、Context、Wrapper，这四个组件之间不是平行关系，而是父子关系。Engine 包含 Host，Host 包含 Context，Context 包含 Wrapper。下面是四个 Container 的核心功能。",-1),_=s("ul",null,[s("li",null,"Engine：用于管理多个站点，一个 Service 最多只能有一个 Engine。"),s("li",null,"Host：代表一个站点，也可以叫虚拟主机，通过在 server.xml 配置文件就可以添加 Host，一个 Host 下可以运行多个 Context，但是在实践中，单 JVM 的处理能力有限，一般一个 Tomcat 实例只会配置一个 Host，也只会配置一个 Context。"),s("li",null,"Context：代表一个应用程序，对应你在日常开发的一个 Web 应用。Context 最重要的功能就是管理它里面的 Servlet 实例，并为 Request 匹配正确的 Servlet。Servlet 实例在 Context 中是以 Wrapper 出现的。"),s("li",null,"Wrapper：一个 Wrapper 负责管理一个 Servlet，包括 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了。")],-1),u=s("p",null,"下面这张图大致展示了从 Connector 开始接收请求，经过 Engine、Host、Context、Wrapper，最终到 Servlet 的流程，这里需要关注的是拿到 Request 请求对象之后的处理：",-1),C=s("p",null,"Container 中真正处理请求的是 Valve，一组 Valve 组成一个 Pipeline，这是典型的责任链模式。责任链模式是指在一个请求处理的过程中会有很多处理器依次对请求进行处理，每个处理器只负责处理自己相应的部分，当对应的部分被处理完成之后，会将请求交给下一个处理器继续处理，直至请求完全处理完成。",-1),d=s("p",null,"以现实生活中汽车组装为例，整个责任链就像是汽车的生产线，责任链上的每个处理器则对应每个组装车间，每个组装车间只组装汽车的一部分，如下图所示：",-1),m=s("p",null,"在每个 Container 的 Pipeline 中，我们可以增加任意多个 Valve，处理请求的 Tomcat 线程会依次执行这些 Valve，并最终完成请求的处理。在上图中我们可以看到，每个 Pipeline 都有一个特定的 Valve（即图中的 StandEngineValve、StandHostValve、StandContextValve、StandWrapperValve），而且这些 Valve 是在 Pipeline 中最后一个执行，这种 Valve 叫作BaseValve。我们可以在 Tomcat 的 server.xml 文件中自定义 Pipeline 中的 Valve，但上述四个 BaseValve 是不可删除的。这些 BaseValve 会负责调用子容器的 Pipeline，将请求传给子容器，以保证处理逻辑能继续向下执行。Valve 接口与四个标准 Valve 实现的继承关系如下图所示：",-1),h=e("",7),x=e("",3),T=e("",5);function k(v,A,S,P,V,D){const n=l("Image");return o(),p("div",null,[r,a(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image3/M01/0A/5A/CgoCgV6nzhOAav2wAAJz0wrnIb8899.png"}),i,E,y,g,_,u,a(n,{alt:"2.png",src:"https://s0.lgstatic.com/i/image3/M01/0A/5B/CgoCgV6nzlmAEVwIAAL7sBPspMA637.png"}),C,d,a(n,{alt:"3.png",src:"https://s0.lgstatic.com/i/image3/M01/0A/5B/CgoCgV6nzmmAcpAbAACdLrM19_c471.png"}),m,a(n,{alt:"4.png",src:"https://s0.lgstatic.com/i/image3/M01/17/89/Ciqah16nznSAYGnWAAETh59IW7M573.png"}),h,a(n,{alt:"5.png",src:"https://s0.lgstatic.com/i/image3/M01/17/8A/Ciqah16nzs-AaQEyAANfduRtXP8265.png"}),x,a(n,{alt:"6.png",src:"https://s0.lgstatic.com/i/image3/M01/17/8A/Ciqah16nzu2AXC4aAACqCsqjVe0795.png"}),T])}const F=t(c,[["render",k]]);export{b as __pageData,F as default};
