import{_ as t,j as s,o as p,g as n,k as r,s as e,h as l,Q as a}from"./chunks/framework.b3d8e22e.js";const W=JSON.parse('{"title":"Zab 一致性协议 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/分布式技术原理与实战45讲_文档/(1902) 第04讲：ZooKeeper 如何保证数据一致性？.md","filePath":"posts/backEnd/分布式技术原理与实战45讲_文档/(1902) 第04讲：ZooKeeper 如何保证数据一致性？.md","lastUpdated":1696417798000}'),i={name:"posts/backEnd/分布式技术原理与实战45讲_文档/(1902) 第04讲：ZooKeeper 如何保证数据一致性？.md"},d=e("p",null,"在分布式场景中，ZooKeeper 的应用非常广泛，比如数据发布和订阅、命名服务、配置中心、注册中心、分布式锁等。",-1),_=e("br",null,null,-1),b=e("p",null,"ZooKeeper 提供了一个类似于 Linux 文件系统的数据模型，和基于 Watcher 机制的分布式事件通知，这些特性都依赖 ZooKeeper 的高容错数据一致性协议。",-1),c=e("br",null,null,-1),h=e("p",null,"那么问题来了，在分布式场景下，ZooKeeper 是如何实现数据一致性的呢？",-1),u=e("h2",{id:"zab-一致性协议",tabindex:"-1"},[l("Zab 一致性协议 "),e("a",{class:"header-anchor",href:"#zab-一致性协议","aria-label":'Permalink to "Zab 一致性协议"'},"​")],-1),Z=e("p",null,"ZooKeeper 是通过 Zab 协议来保证分布式事务的最终一致性。Zab（ZooKeeper Atomic Broadcast，ZooKeeper 原子广播协议）支持崩溃恢复，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间数据一致性。",-1),g=e("br",null,null,-1),m=e("p",null,"系统架构可以参考下面这张图：",-1),L=e("br",null,null,-1),x=a("",19),P=e("br",null,null,-1),A=e("p",null,"Zab 协议的实现也类似，每当有一个新的 Leader 选举出现时，就会从这个 Leader 服务器上取出其本地日志中最大事务的 Zxid，并从中读取 epoch 值，然后加 1，以此作为新的周期 ID。总结一下，高 32 位代表了每代 Leader 的唯一性，低 32 位则代表了每代 Leader 中事务的唯一性。",-1),S=e("h2",{id:"zab-流程分析",tabindex:"-1"},[l("Zab 流程分析 "),e("a",{class:"header-anchor",href:"#zab-流程分析","aria-label":'Permalink to "Zab 流程分析"'},"​")],-1),F=e("p",null,"Zab 的具体流程可以拆分为消息广播、崩溃恢复和数据同步三个过程，下面我们分别进行分析。",-1),T=e("br",null,null,-1),C=e("h3",{id:"消息广播",tabindex:"-1"},[l("消息广播 "),e("a",{class:"header-anchor",href:"#消息广播","aria-label":'Permalink to "消息广播"'},"​")],-1),k=e("p",null,"在 ZooKeeper 中所有的事务请求都由 Leader 节点来处理，其他服务器为 Follower，Leader 将客户端的事务请求转换为事务 Proposal，并且将 Proposal 分发给集群中其他所有的 Follower。",-1),f=e("br",null,null,-1),w=e("p",null,"完成广播之后，Leader 等待 Follwer 反馈，当有过半数的 Follower 反馈信息后，Leader 将再次向集群内 Follower 广播 Commit 信息，Commit 信息就是确认将之前的 Proposal 提交。",-1),K=e("br",null,null,-1),v=e("p",null,"这里的 Commit 可以对比 SQL 中的 COMMIT 操作来理解，MySQL 默认操作模式是 autocommit 自动提交模式，如果你显式地开始一个事务，在每次变更之后都要通过 COMMIT 语句来确认，将更改提交到数据库中。",-1),q=e("br",null,null,-1),I=e("p",null,"Leader 节点的写入也是一个两步操作，第一步是广播事务操作，第二步是广播提交操作，其中过半数指的是反馈的节点数 >=N/2+1，N 是全部的 Follower 节点数量。",-1),z=e("br",null,null,-1),M=e("p",null,"消息广播的过程描述可以参考下图：",-1),D=e("br",null,null,-1),N=a("",16),O=a("",20),Q=a("",18);function V(E,B,R,y,j,J){const o=s("Image");return p(),n("div",null,[d,_,b,c,h,u,Z,g,m,L,r(o,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/DF/Ciqah16O5QyAB4rJAAEiJ-4T3bE046.png"}),x,r(o,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/F5/Cgq2xl6O5QyAeZqMAAB5C-BWbeI425.png"}),P,A,S,F,T,r(o,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/DF/Ciqah16O5QyADv0LAAA84x9hlQc078.png"}),C,k,f,w,K,v,q,I,z,M,D,r(o,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/F5/Cgq2xl6O5Q2ASjMpAAHdAdF67vE736.png"}),N,r(o,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/85/F8/Cgq2xl6O5-SASu1cAABBzFJh3s0114.png"}),O,r(o,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/0C/DF/Ciqah16O5Q2AL03bAADZjhkw3ys031.png"}),Q])}const H=t(i,[["render",V]]);export{W as __pageData,H as default};
