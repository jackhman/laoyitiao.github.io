import{_ as l,j as p,o,g as e,k as n,h as t,Q as a,s as c}from"./chunks/framework.e0c66c3f.js";const g=JSON.parse('{"title":"为什么需要分布式锁？ ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/etcd 原理与实践_文档/(6412) 18  如何基于 etcd 实现分布式锁？.md","filePath":"posts/backEnd/etcd 原理与实践_文档/(6412) 18  如何基于 etcd 实现分布式锁？.md","lastUpdated":1696338709000}'),r={name:"posts/backEnd/etcd 原理与实践_文档/(6412) 18  如何基于 etcd 实现分布式锁？.md"},E=a("",39),y=a("",12),i=c("p",null,"在我们上面的案例中，一旦抢锁失败，客户端就直接返回了。那么当该锁被释放之后，或者持有锁的客户端出现故障退出了，其他客户端如何快速获取锁呢？上述代码可以基于 watch 监测特性进行改进。关于改进的地方，你有什么好的想法吗？欢迎在留言区和我分享。下一讲，我们将介绍如何基于 etcd 实现微服务的注册与发现。",-1);function F(d,C,u,h,D,A){const s=p("Image");return o(),e("div",null,[E,n(s,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image6/M00/26/8C/CioPOWBbEnyAfk67AABZkPIb5so774.png"}),t(),y,n(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M00/26/8D/CioPOWBbEoaANh17AAG9OKrK4kc419.png"}),i])}const f=l(r,[["render",F]]);export{g as __pageData,f as default};
