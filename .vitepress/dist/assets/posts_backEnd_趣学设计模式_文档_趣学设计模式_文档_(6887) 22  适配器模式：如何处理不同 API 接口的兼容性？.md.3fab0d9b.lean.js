import{_ as l,j as o,o as e,g as t,k as a,Q as p,s,h as r}from"./chunks/framework.b3d8e22e.js";const D=JSON.parse('{"title":"模式原理分析 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/趣学设计模式_文档/趣学设计模式_文档/(6887) 22  适配器模式：如何处理不同 API 接口的兼容性？.md","filePath":"posts/backEnd/趣学设计模式_文档/趣学设计模式_文档/(6887) 22  适配器模式：如何处理不同 API 接口的兼容性？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/趣学设计模式_文档/趣学设计模式_文档/(6887) 22  适配器模式：如何处理不同 API 接口的兼容性？.md"},E=p("",7),y=p("",8),i=p("",27),d=s("h3",{id:"课后思考",tabindex:"-1"},[r("课后思考 "),s("a",{class:"header-anchor",href:"#课后思考","aria-label":'Permalink to "课后思考"'},"​")],-1),u=s("p",null,"当使用适配器模式的接口中有外部接口抛出异常时，适配器类是该直接透传抛出异常，还是捕获后重新抛出新异常，又或者是直接内部处理？为什么？",-1),g=s("p",null,"欢迎留言分享，我会第一时间给你回复。",-1),F=s("p",null,'在下一讲，我会接着与你分享"桥接模式：如何实现抽象协议与不同实现的绑定？"这个话题，记得按时来听课！',-1);function h(A,_,C,b,S,B){const n=o("Image");return e(),t("div",null,[E,a(n,{alt:"image.png",src:"https://s0.lgstatic.com/i/image6/M01/41/9A/CioPOWCsz32ARwVLAABfjk8UuXc980.png"}),y,a(n,{alt:"image (1).png",src:"https://s0.lgstatic.com/i/image6/M01/41/91/Cgp9HWCsz4iABEtCAABCKYltQBM798.png"}),i,a(n,{alt:"设计模式22--金句.png",src:"https://s0.lgstatic.com/i/image6/M01/41/9A/CioPOWCsz5SAKHVgAAYS6mFbOh8470.png"}),d,u,g,F])}const f=l(c,[["render",h]]);export{D as __pageData,f as default};
