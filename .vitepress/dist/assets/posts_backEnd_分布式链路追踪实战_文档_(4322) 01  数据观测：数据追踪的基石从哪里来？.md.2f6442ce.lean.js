import{_ as e,j as r,o as l,g as i,k as a,h as o,Q as n,s as t}from"./chunks/framework.a0d18f64.js";const U=JSON.parse('{"title":"01数据观测：数据追踪的基石从哪里来？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/分布式链路追踪实战_文档/(4322) 01  数据观测：数据追踪的基石从哪里来？.md","filePath":"posts/backEnd/分布式链路追踪实战_文档/(4322) 01  数据观测：数据追踪的基石从哪里来？.md","lastUpdated":1696682708000}'),p={name:"posts/backEnd/分布式链路追踪实战_文档/(4322) 01  数据观测：数据追踪的基石从哪里来？.md"},g=n("",25),_=t("h4",{id:"日志-logging",tabindex:"-1"},[o("日志（Logging） "),t("a",{class:"header-anchor",href:"#日志-logging","aria-label":'Permalink to "日志（Logging）"'},"​")],-1),c=t("p",null,[t("strong",null,"日志"),o("是系统中的常见功能，我们前面说的数据来源的各个部分都有可能产生日志。日志一般的描述是：在特定时间发生的事件，被以结构化的形式记录并产生的文本数据。")],-1),h=t("p",null,"日志可以为我们展现系统在任意时间的运行状态，又因为它是结构化的文本，所以我们很容易通过某种格式来进行检索，比如下图就是对 7 月 24 日用户支付下单操作的记录：",-1),d=t("p",null,"由于日志是最容易生成的，如果它大量地输出，会占据比较大的存储空间，进而影响整个应用程序的性能，比如 Java 中 logback 的日志框架，就算使用了异步线程来执行，也会对磁盘和 I/O 的使用率造成影响。",-1),u=t("p",null,"当然，也有一部分系统是利用日志可追溯、结构化的特点，来实现相关功能的，比如我们最常见的 WAL（Write-Ahead Logging）。WAL 就是在操作之前先进行日志写入，再执行操作；如果没有执行操作，那么在下次启动时就可以通过日志中结构化的，有时间标记的信息恢复操作，其中最典型的就是 MySQL 中的 Redo log。",-1),m=t("h4",{id:"统计指标-metrics",tabindex:"-1"},[o("统计指标（Metrics） "),t("a",{class:"header-anchor",href:"#统计指标-metrics","aria-label":'Permalink to "统计指标（Metrics）"'},"​")],-1),C=t("p",null,[t("strong",null,"统计指标"),o("也是我们经常使用的。它是一种可累加的聚合的数值结果，具有原子性。因此，我们可以通过各种数学计算方式来获取一段时间内的数值。")],-1),A=t("p",null,"统计指标针对数据的存储、处理、压缩和检索进行了优化，所以一般可以长期存储并以很简单的方式（聚合）查询。但由于涉及数据的处理（数学计算方式）和压缩，所以它也会占用一定的 CPU 资源。",-1),P=t("p",null,"统计指标是一个压缩后的数值，因此如果指标出现异常，我们很难得知是什么原因导致的异常。此外，如果我们使用了一个高基数的指标来作为统计的维度，那么统计就很容易给机器带来高性能损耗，比如，在基于用户 ID 的维度去做数据统计时，因为在统计的时候需要一段时间范围，如果数据过多就必然会造成内存上的占用。",-1),b=t("p",null,"讲到这里，你应该对指标有了一定的认识。我们后端经常说的 QPS、TPS、SLA 都是计算后得到的指标；基础设施中的 CPU 使用率、负载情况也可以认为是指标。",-1),q=t("h4",{id:"链路追踪-tracing",tabindex:"-1"},[o("链路追踪（Tracing） "),t("a",{class:"header-anchor",href:"#链路追踪-tracing","aria-label":'Permalink to "链路追踪（Tracing）"'},"​")],-1),T=t("p",null,[t("strong",null,"链路追踪"),o(' 可能是一个较新的概念，但是"全链路压测"这个词你一定不陌生。链路追踪中的"链路"和全链路压测中的"链路"，它们的概念是一样的，只不过链路追踪是将链路的完整行为信息进行记录，然后通过可视化的形式展现出来。这里我用一张图来说明：')],-1),S=n("",9),f=n("",7);function k(x,E,V,I,M,R){const s=r("Image");return l(),i("div",null,[g,a(s,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image/M00/3C/5E/CgqCHl8nrEuAdTFMAAFkhS5ucBI061.png"}),o(),_,c,h,a(s,{alt:"4.png",src:"https://s0.lgstatic.com/i/image/M00/3C/88/Ciqc1F8n2O6AXUU_AACiGPnzHJ0060.png"}),o(),d,u,m,C,a(s,{alt:"image (3).png",src:"https://s0.lgstatic.com/i/image/M00/3C/60/CgqCHl8nrU6AQfBSAACjSdwOzUQ263.png"}),o(),A,P,b,q,T,a(s,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image/M00/3C/60/CgqCHl8nrYiAbto2AABwOErWGno259.png"}),o(),S,a(s,{alt:"3.png",src:"https://s0.lgstatic.com/i/image/M00/3C/8E/CgqCHl8n0peAVsZsAAIx_TZards535.png"}),o(),f])}const N=e(p,[["render",k]]);export{U as __pageData,N as default};
