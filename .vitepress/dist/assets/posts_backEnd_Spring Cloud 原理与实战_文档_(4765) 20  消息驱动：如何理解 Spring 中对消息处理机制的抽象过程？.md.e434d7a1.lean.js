import{_ as p,j as e,o,g as t,k as l,h as n,s,Q as r}from"./chunks/framework.b3d8e22e.js";const H=JSON.parse('{"title":"SpringHealth 中的事件驱动架构 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Spring Cloud 原理与实战_文档/(4765) 20  消息驱动：如何理解 Spring 中对消息处理机制的抽象过程？.md","filePath":"posts/backEnd/Spring Cloud 原理与实战_文档/(4765) 20  消息驱动：如何理解 Spring 中对消息处理机制的抽象过程？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Spring Cloud 原理与实战_文档/(4765) 20  消息驱动：如何理解 Spring 中对消息处理机制的抽象过程？.md"},i=s("p",null,"从今天开始，我们将进入到 Spring Cloud 中与消息处理机制相关内容的介绍。Spring Cloud 专门提供了一个 Spring Cloud Stream 框架来实现事件驱动架构，并完成与主流消息中间件的集成。同时，Spring Cloud Stream 背后也整合了 Spring 家族中的消息处理和消息总线方面的几个框架，可以说是 Spring Cloud 中整合程度最高的一个开发框架。",-1),E=s("h3",{id:"springhealth-中的事件驱动架构",tabindex:"-1"},[n("SpringHealth 中的事件驱动架构 "),s("a",{class:"header-anchor",href:"#springhealth-中的事件驱动架构","aria-label":'Permalink to "SpringHealth 中的事件驱动架构"'},"​")],-1),y=s("p",null,"在微服务设计和开发过程中经常会存在这样的需求：系统中的某个服务会因为用户操作或内部行为发布一个事件，该服务知道这个事件在将来的某一个时间点会被其他服务所消费，但是并不知道这个服务具体是谁、也不关心什么时候被消费。同样，消费该事件的服务也不一定需要知道该事件是由哪个服务所发布。如下图所示：",-1),g=s("p",null,"事件发送和消费示意图",-1),d=s("p",null,"在上图中，事件生产者和消费者之间的虚线代表的是一种相互松散、没有直接调用的关联关系。满足以上特性的系统代表着一种松耦合的架构，通常被称为事件驱动架构，而这里的事件也可以被理解是服务与服务之间发送的一种消息。事件驱动架构本质上是一种架构设计风格，实现方法和工具有很多。在 Spring Cloud 家族中这个工具就是 Spring Cloud Stream。在接下来的内容中，我们将结合 SpringHealth 案例来分析事件驱动架构的实现需求以及在微服务架构中的应用。",-1),h=s("p",null,"在微服务系统中引入事件驱动架构的主要目的在于提升系统的扩展性。所谓扩展性，举例来说，就是在向现有系统中添加新业务时，不需要改变原有的各个组件，而只需把新业务封闭在一个新的组件中就能完成整体业务的升级，我们认为这样的系统就具有较好的可扩展性。",-1),u=s("p",null,"让我们回到 SpringHealth 系统，在我们的案例中存在健康干预相关的业务场景，常见的健康干预涉及用户、设备和健康干预自身信息维护等功能，而 SpringHealth 分别提取了 user-service、device-service 和 intervention-service 这三个微服务。显然，这三个服务之间需要进行服务之间的调用和协调从而完成业务闭环。如果在不久的将来，SpringHealth 中需要引入其他服务才能形成完整的业务流程，那么这个业务闭环背后的交互模式就需要进行相应的调整。",-1),S=s("p",null,"一般而言，类似 SpringHealth 这样的系统中的用户信息变动并不会太频繁，所以很多时候我们会想到通过缓存来存放用户信息，并在健康干预处理过程中直接从缓存中获取所需的用户信息。在这样的设计和实现方式下，试想一旦某个用户信息发生变化，我们应该如何正确和高效的应对这一场景？",-1),_=s("p",null,"考虑到系统扩展性，显然在 intervention-service 中直接通过访问 user-service 实时获取用户信息的服务交互模式并不是一个好的选择，因为用户信息更新的时机我们无法事先预知，而事件驱动架构为我们提供了一种更好的实现方案。当用户信息变更时，user-service 可以发送一个事件，该事件表明了某个用户信息已经发生了变化，并将传递到所有对该事件感兴趣的微服务，这些微服务会根据自身的业务逻辑来消费这一事件。通过这种方式，某个特定服务就可以获取用户信息变更事件从而正确且高效的更新缓存信息。基于这种设计思想，该场景下交互示意图如下所示：",-1),F=s("p",null,"用户信息更新场景中的事件驱动架构",-1),C=s("p",null,"在上图中，我们看到了有 consumer-service1 和 consumer-service2 这两个消费者服务，事件处理架构的优势就在于当系统中需要添加新的用户信息变更事件处理逻辑来完成整个流程时，我们只需要对该事件添加一个新的 consumer-service2 即可，而不需要对原有的 consumer-service1 中的处理流程做任何修改。这在应对系统扩展性上有很大的优势。",-1),b=s("p",null,"针对上图，在技术上实现上，我们可以使用主流的消息中间件来实现消息的发布与消费，常见的包括 ActiveMQ、RabbitMQ、Kafka 等。这些消息中间件的核心功能就是能够将所收到的消息存储起来并进行转发。有了存储转发机制之后，就可以做到消息发布者和消费者相互独立。关于各个消息中间件的介绍不是本课程的重点，而在 Spring Cloud Stream 中集成了 RabbitMQ 和 Kafka，我们会在下一课时中进行详细展开。在此之前，我们有必要对 Spring 家族中的消息处理机制做一个展开，因为 Spring Cloud Stream 正是构建在 Spring 消息处理机制之上。",-1),M=s("h3",{id:"spring-家族中的消息处理机制",tabindex:"-1"},[n("Spring 家族中的消息处理机制 "),s("a",{class:"header-anchor",href:"#spring-家族中的消息处理机制","aria-label":'Permalink to "Spring 家族中的消息处理机制"'},"​")],-1),m=s("p",null,"在了解了事件驱动架构以及消息中间件的基本概念之后，我们来看一下 Spring 中针对这些概念提供的技术解决方案。在 Spring 家族中，与消息处理机制相关的框架有三个。事实上，本课程要介绍的 Spring Cloud Stream 是基于 Spring Integration 实现了消息发布和消费机制并提供了一层封装，很多关于消息发布和消费的概念和实现方法本质上都是依赖于 Spring Integration。而在 Spring Integration 的背后，则依赖于 Spring Messaging 组件来实现消息处理机制的基础设施。这三个框架之间的依赖关系如下图所示：",-1),v=r("",22);function A(D,I,k,B,T,f){const a=e("Image");return o(),t("div",null,[i,E,y,l(a,{alt:"Lark20201126-171046.png",src:"https://s0.lgstatic.com/i/image/M00/71/BC/Ciqc1F-_cT2AaPnWAAFG-ke1Gqk780.png"}),n(),g,d,h,u,S,_,l(a,{alt:"Lark20201126-171050.png",src:"https://s0.lgstatic.com/i/image/M00/71/C8/CgqCHl-_cUyANr4AAAIM7JYrwbM905.png"}),n(),F,C,b,M,m,l(a,{alt:"Lark20201126-171053.png",src:"https://s0.lgstatic.com/i/image/M00/71/C8/CgqCHl-_cVaAeckTAAGWUPl4MVk661.png"}),n(),v])}const x=p(c,[["render",A]]);export{H as __pageData,x as default};
