import{_ as l,j as i,o as a,g as p,k as s,Q as t,s as e,h as o}from"./chunks/framework.b3d8e22e.js";const re=JSON.parse('{"title":"学前提示与基础概念","description":"","frontmatter":{},"headers":[],"relativePath":"posts/devops/111-运维高手的36项修炼文档/(1554) 第09课：搭建基于 Jenkin 的持续集成平台所需关注的几个问题.md","filePath":"posts/devops/111-运维高手的36项修炼文档/(1554) 第09课：搭建基于 Jenkin 的持续集成平台所需关注的几个问题.md","lastUpdated":1696417798000}'),_={name:"posts/devops/111-运维高手的36项修炼文档/(1554) 第09课：搭建基于 Jenkin 的持续集成平台所需关注的几个问题.md"},r=t("",9),c=t("",15),h=t("",9),d=e("br",null,null,-1),u=e("p",null,"微服务是当前的一个主流架构，Jenkins 很好的支持企业微服务部署环节。K8s 完美地解决了调度，负载均衡，集群管理、有状态数据的管理等微服务面临的问题，成为企业微服务容器化的首选解决方案。Jenkins 支持打包部署通过 Docker 来承载应用，我们会把应用封装进镜像，然后通过 Jenkins 打包一个完整的镜像并上传到镜像仓库。",-1),b=e("br",null,null,-1),k=e("p",null,"另外，我们会看到在小型的集成方案里面，Shell 是有局限性的，管理起海量的服务系统，不如 Ansible 或者自动化执行的管理模块方便，自动化运维能力也没有那么强大。这个时候我们则可以用 Ansible 来做自动化任务。",-1),A=e("br",null,null,-1),E=e("p",null,"我们会看到镜像仓库，它在这套环境中的代码发布管理流程中至关重要。我们需要把每一个镜像，按照它的版本号和发布时间和主题描述来进行版本的管理，方便于发布记录及回滚，所以仓库管理也成了微服务集成架构里面非常重要的一个组件。",-1),B=e("br",null,null,-1),J=e("p",null,"Jenkins 在微服务的集成架构里面起着一个核心的持续集成环境平台的作用。",-1),g=e("h2",{id:"devops-集成架构",tabindex:"-1"},[o("Devops 集成架构 "),e("a",{class:"header-anchor",href:"#devops-集成架构","aria-label":'Permalink to "Devops 集成架构"'},"​")],-1),m=e("p",null,"最后的一张图示，就是 Devops 集成架构了：",-1),v=t("",10),D=t("",38),T=e("p",{应用名称:""},"1、应用名称：{应用类型}-{端口}-{应用名称} or {类型}-",-1),S=e("p",null,"例如：api-8080-gateway,api-gateway",-1),C=e("br",null,null,-1),P=e("p",null,"首先第一个就是对于单个应用的名称，推荐给你的方式是可以按照这样的格式来定义自己的规范性。如前面是 {应用类型}-{端口}-{应用名称} 或者使用 {类型}-{应用名称}，你可以用这种方式来定义每一个应用的名称。",-1),q=e("br",null,null,-1),f=e("p",{序列号:""},"2、主机名称：{地区}-{机房}-{开发语言}-{项目名称}-{应用类型}-",-1),j=e("p",null,"例如：bj-yz-{java}-imoocc-api--01",-1),x=e("br",null,null,-1),V=e("p",null,"第二个就是对本地所需要管理的主机资源的名称(主机名)。对于主机名的管理是非常重要的，所以在主机名的定义上建议你可以使用 {地区}-{机房}-{开发语言}-{项目名称}-{应用类型}-{序列号} 来对主机定义，例如可以按我这种方式来定义这一台主机的名称。",-1),F=e("br",null,null,-1),I=e("p",{端口:""},"3、日志路径：/opt/logs/{应用类型}/{应用名称}-",-1),N=e("p",null,"例如：/opt/logs/web/gateway-8080",-1),w=e("br",null,null,-1),y=e("p",null,"第三个就是日志的路径，日志路径管理也是非常重要的，我们需要查看相关的日志，所以要定义好规范性。如统一放到了 /opt/logs/ 目录下，每一个 {应用类型} 是根据什么来进行分门别类，然后 {应用名称}-{端口} 来做这一级目录。所以对于应用日志这一级的路径，你可以参考这样的一个规范来进行定义。",-1),G=e("br",null,null,-1),L=e("p",{应用名称:""},"4、代码路径：/opt/apps/",-1),M=e("p",null,"例如：/opt/apps/api-8080-gateway",-1),R=e("br",null,null,-1),O=e("p",null,"还有就是代码的路径，代码的路径存放也要遵循整体的规范性定义，这里假设我把所有的应用都放到了 /opt/apps/ 这个目录下。这个时候就可以按 {应用名称} 为每个应用进行归纳，所以我们可以参考这样的一种方式来规范代码路径。",-1),Q=e("br",null,null,-1),z=e("p",{应用名称:""},"5、tomcat 实例路径：/opt/tomcats/",-1),Y=e("br",null,null,-1),U=e("p",null,"假设你是用 Java 语言代码，并且用的是 tomcat 来做的 servlet/JSP容器，如果你在主机上面有多个 tomcat 的话，那么需要你定义好它的实例名称及路径，这里也给你推荐一个定义方式。",-1),$=e("br",null,null,-1),K=e("p",null,[o("6、Jenkins job命名: {环境}"),e("em",{应用名称:""},"{项目名称}")],-1),W=e("p",null,"如：TEST_IMOOCC1_api-8080-gateway",-1),Z=e("br",null,null,-1),H=e("p",null,[o("还有就是 Jenkins job，同样我们也需要给它定义好相关的名称，方便我们来进行管理，这里推荐你是采用环{环境}"),e("em",{应用名称:""},"{项目名称}"),o("，如这样的一种方式来定义 job 名称。")],-1),X=e("br",null,null,-1),ee=e("p",null,"这样定义好以后，会使持续集成的整套开发过程和管理过程更加的清晰，所以标准的定义是在整套持续集成里面我们需要去做的至关重要的一点。",-1),ne=e("br",null,null,-1);function se(te,oe,le,ie,ae,pe){const n=i("Image");return a(),p("div",null,[r,s(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/76/4B/CgpOIF5wY7yAJJsMAAJRRuQVMKw843.png"}),c,s(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/76/4B/Cgq2xl5wY76ASQwBAAUQzeQk2NQ579.png"}),h,s(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/76/4B/CgpOIF5wY76AB1SaAAZNIemKRrY433.png"}),d,u,b,k,A,E,B,J,g,m,s(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/76/4B/Cgq2xl5wY7-ANUjVAAdwdd2Q2To107.png"}),v,s(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/76/4B/CgpOIF5wY7-AFSPOAAVFUJDaFAI724.png"}),D,T,S,C,P,q,f,j,x,V,F,I,N,w,y,G,L,M,R,O,Q,z,Y,U,$,K,W,Z,H,X,ee,ne])}const ce=l(_,[["render",se]]);export{re as __pageData,ce as default};
