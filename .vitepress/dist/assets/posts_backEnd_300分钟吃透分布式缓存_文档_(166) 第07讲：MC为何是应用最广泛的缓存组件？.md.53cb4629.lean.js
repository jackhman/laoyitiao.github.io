import{_ as l,j as o,o as _,g as h,k as s,h as a,Q as t,s as e}from"./chunks/framework.4e7d56ce.js";const A=JSON.parse('{"title":"第07讲：MC为何是应用最广泛的缓存组件？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(166) 第07讲：MC为何是应用最广泛的缓存组件？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(166) 第07讲：MC为何是应用最广泛的缓存组件？.md","lastUpdated":1696682708000}'),n={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(166) 第07讲：MC为何是应用最广泛的缓存组件？.md"},i=t("",12),p=e("h6",{id:"slab-机制",tabindex:"-1"},[a("slab 机制 "),e("a",{class:"header-anchor",href:"#slab-机制","aria-label":'Permalink to "slab 机制"'},"​")],-1),d=e("p",null,"接下来介绍 Mc 的 slab 机制。",-1),r=e("p",null,"Mc 并不是将所有数据放在一起来进行管理的，而是将内存划分为一系列相同大小的 slab 空间后，每个 slab 只管理一定范围内的数据存储。也就是说 Mc 内部采用 slab 机制来管理内存分配。Mc 内的内存分配以 slab 为单位，默认情况下一个 slab 是 1MB，可以通过 -I 参数在启动时指定其他数值。",-1),u=e("p",null,"slab 空间内部，会被进一步划分为一系列固定大小的 chunk。每个 chunk 内部存储一个 Item，利用 Item 结构存储数据。因为 chunk 大小固定，而 key/value 数据的大小随机。所以，Item存储完 key/value 数据后，一般还会有多余的空间，这个多余的空间就被浪费了。为了提升内存的使用效率，chunk size 就不能太大，而要尽量选择与 key/value size 接近的 ，从而减少 chunk 内浪费的空间。",-1),m=e("br",null,null,-1),k=e("p",null,"Mc 在分配内存时，先将内存按固定大小划分成 slab，然后再将不同 slab 分拆出固定 size 的 chunk。虽然 slab 内的 chunk 大小相同，但不同 slab 的 chunk size 并不同，Mc 会按照一个固定比例，使划分的 chunk size 逐步增大，从而满足不同大小 key/value 存储的需要。",-1),b=e("p",null,"如下图，一组具有相同 chunk size 的所有 slab，就组成一个 slabclass。不同 slabclass 的 chunk size 按递增因子一次增加。Mc 就通过 slabclass 来管理一组 slab 内的存储空间的。每个 slabclass 内部有一个 freelist ，包含这组 slab 里所有空闲的 chunk，当需要存储数据时，从这个 freelist 里面快速分配一个 chunk 做存储空间。当 Item 数据淘汰剔除时，这个 Item 所在的 chunk 又被回收至这个 freelist。",-1),M=t("",9);function y(I,f,v,g,T,C){const c=o("Image");return _(),h("div",null,[i,s(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/74/CgoB5l2kTEyABYmcAAD91NLPzIs234.png"}),a(),p,d,r,u,m,k,b,s(c,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/93/CgotOV2kTEyALjAgAADUQE7hy3o476.png"}),a(),M])}const N=l(n,[["render",y]]);export{A as __pageData,N as default};
