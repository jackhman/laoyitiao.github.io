import{_ as s,o as n,g as a,Q as e}from"./chunks/framework.f949202b.js";const u=JSON.parse('{"title":"TraceModuleProvider ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1743) 第25讲：trace-receiver 插件拆解，Trace 蕴含的宝贵信息（上）.md","filePath":"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1743) 第25讲：trace-receiver 插件拆解，Trace 蕴含的宝贵信息（上）.md","lastUpdated":null}'),p={name:"posts/backEnd/098-讲带你搞懂 SkyWalking文档/(1743) 第25讲：trace-receiver 插件拆解，Trace 蕴含的宝贵信息（上）.md"},l=e(`<p>在上一课时中，我介绍了 SkyWalking OAP 处理 Metrics 监控数据的完整流程。本课时将开始介绍 Trace 处理的相关内容。</p><h3 id="tracemoduleprovider" tabindex="-1">TraceModuleProvider <a class="header-anchor" href="#tracemoduleprovider" aria-label="Permalink to &quot;TraceModuleProvider&quot;">​</a></h3><p>本课时重点内容是来看 OAP 中的 trace-receiver-plugin 如何接收 TraceSegment 数据。</p><p>目前 trace-receiver-plugin 插件同时支持处理 V1 和 V2 两个版本的 TraceSegment。本课时重点分析 V2 版本 TraceSegment，后面不进行特殊说明的情况下，都是指 V2 版本 TraceSegment。</p><p>在 trace-receiver-plugin 插件的 SPI 文件中指定的 ModuleProvider 实现是 TraceModuleProvider，在 prepare() 方法中主要初始化 SegmentParseV2 解析器，SegmentParseV2 主要负责解析 TraceSegment 数据，具体实现后面会详细分析。</p><p>TraceModuleProvider 的 start() 方法核心是将 TraceSegmentReportServiceHandler 注册到 GRPCHandlerRegister 中。TraceSegmentReportServiceHandler 负责接收 Agent 发送来的 TraceSegment 数据，并调用 SegmentParseV2.parse() 方法进行解析，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/1B/D7/CgqCHl7fSYGAKb4lAAEg6Xckx78215.png" alt="Drawing 0.png"></p><h3 id="segmentparsev2" tabindex="-1">SegmentParseV2 <a class="header-anchor" href="#segmentparsev2" aria-label="Permalink to &quot;SegmentParseV2&quot;">​</a></h3><p>每处理一个 UpstreamSegment 都会创建一个相应的 SegmentParseV2 解析器对象，其核心字段如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 在解析过程中产生的 Segment 核心数据都会记录到 SegmentCoreInfo 中</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> SegmentCoreInfo segmentCoreInfo;</span></span>
<span class="line"><span style="color:#6A737D;">// 在解析 TraceSegment 过程中会碰到不同类型的 Span</span></span>
<span class="line"><span style="color:#6A737D;">// 会通过不同的 SpanListener 执行不同的操作</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> List&lt;</span><span style="color:#F97583;">SpanListener</span><span style="color:#E1E4E8;">&gt; spanListeners;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 在解析过程中产生的 Segment 核心数据都会记录到 SegmentCoreInfo 中</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> SegmentCoreInfo segmentCoreInfo;</span></span>
<span class="line"><span style="color:#6A737D;">// 在解析 TraceSegment 过程中会碰到不同类型的 Span</span></span>
<span class="line"><span style="color:#6A737D;">// 会通过不同的 SpanListener 执行不同的操作</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> List&lt;</span><span style="color:#D73A49;">SpanListener</span><span style="color:#24292E;">&gt; spanListeners;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>SegmentCoreInfo 是一个 POJO，用于记录解析 TraceSegment 时产生的核心数据，作用类似于一个 DTO（后面会看到各个 SpanListener 都会从它这里拷贝 TraceSegment 的数据），其核心字段如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// TraceSegment 编号，即 TraceSegment.traceSegmentId 。</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String segmentId;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceId; </span><span style="color:#6A737D;">// Segment 所属的 Service 以及 ServiceInstance</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceInstanceId;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> startTime; </span><span style="color:#6A737D;">// Segment 的开始时间和结束时间</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> endTime;</span></span>
<span class="line"><span style="color:#6A737D;">// 如果 TraceSegment 范围内的任意一个 Span 被标记了 Error，则该字段会被设置为true</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isError;</span></span>
<span class="line"><span style="color:#6A737D;">// TraceSegment 开始时间窗口(即第一个 Span 开始时间所处的分钟级时间窗口)</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> minuteTimeBucket;</span></span>
<span class="line"><span style="color:#6A737D;">// 整个 TraceSegment 的字节数据</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] dataBinary;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isV2; </span><span style="color:#6A737D;">// 是否为 V2 版本的 TraceSegment 数据</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// TraceSegment 编号，即 TraceSegment.traceSegmentId 。</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String segmentId;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceId; </span><span style="color:#6A737D;">// Segment 所属的 Service 以及 ServiceInstance</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceInstanceId;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> startTime; </span><span style="color:#6A737D;">// Segment 的开始时间和结束时间</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> endTime;</span></span>
<span class="line"><span style="color:#6A737D;">// 如果 TraceSegment 范围内的任意一个 Span 被标记了 Error，则该字段会被设置为true</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isError;</span></span>
<span class="line"><span style="color:#6A737D;">// TraceSegment 开始时间窗口(即第一个 Span 开始时间所处的分钟级时间窗口)</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> minuteTimeBucket;</span></span>
<span class="line"><span style="color:#6A737D;">// 整个 TraceSegment 的字节数据</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] dataBinary;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isV2; </span><span style="color:#6A737D;">// 是否为 V2 版本的 TraceSegment 数据</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>这里的 SpanListener 接口分为 GlobalTraceIdsListener、FirstSpanListener、LocalSpanListener、EntrySpanListener、ExitSpanListener 五个子接口，不同类型的子接口监听 SegmentParseV2 解析过程中产生的不同数据，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/1B/D7/CgqCHl7fSYqALG1gAAGuE9qIaPk072.png" alt="Drawing 1.png"></p><p>而这五个子接口的真正实现类只有 SegmentSpanListener 三个，默认情况下都会添加到 spanListeners 集合中。</p><p>在 SegmentParseV2.parse() 中的第一步就是初始化 spanListeners 集合，将这三个实现类的对象添加到 spanListeners 集合中。</p><p>第二步会从 UpstreamSegment 中读取 TraceSegment 的数据，其中主要包括：</p><ol><li>与该 TraceSegment 关联的全部 TraceId 。</li><li>反序列化 TraceSegment 关联的元数据以及 Span 数据，得到对应的 SegmentObject 对象。</li></ol><p>该步骤相关代码如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">UpstreamSegment upstreamSegment </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> bufferData.</span><span style="color:#B392F0;">getMessageType</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 获取该 TraceSegment 关联的全部 TraceId</span></span>
<span class="line"><span style="color:#E1E4E8;">List&lt;</span><span style="color:#F97583;">UniqueId</span><span style="color:#E1E4E8;">&gt; traceIds </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> upstreamSegment.</span><span style="color:#B392F0;">getGlobalTraceIdsList</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 反序列化 UpstreamSegment.segment，得到 SegmentObject 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">SegmentObject segmentObject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">parseBinarySegment</span><span style="color:#E1E4E8;">(upstreamSegment));</span></span>
<span class="line"><span style="color:#6A737D;">// 将 SegmentObject 封装成 SegmentDecorator</span></span>
<span class="line"><span style="color:#E1E4E8;">SegmentDecorator segmentDecorator </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SegmentDecorator</span><span style="color:#E1E4E8;">(segmentObject);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">UpstreamSegment upstreamSegment </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> bufferData.</span><span style="color:#6F42C1;">getMessageType</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 获取该 TraceSegment 关联的全部 TraceId</span></span>
<span class="line"><span style="color:#24292E;">List&lt;</span><span style="color:#D73A49;">UniqueId</span><span style="color:#24292E;">&gt; traceIds </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> upstreamSegment.</span><span style="color:#6F42C1;">getGlobalTraceIdsList</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 反序列化 UpstreamSegment.segment，得到 SegmentObject 对象</span></span>
<span class="line"><span style="color:#24292E;">SegmentObject segmentObject </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">parseBinarySegment</span><span style="color:#24292E;">(upstreamSegment));</span></span>
<span class="line"><span style="color:#6A737D;">// 将 SegmentObject 封装成 SegmentDecorator</span></span>
<span class="line"><span style="color:#24292E;">SegmentDecorator segmentDecorator </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SegmentDecorator</span><span style="color:#24292E;">(segmentObject);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>这里先帮助你回顾一下，Unique 中封装了三个 long，这三个 long 拼接起来就是一个 TraceId，这与前面介绍的 DistributedTraceId 一致。</p><p>SegmentObject 中封装了 TraceSegment 的全部信息，其中包括 TraceSegmentId、serviceId、serviceInstanceId 以及每个 Span 的数据（封装在 SpanObjectV2 中）。在 SpanObjectV2 中封装了一个 Span 的全部信息，例如：spanId、parentSpanId、startTime、endTime 等等（全部字段可以参考 apm-protocol/apm-network/src/main/proto/language-agent-v2/trace.proto 文件）。</p><h3 id="standardbuilder" tabindex="-1">StandardBuilder <a class="header-anchor" href="#standardbuilder" aria-label="Permalink to &quot;StandardBuilder&quot;">​</a></h3><p>SegmentParseV2 解析得到的 SegmentObject 会立即封装到 SegmentDecorator 中，它是 StandardBuilder 接口的实现类，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/1B/D7/CgqCHl7fSZuAcM1EAAG3Hx3xP4Y420.png" alt="Drawing 2.png"></p><p>为了更清晰的说明 StandardBuilder 对象的作用，这里以 SpanDecorator 为例进行说明。在 SpanDecorator 底层封装了 SpanObjectV2 对象以及其关联的 Builder 对象，如下所示：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 底层封装的 SpanObjectV2 对象</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> SpanObjectV2 spanObjectV2;</span></span>
<span class="line"><span style="color:#6A737D;">// SpanObjectV2 关联的 Builder</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> SpanObjectV2.Builder spanBuilderV2;</span></span>
<span class="line"><span style="color:#6A737D;">// Builder 是否已经创建</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> isOrigin </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 底层封装的 SpanObjectV2 对象</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> SpanObjectV2 spanObjectV2;</span></span>
<span class="line"><span style="color:#6A737D;">// SpanObjectV2 关联的 Builder</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> SpanObjectV2.Builder spanBuilderV2;</span></span>
<span class="line"><span style="color:#6A737D;">// Builder 是否已经创建</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> isOrigin </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>SpanDecorator 暴露出来的主要是 SpanObjectV2 相应字段的 getter/setter 方法：</p><ol><li>其 getter 方法底层调用 SpanObjectV2 或是 Builder 相应的 getter 方法读取相应字段数据；</li><li>其 setter 方法底层只能通过 Builder 的 setter 方法修改相应字段的数据（通过 isOrigin 字段确定 SpanBuilderV2 是否已经初始化，若未初始化则先进行初始化）。</li></ol><p>以 SpanDecorator 中的 setComponentId() 方法为例进行介绍，其他方法的实现与其类似：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setComponentId</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> value) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (isOrigin) { </span><span style="color:#6A737D;">// 先检查 isOrigin，确定 spanBuilderV2 字段是否已经初始化</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">toBuilder</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 初始化 spanBuilderV2 字段，即创建 SpanObjectV2 关联的 Builder 对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">// 通过 Builder 完成更新（这里省略 V1 版本的相关代码）</span></span>
<span class="line"><span style="color:#E1E4E8;">   spanBuilderV2.</span><span style="color:#B392F0;">setComponentId</span><span style="color:#E1E4E8;">(value);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setComponentId</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> value) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (isOrigin) { </span><span style="color:#6A737D;">// 先检查 isOrigin，确定 spanBuilderV2 字段是否已经初始化</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">toBuilder</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 初始化 spanBuilderV2 字段，即创建 SpanObjectV2 关联的 Builder 对象</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">// 通过 Builder 完成更新（这里省略 V1 版本的相关代码）</span></span>
<span class="line"><span style="color:#24292E;">   spanBuilderV2.</span><span style="color:#6F42C1;">setComponentId</span><span style="color:#24292E;">(value);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>通过 SpanDecorator 装饰器的封装，屏蔽了底层 SpanObjectV2 和 SpanObjectV.Builder 切换的实现细节，外层可以像 POJO 那样直接使用 getter/setter 修改字段值。</p><p>最后，为什么不用 SegmentDecorator 进行举例呢？因为 SegmentDecorator 只提供了 getter 方法，而没有 setter 方法，用它举例可能会造成误导。</p><h4 id="prebuild" tabindex="-1">preBuild <a class="header-anchor" href="#prebuild" aria-label="Permalink to &quot;preBuild&quot;">​</a></h4><p>下面回到 SegmentParseV2 继续介绍解析 TraceSegment 的过程。完成 TraceSegment 数据的读取和反序列化之后，接下来就是预构建（preBuild）操作。预构建操作分为很多步，我们一步步进行分析。整个过程会涉及上面提到的三个 SpanListener 接口实现类，TraceSegment 的数据会从 SegmentCoreInfo 中拷贝多份，流向不同的处理流程。这里为了防止混乱，先以 SegmentSpanListener 为主线进行分析，等你了解 SegmentParseV2 的整个处理流程之后，再介绍另外两个 SpanListener 实现的具体实现。</p><p>预构建首先会通过 notifyGlobalsListener() 方法将该 TraceSegment 关联的全部 TraceId 交给 GlobalTraceIdsListener 进行解析。GlobalTraceIdsListener 接口只定义了一个 parseGlobalTraceId() 方法，SegmentSpanListener 、MultiScopesSpanListener 都是该接口的实现类。SegmentSpanListener 首先会对 TraceId 进行采样，采样逻辑在 TraceSegmentSampler 中实现，采样的大致逻辑是计算 TraceId 中第三部分的 long 值（即线程内递增值）与 10000 取模，小于 sampleRate 即被采样（sampleRate 是在 application.yml 文件中配置的万分比采样率），采样的代码片段如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> sampleValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> lastLong </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">10000</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sampleValue </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> sampleRate) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">long</span><span style="color:#24292E;"> sampleValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> lastLong </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">10000</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sampleValue </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> sampleRate) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>被采样的 TraceId 会记录到 SegmentSpanListener.segment 字段（Segment 类型）中：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">segment.</span><span style="color:#B392F0;">setTraceId</span><span style="color:#E1E4E8;">(traceIdBuilder.</span><span style="color:#B392F0;">toString</span><span style="color:#E1E4E8;">()); </span><span style="color:#6A737D;">// 记录traceId</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">segment.</span><span style="color:#6F42C1;">setTraceId</span><span style="color:#24292E;">(traceIdBuilder.</span><span style="color:#6F42C1;">toString</span><span style="color:#24292E;">()); </span><span style="color:#6A737D;">// 记录traceId</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>不仅是 TraceId，在后面会看到 SegmentSpanListener 将解析到的所有 TraceSegment 数据都记录到一个 Segment 对象（segment 字段）中。Segment 继承了 Source 抽象类，看到 Source 抽象类是不是很熟悉？当分析完一个 TraceSegment 之后，SegmentSpanListener 会将 Segment 传递给 SourceReceiver（sourceReceiver 字段）处理。SourceReceiver 前面也已经分析过了，其底层封装的 DispatcherManager 会根据 Source 的类型选择相应的 SourceDispatcher 进行分发。</p><p>预构建接下来的步骤叫 &quot;exchange&quot; ，该步骤主要实现字符串到 id 的转换。前文提到，Agent 会定期将 EndpointName、NetworkAddress 等一系列字符串同步到 OAP 生成相应 id，后续 Agent 生成的 Span 将不再携带这些字符串，而是携带相应的 id。如果在生成 Span 的时候，OAP 还未能及时为这些字符串生成相应 id，则 Agent 会继续使用字符串填充上述字段，后续由 OAP 完成字符串到 id 的转换，也就是这里的 exchange 步骤。</p><p>这里的 exchange 过程是通过 IdExchanger 接口实现的，IdExchange 接口有两个实现类，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/1B/CC/Ciqc1F7fSaaAbOcSAAApWn6Htjw623.png" alt="Drawing 3.png"></p><p>IdExchanger 接口只定义了一个 exchange() 方法，也是整个 exchange 过程的核心。下面先来分析 SpanIdExchanger 的实现，其核心字段如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ServiceInventoryCache serviceInventoryCacheDAO;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> IServiceInventoryRegister serviceInventoryRegister;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> IEndpointInventoryRegister endpointInventoryRegister;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> INetworkAddressInventoryRegister networkAddressInventoryRegister;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> IComponentLibraryCatalogService componentLibraryCatalogService;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ServiceInventoryCache serviceInventoryCacheDAO;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> IServiceInventoryRegister serviceInventoryRegister;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> IEndpointInventoryRegister endpointInventoryRegister;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> INetworkAddressInventoryRegister networkAddressInventoryRegister;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> IComponentLibraryCatalogService componentLibraryCatalogService;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>SpanIdExchanger 会依赖这些 Service 获取不同类型字符串对应的唯一 id 值。在 exchange() 方法实现主要处理了 Span 中三种数据的 id 转换：component、peer、operationName。这里以 peer 为例进行分析：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 这里的 standardBuilder 就是前面介绍的 SpanDecorator，用于读写SpanObjectV2 中的数据</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> peerId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> standardBuilder.</span><span style="color:#B392F0;">getPeerId</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 检测该 SpanObjectV2 的 peer 是否需要进行转换</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (peerId </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">Strings.</span><span style="color:#B392F0;">isNullOrEmpty</span><span style="color:#E1E4E8;">(standardBuilder.</span><span style="color:#B392F0;">getPeer</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过 NetworkAddressInventoryRegister 获取 peer 对应的 id</span></span>
<span class="line"><span style="color:#E1E4E8;">    peerId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> networkAddressInventoryRegister.</span><span style="color:#B392F0;">getOrCreate</span><span style="color:#E1E4E8;">(standardBuilder.</span><span style="color:#B392F0;">getPeer</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">buildServiceProperties</span><span style="color:#E1E4E8;">(standardBuilder));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (peerId </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 该 peer 字符串没有对应的id</span></span>
<span class="line"><span style="color:#E1E4E8;">        exchanged </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">; </span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 记录 peerId，并清空 peer 字段</span></span>
<span class="line"><span style="color:#E1E4E8;">        standardBuilder.</span><span style="color:#B392F0;">toBuilder</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        standardBuilder.</span><span style="color:#B392F0;">setPeerId</span><span style="color:#E1E4E8;">(peerId);</span></span>
<span class="line"><span style="color:#E1E4E8;">        standardBuilder.</span><span style="color:#B392F0;">setPeer</span><span style="color:#E1E4E8;">(Const.EMPTY_STRING);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 这里的 standardBuilder 就是前面介绍的 SpanDecorator，用于读写SpanObjectV2 中的数据</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> peerId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> standardBuilder.</span><span style="color:#6F42C1;">getPeerId</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#6A737D;">// 检测该 SpanObjectV2 的 peer 是否需要进行转换</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (peerId </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">Strings.</span><span style="color:#6F42C1;">isNullOrEmpty</span><span style="color:#24292E;">(standardBuilder.</span><span style="color:#6F42C1;">getPeer</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过 NetworkAddressInventoryRegister 获取 peer 对应的 id</span></span>
<span class="line"><span style="color:#24292E;">    peerId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> networkAddressInventoryRegister.</span><span style="color:#6F42C1;">getOrCreate</span><span style="color:#24292E;">(standardBuilder.</span><span style="color:#6F42C1;">getPeer</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">buildServiceProperties</span><span style="color:#24292E;">(standardBuilder));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (peerId </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 该 peer 字符串没有对应的id</span></span>
<span class="line"><span style="color:#24292E;">        exchanged </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">; </span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 记录 peerId，并清空 peer 字段</span></span>
<span class="line"><span style="color:#24292E;">        standardBuilder.</span><span style="color:#6F42C1;">toBuilder</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        standardBuilder.</span><span style="color:#6F42C1;">setPeerId</span><span style="color:#24292E;">(peerId);</span></span>
<span class="line"><span style="color:#24292E;">        standardBuilder.</span><span style="color:#6F42C1;">setPeer</span><span style="color:#24292E;">(Const.EMPTY_STRING);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>component 和 endpointName 的 id 转换逻辑类似，这里不再展开分析。</p><p>ReferenceIdExchanger 主要处理 TraceSegmentReference 中的 endpointName、parentEndpointName 以及 NetworkAddress 的 id 转换，具体的转换逻辑与上述逻辑类似，不再展开分析。</p><p>完成 exchange 操作之后，SegmentParseV2 会将解析到的 Segment 信息拷贝到 segmentCoreInfo 中暂存。</p><p>在预构建的最后，会根据 TraceSegment 中各个 Span 的类型，交给不同的 SpanListener 进行处理，大致实现代码如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> segmentDecorator.</span><span style="color:#B392F0;">getSpansCount</span><span style="color:#E1E4E8;">(); i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    SpanDecorator spanDecorator </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> segmentDecorator.</span><span style="color:#B392F0;">getSpans</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 针对 TraceSegment 中第一个 Span 的处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (spanDecorator.</span><span style="color:#B392F0;">getSpanId</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">notifyFirstListener</span><span style="color:#E1E4E8;">(spanDecorator);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据 SpanType 处理各个 Span</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (SpanType.Exit.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(spanDecorator.</span><span style="color:#B392F0;">getSpanType</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">notifyExitListener</span><span style="color:#E1E4E8;">(spanDecorator);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (SpanType.Entry.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(spanDecorator.</span><span style="color:#B392F0;">getSpanType</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">notifyEntryListener</span><span style="color:#E1E4E8;">(spanDecorator);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (SpanType.Local.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(spanDecorator.</span><span style="color:#B392F0;">getSpanType</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#B392F0;">notifyLocalListener</span><span style="color:#E1E4E8;">(spanDecorator);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> segmentDecorator.</span><span style="color:#6F42C1;">getSpansCount</span><span style="color:#24292E;">(); i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    SpanDecorator spanDecorator </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> segmentDecorator.</span><span style="color:#6F42C1;">getSpans</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 针对 TraceSegment 中第一个 Span 的处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (spanDecorator.</span><span style="color:#6F42C1;">getSpanId</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">notifyFirstListener</span><span style="color:#24292E;">(spanDecorator);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据 SpanType 处理各个 Span</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (SpanType.Exit.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(spanDecorator.</span><span style="color:#6F42C1;">getSpanType</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">notifyExitListener</span><span style="color:#24292E;">(spanDecorator);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (SpanType.Entry.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(spanDecorator.</span><span style="color:#6F42C1;">getSpanType</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">notifyEntryListener</span><span style="color:#24292E;">(spanDecorator);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (SpanType.Local.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(spanDecorator.</span><span style="color:#6F42C1;">getSpanType</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6F42C1;">notifyLocalListener</span><span style="color:#24292E;">(spanDecorator);</span></span>
<span class="line"><span style="color:#24292E;">    } </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>下面我们深入到 notify*Listener() 方法中，分析不同 SpanListener 实现对各个类型的 Span 的处理逻辑。</p><h4 id="notifyfirstlistener" tabindex="-1">notifyFirstListener <a class="header-anchor" href="#notifyfirstlistener" aria-label="Permalink to &quot;notifyFirstListener&quot;">​</a></h4><p>notifyFirstListener() 方法会调用所有 FirstSpanListener 的 parseFirst() 方法处理 TraceSegment 中的第一个 Span，这里只有 SegmentSpanListener 实现了该方法，具体实现分为三步：</p><ol><li>检测当前 TraceSegment 是否被成功采样。</li><li>将 segmentCoreInfo 中记录的 TraceSegment 数据拷贝到 segment 字段中。</li><li>将 endpointNameId 记录到 firstEndpointId 字段，通过前面的分析我们知道，endpointNameId 在 Spring MVC 里面对应的是 URL，在 Dubbo 里面对应的是 RPC 请求 path 与方法名称的拼接。</li></ol><p>SegmentSpanListener.parseFirst() 方法的具体实现代码如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">parseFirst</span><span style="color:#E1E4E8;">(SpanDecorator spanDecorator, SegmentCoreInfo segmentCoreInfo) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sampleStatus.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(SAMPLE_STATUS.IGNORE)) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 检测是否采样成功</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> timeBucket </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TimeBucket.</span><span style="color:#B392F0;">getSecondTimeBucket</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getStartTime</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将 segmentCoreInfo 中记录的数据全部拷贝到 Segment 中</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setSegmentId</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getSegmentId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setServiceId</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getServiceId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setServiceInstanceId</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getServiceInstanceId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setLatency</span><span style="color:#E1E4E8;">((</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">)(segmentCoreInfo.</span><span style="color:#B392F0;">getEndTime</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> segmentCoreInfo.</span><span style="color:#B392F0;">getStartTime</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setStartTime</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getStartTime</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setEndTime</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getEndTime</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setIsError</span><span style="color:#E1E4E8;">(BooleanUtils.</span><span style="color:#B392F0;">booleanToValue</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">isError</span><span style="color:#E1E4E8;">()));</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setTimeBucket</span><span style="color:#E1E4E8;">(timeBucket);</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setDataBinary</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">getDataBinary</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    segment.</span><span style="color:#B392F0;">setVersion</span><span style="color:#E1E4E8;">(segmentCoreInfo.</span><span style="color:#B392F0;">isV2</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 记录 endpointNameId</span></span>
<span class="line"><span style="color:#E1E4E8;">    firstEndpointId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> spanDecorator.</span><span style="color:#B392F0;">getOperationNameId</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">parseFirst</span><span style="color:#24292E;">(SpanDecorator spanDecorator, SegmentCoreInfo segmentCoreInfo) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sampleStatus.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(SAMPLE_STATUS.IGNORE)) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 检测是否采样成功</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> timeBucket </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> TimeBucket.</span><span style="color:#6F42C1;">getSecondTimeBucket</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getStartTime</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将 segmentCoreInfo 中记录的数据全部拷贝到 Segment 中</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setSegmentId</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getSegmentId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setServiceId</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getServiceId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setServiceInstanceId</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getServiceInstanceId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setLatency</span><span style="color:#24292E;">((</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">)(segmentCoreInfo.</span><span style="color:#6F42C1;">getEndTime</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> segmentCoreInfo.</span><span style="color:#6F42C1;">getStartTime</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setStartTime</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getStartTime</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setEndTime</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getEndTime</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setIsError</span><span style="color:#24292E;">(BooleanUtils.</span><span style="color:#6F42C1;">booleanToValue</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">isError</span><span style="color:#24292E;">()));</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setTimeBucket</span><span style="color:#24292E;">(timeBucket);</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setDataBinary</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">getDataBinary</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    segment.</span><span style="color:#6F42C1;">setVersion</span><span style="color:#24292E;">(segmentCoreInfo.</span><span style="color:#6F42C1;">isV2</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 记录 endpointNameId</span></span>
<span class="line"><span style="color:#24292E;">    firstEndpointId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> spanDecorator.</span><span style="color:#6F42C1;">getOperationNameId</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h4 id="notifyentrylistener" tabindex="-1">notifyEntryListener <a class="header-anchor" href="#notifyentrylistener" aria-label="Permalink to &quot;notifyEntryListener&quot;">​</a></h4><p>在 notifyEntryListener() 方法中，会调用所有 EntrySpanListener 实现的 parseEntry() 方法对于 Entry 类型的 Span 进行处理。SegmentSpanListener.parseEntry() 方法只做了一件事，就是将 endpointNameId 记录到 entryEndpointId 字段中：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">entryEndpointId </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> spanDecorator.</span><span style="color:#B392F0;">getOperationNameId</span><span style="color:#E1E4E8;">();</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">entryEndpointId </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> spanDecorator.</span><span style="color:#6F42C1;">getOperationNameId</span><span style="color:#24292E;">();</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h4 id="notifylocallistener" tabindex="-1">notifyLocalListener <a class="header-anchor" href="#notifylocallistener" aria-label="Permalink to &quot;notifyLocalListener&quot;">​</a></h4><p>上述的三个 SpanListener 实现类中，全部都没有实现 LocalSpanListener 接口，所以在 trace-receiver-plugin 插件中并不会处理 Local 类型的 Span。</p><h4 id="notifyexitlistener" tabindex="-1">notifyExitListener <a class="header-anchor" href="#notifyexitlistener" aria-label="Permalink to &quot;notifyExitListener&quot;">​</a></h4><p>trace-receiver-plugin 插件中，只有 MultiScopesSpanListener 实现了 ExitSpanListener 接口，后面会单独介绍 MultiScopesSpanListener 对各类 Span 的处理，这里暂不展开。</p><p>到此，预构建（preBuild）操作就到此结束了。最后需要提醒的是，preBuild() 方法的返回值是一个 boolean 值，表示 exchange 操作是否已经将全部字符串转换成 id。</p><h4 id="notifylistenertobuild" tabindex="-1">notifyListenerToBuild <a class="header-anchor" href="#notifylistenertobuild" aria-label="Permalink to &quot;notifyListenerToBuild&quot;">​</a></h4><p>如果预构建（preBuild）中的 exchange 过程已经将全部字符串转换成了相应的 id，则会通过 notifyListenerToBuild() 方法调用所有 SpanListener 实现的 build() 方法。这里重点来看 SegmentSpanListener 的实现：</p><ol><li>首先会检测 TraceSegment 是否已被采样，它只会处理被采样的 TraceSegment。</li><li>设置 Segment 的 endpointName 字段。</li><li>将 Segment 交给 SourceReceiver 继续处理。</li></ol><h3 id="recordstreamprocessor" tabindex="-1">RecordStreamProcessor <a class="header-anchor" href="#recordstreamprocessor" aria-label="Permalink to &quot;RecordStreamProcessor&quot;">​</a></h3><p>SourceReceiver 底层封装的 DispatcherManager 会根据 Segment 选择相应的 SourceDispatcher 实现 ------ SegmentDispatcher 进行分发。</p><p>SegmentDispatcher.dispatch() 方法中会将 Segment 中的数据拷贝到 SegmentRecord 对象中。</p><p>SegmentRecord 继承了 StorageData 接口，与前面介绍的 RegisterSource 以及 Metrics 的实现类似，通过注解指明了 Trace 数据存储的 index 名称的前缀（最终写入的 index 是由该前缀以及 TimeBucket 后缀两部分共同构成）以及各个字段对应的 field 名称，如下所示：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// @Stream 注解的 name 属性指定了 index 的名称(index 前缀)，processor 指定了处理该类型数据的 StreamProcessor 实现</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Stream</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;segment&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">processor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RecordStreamProcessor.class...)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SegmentRecord</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Record</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// @Column 注解中指定了该字段在 index 中对应的 field 名称</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Setter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Getter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;segment_id&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String segmentId;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Setter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Getter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;trace_id&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> String traceId;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Setter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Getter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;service_id&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceId;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Setter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Getter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;service_instance_id&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> serviceInstanceId;</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Setter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Getter</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">Column</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">columnName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;endpoint_name, matchQuery = true) private String endpointName;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">endpoint_id</span><span style="color:#9ECBFF;">&quot;) private int endpointId;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">start_time</span><span style="color:#9ECBFF;">&quot;) private long startTime;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">end_time</span><span style="color:#9ECBFF;">&quot;) private long endTime;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">latency</span><span style="color:#9ECBFF;">&quot;) private int latency;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">is_error</span><span style="color:#9ECBFF;">&quot;) private int isError;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">data_binary</span><span style="color:#9ECBFF;">&quot;) private byte[] dataBinary;</span></span>
<span class="line"><span style="color:#9ECBFF;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#E1E4E8;">version</span><span style="color:#9ECBFF;">&quot;) private int version;</span></span>
<span class="line"><span style="color:#9ECBFF;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// @Stream 注解的 name 属性指定了 index 的名称(index 前缀)，processor 指定了处理该类型数据的 StreamProcessor 实现</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Stream</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;segment&quot;</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">processor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RecordStreamProcessor.class...)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SegmentRecord</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Record</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// @Column 注解中指定了该字段在 index 中对应的 field 名称</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Setter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Getter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;segment_id&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String segmentId;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Setter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Getter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;trace_id&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> String traceId;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Setter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Getter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;service_id&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceId;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Setter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Getter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;service_instance_id&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> serviceInstanceId;</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Setter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Getter</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">Column</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">columnName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;endpoint_name, matchQuery = true) private String endpointName;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">endpoint_id</span><span style="color:#032F62;">&quot;) private int endpointId;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">start_time</span><span style="color:#032F62;">&quot;) private long startTime;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">end_time</span><span style="color:#032F62;">&quot;) private long endTime;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">latency</span><span style="color:#032F62;">&quot;) private int latency;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">is_error</span><span style="color:#032F62;">&quot;) private int isError;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">data_binary</span><span style="color:#032F62;">&quot;) private byte[] dataBinary;</span></span>
<span class="line"><span style="color:#032F62;">    @Setter @Getter @Column(columnName = &quot;</span><span style="color:#24292E;">version</span><span style="color:#032F62;">&quot;) private int version;</span></span>
<span class="line"><span style="color:#032F62;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在 SegmentRecord 的父类 ------ Record 中还定义了一个 timeBucket 字段（long 类型），对应的 field 名称是 &quot;time_bucket&quot;。</p><p>RecordStreamProcessor 的核心功能是为每个 Record 类型创建相应的 worker 链，这与前面介绍的 InventoryStreamProcessor 以及 MetricsStreamProcessor 类似。在 RecordStreamProcessor 中，每个 Record 类型对应的 worker 链中只有一个worker 实例 ------ RecordPersistentWorker。</p><p>与前面介绍的 MetricsPersistentWorker 类型，RecordPersistentWorker 负责 SegmentRecord 数据的持久化：</p><p><img src="https://s0.lgstatic.com/i/image/M00/1B/D7/CgqCHl7fSbWALRYDAAEn3HDWLfM382.png" alt="Drawing 4.png"></p><p>如上图所示，RecordPersistentWorker 也继承了 PersistentWorker，写入流程大致如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/1B/CC/Ciqc1F7fSbuAPPvbAAG3YJeCl48222.png" alt="Drawing 5.png"></p><p>RecordPersistentWorker 有两个地方与 MetricsPersistentWorker 有些区别：</p><ol><li>RecordPersistentWorker 中使用的 DataCache（以及 Window）实现是 NoMergeDataCache，它与 MergeDataCache 的唯一区别就是没有提供判断数据是否存在的 containKey() 方法，这样就只提供了缓存数据的功能，调用方无法合并重复数据。</li><li>当 NoMergeDataCache 中缓存的数据到达阈值之后，RecordPersistentWorker 会通过 RecordDAO 生成批量的 IndexRequest 请求，Trace 数据没有合并的情况，所以 RecordDAO 以及 IRecordDAO 接口没有定义 prepareBatchUpdate() 方法。</li></ol><p>RecordDAO.perpareBatchInsert() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> IndexRequest </span><span style="color:#B392F0;">prepareBatchInsert</span><span style="color:#E1E4E8;">(Model model, Record record) throws IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    XContentBuilder builder </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">map2builder</span><span style="color:#E1E4E8;">(storageBuilder.</span><span style="color:#B392F0;">data2Map</span><span style="color:#E1E4E8;">(record));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 生成的是最终 Index 名称，这里的 Index 由前缀字符串(即&quot;segment&quot;)+TimeBucket 两部分构成</span></span>
<span class="line"><span style="color:#E1E4E8;">    String modelName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> TimeSeriesUtils.</span><span style="color:#B392F0;">timeSeries</span><span style="color:#E1E4E8;">(model, record.</span><span style="color:#B392F0;">getTimeBucket</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 创建 IndexRequest 请求</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getClient</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">prepareInsert</span><span style="color:#E1E4E8;">(modelName, record.</span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">(), builder);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> IndexRequest </span><span style="color:#6F42C1;">prepareBatchInsert</span><span style="color:#24292E;">(Model model, Record record) throws IOException {</span></span>
<span class="line"><span style="color:#24292E;">    XContentBuilder builder </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">map2builder</span><span style="color:#24292E;">(storageBuilder.</span><span style="color:#6F42C1;">data2Map</span><span style="color:#24292E;">(record));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 生成的是最终 Index 名称，这里的 Index 由前缀字符串(即&quot;segment&quot;)+TimeBucket 两部分构成</span></span>
<span class="line"><span style="color:#24292E;">    String modelName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> TimeSeriesUtils.</span><span style="color:#6F42C1;">timeSeries</span><span style="color:#24292E;">(model, record.</span><span style="color:#6F42C1;">getTimeBucket</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 创建 IndexRequest 请求</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getClient</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">prepareInsert</span><span style="color:#24292E;">(modelName, record.</span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">(), builder);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>与 MetricsPersistentWorker 一样，RecordPersistentWorker 生成的全部 IndexRequest 请求会交给全局唯一的 BatchProcessEsDAO 实例批量发送到 ES ，完成写入。</p><p>到此，以 SegmentSpanListener 为主的 TraceSegment 处理线就介绍完了。</p>`,86),o=[l];function r(t,c,i,y,E,d){return n(),a("div",null,o)}const g=s(p,[["render",r]]);export{u as __pageData,g as default};
