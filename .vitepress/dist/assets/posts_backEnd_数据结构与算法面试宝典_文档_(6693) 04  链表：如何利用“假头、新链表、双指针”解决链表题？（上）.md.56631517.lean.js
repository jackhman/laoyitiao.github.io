import{_ as p,j as o,o as e,g as t,k as a,Q as l,s,h as c}from"./chunks/framework.b3d8e22e.js";const B=JSON.parse('{"title":"三板斧中的第一斧：假头 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6693) 04  链表：如何利用“假头、新链表、双指针”解决链表题？（上）.md","filePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6693) 04  链表：如何利用“假头、新链表、双指针”解决链表题？（上）.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/数据结构与算法面试宝典_文档/(6693) 04  链表：如何利用“假头、新链表、双指针”解决链表题？（上）.md"},E=l("",31),y=s("p",null,[s("strong",null,"小测验"),c("：这里 tail 指针需要判断是否为空吗？")],-1),i=s("ul",null,[s("li",null,[s("p",null,"A. 需要")]),s("li",null,[s("p",null,"B. 不需要")])],-1),d=s("p",null,[s("strong",null,"正确答案 B")],-1),A=s("p",null,"带假头的链表初始化之后，可以保证 tail 指针永远非空，因此，也就可以直接去修改 tail.next 指针，省略掉了关于 tail 指针是否为空的判断。比如，空链表追加新结点时执行过程如下动图所示：",-1),g=l("",7),h=s("p",null,"这段代码有趣的地方在于，当链表为空的时候，它依然是可以工作的。因为虽然链表是空的，但是由于有 dummy 结点的存在，代码并不会遇到空指针，此时工作流程如下：",-1),u=l("",13),D=l("",16),b=l("",9),m=l("",7);function F(v,_,x,L,k,C){const n=o("Image");return e(),t("div",null,[E,a(n,{alt:"1.gif",src:"https://s0.lgstatic.com/i/image6/M00/17/CA/CioPOWBIMYOASGfSAAfGljWjNtw694.gif"}),y,i,d,A,a(n,{alt:"2.gif",src:"https://s0.lgstatic.com/i/image6/M00/17/CD/Cgp9HWBIMZCAEHw5AAVk4Jb8MEs921.gif"}),g,a(n,{alt:"3.gif",src:"https://s0.lgstatic.com/i/image6/M00/17/CD/Cgp9HWBIMZ2AEMTiAAoTgPIJPh8420.gif"}),h,a(n,{alt:"4.gif",src:"https://s0.lgstatic.com/i/image6/M00/17/CD/Cgp9HWBIMaeAMwi6AAdLTcRFg2U490.gif"}),u,a(n,{alt:"5.gif",src:"https://s0.lgstatic.com/i/image6/M00/17/CA/CioPOWBIMbWAZF4OAAuzYmMlByU170.gif"}),D,a(n,{alt:"6.gif",src:"https://s0.lgstatic.com/i/image6/M00/17/CA/CioPOWBIMgiAGcwWAAeNIlv7KX0437.gif"}),b,a(n,{alt:"Drawing 13.png",src:"https://s0.lgstatic.com/i/image6/M00/17/CA/CioPOWBIMhaAJYx8AADVb1uk2iI792.png"}),m])}const N=p(r,[["render",F]]);export{B as __pageData,N as default};
