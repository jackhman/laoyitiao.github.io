import{_ as o,D as e,o as t,g as r,J as a,h as s,Q as p,m as l}from"./chunks/framework.f67d7268.js";const O=JSON.parse('{"title":"11 贪心：这种思想，没有模板，如何才能掌握它？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6700) 11  贪心：这种思想，没有模板，如何才能掌握它？.md","filePath":"posts/backEnd/数据结构与算法面试宝典_文档/(6700) 11  贪心：这种思想，没有模板，如何才能掌握它？.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/数据结构与算法面试宝典_文档/(6700) 11  贪心：这种思想，没有模板，如何才能掌握它？.md"},E=p(`<h1 id="_11-贪心-这种思想-没有模板-如何才能掌握它" tabindex="-1">11 贪心：这种思想，没有模板，如何才能掌握它？ <a class="header-anchor" href="#_11-贪心-这种思想-没有模板-如何才能掌握它" aria-label="Permalink to &quot;11 贪心：这种思想，没有模板，如何才能掌握它？&quot;">​</a></h1><p>贪心算法（Greedy Algorithms）指的是求解问题时，总是做出在当前看来是最好的选择。 一个全局最优解可以通过选择局部最优解来达到。</p><p>贪心算法的运用非常广泛，比如哈夫曼（Huffman）树，单源最短路径（Dijkstra），构建最小生成树的 Prim 算法和 Kruskal 算法等。</p><p>学完这一讲，你将会收获：</p><ul><li><p>贪心算法类题目的特点</p></li><li><p>贪心算法的解题思路</p></li></ul><p><em>注：贪心算法没有模板可以套，其重点在于对题目的分析，对结论的推导。因此，这一讲，我们不再延用&quot;模拟、规律、匹配、画图&quot;四步分析法，而是将重点放在介绍一些题目是如何演变而来的，以及如何推导出贪心所用的结论。我会尝试用尽量少的数学公式，且让你能看懂的方式来讲解。</em></p><h3 id="贪心的特点" tabindex="-1">贪心的特点 <a class="header-anchor" href="#贪心的特点" aria-label="Permalink to &quot;贪心的特点&quot;">​</a></h3><p>面试中考察贪心算法的题目必然具备以下<strong>2 个特点，<strong>这里我用</strong>最通俗的话</strong>给你描述。</p><h4 id="特点-1-只选局部最优解" tabindex="-1">特点 1：只选局部最优解 <a class="header-anchor" href="#特点-1-只选局部最优解" aria-label="Permalink to &quot;特点 1：只选局部最优解&quot;">​</a></h4><p>在求解过程中，我们可以通过<strong>每一步都选择最优解</strong>，最终得到整个问题的最优解。下面我们通过一个简单的题目：寻找数组中最大的数，进一步说明一下这个特点。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">maxValue</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> maxValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.MIN_VALUE; </span><span style="color:#6A737D;">// 初始集合里面的最大值</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    maxValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(maxValue, </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i]);  </span><span style="color:#6A737D;">// 迭代当前最优解</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> maxValue; </span><span style="color:#6A737D;">// 结束后，当前最优解变身全局最优解。</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">maxValue</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> maxValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MIN_VALUE; </span><span style="color:#6A737D;">// 初始集合里面的最大值</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    maxValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(maxValue, </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i]);  </span><span style="color:#6A737D;">// 迭代当前最优解</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> maxValue; </span><span style="color:#6A737D;">// 结束后，当前最优解变身全局最优解。</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p><strong>首先：</strong> 在一个初始集（这里是一个空集），设置一个初始解。在这里，我们设置为 Integer.MIN_VALUE。</p>`,12),y=l("p",null,[l("strong",null,"迭代"),s("：当有新元素进来的时候，我们需要迭代当前最优解。迭代后的最优解是已知数据的最优解。")],-1),i=l("p",null,[l("strong",null,"答案"),s(" ：当处理完所有的数据之后，"),l("strong",null,"当前最优解"),s(" 立马"),l("strong",null,"变身全局最优解"),s("。")],-1),A=l("p",null,[l("em",null,"由此，我们也可以看出，贪心算法在操作的时候，总是把局部次优解直接扔掉，保留局部最优解，最终得到整个问题的最优解。")],-1),g=l("h4",{id:"特点-2-不能-逆袭",tabindex:"-1"},[s('特点 2：不能"逆袭" '),l("a",{class:"header-anchor",href:"#特点-2-不能-逆袭","aria-label":'Permalink to "特点 2：不能"逆袭""'},"​")],-1),D=l("p",null,[s("下面我们用一道题目说明"),l("strong",null,'什么是"逆袭"'),s("。给定如下图所示的图形，从上往下走的时候，只能走到相邻格子的左边或者右边。求从顶部走到底部的最大和。")],-1),F=l("p",null,"比如，这里我们给出合法与不合法的两种情况，如下图所示：",-1),u=l("p",null,"如果使用贪心算法求解这个问题，你可以结合下图进行思考：",-1),d=l("p",null,"如果在每一步，我们总是选择当前能选择的最大值，那么得到的解就不是最优解。因为最优解是 2 + 3 + 100 = 105。",-1),C=l("p",null,[s("那么问题出在哪里？这是因为在第二层有一个"),l("strong",null,"次优解"),s(" 2 + 3，在第三层能够从 3 跳到 100，最终变成整个问题的最优解。")],-1),h=p('<p>因此，在利用贪心算法的时候，必须要满足&quot;<strong>不能逆袭</strong>&quot;的特性：</p><blockquote><p>局部次优解不能反超，不能成为问题的最终最优解！</p></blockquote><p><em>注：这里我只是用一个例子来说明&quot;不能逆袭&quot;的特性，你能够意会到这种&quot;次优解反超的特点&quot;即可。</em></p><h4 id="记忆" tabindex="-1">记忆 <a class="header-anchor" href="#记忆" aria-label="Permalink to &quot;记忆&quot;">​</a></h4><p>在生活中，有一句有趣的歌诀形象地表现了贪心算法的特点：龙生龙，凤生凤，老鼠生儿会打洞。</p><p>之前的最优解&quot;龙&quot;生成新的&quot;龙&quot;，依然处在食物链的高层，最后得出的仍然是最优解。而次优解&quot;凤&quot;和&quot;老鼠&quot;通过繁育是无法完成&quot;逆袭&quot;的，因此无法变成最优解。</p><p>另外，贪心算法的题目比较依赖一些现有的结论。在日常学习算法和数据结构的过程中，你要特别注意总结经验和积累结论。下面我们一起通过几道例题深入学习贪心算法，然后我还会带你总结出一些有趣的结论。</p><h3 id="例-1-木桶装水" tabindex="-1">例 1：木桶装水 <a class="header-anchor" href="#例-1-木桶装水" aria-label="Permalink to &quot;例 1：木桶装水&quot;">​</a></h3><p>【<strong>题目</strong> 】给定一个数组，表示不同的木板的高度，在装水的时候，你可以选择<strong>两根木板</strong>，然后装满水，在不能倾斜的情况下，里面能装多少水，应该由较短的木板决定。请问最多能装多少水？</p>',9),m=p(`<p>输入：A = [1, 0, 1, 1, 0]</p><p>输出：3</p><p>解释：你可以选择 index = 0 和 index = 3，由于高度都为 1，宽度为 3，装水为 3 x 1 = 3。这样组合装的水最多。</p><p>【<strong>分析</strong>】在正式求解这道题目之前，我们先从一些简单的题目进行展开。比如我们非常熟悉的：求一个数组中的最大值。相信你拿到这道题目就可以开始写代码了：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getMaxValue</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.MIN_VALUE;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(ans, </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i]);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getMaxValue</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MIN_VALUE;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(ans, </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i]);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果我们仔细观察上述解法，可以发现贪心算法成立的关键在于：贪心的策略保证了在已知求解范围（绿色）区域里面始终是最大的。如下图所示：</p>`,6),b=p(`<p>在这个解法里面，我们采用的是从一侧推进来求最大值，如果我问你，是否有其他我们已经学过的办法可以解决这道题目呢？答案就是&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6699" target="_blank" rel="noreferrer">10 | 双指针：如何掌握解决最长，定长，最短区间问题的决窍？</a>&quot;介绍的<strong>双指针</strong>。我们可以利用双指针从数组的两侧来推进，求解这个数组的最大值，代码可以写成如下这样：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getMaxValue</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A</span><span style="color:#6A737D;">/*输入保证非空*/</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getMaxValue</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A</span><span style="color:#6A737D;">/*输入保证非空*/</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> j) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[j]) {</span></span>
<span class="line"><span style="color:#24292E;">      j</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>如果用比武打个比方，这种思路的依据就是每次取两个人来比武，胜者留下，那么留下来的当然是数组中的最大值。因此，可以得到<strong>结论 1</strong>。</p><p><strong>结论 1</strong>：</p><blockquote><p>max(A[i]，A[j]) 就是 [0...i] 和 [j ... N) 这两个区间里面的最大值。</p></blockquote><p>前面我们都把注意力放在了较大的数。那么，有没有什么结论留给&quot;较小的数&quot;呢？</p><p>实际上，对于较小的数，还有一个有用的结论。下面我们从头开始推导一下。</p><p>首先，数组的最大值所在位置，最终肯定可以将数组切分成 3 个区域，分别用 3 种颜色来表示（如果数组中有多个同值的最大值，只需要挑一个出来当最大值即可）。但是具体如何切分，我们一开始并不清楚。</p>`,8),_=l("p",null,[s("但是，如果利用 i，j 左右同时向中间走，最大值一定出现在 [i, j] 这个范围里面，所以 "),l("strong",null,"[0, i) 区域肯定是绿色的，而 (j, N) 区域肯定是红色的"),s("。")],-1),f=p("<p>那么，如果 A[i] &gt; A[j]，留给较小的数 A[j] 的结论是什么呢？</p><p>留下的便是<strong>结论 2</strong>：</p><blockquote><p>异色区域，大于等于 A[j] 且离 j 最远的元素就是 A[i]。</p></blockquote><p>我们用反证法简略证明一下：假设程序执行到 A[i] &gt; A[j] 成立，但是数组中有另外一个元素 0 &lt;= x &lt; i，并且 A[x] &gt; A[j] 成立。那么：</p><ul><li><p>根据结论 1，[0, x] 区域，和 [j, N) 区域里面的最大值必然是 max(A[x], A[j])；</p></li><li><p>由于A[x] &gt; A[j]，所以 [0, x] 区域和 [j, N) 区域里面的最大值必然是 A[x]；</p></li><li><p>那么在执行算法的时候，当执行到 A[x] &gt; A[j] 时，会接着执行 j--，也就是说，程序不可能执行到 A[i] &gt; A[j] 位置，这与假设矛盾。</p></li></ul><p>当然，结论 2 也可以针对 A[i] &lt; A[j] 写成：</p><blockquote><p>异色区域，大于等于 A[i] 且离 i 最远的元素就是 A[j]。</p></blockquote><p>那么利用结论 2，我们能做什么呢？由于已经知道异色区域中更大的元素的位置。我们再回到原题，用木板装水的过程中，装水量是由最短的木板决定的。</p><p>根据上述分析，我们是不是可以得出第三个结论：装水最多的时候，是否就是<strong>异色且成对</strong>的 &lt;i, j&gt; 呢？我们假设该结论成立。</p><p><strong>结论 3</strong>：</p><blockquote><p>装水最多的时候，必定由异色区域两根木板来装。</p></blockquote><p>但是你可能很快会找到一个反例。如下图所示（注意，不同位置的竖线高度，分别表示相应位置元素的值的大小）：</p>",12),B=l("p",null,"在 j 的同侧，还有一个 A[k] 比 A[j] 稍大且 A[k]，A[j] 离得很远。此时 A[i] 和 A[j] 装的水（1 号区域）肯定比 A[j] 和 A[k] 装的水（2 号区域）少。",-1),v=l("p",null,"但是，既然已经出现这种情况，那么可以肯定的是，此时 A[i] > A[j] 且 A[i] > A[k]。并且 A[k] > A[j]，实际上可以得到一个更大的装水区域。即由 A[i]，A[k] 形成的下图中 3 号区域：",-1),x=p(`<p>同样也得出结论 3 是成立的。</p><p>那么根据结论 3，我们就知道最优答案只能在异色区域里面选（可以想象成装水的水桶两根木板一定要不一样的颜色）。然后根据结论 2，我们又可以知道每个元素 A[x] 在异色区域里面离 x 最远且更大的是谁。那么这道题目就可以求解了。</p><p>【<strong>代码</strong>】根据结论 2 和结论 3 我们可以写出代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">maxArea</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] A) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, j </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> j) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> height </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">min</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i], </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[j]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> width </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> j </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> i;</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Math.</span><span style="color:#B392F0;">max</span><span style="color:#E1E4E8;">(ans, height </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> width);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[j]) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      j</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">maxArea</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] A) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, j </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> j) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> height </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">min</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i], </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[j]);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> width </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> j </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> i;</span></span>
<span class="line"><span style="color:#24292E;">    ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Math.</span><span style="color:#6F42C1;">max</span><span style="color:#24292E;">(ans, height </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> width);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[j]) {</span></span>
<span class="line"><span style="color:#24292E;">      j</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/11.%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：双指针左右同时遍历数组的元素，每个元素只访问一遍，因此，其复杂度为 O(N)，空间复杂度为 O(1)。</p><p>【<strong>小结</strong>】本质上这道题就是从&quot;求一个求数组的最大值&quot;延伸和演变而来。只是我们通过双指针求解数组最大值的过程中，总结出了结论 1 和结论 2。然后再结合题意要求，得到结论 3，最后使这个问题得到解决。</p><p>这道题目的考点我们进行一下归纳。</p><ul><li><p>双指针：需要从左右两端向中间走（这和我们前面所讲的双指针略有不同）。</p></li><li><p>贪心算法：通过结论 1、结论 2、结论 3，每一步都选择最优解，最终得到整个问题的最优解。</p></li></ul><p>为了帮助你巩固上述解题方法，这里我再给你留一道类似的题目。</p><p><strong>练习题 1</strong>：给定一个数组 A[]，A[i] 表示柱子的高度，宽度为一个单位。如果我们不停往里面加水，直到所有柱子之间都加满为止。请问：给定一个图形，最多能接多少单位面积的水？</p>`,11),q=p('<p>输入：A = [0,1,0,2,1,0,1,3,2,1,2,1]</p><p>输出：6</p><p>解释：如图所示，最多只能接 6 个单位面积的水。蓝色部分是水，而黑色部分是柱子，数组中不同的值，由不同高度的柱子表示。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/42.%E6%8E%A5%E9%9B%A8%E6%B0%B4.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="例-2-不重叠区间" tabindex="-1">例 2：不重叠区间 <a class="header-anchor" href="#例-2-不重叠区间" aria-label="Permalink to &quot;例 2：不重叠区间&quot;">​</a></h3><p>【<strong>题目</strong> 】给定一系列区间，请你选一个子集，使得这个子集里面区间都不相互重叠，并且这个子集里面元素个数最多。不重叠的定义：区间 [3,4] 和 [4,5] 就是不重叠。</p><p>输入：A = [[1,2],[2, 3], [3,4], [1,3]</p><p>输出：3</p><p>解释：最多只能选出 3 个区间相互不重叠[1,2], [2,3], [3,4]。</p><p>【<strong>分析</strong>】这个问题，最后相互不重叠的区间应该是初始集合的一个子集。那么，当我们遇到一个区间的时候，应该取还是不取呢？</p><p>下面我们从&quot;单个区间：取和不取&quot;来展开讲解。这里我们需要稍微进行一下推导。假设：</p><ol><li><p>已经求解了下图中的绿色区域，并且得到了绿色区域的最优解 maxNum；</p></li><li><p>接下来我们要处理红色元素（也就是单个的区间）。</p></li></ol><p>（注意：下文的 maxNum 和 newMaxNum 均表示区间里面的不重合区间的最大数目，其中 newMaxNum 表示区间<strong>范围变长</strong> 之后的<strong>新的不重合区间</strong> 的<strong>最大数目</strong>）</p>',13),k=p("<p>那么当红色区间进来的时候，应该如何更新 maxNum 的值呢？新的 newMaxNum 的值又如何决定呢？</p><p>这里可以分为两种情况。</p><p>Case 1：newMaxNum <strong>不包含</strong>新来的区间（红色部分），应该直接等于旧的 maxNum</p><p>Case 2：newMaxNum<strong>一定包含</strong>新来的区间（红色部分）</p><p>如果进行迭代的话，就是：</p><blockquote><p>更新后的最优解 = max（不包含红色区间 =maxNum， 一定包含红色区间的最优解）</p></blockquote><p>Case 1 的值是不需要求解的。那么接下来，我们只需要看 Case 2。</p><p>这种情况又可以分为两种小情况。</p><p>Case 2.1：新来的区间与旧的任何区间都没有交集，那么 newMaxNum = maxNum + 1。</p><p>Case 2.2：新来的区间与旧的区间有交集。</p><p>Case 2.1 的值已经计算出来了，我们再来看 Case 2.2。</p><p>求解 Case 2.2，需要从区间的不重叠性出发。关于&quot;区间不重叠&quot;，有一个<strong>性质</strong>：</p><blockquote><p>两个区间 [a, b] 和 [c,d] 不相交，只需要满足 b &lt;= c || d &lt;= a 就可以了。</p></blockquote><p>现在，我们知道：区间的重叠只需要看两端的大小。可以将绿色区间部分<strong>排序</strong> 。<strong>绿色区间集合</strong>将分为两部分：</p><ul><li><p>集合 a. 与红色新进来的区间有交集（下图紫色部分）；</p></li><li><p>集合 b. 与红色新进来的区间没有交集（下图绿色部分）。</p></li></ul><p>我们画图如下：</p>",16),j=p("<p>假设已知集合 a 中不重叠的区间个数为 preMaxNum，那么我们就得到了 Case 2.2 的解：preMaxNum + 1。</p><p>此外， preMaxNum 肯定小于 maxNum，所以此时 preMaxNum + 1 &lt;= maxNum。也就是说，Case 2.2 最优的时候，都没有 Case 1 好。所以对于整个问题：我们只需要考虑 Case 1 和 Case 2.1。</p><blockquote><p>Case 2.2 逆袭的最优情况也只是等同于 Case 1。次优解不能逆袭超车，正好使用贪心算法。</p></blockquote><p>那么接下来，我们看 Case 1 与 Case 2.1，由此可以得到一个<strong>结论 1</strong>：</p><blockquote><p><strong>如果新来的区间与前面的区间不重叠，那么不重叠区间数目就能增加一个。</strong></p></blockquote><p>至此，我们知道通过排序，并且依赖性质 1 可以得出两个区间是否重叠。那么如何排序呢？区间有两个端点 [start, end]，是按照 start 排序还是按 end 排序呢？</p><p>这里我们先用 end 来排序（很多博客上说不能用 start 排序，实际上是可以的，下面我们会具体分析）。</p>",7),T=p(`<p>由于我们是按照每个区间的 [start, end] 来排序的，并且用了一个变量 maxEnd 记录已经处理的区间的最大 maxEnd。那么当新区间 [c, d] 进来的时候，只需要判断：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">newMaxNum </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> maxNum </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> (maxEnd </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> c </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">maxNum </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newMaxNum;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">newMaxNum </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> maxNum </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> (maxEnd </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> c </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">maxNum </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> newMaxNum;</span></span></code></pre></div><p>此外，还需要注意 maxEnd 的更新。在前面的图中，为了简化条件，我并没有清晰地指出 maxEnd 指代的含义。你需要注意 maxEnd 的含义：如果你选取的区间都是不重叠的，maxEnd 是你<strong>选中的区间</strong> 的最大 end，而<strong>不是你查看过的区间</strong>的最大 end。</p><p>因为，只有这样，我们才可以知道<strong>要不要把新区间加入不重叠的集合</strong>里面。</p><p>【<strong>代码</strong>】原理已经讲清楚了，下面可以开始写代码了（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">nonOverlapIntervals</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[][] A) {</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#6A737D;">// 将区间进行排序</span></span>
<span class="line"><span style="color:#E1E4E8;">Arrays.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(A, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Comparator&lt;</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[]&gt;() {</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compare</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> b[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (a[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> b[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"><span style="color:#6A737D;">// 已重叠的区间的最右端点</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> maxEnd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.MIN_VALUE;</span></span>
<span class="line"><span style="color:#6A737D;">// 不重叠 的区间的个数</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 开始贪心算法</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> start </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i][</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (maxEnd </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> start) {</span></span>
<span class="line"><span style="color:#E1E4E8;">maxEnd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i][</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">ans</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">nonOverlapIntervals</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[][] A) {</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#6A737D;">// 将区间进行排序</span></span>
<span class="line"><span style="color:#24292E;">Arrays.</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(A, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Comparator&lt;</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[]&gt;() {</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compare</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> b[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (a[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> b[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"><span style="color:#6A737D;">// 已重叠的区间的最右端点</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> maxEnd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MIN_VALUE;</span></span>
<span class="line"><span style="color:#6A737D;">// 不重叠 的区间的个数</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 开始贪心算法</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> start </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i][</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (maxEnd </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> start) {</span></span>
<span class="line"><span style="color:#24292E;">maxEnd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i][</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">ans</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.1.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：假设有 N个 区间，程序的核心分为排序与贪心。排序的时间复杂度为 O(NlgN)，而贪心的算法复杂度为 O(N)，空间复杂度为 O(1)。</p><p>【<strong>小结</strong>】我们分析这道题目的时候，并不清楚是否要引入排序，而是一步步推导得出&quot;需要使用排序来进行预处理&quot;，然后再使用贪心算法。</p><p>不过前文说到，排序的时候也可以使用区间 [start, end] 中的 start 排序。这里我就再给出根据 start 进行排序的代码。核心思路：<strong>如果在区间排序的时候，根据 start 来排序，那么在处理的时候，需要逆序进行</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">eraseOverlapIntervals</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[][] A) {</span></span>
<span class="line"><span style="color:#6A737D;">// 区间的总数</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#6A737D;">// 将区间[start, end]根据start来排序</span></span>
<span class="line"><span style="color:#E1E4E8;">Arrays.</span><span style="color:#B392F0;">sort</span><span style="color:#E1E4E8;">(A, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Comparator&lt;</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[]&gt;() {</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">compare</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">a</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">b</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> b[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (a[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> b[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">] </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> preStart </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 处理的时候，从后面开始处理</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> start </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i][</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> end </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i][</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (end </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> preStart) {</span></span>
<span class="line"><span style="color:#E1E4E8;">preStart </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> start;</span></span>
<span class="line"><span style="color:#E1E4E8;">ans</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">eraseOverlapIntervals</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[][] A) {</span></span>
<span class="line"><span style="color:#6A737D;">// 区间的总数</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#6A737D;">// 将区间[start, end]根据start来排序</span></span>
<span class="line"><span style="color:#24292E;">Arrays.</span><span style="color:#6F42C1;">sort</span><span style="color:#24292E;">(A, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Comparator&lt;</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[]&gt;() {</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">compare</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">a</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">b</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> b[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (a[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> b[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">] </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> preStart </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Integer.MAX_VALUE;</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 处理的时候，从后面开始处理</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> start </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i][</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> end </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i][</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (end </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> preStart) {</span></span>
<span class="line"><span style="color:#24292E;">preStart </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> start;</span></span>
<span class="line"><span style="color:#24292E;">ans</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/nonOverlap.2.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>不重叠区间问题是很多问题的模板题。你掌握了这个模板就可以解决掉更多题目。下面请你尝试完成下面一批练习题。你一定要自己动手练习，不要偷懒哦！如果有你对哪里有疑问，也欢迎你写在留言区，我们一起讨论。</p><p><strong>练习题 2</strong>：给定一系列区间，返回最少需要删除的区间数目，使得剩下的区间不重叠。</p><p>输入：A = [[1,2], [2,3], [1,4]]</p><p>输出：1</p><p>解释：这里我们选择删除 [1, 4] 剩下的区间便不再重叠。这是最少的删除区间的数目。</p><blockquote><p>解法 1：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.1.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p><p>解法 2：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.2.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 3</strong>：给定一个字符串，需要切分成尽可能多的切片，但是一个字母只能放在一个切片里面。</p><p>输入：A = &quot;abcabdefg&quot;</p><p>输出：5</p><p>解释：最多可以分为 [&quot;abcab&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot;]。你不能切成 [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;]，在这种情况下 &#39;a&#39; 字母并没有处于同一个切片。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 4</strong>：给定一系列区间，将重合的区间合并在一起。</p><p>输入：A = [[1,2], [2,3], [2,6], [7, 8]]</p><p>输出：[[1, 6], [7,8]]</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="例-3-青蛙跳" tabindex="-1">例 3：青蛙跳 <a class="header-anchor" href="#例-3-青蛙跳" aria-label="Permalink to &quot;例 3：青蛙跳&quot;">​</a></h3><p>【<strong>题目</strong>】给定一个数组 A[]，元素 A[i] &gt;= 0，一只青蛙站在 index = i，那它可以跳到 A[i+1], ..., A[i+A[i]]（当然，它是不能跳出数组的）。那么请问这只青蛙从 index = 0 出发，能不能跳到 index = A.length - 1。</p><p>输入：A = [2, 3, 1, 2, 1]</p><p>输出：true</p><p>解释：青蛙可以这样跳，A[0] → A[1] → A[4]</p><p>【<strong>分析</strong> 】这个问题的重点在于，<strong>站在 index = i，那它可以跳到 [i, ..., i + A[i]]</strong>。</p><p>因此，它表示的信息就是两点：</p><ul><li><p>起点 i</p></li><li><p>终点 i + A[i]</p></li></ul><p>这货不就是一个区间吗？因此，数组里面的每一个元素，实际上都表示了一段区间 [i, i + A[i]]。并且，这些区间都已经按照区间的起始点排好序了。</p><p>那么问题就演变成：给定一系列区间，这段区间是否可以<strong>连续</strong>覆盖 [0, N-1] 这个范围。题目也就变成一个区间覆盖问题。</p><p>当走到位置 i 的时候，相当于已经覆盖了范围 [0, i + A[i]]。那么接下来，由于我们需要实现的目标是：连续覆盖得越远越好。</p><p>因此只需要选择这样的区间：</p><ul><li><p>区间的起始位置 x 一定要在 [0, i + A[i]] 范围里面，也就是要<strong>满足相连</strong>；</p></li><li><p>区间的终止位置 x + A[x] 一定要越远越好。</p></li></ul><p>那么，我们可以写出暴力的算法<strong>版本 1</strong>如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">canJump</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">A</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 起始位置能拿到的区间是[0, 0 + A[0]]</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> coveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">];</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> used </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (coveredRange </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> used </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> oldCoveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> coveredRange;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 我们从0 ~ N - 1里面选一个区间</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 注意，我们并不害怕重复选择同一个区间</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 因为重复选择同一个区间，并不能让覆盖范围变长。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 不能变长的情况，我们就直接return false.</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">//</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// （扫描循环:待优化）.....</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 1. 如果这个区间和我们已经覆盖的范围是相连的!</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 满足相连性</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> oldCoveredRange) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 2. 如果这个区间能覆盖得更远</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> coveredRange) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 更新我们能cover的范围</span></span>
<span class="line"><span style="color:#E1E4E8;">                        coveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">                    } </span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldCoveredRange </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> coveredRange) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 否则，已经使用的区间数目++</span></span>
<span class="line"><span style="color:#E1E4E8;">            used</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">canJump</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">A</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 起始位置能拿到的区间是[0, 0 + A[0]]</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> coveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">];</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> used </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (coveredRange </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> used </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldCoveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> coveredRange;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 我们从0 ~ N - 1里面选一个区间</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 注意，我们并不害怕重复选择同一个区间</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 因为重复选择同一个区间，并不能让覆盖范围变长。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 不能变长的情况，我们就直接return false.</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">//</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// （扫描循环:待优化）.....</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 1. 如果这个区间和我们已经覆盖的范围是相连的!</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 满足相连性</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> oldCoveredRange) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 2. 如果这个区间能覆盖得更远</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> coveredRange) {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 更新我们能cover的范围</span></span>
<span class="line"><span style="color:#24292E;">                        coveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">                    } </span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCoveredRange </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> coveredRange) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 否则，已经使用的区间数目++</span></span>
<span class="line"><span style="color:#24292E;">            used</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>暴力算法每次在完成区间更新的时候，都是搜索所有可能的解，因此其正确性是可以得到保证的。（在<a href="https://leetcode-cn.com/problems/jump-game/?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">测试平台</a>上也可以通过）。但是面试官要的肯定不是复杂度这么高的算法。因此，我们需要在此基础上继续优化。</p><p><strong>【优化 1</strong>】由于连续性的要求，在扫描的时候，不需要遍历 [0, N) 的所有元素，只需要遍历 [0,oldCoveredRange] 这个范围里面的元素。那么扫描循环可以优化如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// （扫描循环:待优化）.....</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> oldCoveredRange; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 1. 这个区间和我们已经覆盖的范围是相连的!</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 满足相连性</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 2. 如果这个区间能覆盖得更远</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> coveredRange) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 更新我们能cover的范围</span></span>
<span class="line"><span style="color:#E1E4E8;">                    coveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// （扫描循环:待优化）.....</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> oldCoveredRange; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 1. 这个区间和我们已经覆盖的范围是相连的!</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 满足相连性</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 2. 如果这个区间能覆盖得更远</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> coveredRange) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 更新我们能cover的范围</span></span>
<span class="line"><span style="color:#24292E;">                    coveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">                } </span></span>
<span class="line"><span style="color:#24292E;">            }</span></span></code></pre></div><p><strong>【优化 2</strong>】我们发现：</p><ul><li><p>如果有区间在覆盖范围 [0, A] 里面被扫描过了；</p></li><li><p>在下一轮覆盖范围 [0, B] 里面还会被扫描；</p></li><li><p>B &gt;= A。</p></li></ul><p>而 [0, B] 实际上可以分为两段，[0, A] 和 [A+1, B]。既然 [0,A] 这一段已经扫描过了，那么为了避免重复扫描，接下来只需要扫描 [A+1, B] 即可。因此，每次扫描的时候，你都需要记住当前这次扫描的终点 A。</p><p>【<strong>代码</strong>】根据上述分析，我们就可以写出如下代码了（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Solution</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">canJump</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">A</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> A </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> A.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 所以之记录之前扫描位置设置为-1</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> preScanedPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 根据题意</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> curCoveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 如果当前</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">while</span><span style="color:#E1E4E8;"> (curCoveredRange </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> oldCoveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> curCoveredRange;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 根据优化1和优化2，我们只需要遍历</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// [preScanedPos + 1, oldCoveredRange]即可。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 然后不停更新curCoveredRange</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> preScanedPos </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> oldCoveredRange; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 1. 这个区间和我们已经覆盖的范围是相连的!</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 满足相连性</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 2. 如果这个区间能覆盖得更远</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> curCoveredRange) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 更新我们能cover的范围</span></span>
<span class="line"><span style="color:#E1E4E8;">                    curCoveredRange </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">A</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (oldCoveredRange </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> curCoveredRange) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 我们记住上次已经扫描过的位置</span></span>
<span class="line"><span style="color:#E1E4E8;">            preScanedPos </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> oldCoveredRange;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Solution</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">canJump</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">A</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> A </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> A.length;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 一开始，在正式开始第一次扫描之前，肯定什么元素都还没有扫描过</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 所以之记录之前扫描位置设置为-1</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> preScanedPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 根据题意</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 当前能覆盖到数组的第0个元素。也就是当前可以够得着的元素</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> curCoveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 如果当前</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">while</span><span style="color:#24292E;"> (curCoveredRange </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> oldCoveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> curCoveredRange;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 根据优化1和优化2，我们只需要遍历</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// [preScanedPos + 1, oldCoveredRange]即可。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 然后不停更新curCoveredRange</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> preScanedPos </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> oldCoveredRange; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 1. 这个区间和我们已经覆盖的范围是相连的!</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 满足相连性</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 2. 如果这个区间能覆盖得更远</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> curCoveredRange) {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 更新我们能cover的范围</span></span>
<span class="line"><span style="color:#24292E;">                    curCoveredRange </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">A</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">                } </span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果发现不能更新覆盖范围，说明已经没有变长的可能性了。</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (oldCoveredRange </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> curCoveredRange) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 我们记住上次已经扫描过的位置</span></span>
<span class="line"><span style="color:#24292E;">            preScanedPos </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> oldCoveredRange;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/55.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度 O(N)，空间复杂度 O(1)。实际上，这里最多每个点遍历一次，所以时间复杂度为 O(N)。</p><p>【<strong>小结</strong> 】在做完这个题之后，不妨和我们&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=685#/detail/pc?id=6691&amp;fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">第 02 讲</a>&quot;学过的 FIFO 队列进行一个知识上的联动。</p><p>记得我以前学习队列的时候，访问一个点时，会把后续的点都放到队列中，如下图所示：</p>`,54),G=l("p",null,"但是在这道题中，当访问 i 这个点的时候，后续能够走的点是 A[i+1] ... A[i+A[i]]，但并没有把所有的点都入队，而是从里面选择了一个最优的点。",-1),N=l("p",null,"如果把遍历的顺序也放到一个队列中，那么入队的时候，就只是把后面最优的点放到队列中。这个性质和优先级队列不太一样。优先级队列会把所有的元素都放到堆里面，然后堆内有序。但是对于贪心来说，只需要把最优秀的元素入队即可。",-1),R=p('<p>当然，由于每次都只选一个后续最优元素入队，因此这个 Queue 的长度最长是 1。这和我们之前学过的队列知识存在相似之处，但也有不同的地方。</p><p>如果我们再从深度上挖掘一下这道题，还可以有得到下面这些练习题。</p><p><strong>练习题 5</strong>：问题与例 3 一样，只不过这个题：需要输出最少跳跃的次数？如果不能跳到 A.length-1，请输出 -1。</p><p>输入：A = [2, 3, 1, 2, 1]</p><p>输出：2</p><p>解释：A[0]→A[1]→A[4] 最少跳两次就可以到达最后一个下标。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/45.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>接下来我们看一下：给定一系列区间，如果要完全覆盖 [start, end] 这个区间，应该如何处理呢？请看练习题 6。</p><p><strong>练习题 6</strong>：一个大门安装了好几个摄像头，每个摄像头会录下一段时间的视频（假设起始时间与结束时间都是一个整数，可能为负数）。如果想找到 [0, T] 时间段的视频，请问最少需要提取几个摄像头的视频？如果不能得到 [0, T] 这个时间段的视频，输出 -1。</p><p>输入：[[1,2], [0,2], [0,1], [2,3], [2,6], [3,8]], T = 5</p><p>输出：2</p><p>解释：只需要用 [0, 2]，[2,6] 就可以完全覆盖 [0, 5] 这个时间段。因此，最少需要看 2 个摄像头。</p><blockquote><p>代码：J<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">ava/</a><a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/1024.%E8%A7%86%E9%A2%91%E6%8B%BC%E6%8E%A5.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="例-4-加油站" tabindex="-1">例 4： 加油站 <a class="header-anchor" href="#例-4-加油站" aria-label="Permalink to &quot;例 4： 加油站&quot;">​</a></h3><p>【<strong>题目</strong>】巨大的环形赛道上有 N 个加油站，第 i 个加油站可以加油 G[i] 升，而从第 i 个加油站开到下一个加油站，需要 C[i] 升汽油。请你选择一个起始加油站，能够跑完环形赛道一圈。</p><p>条件：1. 注意是环形赛道；2. 汽车油箱总是足够大。</p><p>输入：G = [1,2], C=[2, 1]</p><p>输出：1</p><p>解释：从站点 0 出发，一开始只能收获 1 升油，而从 index = 0 跑到 index = 1 需要用掉 2 升汽油，所以不能从站点 0 出发。而从站点 1 出发，则可以绕着环形跑道跑一圈。</p><p>【<strong>分析</strong>】当拿到这个题的时候，我们首先考虑一种极端情况，那就是收入与付出不成正比。当 sum(G) &lt; sum(C) 的时候，应该是无论如何也不可能跑一圈的。</p><p>那么接下来就<strong>只需要考虑 sum(G) &gt;= sum(C) 的情况</strong> 。在这种情况下，可以得到<strong>结论 1：</strong></p><blockquote><p>当 sum(G) &gt;= sum(C) 时，必然存在某个点出发可以绕着赛道跑一圈的情况。</p></blockquote><p>证明这个结论需要使用反证法。假设：当 sum(G) &gt;= sum(C)，<strong>不存在</strong>某个点出发，可以绕着赛道跑一圈。若假设成立，那么必然可以将环形跑道切成几段，如下图所示：</p>',23),V=p(`<p>并且每一段都是负数（因为不能绕着跑道跑一圈）。这时不同的段用不同的颜色表示。由于每一个小段和都是 sub_sum(G) &lt; sub_sum(C)，那么必然可以得到总和 sum(G) &lt; sum(C)。这与题目条件相矛盾。</p><p><em>注：我们用 sub_sum() 函数表示求这一小段对应子数组的和。</em></p><p>根据<strong>结论 1</strong>，可以将 sum(G) &gt;= sum(C) 的情况再次分为两种。</p><ul><li><p>Case 1：从站点 0 出发可以跑遍全场。</p></li><li><p>Case 2：从非 0 站点出发可以跑遍全场。</p></li></ul><p>如果是Case 1，那么我们可以写出代码如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// ans表示从哪里出发 </span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 车里剩余的油量。</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 开始遍历每个站点</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  total </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 油量足够</span></span>
<span class="line"><span style="color:#E1E4E8;">    left </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i]; </span><span style="color:#6A737D;">// 把油耗算上去</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// &lt;-- 油量不够</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 不能从站点0出发。! &lt;!待处理!&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 可以从站点0出发，此时ans = 0</span></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> ans;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// ans表示从哪里出发 </span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 车里剩余的油量。</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 开始遍历每个站点</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  total </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 油量足够</span></span>
<span class="line"><span style="color:#24292E;">    left </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i]; </span><span style="color:#6A737D;">// 把油耗算上去</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// &lt;-- 油量不够</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 不能从站点0出发。! &lt;!待处理!&gt;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 可以从站点0出发，此时ans = 0</span></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> ans;</span></span></code></pre></div><p>如果是Case 2，接下来我们再看一下<strong>不能从站点 0 出发</strong>的情况。也就是存在某个点 i，使得汽油不够了。会有 left（余下的汽油） + G[i] - C[i] &lt; 0，那接下来应该从哪里开始呢？</p><ul><li><p>首先，当 G[0] - C[0] &lt; 0 的时候，肯定是不能从 0 开始。</p></li><li><p>其次，当 G[0] - C[0] &gt;= 0 的时候，如果 [0, i] 的油量收益为负数。那么中间任意选一个点 x，且 0 &lt; x &lt;= i，那么 [x, i] 这个区间上的油量收益也必然为负（因为去掉了从 0 位置出发的正收益 G[0] - C[0]）。</p></li></ul><p>这两种情况可以<strong>统一处理</strong>如下：当出现油量不够的时候，下一个尝试的起点应该是 i + 1。</p><p>此时我们可以统一用代码处理如下（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// ans表示从哪里出发 </span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 车里剩余的油量。</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 开始遍历每个站点</span></span>
<span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// &lt;-- 结论1</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  total </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i]; </span><span style="color:#6A737D;">// &lt;-- 结论1</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 油量足够</span></span>
<span class="line"><span style="color:#E1E4E8;">    left </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i] </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i]; </span><span style="color:#6A737D;">// 把油耗算上去</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// &lt;-- 油量不够</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 尝试新站点出发</span></span>
<span class="line"><span style="color:#E1E4E8;">    ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> ans; </span><span style="color:#6A737D;">// &lt;-- 结论1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// ans表示从哪里出发 </span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 车里剩余的油量。</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#6A737D;">// 开始遍历每个站点</span></span>
<span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// &lt;-- 结论1</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  total </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i]; </span><span style="color:#6A737D;">// &lt;-- 结论1</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 油量足够</span></span>
<span class="line"><span style="color:#24292E;">    left </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i] </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i]; </span><span style="color:#6A737D;">// 把油耗算上去</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// &lt;-- 油量不够</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 尝试新站点出发</span></span>
<span class="line"><span style="color:#24292E;">    ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> ans; </span><span style="color:#6A737D;">// &lt;-- 结论1</span></span></code></pre></div><p>但是需要验证找到的 ans 站点出发，可以绕赛道一圈？答案是不需要的，下面我们证明一下这个结论。</p><p>假设从 ans=start 站点出发，那么环形区域必然可以分为两半部分，[0, start) 和 [start, N)。由于不能从 index = 0 出发，那么 [0, start) 这个区域油量收益肯定是 sub_sum(G) &lt; sub_sum(C)，即油量收益肯定是负数。</p>`,13),P=p(`<p>由于油的总量是 sum(G) &gt;= sum(C)，那么后半段油的收益 sub_sum(G) - sub_sum(C) &gt; 0 必然成立。并且，我们可以得到：后半段的收益肯定可以平衡掉前半段的负收益。因此，从 start 出发，就必然可以绕着赛道跑一圈。</p><p>【<strong>代码</strong>】到此时，我们已经可以写出代码了（解析在注释里）：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">canCompleteCircuit</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] G, </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;">[] C) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> N </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> G </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> G.length;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 找一个子数组和最大的地方</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 那么也是相当于找一个子数组和最小的地方</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;"> N; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> get </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">G</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> cost </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">C</span><span style="color:#E1E4E8;">[i];</span></span>
<span class="line"><span style="color:#E1E4E8;">    total </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> get </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> cost;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果我还能开到下一站，好的，那么继续开</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (left </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> get </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> cost </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      left </span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;"> get </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> cost;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 如果从[ans ...i]这段区间里面的收益为负数</span></span>
<span class="line"><span style="color:#E1E4E8;">      left </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">      ans </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> total </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> ans </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">int</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">canCompleteCircuit</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] G, </span><span style="color:#D73A49;">int</span><span style="color:#24292E;">[] C) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> N </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> G </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> G.length;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 找一个子数组和最大的地方</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 那么也是相当于找一个子数组和最小的地方</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;"> N; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> get </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">G</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> cost </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">C</span><span style="color:#24292E;">[i];</span></span>
<span class="line"><span style="color:#24292E;">    total </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> get </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> cost;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果我还能开到下一站，好的，那么继续开</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (left </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> get </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> cost </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      left </span><span style="color:#D73A49;">+=</span><span style="color:#24292E;"> get </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> cost;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 如果从[ans ...i]这段区间里面的收益为负数</span></span>
<span class="line"><span style="color:#24292E;">      left </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">      ans </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> total </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> ans </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>复杂度分析</strong>：时间复杂度为 O(N)，空间复杂度为 O(1)。</p><p>【<strong>小结</strong>】我们经过层层分析，得到最终求解的代码。最后还证明了不需要额外的代码去验证 ans 站点出发的有效性。在这个题中用到的结论 1 是我们分析问题的关键。</p><p>不过这个题还有一个比较<strong>有趣的解法</strong>，解题思路是这样的：</p><ul><li><p>当总和小于 0 的时候，肯定没有解；</p></li><li><p>当总和大于等于 0 的时候，总是有解的，那么在选择起点的时候，可以选择一个子数组，这个子数组是数组里面的最大和，然后就以这里作为起点。（可以反证一下，如果从最大子数组和的起点出发都不能绕赛道一圈，那么其他的点就更没戏了）。</p></li></ul><p>不过想要通关这种解法，需要你依次解决以下几道练习题哦。</p><p><strong>练习题 7</strong>：给定一个数组，求这个子数组里面的最大子数组和。</p><p>输入：A = [1,-5,3,4]</p><p>输出：7</p><p>解释：最大子数组和为 [3,4]，形成的和为 7，没有比 7 更大的子数组和了。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 8</strong>：给定一个数组，这个数组首尾成环，求这个环形数组里面的最大子数组和。</p><p>输入：A = [2, -2, -2, -2, 2]</p><p>输出：4</p><p>解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4 更大的子数组和了。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p><strong>练习题 9</strong> ：同样是例题 4，你能使用我们前面提过的&quot;<strong>从最大子数组和的起点出发</strong>&quot;这种思路进行求解吗？</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/134.%E5%8A%A0%E6%B2%B9%E7%AB%99.2.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><h3 id="总结与延伸" tabindex="-1">总结与延伸 <a class="header-anchor" href="#总结与延伸" aria-label="Permalink to &quot;总结与延伸&quot;">​</a></h3><p>贪心算法是一种思路，没有模板和套路。不过经过今天的学习。可以发现，贪心算法的两个特点中，第一个特点<strong>只选局部最优解</strong> 是比较容易做到的。但是难点在于： <strong>次优解不能逆袭</strong>。</p><p>往往我们要花非常多的时间证明，才能够保证次优解可以扔掉。这里面还涉及了非常多的数学思维，需要你活学活用。</p><p>作为面试官，我给你的建议是：刷贪心题目的时候，<strong>一定要注意推导</strong> ！如果你不会证明：&quot;<strong>为什么次优解可以扔掉？</strong>&quot;，但知道如何进行操作，这说明你还没有真正掌握贪心这种思想。</p><h3 id="思考题" tabindex="-1"><strong>思考题</strong> <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;**思考题**&quot;">​</a></h3><p>最后我再给你留一道思考题：既然可以用练习题 8 思路解决例 4 的问题，那么肯定也可以用例 4 的思路解决练习题 8，你能想一下代码应该怎么写吗？</p><p>给定一个数组，这个数组首尾成环，求这个环形子数组里面的最大子数组和。</p><p>输入：A = [2, -2, -2, -2, 2]</p><p>输出：4</p><p>解释：最大子数组为首尾的 [2, 2]，形成的和为 4，没有比 4 更大的子数组和了。</p><blockquote><p>代码：<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.java?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Java</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.cpp?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">C++</a>/<a href="https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/11.Greedy/918.%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.py?fileGuid=xxQTRXtVcqtHK6j8" target="_blank" rel="noreferrer">Python</a></p></blockquote><p>希望你可以自己动一动手，也欢迎在留言区分享你的思路，我们一起讨论。接下来请和我一起踏上更加奇妙的算法旅程，下一讲将介绍 12 |回溯：我把回溯总结成一个公式，回溯题一出就用它。记得按时来探险。</p>`,33);function H(M,S,I,Q,K,w){const n=e("Image");return t(),r("div",null,[E,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/C9/CioPOWBm7DyAevBHAAB4d_r01V8988.png"}),s(),y,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/C9/CioPOWBm7EOAYHjdAACrP3SVk1w191.png"}),s(),i,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7KuAMBTnAACDRzs75_E116.png"}),s(),A,g,D,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7LSAaCRaAADJvxICzaI478.png"}),s(),F,a(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7LuAEeDiAAEUHK2pjOY488.png"}),s(),u,a(n,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7MGALOGVAADo12H0WNA033.png"}),s(),d,a(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7MeAa4e_AAEETkRZECs168.png"}),s(),C,a(n,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/C1/Cgp9HWBm7M6AWo3fAADom4u66Ss987.png"}),s(),h,a(n,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/CA/CioPOWBm7NeAbj76AAQd0dopTpA832.png"}),s(),m,a(n,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/C3/Cgp9HWBm8cmAJOBqAAC4ja2Veks049.png"}),s(),b,a(n,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/CB/CioPOWBm8jCASGnfAACa3H_KBpM205.png"}),s(),_,a(n,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/C3/Cgp9HWBm8jeAPZokAACCr2BAJUs411.png"}),s(),f,a(n,{alt:"2021423-163817.png",src:"https://s0.lgstatic.com/i/image6/M00/3B/15/Cgp9HWCCh6uAG6fTAACBJOzbUF4404.png"}),s(),B,v,a(n,{alt:"2021423-163823.png",src:"https://s0.lgstatic.com/i/image6/M00/3B/1D/CioPOWCCh7OACEAIAAB4ET8YQCk104.png"}),s(),x,a(n,{alt:"Drawing 14.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/C4/Cgp9HWBm8nKAdTAFAAVvP6TxkfM792.png"}),s(),q,a(n,{alt:"Drawing 15.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/CC/CioPOWBm8nuAQENIAACKoN1sPiQ926.png"}),s(),k,a(n,{alt:"Drawing 16.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/C4/Cgp9HWBm8oeACww_AACubbwdL_c165.png"}),s(),j,a(n,{alt:"Drawing 17.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/CC/CioPOWBm8pGAPhp2AACThtOxY5g556.png"}),s(),T,a(n,{alt:"Drawing 18.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/CD/CioPOWBm8tCAH_xHAADOxSUIRfw102.png"}),s(),G,a(n,{alt:"Drawing 19.png",src:"https://s0.lgstatic.com/i/image6/M01/2D/C5/Cgp9HWBm8taAUbvHAADTudQRn6s636.png"}),s(),N,a(n,{alt:"Drawing 20.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/C5/Cgp9HWBm8t2ASM7CAADVY3j8Qig907.png"}),s(),R,a(n,{alt:"Drawing 21.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/C5/Cgp9HWBm8uqAES68AAIfEBlAW9s655.png"}),s(),V,a(n,{alt:"Drawing 22.png",src:"https://s0.lgstatic.com/i/image6/M00/2D/CE/CioPOWBm8xOAKZD3AAEboP-L1yM535.png"}),s(),P])}const J=o(c,[["render",H]]);export{O as __pageData,J as default};
