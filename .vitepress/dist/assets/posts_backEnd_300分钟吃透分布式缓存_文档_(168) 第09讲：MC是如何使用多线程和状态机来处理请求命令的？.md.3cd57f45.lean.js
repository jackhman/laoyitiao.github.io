import{_ as t,j as _,o as i,g as r,k as c,s as n,h as a,Q as o}from"./chunks/framework.e0c66c3f.js";const K=JSON.parse('{"title":"网络模型 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(168) 第09讲：MC是如何使用多线程和状态机来处理请求命令的？.md","filePath":"posts/backEnd/300分钟吃透分布式缓存_文档/(168) 第09讲：MC是如何使用多线程和状态机来处理请求命令的？.md","lastUpdated":1696338709000}'),s={name:"posts/backEnd/300分钟吃透分布式缓存_文档/(168) 第09讲：MC是如何使用多线程和状态机来处理请求命令的？.md"},l=n("p",null,'你好，我是你的缓存老师陈波，欢迎你进入第 9 课时"Memcached 网络模型及状态机"的学习。',-1),d=n("br",null,null,-1),p=n("h6",{id:"网络模型",tabindex:"-1"},[a("网络模型 "),n("a",{class:"header-anchor",href:"#网络模型","aria-label":'Permalink to "网络模型"'},"​")],-1),h=n("br",null,null,-1),m=n("p",null,"了解了 Mc 的系统架构之后，我们接下来可以逐一深入学习 Mc 的各个模块了。首先，我们来学习 Mc 的网络模型。",-1),u=n("h6",{id:"主线程",tabindex:"-1"},[a("主线程 "),n("a",{class:"header-anchor",href:"#主线程","aria-label":'Permalink to "主线程"'},"​")],-1),g=n("p",null,"Mc 基于 Libevent 实现多线程网络 IO 模型。Mc 的 IO 处理线程分主线程和工作线程，每个线程各有一个 event_base，来监听网络事件。主线程负责监听及建立连接。工作线程负责对建立的连接进行网络 IO 读取、命令解析、处理及响应。",-1),b=n("p",null,"Mc 主线程在监听端口时，当有连接到来，主线程 accept 该连接，并将连接调度给工作线程。调度处理逻辑，主线程先将 fd 封装成一个 CQ_ITEM 结构，并存入新连接队列中，然后轮询一个工作线程，并通过管道向该工作线程发送通知。工作线程监听到通知后，会从新连接队列获取一个连接，然后开始从这个连接读取网络 IO 并处理，如下图所示。主线程的这个处理逻辑主要在状态机中执行，对应的连接状态为 conn_listening。",-1),w=n("h6",{id:"工作线程",tabindex:"-1"},[a("工作线程 "),n("a",{class:"header-anchor",href:"#工作线程","aria-label":'Permalink to "工作线程"'},"​")],-1),k=n("p",null,"工作线程监听到主线程的管道通知后，会从连接队列弹出一个新连接，然后就会创建一个 conn 结构体，注册该 conn 读事件，然后继续监听该连接上的 IO 事件。后续这个连接有命令进来时，工作线程会读取 client 发来的命令，进行解析并处理，最后返回响应。工作线程的主要处理逻辑也是在状态机中，一个名叫 drive_machine 的函数。",-1),M=n("h6",{id:"状态机",tabindex:"-1"},[a("状态机 "),n("a",{class:"header-anchor",href:"#状态机","aria-label":'Permalink to "状态机"'},"​")],-1),f=n("p",null,"这个状态机由主线程和工作线程共享，实际是采用 switch-case 来实现的。状态机函数如下图所示，switch 连接的 state，然后根据连接的不同状态，执行不同的逻辑操作，并进行状态转换。接下来我们开始分析 Mc 的状态机。",-1),A=n("h6",{id:"主线程状态机",tabindex:"-1"},[a("主线程状态机 "),n("a",{class:"header-anchor",href:"#主线程状态机","aria-label":'Permalink to "主线程状态机"'},"​")],-1),P=n("p",null,"如下图所示，主线程在状态机中只处理 conn_listening 状态，负责 accept 新连接和调度新连接给工作线程。状态机中其他状态处理基本都在工作线程中进行。由于 Mc 同时支持 TCP、UDP 协议，而互联网企业大多使用 TCP 协议，并且通过文本协议，来访问 Mc，所以后面状态机的介绍，将主要结合 TCP 文本协议来进行重点分析。",-1),q=n("h6",{id:"工作线程状态机",tabindex:"-1"},[a("工作线程状态机 "),n("a",{class:"header-anchor",href:"#工作线程状态机","aria-label":'Permalink to "工作线程状态机"'},"​")],-1),x=n("p",null,"工作线程的状态机处理逻辑，如下图所示，包括刚建立 conn 连接结构体时进行的一些重置操作，然后注册读事件，在有数据进来时，读取网络数据，并进行解析并处理。如果是读取指令或统计指令，至此就基本处理完毕，接下来将响应写入连接缓冲。如果是更新指令，在进行初步处理后，还会继续读取 value 部分，再进行存储或变更，待变更完毕后将响应写入连接缓冲。最后再将响应写给 client。响应 client 后，连接会再次重置连接状态，等待进入下一次的命令处理循环中。这个过程主要包含了 conn_new_cmd、conn_waiting、conn_read、conn_parse_cmd、conn_nread、conn_write、conn_mwrite、conn_closing 这 8 个状态事件。",-1),T=o("",14),v=o("",12),C=o("",6),V=n("p",null,'OK，这节课就讲到这里，下一课时我会分享"Memcached 哈希表"，记得按时来听课哈。好，下节课见，拜拜！',-1),I=n("br",null,null,-1);function O(S,B,E,y,D,N){const e=_("Image");return i(),r("div",null,[l,d,p,h,m,u,g,b,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/99/CgotOV2kVk2AMRZMAADqfhcmoSg472.png"}),w,k,M,f,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/7A/CgoB5l2kVk6AdzanAAIOzo8tKWs049.png"}),A,P,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/99/CgotOV2kVk6AXIB1AAFDHXaxLqE384.png"}),q,x,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/7A/CgoB5l2kVk6AWUKfAALnpKe8zig379.png"}),T,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/99/CgotOV2kVk-AZQTMAAHUDRrjRxI205.png"}),v,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/7A/CgoB5l2kVk-AQuaUAAITowFQ3VM623.png"}),C,c(e,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/99/99/CgotOV2kVk-AJLjpAAFvwWrEphw784.png"}),V,I])}const L=t(s,[["render",O]]);export{K as __pageData,L as default};
