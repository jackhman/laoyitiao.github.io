import{_ as n,j as s,o as l,g as p,k as i,s as t,h as e,Q as o}from"./chunks/framework.b3d8e22e.js";const ot=JSON.parse('{"title":"Bitmap 占用内存分析 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1872) 第18讲：Android Bitmap 全面详解.md","filePath":"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1872) 第18讲：Android Bitmap 全面详解.md","lastUpdated":1696417798000}'),r={name:"posts/frontEnd/Android 工程师进阶 34 讲_文档/(1872) 第18讲：Android Bitmap 全面详解.md"},c=t("p",null,"本课时我们主要对 Bitmap 进行详解。",-1),m=t("p",null,"每一个 Android App 中都会使用到 Bitmap，它也是程序中内存消耗的大户，当 Bitmap 使用内存超过可用空间，则会报 OOM。 因此如何正确使用也是 Android 工程师的重点关注内容。",-1),d=t("h3",{id:"bitmap-占用内存分析",tabindex:"-1"},[e("Bitmap 占用内存分析 "),t("a",{class:"header-anchor",href:"#bitmap-占用内存分析","aria-label":'Permalink to "Bitmap 占用内存分析"'},"​")],-1),_=t("p",null,"Bitmap 用来描述一张图片的长、宽、颜色等信息。通常情况下，我们可以使用 BitmapFactory 来将某一路径下的图片解析为 Bitmap 对象。",-1),g=t("p",null,"当一张图片加载到内存后，具体需要占用多大内存呢？",-1),h=t("h4",{id:"getallocationbytecount-探索",tabindex:"-1"},[e("getAllocationByteCount 探索 "),t("a",{class:"header-anchor",href:"#getallocationbytecount-探索","aria-label":'Permalink to "getAllocationByteCount 探索"'},"​")],-1),u=t("p",null,"我们可以通过 Bitmap.getAllocationByteCount() 方法获取 Bitmap 占用的字节大小，比如以下代码：",-1),A=o("",12),B=t("p",null,"我运行的设备是 Nexus 4，屏幕密度为 320。如果将 rodman 放到 drawable-hdpi 目录下，最终的计算公式如下：",-1),b=t("blockquote",null,[t("p",null,[e("rodman 实际占用内存大小 = 600 * (320 / 240) * 600 * (320 / 240) * 4 = "),t("strong",null,"2560000")])],-1),C=t("h4",{id:"assets-中的图片大小",tabindex:"-1"},[e("assets 中的图片大小 "),t("a",{class:"header-anchor",href:"#assets-中的图片大小","aria-label":'Permalink to "assets 中的图片大小"'},"​")],-1),f=t("p",null,"我们知道，Android 中的图片不仅可以保存在 drawable 目录中，还可以保存在 assets 目录下，然后通过 AssetManager 获取图片的输入流。那这种方式加载生成的 Bitmap 是多大呢？同样是上面的 rodman.png，这次将它放到 assets 目录中，使用如下代码加载：",-1),q=o("",7),k=t("p",null,"打印日志如下:",-1),I=t("blockquote",null,[t("p",null,[e("I/Bitmap ( 6339): bitmap size is "),t("strong",null,"720000")])],-1),T=t("p",null,"另外 Options 中还有一个 inSampleSize 参数，可以实现 Bitmap 采样压缩，这个参数的含义是宽高维度上每隔 inSampleSize 个像素进行一次采集。比如以下代码：",-1),E=t("p",null,"因为宽高都会进行采样，所以最终图片会被缩略 4 倍，最终打印效果如下：",-1),F=t("blockquote",null,[t("p",null,[e("I/Bitmap ( 6414): bitmap size is "),t("strong",null,"180000"),e(" // 170Kb")])],-1),G=t("h3",{id:"bitmap-复用",tabindex:"-1"},[e("Bitmap 复用 "),t("a",{class:"header-anchor",href:"#bitmap-复用","aria-label":'Permalink to "Bitmap 复用"'},"​")],-1),P=t("h4",{id:"场景描述",tabindex:"-1"},[e("场景描述 "),t("a",{class:"header-anchor",href:"#场景描述","aria-label":'Permalink to "场景描述"'},"​")],-1),M=t("p",null,"如果在 Android 某个页面创建很多个 Bitmap，比如有两张图片 A 和 B，通过点击某一按钮需要在 ImageView 上切换显示这两张图片，实现效果如下所示：",-1),S=t("p",null,"可以使用以下代码实现上述效果：",-1),y=t("p",null,"但是在每次调用 switchImage 切换图片时，都需要通过 BitmapFactory 创建一个新的 Bitmap 对象。当方法执行完毕后，这个 Bitmap 又会被 GC 回收，这就造成不断地创建和销毁比较大的内存对象，从而导致频繁 GC（或者叫内存抖动）。像 Android App 这种面相最终用户交互的产品，如果因为频繁的 GC 造成 UI 界面卡顿，还是会影响到用户体验的。可以在 Android Studio Profiler 中查看内存情况，多次切换图片后，显示的效果如下：",-1),D=t("h4",{id:"使用-options-inbitmap-优化",tabindex:"-1"},[e("使用 Options.inBitmap 优化 "),t("a",{class:"header-anchor",href:"#使用-options-inbitmap-优化","aria-label":'Permalink to "使用 Options.inBitmap 优化"'},"​")],-1),w=t("p",null,"实际上经过第一次显示之后，内存中已经存在了一个 Bitmap 对象。每次切换图片只是显示的内容不一样，我们可以重复利用已经占用内存的 Bitmap 空间，具体做法就是使用 Options.inBitmap 参数。将 getBitmap 方法修改如下：",-1),x=t("p",null,"解释说明：",-1),J=t("ul",null,[t("li",null,"图中 1 处创建一个可以用来复用的 Bitmap 对象。"),t("li",null,"图中 2 处，将 options.inBitmap 赋值为之前创建的 reuseBitmap 对象，从而避免重新分配内存。")],-1),V=t("p",null,"重新运行代码，并查看 Profiler 中的内存情况，可以发现不管我们切换图片多少次，内存占用始终处于一个水平线状态。",-1),R=t("p",null,[t("strong",null,"注意"),e("：在上述 getBitmap 方法中，复用 inBitmap 之前，需要调用 canUseForInBitmap 方法来判断 reuseBitmap 是否可以被复用。这是因为 Bitmap 的复用有一定的限制：")],-1),L=t("ul",null,[t("li",null,"在 Android 4.4 版本之前，只能重用相同大小的 Bitmap 内存区域；"),t("li",null,"4.4 之后你可以重用任何 Bitmap 的内存区域，只要这块内存比将要分配内存的 bitmap 大就可以。")],-1),N=t("p",null,"canUserForInBitmap 方法具体如下：",-1),U=o("",7),H=t("p",null,[t("strong",null,"BitmapRegionDecoder 基本使用")],-1),O=t("p",null,"首先需要使用 BitmapRegionDecoder 将图片加载到内存中，图片可以以绝对路径、文件描述符、输入流的方式传递给 BitmapRegionDecoder，如下所示：",-1),z=t("p",null,"运行后显示效果如下：",-1),j=t("p",null,[e("在此基础上，我们可以通过自定义View，添加 touch 事件来动态地设置 Bitmap 需要显示的区域 Rect。具体实现网上已经有很多成熟的轮子可以直接使用，比如 "),t("a",{href:"https://github.com/LuckyJayce/LargeImage/blob/master/library/src/main/java/com/shizhefei/view/largeimage/LargeImageView.java",target:"_blank",rel:"noreferrer"},"LargeImageView"),e(" 。张鸿洋先生也有一篇比较详细文章对此介绍："),t("a",{href:"https://blog.csdn.net/lmj623565791/article/details/49300989",target:"_blank",rel:"noreferrer"},"Android 高清加载巨图方案"),e("。")],-1),v=t("h3",{id:"bitmap-缓存",tabindex:"-1"},[e("Bitmap 缓存 "),t("a",{class:"header-anchor",href:"#bitmap-缓存","aria-label":'Permalink to "Bitmap 缓存"'},"​")],-1),K=t("p",null,"当需要在界面上同时展示一大堆图片的时候，比如 ListView、RecyclerView 等，由于用户不断地上下滑动，某个 Bitmap 可能会被短时间内加载并销毁多次。这种情况下通过使用适当的缓存，可以有效地减缓 GC 频率保证图片加载效率，提高界面的响应速度和流畅性。",-1),W=t("p",null,"最常用的缓存方式就是 LruCache，基本使用方式如下：",-1),$=o("",5);function X(Z,Q,Y,tt,at,it){const a=s("Image");return l(),p("div",null,[c,m,d,_,g,h,u,i(a,{alt:"image.png",src:"https://s0.lgstatic.com/i/image/M00/0E/AD/CgqCHl7GI9-AU6LJAAFunSI1GAc025.png"}),A,i(a,{alt:"111.png",src:"https://s0.lgstatic.com/i/image/M00/0E/B1/CgqCHl7GJ4CAJWx9AACWL0y3jm0873.png"}),B,b,C,f,i(a,{alt:"image (1).png",src:"https://s0.lgstatic.com/i/image/M00/0E/AD/CgqCHl7GI-6ADafPAAC87wB3U2c974.png"}),q,i(a,{alt:"image (2).png",src:"https://s0.lgstatic.com/i/image/M00/0E/AE/CgqCHl7GJUyAPcYTAAHDKDnB6wE358.png"}),k,I,T,i(a,{alt:"image (3).png",src:"https://s0.lgstatic.com/i/image/M00/0E/A3/Ciqc1F7GJVyActI9AAIFtHMpSCo369.png"}),E,F,G,P,M,i(a,{alt:"image.gif",src:"https://s0.lgstatic.com/i/image/M00/0E/A3/Ciqc1F7GJYyACIiCAMbF_4x1vIQ360.gif"}),S,i(a,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image/M00/0E/AF/CgqCHl7GJaqABz77AAIZRUExynU013.png"}),y,i(a,{alt:"image (5).png",src:"https://s0.lgstatic.com/i/image/M00/0E/A3/Ciqc1F7GJbGAX18WAAJGL3irS4A779.png"}),D,w,i(a,{alt:"image (6).png",src:"https://s0.lgstatic.com/i/image/M00/0E/AF/CgqCHl7GJbmAaThsAAfZxD2Nk4g697.png"}),x,J,V,i(a,{alt:"image (7).png",src:"https://s0.lgstatic.com/i/image/M00/0E/A3/Ciqc1F7GJcCARDsaAAB-hGb9K9w827.png"}),R,L,N,i(a,{alt:"image (8).png",src:"https://s0.lgstatic.com/i/image/M00/0E/AF/CgqCHl7GJciALgl-AAJID6lRHu4721.png"}),U,i(a,{alt:"image.jpeg",src:"https://s0.lgstatic.com/i/image/M00/0E/AF/CgqCHl7GJdyANF1HAACsiTjhRw869.jpeg"}),H,O,i(a,{alt:"image (9).png",src:"https://s0.lgstatic.com/i/image/M00/0E/A4/Ciqc1F7GJeeAFD6CAAFug--inhA254.png"}),z,i(a,{alt:"image (10).png",src:"https://s0.lgstatic.com/i/image/M00/0E/A4/Ciqc1F7GJe2AX63nAAXfDN4qgKU233.png"}),j,v,K,W,i(a,{alt:"image (11).png",src:"https://s0.lgstatic.com/i/image/M00/0E/A4/Ciqc1F7GJfaAG6-mAAU9UuZI15w565.png"}),$])}const nt=n(r,[["render",X]]);export{ot as __pageData,nt as default};
