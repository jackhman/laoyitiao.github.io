import{_ as o,j as e,o as c,g as t,k as n,h as p,Q as l,s}from"./chunks/framework.4e7d56ce.js";const x=JSON.parse('{"title":"04构造复杂的程序：将一个递归函数转成非递归函数的通用方法","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/重学操作系统_文档/(4609) 04  构造复杂的程序：将一个递归函数转成非递归函数的通用方法.md","filePath":"posts/backEnd/重学操作系统_文档/(4609) 04  构造复杂的程序：将一个递归函数转成非递归函数的通用方法.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/重学操作系统_文档/(4609) 04  构造复杂的程序：将一个递归函数转成非递归函数的通用方法.md"},E=l(`<h1 id="_04构造复杂的程序-将一个递归函数转成非递归函数的通用方法" tabindex="-1">04构造复杂的程序：将一个递归函数转成非递归函数的通用方法 <a class="header-anchor" href="#_04构造复杂的程序-将一个递归函数转成非递归函数的通用方法" aria-label="Permalink to &quot;04构造复杂的程序：将一个递归函数转成非递归函数的通用方法&quot;">​</a></h1><p><strong>我看到过一道非常不错的面试题：不支持递归的程序语言如何实现递归程序？</strong></p><p>之所以说这道题好，是因为：</p><ul><li><p>首先，它不是纯粹考概念和死记硬背，求职者在回答问题之前需要进行一定的思考；</p></li><li><p>其次，这道题目可以继续深挖，比如可以让求职者具体写一个程序，就变成了一道编程题；</p></li><li><p>最后，这道题目有实战意义，它背后考察的是求职者的编程功底。</p></li></ul><p>为了弄清楚这道题目，你需要对程序有一个更深层次的认识，不仅仅停留在指令的执行层面，而是要灵活使用指令，去实现更加复杂的功能。</p><h3 id="for-循环如何被执行" tabindex="-1">for 循环如何被执行 <a class="header-anchor" href="#for-循环如何被执行" aria-label="Permalink to &quot;for 循环如何被执行&quot;">​</a></h3><p>首先，我们来看 for 循环是如何实现的。</p><p>下面是一个求 1 加到 100 的 Java 程序，请你思考如何将它转换为指令：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">for</span><span style="color:#E1E4E8;">(; i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  s</span><span style="color:#F97583;">+=</span><span style="color:#E1E4E8;">i;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">for</span><span style="color:#24292E;">(; i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  s</span><span style="color:#D73A49;">+=</span><span style="color:#24292E;">i;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>指令是简单的，像积木一样，程序是复杂的，像房子一样。我们将简单的事情组合，然后去完成复杂的事情，这就是程序员每天在做的。在这个过程中，你会产生思考，比如如何排列组合，如何搭积木，才能更快更准地完成项目？所以这也是训练思维的一个过程。</p><p>经过思考，如果按照顺序执行上面的程序，则需要很多指令，因为 for 循环可以执行 1 次，也可以执行 100W 次，还可以执行无数次。因此，指令的设计者提供了一种 <code>jump</code> 类型的指令，让你可以在程序间跳跃，比如:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">loop</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">  jump loop</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">loop</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#24292E;">  jump loop</span></span></code></pre></div><p>这就实现了一个无限循环，程序执行到 <code>jumploop</code> 的时候，就会跳回 <code>loop</code> 标签。</p><p>用这种方法，我们可以将 <code>for</code> 循环用底层的指令实现：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># </span><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, s </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span></span>
<span class="line"><span style="color:#E1E4E8;"># 对应 </span><span style="color:#79B8FF;">Java</span><span style="color:#E1E4E8;"> 代码，我们首先将 </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> 和 </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> 存储到两个地址</span></span>
<span class="line"><span style="color:#E1E4E8;"># 这两个地址我们用 $i 和 $s 表示</span></span>
<span class="line"><span style="color:#E1E4E8;">store #</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> $i </span><span style="color:#6A737D;">// 将数字 1 存入i的地址</span></span>
<span class="line"><span style="color:#E1E4E8;">store #</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> $s </span><span style="color:#6A737D;">// 将数字 0 存入 s 的地址</span></span>
<span class="line"><span style="color:#E1E4E8;"># 接下来循环要开始了，我们在这里预留一个 loop 标签</span></span>
<span class="line"><span style="color:#E1E4E8;"># loop 是一个自定义标签，它代表指令的相对位置</span></span>
<span class="line"><span style="color:#E1E4E8;"># 后续我们可以用 jump 指令跳转回这个位置实现循环</span></span>
<span class="line"><span style="color:#E1E4E8;">loop</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> # 循环标签</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> ... i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">100</span></span>
<span class="line"><span style="color:#E1E4E8;"># 接下来我们开始实现循环控制</span></span>
<span class="line"><span style="color:#E1E4E8;"># 我们先首先 i </span><span style="color:#F97583;">&lt;=</span><span style="color:#E1E4E8;"> 100的比较</span></span>
<span class="line"><span style="color:#E1E4E8;"># 我们先将变量 i 的地址，也就是 $i 导入寄存器 </span><span style="color:#79B8FF;">R0</span></span>
<span class="line"><span style="color:#E1E4E8;">load $i </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R0</span></span>
<span class="line"><span style="color:#E1E4E8;"># 然后我们用 cmp 比较指令 </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> 和数字 </span><span style="color:#79B8FF;">100</span></span>
<span class="line"><span style="color:#E1E4E8;">cmp </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> #</span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 比较 R0 和数字 100</span></span>
<span class="line"><span style="color:#E1E4E8;"># 注意指令不会有返回值，它会进行计算，然后改变机器的状态（也就是寄存器）</span></span>
<span class="line"><span style="color:#E1E4E8;"># 比较后，有几个特殊的寄存器会保存比较结果</span></span>
<span class="line"><span style="color:#E1E4E8;"># 然后我们用 ja（jump above）, 如果比较结果 </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> 比 </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;"> 大</span></span>
<span class="line"><span style="color:#E1E4E8;"># 那么我们就跳转到 end 标签，实现循环的跳出</span></span>
<span class="line"><span style="color:#E1E4E8;">ja end </span></span>
<span class="line"><span style="color:#E1E4E8;">nop</span></span>
<span class="line"><span style="color:#E1E4E8;"># 如果 </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;">&lt;=100，那么ja end 没有生效，这时我们处理 s+=i</span></span>
<span class="line"><span style="color:#E1E4E8;"># 首先我们把变量 s 所在地址的数据导入寄存器 </span><span style="color:#79B8FF;">R1</span></span>
<span class="line"><span style="color:#E1E4E8;">load $s -&gt; </span><span style="color:#79B8FF;">R1</span></span>
<span class="line"><span style="color:#E1E4E8;"># 然后我们把寄存器R0和R1加和，把结果存储寄存器 </span><span style="color:#79B8FF;">R2</span></span>
<span class="line"><span style="color:#E1E4E8;">add </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R1</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R2</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;"># 这时，我们把寄存器 </span><span style="color:#79B8FF;">R2</span><span style="color:#E1E4E8;"> 的值存入变量 s 所在的地址</span></span>
<span class="line"><span style="color:#E1E4E8;">store </span><span style="color:#79B8FF;">R2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> $s</span></span>
<span class="line"><span style="color:#E1E4E8;"># 刚才我们完成了一次循环</span></span>
<span class="line"><span style="color:#E1E4E8;"># 我们还需要维护变量 i 的自增</span></span>
<span class="line"><span style="color:#E1E4E8;"># 现在 i 的值在 </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> 中，我们首先将整数 </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> 叠加到 </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> 上</span></span>
<span class="line"><span style="color:#E1E4E8;">add </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> #</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R0</span></span>
<span class="line"><span style="color:#E1E4E8;"># 再把 </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> 的值存入i所在的内存地址</span></span>
<span class="line"><span style="color:#E1E4E8;">store </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> $i</span></span>
<span class="line"><span style="color:#E1E4E8;"># 这时我们的循环体已经全部执行完成，我们需要调转回上面 loop 标签所在的位置</span></span>
<span class="line"><span style="color:#E1E4E8;"># 继续循环</span></span>
<span class="line"><span style="color:#E1E4E8;">jump loop</span></span>
<span class="line"><span style="color:#E1E4E8;">nop</span></span>
<span class="line"><span style="color:#E1E4E8;">end</span><span style="color:#F97583;">:</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># </span><span style="color:#D73A49;">var</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, s </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span></span>
<span class="line"><span style="color:#24292E;"># 对应 </span><span style="color:#005CC5;">Java</span><span style="color:#24292E;"> 代码，我们首先将 </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> 和 </span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> 存储到两个地址</span></span>
<span class="line"><span style="color:#24292E;"># 这两个地址我们用 $i 和 $s 表示</span></span>
<span class="line"><span style="color:#24292E;">store #</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> $i </span><span style="color:#6A737D;">// 将数字 1 存入i的地址</span></span>
<span class="line"><span style="color:#24292E;">store #</span><span style="color:#005CC5;">0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> $s </span><span style="color:#6A737D;">// 将数字 0 存入 s 的地址</span></span>
<span class="line"><span style="color:#24292E;"># 接下来循环要开始了，我们在这里预留一个 loop 标签</span></span>
<span class="line"><span style="color:#24292E;"># loop 是一个自定义标签，它代表指令的相对位置</span></span>
<span class="line"><span style="color:#24292E;"># 后续我们可以用 jump 指令跳转回这个位置实现循环</span></span>
<span class="line"><span style="color:#24292E;">loop</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> # 循环标签</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> ... i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">100</span></span>
<span class="line"><span style="color:#24292E;"># 接下来我们开始实现循环控制</span></span>
<span class="line"><span style="color:#24292E;"># 我们先首先 i </span><span style="color:#D73A49;">&lt;=</span><span style="color:#24292E;"> 100的比较</span></span>
<span class="line"><span style="color:#24292E;"># 我们先将变量 i 的地址，也就是 $i 导入寄存器 </span><span style="color:#005CC5;">R0</span></span>
<span class="line"><span style="color:#24292E;">load $i </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R0</span></span>
<span class="line"><span style="color:#24292E;"># 然后我们用 cmp 比较指令 </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> 和数字 </span><span style="color:#005CC5;">100</span></span>
<span class="line"><span style="color:#24292E;">cmp </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> #</span><span style="color:#005CC5;">100</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 比较 R0 和数字 100</span></span>
<span class="line"><span style="color:#24292E;"># 注意指令不会有返回值，它会进行计算，然后改变机器的状态（也就是寄存器）</span></span>
<span class="line"><span style="color:#24292E;"># 比较后，有几个特殊的寄存器会保存比较结果</span></span>
<span class="line"><span style="color:#24292E;"># 然后我们用 ja（jump above）, 如果比较结果 </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> 比 </span><span style="color:#005CC5;">100</span><span style="color:#24292E;"> 大</span></span>
<span class="line"><span style="color:#24292E;"># 那么我们就跳转到 end 标签，实现循环的跳出</span></span>
<span class="line"><span style="color:#24292E;">ja end </span></span>
<span class="line"><span style="color:#24292E;">nop</span></span>
<span class="line"><span style="color:#24292E;"># 如果 </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;">&lt;=100，那么ja end 没有生效，这时我们处理 s+=i</span></span>
<span class="line"><span style="color:#24292E;"># 首先我们把变量 s 所在地址的数据导入寄存器 </span><span style="color:#005CC5;">R1</span></span>
<span class="line"><span style="color:#24292E;">load $s -&gt; </span><span style="color:#005CC5;">R1</span></span>
<span class="line"><span style="color:#24292E;"># 然后我们把寄存器R0和R1加和，把结果存储寄存器 </span><span style="color:#005CC5;">R2</span></span>
<span class="line"><span style="color:#24292E;">add </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R1</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R2</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;"># 这时，我们把寄存器 </span><span style="color:#005CC5;">R2</span><span style="color:#24292E;"> 的值存入变量 s 所在的地址</span></span>
<span class="line"><span style="color:#24292E;">store </span><span style="color:#005CC5;">R2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> $s</span></span>
<span class="line"><span style="color:#24292E;"># 刚才我们完成了一次循环</span></span>
<span class="line"><span style="color:#24292E;"># 我们还需要维护变量 i 的自增</span></span>
<span class="line"><span style="color:#24292E;"># 现在 i 的值在 </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> 中，我们首先将整数 </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> 叠加到 </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> 上</span></span>
<span class="line"><span style="color:#24292E;">add </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> #</span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R0</span></span>
<span class="line"><span style="color:#24292E;"># 再把 </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> 的值存入i所在的内存地址</span></span>
<span class="line"><span style="color:#24292E;">store </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> $i</span></span>
<span class="line"><span style="color:#24292E;"># 这时我们的循环体已经全部执行完成，我们需要调转回上面 loop 标签所在的位置</span></span>
<span class="line"><span style="color:#24292E;"># 继续循环</span></span>
<span class="line"><span style="color:#24292E;">jump loop</span></span>
<span class="line"><span style="color:#24292E;">nop</span></span>
<span class="line"><span style="color:#24292E;">end</span><span style="color:#D73A49;">:</span></span></code></pre></div><p>通过上面的方法，我们成功将 for 循环的程序转换成了指令，然后再将它们编码成二进制，就可以存储到内存中了。</p><p>讲到这里，我要强调几个事情：</p><ol><li><p>jump 指令直接操作 PC 指针，但是很多 CPU 会抢先执行下一条指令，因此通常我们在 jump 后面要跟随一条 nop 指令，让 CPU 空转一个周期，避免 jump 下面的指令被执行。<strong>是不是到了微观世界，和你所认识的程序还不太一样</strong>？</p></li><li><p>上面我写指令的时候用到了 add/store 这些指令，它们叫作助记符，是帮助你记忆的。整体这段程序，我们就称作汇编程序。</p></li><li><p>因为不同的机器助记符也不一样，所以你不用太关注我用的是什么汇编语言，也不用去记忆这些指令。当你拿到指定芯片的时候，直接去查阅芯片的说明书就可以了。</p></li><li><p>虽然不同 CPU 的指令不一样，但也是有行业标准的。现在使用比较多的是 RISC（精简指令集）和 CISC（复杂指令集）。比如目前Inte 和 AMD 家族主要使用 CISC 指令集，ARM 和 MIPS 等主要使用RISC 指令集。</p></li></ol><h3 id="条件控制程序" tabindex="-1">条件控制程序 <a class="header-anchor" href="#条件控制程序" aria-label="Permalink to &quot;条件控制程序&quot;">​</a></h3><p>条件控制程序有两种典型代表，一种是 <code>if-else</code> ，另一种是 <code>switch-case</code> 。 总体来说， <code>if-else</code> 翻译成指令，是比较简单的，你需要用跳转指令和比较指令处理它的跳转逻辑。</p><p>当然，它们的使用场景不同，这块我不展开了。在这里我主要想跟你说说，它们的内部实现是不一样的。<code>if-else</code> 是一个自上向下的执行逻辑， <code>switch-case</code>是一种精确匹配算法。比如你有 1000 个 case，如果用 <code>if-else</code> 你需要一个个比较，最坏情况下需要比较 <code>999</code> 次；而如果用 <code>switch-case</code> ，就不需要一个个比较，通过算法就可以直接定位到对应的<code>case</code> 。</p><p>举个具体的例子，比如一个根据数字返回星期的程序。如果用<code>if-else</code>，那么你需要这样做：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(week </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;周一&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(week </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;周二&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">......</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;">(week </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;周一&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">} </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(week </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;周二&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">......</span></span></code></pre></div><p>如果用 <code>switch-case</code> 的逻辑，你可能会这样计算：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">跳转位置</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;">当前PC </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">(week </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">跳转位置</span><span style="color:#D73A49;">=</span><span style="color:#24292E;">当前PC </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">(week </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span></span></code></pre></div><p>你不用太关心上面的数学关系，我只是举一个例子告诉你， <code>switch-case</code> 实现更多是依赖数学关系，直接算出 case 所在指令的位置，而不是一行行执行和比较。</p><h3 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h3><p>了解了循环和条件判断，我们再来看看函数是如何被执行的。函数的执行过程必须深入到底层，也会涉及一种叫作栈的数据结构。</p><p>下面是一段 C 程序，传入两个参数，然后返回两个参数的和：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">int </span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(int a, int b){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> b;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">int </span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(int a, int b){</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> b;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里我先不说具体的解决方案，希望你可以先自己思考。其实到这里，你已经学了不少知识了。下面我们一起分析一下，一种思考的方向是：</p><ol><li><p>通过观察，我们发现函数的参数 a,b 本质是内存中的数据，因此需要给它们分配内存地址。</p></li><li><p>函数返回值也是内存中的数据，也就是返回值也需要分配内存地址。</p></li><li><p>调用函数其实就是跳转到函数体对应的指令所在的位置，因此函数名可以用一个标签，调用时，就用 <code>jump</code> 指令跟这个标签。</p></li></ol><p>比如上面函数进行了<code>a+b</code>的运算，我们可以这样构造指令：</p><div class="language-yaml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># 首先我们定义一个叫作add的标签</span></span>
<span class="line"><span style="color:#85E89D;">add</span><span style="color:#E1E4E8;">:</span></span>
<span class="line"><span style="color:#6A737D;"># 然后我们将a和b所在地址中的数据都导入寄存器</span></span>
<span class="line"><span style="color:#9ECBFF;">load $a -&gt; R0</span></span>
<span class="line"><span style="color:#9ECBFF;">load $b -&gt; R1</span></span>
<span class="line"><span style="color:#6A737D;"># 然后我们将寄存器求和，并将结果回写到返回地址</span></span>
<span class="line"><span style="color:#9ECBFF;">add R0 R1 R2</span></span>
<span class="line"><span style="color:#9ECBFF;">store R2 -&gt; $r</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># 首先我们定义一个叫作add的标签</span></span>
<span class="line"><span style="color:#22863A;">add</span><span style="color:#24292E;">:</span></span>
<span class="line"><span style="color:#6A737D;"># 然后我们将a和b所在地址中的数据都导入寄存器</span></span>
<span class="line"><span style="color:#032F62;">load $a -&gt; R0</span></span>
<span class="line"><span style="color:#032F62;">load $b -&gt; R1</span></span>
<span class="line"><span style="color:#6A737D;"># 然后我们将寄存器求和，并将结果回写到返回地址</span></span>
<span class="line"><span style="color:#032F62;">add R0 R1 R2</span></span>
<span class="line"><span style="color:#032F62;">store R2 -&gt; $r</span></span></code></pre></div><p>当我们需要调用这个函数的时候，我们就构造下面这样的指令：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">jump add</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">jump add</span></span></code></pre></div><p>细心的同学可能已经发现，这里有 2 个问题还没有解决：</p><ol><li><p>参数如何传递给函数？</p></li><li><p>返回值如何传递给调用者？</p></li></ol><p>为了解决这 2 个问题，我们就需要用到前面提到的一个叫作栈的数据结构。栈的英文是 Stack，意思是码放整齐的一堆东西。首先在调用方，我们将参数传递给栈；然后在函数执行过程中，我们从栈中取出参数。</p>`,39),y=s("p",null,"函数执行过程中，先将执行结果写入栈中，然后在返回前把之前压入的参数出栈，调用方再从栈中取出执行结果。",-1),i=s("p",null,"将参数传递给 Stack 的过程，叫作压栈。取出结果的过程，叫作出栈。栈就好像你书桌上的一摞书，压栈就是把参数放到书上面，出栈就是把顶部的书拿下来。",-1),d=s("p",null,"因为栈中的每个数据大小都一样，所以在函数执行的过程中，我们可以通过参数的个数和参数的序号去计算参数在栈中的位置。",-1),F=s("p",null,"接下来我们来看看函数执行的整体过程：假设要计算 11 和 15 的和，我们首先在内存中开辟一块单独的空间，也就是栈。",-1),C=l(`<p>就如前面所讲，栈的使用方法是不断往上堆数据，所以需要一个栈指针（Stack Pointer， SP）指向栈顶（也就是下一个可以写入的位置）。每次将数据写入栈时，就把数据写到栈指针指向的位置，然后将 SP 的值增加。</p><p>为了提高效率，我们通常会用一个特殊的寄存器来存储栈指针，这个寄存器就叫作 Stack Pointer，在大多数芯片中都有这个特殊的寄存器。一开始，SP 指向 0x100 位置，而 0x100 位置还没有数据。</p><ul><li><strong>压栈参数11</strong></li></ul><p>接下来我们开始传参，我们先将 11 压栈，之所以称作压栈（ Push)，就好像我们把数据 11 堆在内存中一样。模拟压栈的过程是下面两条指令：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">store #</span><span style="color:#79B8FF;">11</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> $SP </span><span style="color:#6A737D;">// 将11存入SP指向的地址0x100</span></span>
<span class="line"><span style="color:#E1E4E8;">add </span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 栈指针增加4（32位机器）</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">store #</span><span style="color:#005CC5;">11</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> $SP </span><span style="color:#6A737D;">// 将11存入SP指向的地址0x100</span></span>
<span class="line"><span style="color:#24292E;">add </span><span style="color:#005CC5;">SP</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">SP</span><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 栈指针增加4（32位机器）</span></span></code></pre></div><p>第一条 store 指令将 SP 寄存器指向的内存地址设置为常数 11。</p><p>第二条指令将栈指针自增 4。</p><p>这里用美元符号代表将 11 存入的是 SP 寄存器指向的内存地址，这是一次间接寻址。存入后，栈指针不是自增 1 而是自增了 4，因为我在这里给你讲解时，用的是一个 32 位宽的 CPU 。如果是 64 位宽的 CPU，那么栈指针就需要自增 8。</p><p>压栈完成后，内存变成下图中所示的样子。11 被写入内存，并且栈指针指向了 0x104 位置。</p>`,9),g=s("ul",null,[s("li",null,[s("strong",null,"压栈参数15")])],-1),h=s("p",null,"然后我们用同样的方法将参数 15 压栈。",-1),u=s("p",null,"压栈后，11 和 15 都被放入了对应的内存位置，并且栈指针指向了 0x108。",-1),_=s("ul",null,[s("li",null,[s("strong",null,"将返回值压栈")])],-1),A=s("p",null,"接下来，我们将返回值压栈。到这里你可能会问，返回值还没有计算呢，怎么就压栈了？其实这相当于一个占位，后面我们会改写这个地址。",-1),v=l(`<ul><li><strong>调用函数</strong></li></ul><p>当我们完成了上面的压栈后，就开始调用函数，一种简单的做法是用 jump 指令直接跳转到函数的标签，比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">jump add</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">jump add</span></span></code></pre></div><p>这个时候，要加和在栈中的数据 11 和 15，我们可以利用 SP 指针寻找数据。11 距离当前 SP 指针差 3 个位置，15 距离 SP 指针差 2 个位置。这种寻址方式是一种复合的寻址方式，是间接 + 偏移量寻址。</p><p>我们可以用下面的代码完成将 11 和 15 导入寄存器的过程：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">load </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">12</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R0</span></span>
<span class="line"><span style="color:#E1E4E8;">load </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">8</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">load </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">SP</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">12</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R0</span></span>
<span class="line"><span style="color:#24292E;">load </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">SP</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">8</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R1</span></span></code></pre></div><p>然后进行加和，将结果存入 R2。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">load </span><span style="color:#79B8FF;">R0</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R1</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">R2</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">load </span><span style="color:#005CC5;">R0</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R1</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">R2</span></span></code></pre></div><p>最后我们可以再次利用数学关系将结果写入返回值所在的位置。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">store </span><span style="color:#79B8FF;">R2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">SP</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">store </span><span style="color:#005CC5;">R2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">SP</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">)</span></span></code></pre></div><p>上面我们用到了一种间接寻址的方式来进行加和运算，也就是利用 SP 中的地址做加减法操作内存。</p><p>经过函数调用的结果如下图所示，运算结果 26 已经被写入了返回值的位置：</p>`,12),b=s("ul",null,[s("li",null,[s("strong",null,"发现-解决问题")])],-1),k=s("p",null,"一个好的解决方案，也会面临问题。现在我们就遇到了麻烦：",-1),D=s("ol",null,[s("li",null,[s("p",null,"函数计算完成，这时应该跳转回去。可是我们没有记录函数调用前 PC 指针的位置，因此这里需要改进，我们需要存储函数调用前的 PC 指针方便调用后恢复。")]),s("li",null,[s("p",null,"栈不可以被无限使用，11和 15 作为参数，计算出了结果 26，那么它们就可以清空了。如果用调整栈指针的方式去清空，我们就会先清空 26。此时就会出现顺序问题，因此我们需要调整压栈的顺序。")])],-1),B=s("p",null,"具体顺序你可以看下图。首先，我们将函数参数和返回值换位，这样在清空数据的时候，就会先清空参数，再清空返回值。",-1),m=l(`<p>然后我们在调用函数前，还需要将返回地址压栈。这样在函数计算完成前，就能跳转回对应的返回地址。翻译成指令，就是下面这样：</p><div class="language-dart vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">dart</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">## 压栈返回值</span></span>
<span class="line"><span style="color:#E1E4E8;">add </span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 计算返回地址</span></span>
<span class="line"><span style="color:#E1E4E8;"># 我们需要跳转到清理堆栈那行，也就是16行</span></span>
<span class="line"><span style="color:#79B8FF;">MOV</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">PC</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">4</span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;">(参数个数</span><span style="color:#F97583;">*</span><span style="color:#79B8FF;">2</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">SP</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 压栈参数的程序</span></span>
<span class="line"><span style="color:#E1E4E8;">......</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 执行函数，计算返回值</span></span>
<span class="line"><span style="color:#E1E4E8;">call function</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;"># 清理堆栈</span></span>
<span class="line"><span style="color:#E1E4E8;">add </span><span style="color:#79B8FF;">SP</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">(参数个数</span><span style="color:#F97583;">+</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">*</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">， </span><span style="color:#79B8FF;">SP</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"></span>
<span class="line"><span style="color:#24292E;">## 压栈返回值</span></span>
<span class="line"><span style="color:#24292E;">add </span><span style="color:#005CC5;">SP</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">4</span><span style="color:#24292E;">  </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">SP</span><span style="color:#24292E;"> </span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 计算返回地址</span></span>
<span class="line"><span style="color:#24292E;"># 我们需要跳转到清理堆栈那行，也就是16行</span></span>
<span class="line"><span style="color:#005CC5;">MOV</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">PC</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">4</span><span style="color:#D73A49;">*</span><span style="color:#24292E;">(参数个数</span><span style="color:#D73A49;">*</span><span style="color:#005CC5;">2</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">SP</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 压栈参数的程序</span></span>
<span class="line"><span style="color:#24292E;">......</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 执行函数，计算返回值</span></span>
<span class="line"><span style="color:#24292E;">call function</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;"># 清理堆栈</span></span>
<span class="line"><span style="color:#24292E;">add </span><span style="color:#005CC5;">SP</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">(参数个数</span><span style="color:#D73A49;">+</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">)</span><span style="color:#D73A49;">*</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">， </span><span style="color:#005CC5;">SP</span></span></code></pre></div><h3 id="递归函数如何被执行" tabindex="-1">递归函数如何被执行 <a class="header-anchor" href="#递归函数如何被执行" aria-label="Permalink to &quot;递归函数如何被执行&quot;">​</a></h3><p>我们刚刚使用了栈解决了函数的调用问题。但是这个方案究竟合不合理，还需要用更复杂的情况来验证。</p><p>如下所示，我们给出一个递归函数，请你判断是否可以用上面的方法执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">int </span><span style="color:#B392F0;">sum</span><span style="color:#E1E4E8;">(int n){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;}</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sum</span><span style="color:#E1E4E8;">(n</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">int </span><span style="color:#6F42C1;">sum</span><span style="color:#24292E;">(int n){</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(n </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;}</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sum</span><span style="color:#24292E;">(n</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>递归的时候，我们每次执行函数都形成一个如下所示的栈结构：</p>`,7),R=s("p",null,"比如执行 sum(100)，我们就会形成一个复杂的栈，第一次调用 n = 100，第二次递归调用 n = 99：",-1),P=s("p",null,"它们堆在了一起，就形成了一个很大的栈，简化一下就是这样的一个模型，如下所示：",-1),S=l('<p>到这里，递归消耗了更多空间，但是也保证了中间计算的独立性。当递归执行到 100 次的时候，就会执行下面的语句：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) {</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(n </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) {</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;}</span></span></code></pre></div><p>于是触发第 99 次递归执行：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">sum</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// sum(1) = 1</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">sum</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// sum(1) = 1</span></span></code></pre></div><p>上面程序等价于<code>return 3</code>，接着再触发第 98 次递归的执行，然后是第 97 次，最终触发到第一次函数调用返回结果。</p><p>由此可见，栈这种结构同样适合递归的计算。事实上，计算机编程语言就是用这种结构来实现递归函数。</p><h3 id="类型-class-如何实现" tabindex="-1">类型（class）如何实现 <a class="header-anchor" href="#类型-class-如何实现" aria-label="Permalink to &quot;类型（class）如何实现&quot;">​</a></h3><p>按照我们之前已经学习到的知识：</p><ul><li><p>变量是一个内存地址，所以只需要分配内存就好了；</p></li><li><p>循环控制可以用跳转加判断实现；</p></li><li><p>条件控制也可以用跳转加判断实现，只不过如果是 <code>switch-case</code> 还需要一定的数学计算；</p></li><li><p>函数调用需要压栈参数、返回值和返回地址。</p></li></ul><p>最后，我们来说说类型是如何实现的，也就是很多语言都支持的 class 如何被翻译成指令。其实 class 实现非常简单，首先一个 class 会分成两个部分，一部分是数据（也称作属性），另一部分是函数（也称作方法）。</p>',10),j=l(`<p>class 有一个特殊的方法叫作构造函数，它会为 class 分配内存。构造函数执行的时候，开始扫描类型定义中所有的属性和方法。</p><ul><li><p>如果遇到属性，就为属性分配内存地址；</p></li><li><p>如果遇到方法，方法本身需要存到正文段（也就是程序所在的内存区域），再将方法的值设置为方法指令所在的内存地址。</p></li></ul><p>当我们调用一个 class 方法的时候，本质上是执行了一个函数，因此和函数调用是一致的：</p><ol><li><p>首先把返回值和返回地址压栈；</p></li><li><p>然后压栈参数；</p></li><li><p>最后执行跳转。</p></li></ol><p>这里有一个小问题，有时候 class 的方法会用到<code>this</code> ，这其实并不复杂，你仔细想想， <code>this</code>指针不就是构造函数创建的一个指向 class 实例的地址吗？那么，有一种简单的实现，就是我们可以把 <code>this</code> 作为函数的第一个参数压栈。这样，类型的函数就可以访问类型的成员了，而类型也就可以翻译成指令了。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>下面我们做一个简单的总结：</p><ol><li><p>我们写的程序需要翻译成指令才能被执行，在 03 课时中我们提到过，这个翻译工具叫作编译器。</p></li><li><p>平时你编程做的事情，用机器指令也能做，所以从计算能力上来说它们是等价的，最终这种计算能力又和图灵机是等价的。如果一个语言的能力和图灵机等价，我们就说这个语言是图灵完备的语言。现在市面上的绝大多数语言都是图灵完备的语言，但也有一些不是，比如 HTML、正则表达式和 SQL 等。</p></li><li><p>我们通过汇编语言构造高级程序；通过高级程序构造自己的业务逻辑，这些都是工程能力的一种体现。</p></li></ol><p>那么通过这节课的学习，你现在可以来回答本节关联的面试题目：<strong>一个程序语言如果不支持递归函数的话，该如何实现递归算法？</strong></p><p>老规矩，请你先在脑海里思考问题的答案，并把你的思考写在留言区，然后再来看我接下来的分析。</p><p><strong>【解析】</strong> 思路如下：</p><ul><li><p>我们需要用到一个栈（其实用数组就可以）；</p></li><li><p>我们还需要一个栈指针，支持寄存器的编程语言能够直接用寄存器，而不支持直接用寄存器的编程语言，比如 Java，我们可以用一个变量；</p></li><li><p>然后我们可以实现压栈、出栈的操作，并按照上面学习的函数调用方法操作我们的栈。</p></li></ul><h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-label="Permalink to &quot;思考题&quot;">​</a></h3><p>最后我给你出一道常见的白板面试题，也是一道经典的面试题目。<strong>假设你使用的程序语言不支持递归程序，如果要求用栈来模拟下面这个斐波那契求第n项的程序，应该如何转换成等价的基于栈的非递归实现</strong>？</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">int </span><span style="color:#B392F0;">fib</span><span style="color:#E1E4E8;">(int n) {</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(n </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">) { </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> n; }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fib</span><span style="color:#E1E4E8;">(n</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fib</span><span style="color:#E1E4E8;">(n</span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">int </span><span style="color:#6F42C1;">fib</span><span style="color:#24292E;">(int n) {</span></span>
<span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(n </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">) { </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> n; }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fib</span><span style="color:#24292E;">(n</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fib</span><span style="color:#24292E;">(n</span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>你可以把你的答案、思路或者课后总结写在留言区，这样可以帮助你产生更多的思考，这也是构建知识体系的一部分。经过长期的积累，相信你会得到意想不到的收获。如果你觉得今天的内容对你有所启发，欢迎分享给身边的朋友。期待看到你的思考！</p>`,16);function f(T,q,$,I,M,V){const a=e("Image");return c(),t("div",null,[E,n(a,{alt:"Lark20200916-181251.png",src:"https://s0.lgstatic.com/i/image/M00/50/25/Ciqc1F9h5mWAGqrjAABpcF79u8M632.png"}),p(),y,n(a,{alt:"Lark20200916-181255.png",src:"https://s0.lgstatic.com/i/image/M00/50/31/CgqCHl9h5m2ALcHaAABs3s6zJkQ202.png"}),p(),i,d,F,n(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/50/25/Ciqc1F9h5nWAFY-ZAAAwk_1T41E731.png"}),p(),C,n(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/50/25/Ciqc1F9h5n-APEFtAAAy3ahEVnE846.png"}),p(),g,h,n(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/50/31/CgqCHl9h5oWAejVOAAA-DX72fJI426.png"}),p(),u,_,A,n(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/50/31/CgqCHl9h5o2ARmc3AABEUYqLaKo705.png"}),p(),v,n(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/50/25/Ciqc1F9h5pWAQ-8nAABHqkFWy4k580.png"}),p(),b,k,D,B,n(a,{alt:"Lark20201225-140329.png",src:"https://s0.lgstatic.com/i/image/M00/8C/1E/CgqCHl_lhT6AP75kAAD-cUrMUNg773.png"}),p(),m,n(a,{alt:"Lark20201225-140329.png",src:"https://s0.lgstatic.com/i/image/M00/8C/1E/CgqCHl_lhQKAIVTlAAD-cUrMUNg043.png"}),p(),R,n(a,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/51/2C/CgqCHl9kbw6AEGmQAADNH1dIS2Q053.png"}),p(),P,n(a,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/51/21/Ciqc1F9kcBCAalP8AACq_zc_LfM551.png"}),p(),S,n(a,{alt:"Lark20200916-181235.png",src:"https://s0.lgstatic.com/i/image/M00/50/25/Ciqc1F9h5rmANakFAACFALCOZaU910.png"}),p(),j])}const N=o(r,[["render",f]]);export{x as __pageData,N as default};
