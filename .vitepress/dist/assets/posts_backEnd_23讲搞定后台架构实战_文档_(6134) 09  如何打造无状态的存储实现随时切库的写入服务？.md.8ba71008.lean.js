import{_,j as l,o as n,g as p,k as s,h as a,Q as e,s as t}from"./chunks/framework.4e7d56ce.js";const G=JSON.parse('{"title":"09 如何打造无状态的存储实现随时切库的写入服务？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6134) 09  如何打造无状态的存储实现随时切库的写入服务？.md","filePath":"posts/backEnd/23讲搞定后台架构实战_文档/(6134) 09  如何打造无状态的存储实现随时切库的写入服务？.md","lastUpdated":1696417798000}'),i={name:"posts/backEnd/23讲搞定后台架构实战_文档/(6134) 09  如何打造无状态的存储实现随时切库的写入服务？.md"},c=e("",14),r=t("p",null,"图 1：分库分表且分机房架构",-1),h=t("p",null,"当其中一个分库所处的机房出现网络故障，导致该分库不可达时，理论上系统就出现故障了。在上一讲里我们提到过，分库分表后，数据在写入时是按固定规则（比如用户账号）路由到具体分库的，当某个分库不可达时，对应规则的数据就无法写入了。",-1),d=t("p",null,"但是写服务最重要的是保障数据写入，为了保障可写入，能不能在某一个分库故障（如网络不可达）后，将原有的数据全部写入当前可用的数据库呢？从保障数据可随时写入的角度看，此方式是可行的。升级后的架构如下图 2 所示：",-1),g=t("p",null,"图 2：可随时写入的架构方案",-1),u=t("p",null,[a('上述这种当分库分表里一个分库出现故障后，就随机寻找一个可用的数据库进行写入的方式即是一种保障系统高可用的架构方案。此方案可以将图 2 和"'),t("strong",null,"08 讲"),a('"提到的按固定规则路由的分库分表方案进行结合，方案如下图 3 所示：')],-1),A=e("",7),m=t("p",null,"图 4：按权重的数据写入架构",-1),P=t("h3",{id:"写入后如何处理",tabindex:"-1"},[a("写入后如何处理 "),t("a",{class:"header-anchor",href:"#写入后如何处理","aria-label":'Permalink to "写入后如何处理"'},"​")],-1),b=t("p",null,"通过数据库写入的随机化，实现了写服务的高可用方案。但不得不说，虽然解决了写入的高可用，但想要达成一个完整的架构方案，此设计还有几个重要的技术点需要解决。",-1),T=t("ul",null,[t("li",null,[t("p",null,"如果某一个分库故障后便将其从可用列表中移除，应该如何处理其中已写入的数据呢？")]),t("li",null,[t("p",null,"因为数据是随机写入，应该如何查询写入的数据呢？")])],-1),C=t("p",null,"对于上述的问题，我先向你介绍一个整体的架构解决方案。如下图 5 所示：",-1),q=e("",7),E=t("p",null,"图 6：解决数据延迟的架构",-1),f=t("p",null,"在数据写入后，用户需要立即查看写入内容的场景并不太多。比如上传完论文后，你只要立刻确定论文上传成功且查看系统里的论文内容和你上传的一致即可。",-1),k=t("p",null,"对于这些有时延要求的场景，我们在图 5 的架构里已经进行了单独预处理。当数据写入随机存储成功后，可以在请求返回前，主动地将数据写入缓存中，同时将此次写入的数据全部返回给前台。但此处并不强制缓存一定要写成功，缓存写入失败也可以返回成功。对时延敏感的场景，可以直接查询此缓存。",-1),S=t("p",null,"对于无状态存储中的数据，可以在写入请求中主动触发同步模块进行迁移，如上图 5 中标号 X 的流程。同步模块在接收到请求后，立刻将数据同步至分库分表及缓存中，后续流程就和上一讲保持一致了。",-1),x=t("p",null,"主动触发同步模块的请求及同步模块本身运行都有可能出现异常，对于可能出现的异常情况，可以设计兜底策略进行处理。兜底策略和同步模块比较类似，主要架构如下图 7 所示：",-1),V=t("p",null,"图 7：兜底同步策略",-1),B=t("p",null,[a("兜底的同步对于无状态存储中的数据按创建时间进行不断轮询，轮询会对超过设置的时间阈值（如 5S）仍未得到同步的数据进行主动同步。此兜底方案保证了当上述缓存预写入和主动同步故障时，数据仍然可以写入分库分表。此外，如果兜底策略的时间阈值设置得过小，有可能和主动同步产生重复同步。"),t("strong",null,"对于重复同步，在分库分表处可以设置数据库唯一索引、插入前查询进行简单防重即可"),a("。")],-1),M=t("h4",{id:"缓存可降级",tabindex:"-1"},[a("缓存可降级 "),t("a",{class:"header-anchor",href:"#缓存可降级","aria-label":'Permalink to "缓存可降级"'},"​")],-1),I=t("p",null,"因为主动写入缓存可能存在异常，导致数据未写入缓存，且主动数据同步和兜底同步是先写分库分表再通过 Binlog 刷新缓存，存在一定的延迟。因此在查询时需要具备降级功能，当缓存中未查询到时，可以主动降级到数据库进行一次兜底查询，并将查询到的值存储至缓存中。后续再有数据变更，和原有保持一致即可。可降级的架构方案如下图 8 所示：",-1),N=e("",9);function W(D,H,v,K,O,w){const o=l("Image");return n(),p("div",null,[c,s(o,{alt:"图片1.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E6/Cgp9HWAa0omAPU8cAADv9X0M2BY613.png"}),a(),r,h,d,s(o,{alt:"图片2.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E4/CioPOWAa0qeAd9NPAAGhERcmtvo212.png"}),a(),g,u,s(o,{alt:"图片3.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E6/Cgp9HWAa0r2ACxQBAAGr3Be48M0711.png"}),a(),A,s(o,{alt:"图片4.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E6/Cgp9HWAa0tGAaBHMAAH4Kq0ce58291.png"}),a(),m,P,b,T,C,s(o,{alt:"图片5.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E4/CioPOWAa0uSAb6wYAAJK-5ggZ-o057.png"}),a(),q,s(o,{alt:"图片6.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E4/CioPOWAa0vWAe8wCAAKCqwZXBlc775.png"}),a(),E,f,k,S,x,s(o,{alt:"图片7.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E4/CioPOWAa0wWAKXuHAAESjKmiY88514.png"}),a(),V,B,M,I,s(o,{alt:"图片8.png",src:"https://s0.lgstatic.com/i/image6/M00/00/E4/CioPOWAa0xKAV4rGAAEwLSn6Hc0120.png"}),a(),N])}const X=_(i,[["render",W]]);export{G as __pageData,X as default};
