import{_ as o,j as e,o as t,g as c,k as a,h as s,s as l,Q as p}from"./chunks/framework.b3d8e22e.js";const x=JSON.parse('{"title":"适配器模式 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/深入剖析 MyBatis 核心原理_文档/(6377) 06  日志框架千千万，MyBati 都能兼容的秘密是什么？.md","filePath":"posts/backEnd/深入剖析 MyBatis 核心原理_文档/(6377) 06  日志框架千千万，MyBati 都能兼容的秘密是什么？.md","lastUpdated":1696417798000}'),r={name:"posts/backEnd/深入剖析 MyBatis 核心原理_文档/(6377) 06  日志框架千千万，MyBati 都能兼容的秘密是什么？.md"},E=p('<p>Apache Commons Logging、Log4j、Log4j2、java.util.logging 等是 Java 开发中常用的几款日志框架，这些日志框架来源于不同的开源组织，给用户暴露的接口也有很多不同之处，所以很多开源框架会自己定义一套统一的日志接口，兼容上述第三方日志框架，供上层使用。</p><p>一般实现的方式是使用<strong>适配器模式，将各个第三方日志框架接口转换为框架内部自定义的日志接口</strong>。MyBatis 也提供了类似的实现。</p><h3 id="适配器模式" tabindex="-1">适配器模式 <a class="header-anchor" href="#适配器模式" aria-label="Permalink to &quot;适配器模式&quot;">​</a></h3><p>适配器模式主要解决的是<strong>由于接口不能兼容而导致类无法使用的问题，这在处理遗留代码以及集成第三方框架的时候用得比较多</strong> 。其核心原理是：<strong>通过组合的方式，将需要适配的类转换成使用者能够使用的接口</strong>。</p><p>适配器模式的类图如下所示：</p>',5),y=p('<p>适配器模式类图</p><p>在该类图中，你可以看到适配器模式涉及的三个核心角色。</p><ul><li><p><strong>目标接口（Target）</strong>：使用者能够直接使用的接口。以处理遗留代码为例，Target 就是最新定义的业务接口。</p></li><li><p><strong>需要适配的类/要使用的实现类（Adaptee）</strong>：定义了真正要执行的业务逻辑，但是其接口不能被使用者直接使用。这里依然以处理遗留代码为例，Adaptee 就是遗留业务实现，由于编写 Adaptee 的时候还没有定义 Target 接口，所以 Adaptee 无法实现 Target 接口。</p></li><li><p><strong>适配器（Adapter）</strong>：在实现 Target 接口的同时，维护了一个指向 Adaptee 对象的引用。Adapter 底层会依赖 Adaptee 的逻辑来实现 Target 接口的功能，这样就能够复用 Adaptee 类中的遗留逻辑来完成业务。</p></li></ul><p>适配器模式带来的最大好处就是<strong>复用已有的逻辑</strong>，避免直接去修改 Adaptee 实现的接口，这符合开放-封闭原则（也就是程序要对扩展开放、对修改关闭）。</p><p>MyBatis 使用的日志接口是自己定义的 Log 接口，但是 Apache Commons Logging、Log4j、Log4j2 等日志框架提供给用户的都是自己的 Logger 接口。为了统一这些第三方日志框架，<strong>MyBatis 使用适配器模式添加了针对不同日志框架的 Adapter 实现</strong>，使得第三方日志框架的 Logger 接口转换成 MyBatis 中的 Log 接口，从而实现集成第三方日志框架打印日志的功能。</p><h3 id="日志模块" tabindex="-1">日志模块 <a class="header-anchor" href="#日志模块" aria-label="Permalink to &quot;日志模块&quot;">​</a></h3><p><strong>MyBatis 自定义的 Log 接口位于 org.apache.ibatis.logging 包中，相关的适配器也位于该包中</strong>，下面我们就来看看该模块的具体实现。</p><p>首先是 LogFactory 工厂类，它负责创建 Log 对象。这些 Log 接口的实现类中，就包含了多种第三方日志框架的适配器，如下图所示：</p>',8),i=p(`<p>Log 接口继承关系图</p><p>在 LogFactory 类中有<a href="https://github.com/xxxlxy2008/mybatis/blob/master/src/main/java/org/apache/ibatis/logging/LogFactory.java#L31-L43" target="_blank" rel="noreferrer">一段静态代码块</a>，其中会依次加载各个第三方日志框架的适配器。在静态代码块执行的 tryImplementation() 方法中，首先会检测 logConstructor 字段是否为空，如果不为空，则表示已经成功确定当前使用的日志框架，直接返回；如果为空，则在当前线程中执行传入的 Runnable.run() 方法，尝试确定当前使用的日志框架。</p><p>以 JDK Logging 的加载流程（useJdkLogging() 方法）为例，其具体代码实现和注释如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">synchronized</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">useJdkLogging</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">setImplementation</span><span style="color:#E1E4E8;">(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setImplementation</span><span style="color:#E1E4E8;">(Class</span><span style="color:#F97583;">&lt;?</span><span style="color:#E1E4E8;"> extends Log</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> implClass) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取implClass这个适配器的构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    Constructor&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Log</span><span style="color:#E1E4E8;">&gt; candidate </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> implClass.</span><span style="color:#B392F0;">getConstructor</span><span style="color:#E1E4E8;">(String.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 尝试加载implClass这个适配器，加载失败会抛出异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    Log log </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> candidate.</span><span style="color:#B392F0;">newInstance</span><span style="color:#E1E4E8;">(LogFactory.class.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 加载成功，则更新logConstructor字段，记录适配器的构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    logConstructor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> candidate;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">LogException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;Error setting Log implementation.  Cause: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> t, t);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">synchronized</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">useJdkLogging</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">setImplementation</span><span style="color:#24292E;">(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setImplementation</span><span style="color:#24292E;">(Class</span><span style="color:#D73A49;">&lt;?</span><span style="color:#24292E;"> extends Log</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> implClass) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取implClass这个适配器的构造方法</span></span>
<span class="line"><span style="color:#24292E;">    Constructor&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Log</span><span style="color:#24292E;">&gt; candidate </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> implClass.</span><span style="color:#6F42C1;">getConstructor</span><span style="color:#24292E;">(String.class);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 尝试加载implClass这个适配器，加载失败会抛出异常</span></span>
<span class="line"><span style="color:#24292E;">    Log log </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> candidate.</span><span style="color:#6F42C1;">newInstance</span><span style="color:#24292E;">(LogFactory.class.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 加载成功，则更新logConstructor字段，记录适配器的构造方法</span></span>
<span class="line"><span style="color:#24292E;">    logConstructor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> candidate;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">LogException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;Error setting Log implementation.  Cause: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> t, t);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>下面我们以 Jdk14LoggingImpl 为例介绍一下 MyBatis Log 接口的实现。</p><p>Jdk14LoggingImpl 作为 Java Logging 的适配器，在实现 MyBatis Log 接口的同时，在内部还封装了一个 java.util.logging.Logger 对象（这是 JDK 提供的日志框架），如下图所示：</p>`,6),g=p(`<p>Jdk14LoggingImpl 继承关系图</p><p>Jdk14LoggingImpl 对 Log 接口的实现也比较简单，其中会将日志输出操作委托给底层封装的java.util.logging.Logger 对象的相应方法，这与前文介绍的典型适配器模式的实现完全一致。Jdk14LoggingImpl 中的核心实现以及注释如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Jdk14LoggingImpl</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Log</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 指向一个java.util.logging.Logger对象</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Logger log;</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Jdk14LoggingImpl</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">clazz</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 初始化log字段</span></span>
<span class="line"><span style="color:#E1E4E8;">    log </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Logger.</span><span style="color:#B392F0;">getLogger</span><span style="color:#E1E4E8;">(clazz);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">  @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(String </span><span style="color:#FFAB70;">s</span><span style="color:#E1E4E8;">, Throwable </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 全部调用依赖java.util.logging.Logger对象进行实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    log.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(Level.SEVERE, s, e);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 省略其他级别的日志输出方法</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Jdk14LoggingImpl</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Log</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 指向一个java.util.logging.Logger对象</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Logger log;</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Jdk14LoggingImpl</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">clazz</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 初始化log字段</span></span>
<span class="line"><span style="color:#24292E;">    log </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Logger.</span><span style="color:#6F42C1;">getLogger</span><span style="color:#24292E;">(clazz);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">  @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(String </span><span style="color:#E36209;">s</span><span style="color:#24292E;">, Throwable </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 全部调用依赖java.util.logging.Logger对象进行实现</span></span>
<span class="line"><span style="color:#24292E;">    log.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(Level.SEVERE, s, e);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 省略其他级别的日志输出方法</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 MyBatis 的 org.apache.ibatis.logging 包下面，除了集成三方日志框架的适配器实现之外，还有一个 jdbc 包，这个包的功能不是将日志写入数据库中，而是将数据库操作涉及的信息通过指定的 Log 打印到日志文件中。我们可以通过这个包，将执行的 SQL 语句、SQL 绑定的参数、SQL 执行之后影响的行数等信息，统统打印到日志中，这个功能主要是在测试环境进行调试的时候使用，很少在线上开启，因为这会产生非常多的日志，拖慢系统性能。</p><h3 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to &quot;代理模式&quot;">​</a></h3><p>在后面即将介绍的 org.apache.ibatis.logging.jdbc 包中，使用到了 JDK 动态代理的相关知识，所以这里我们就先来介绍一下经典的静态代理模式，以及 JDK 提供的动态代理。</p><h4 id="_1-静态代理模式" tabindex="-1">1. 静态代理模式 <a class="header-anchor" href="#_1-静态代理模式" aria-label="Permalink to &quot;1. 静态代理模式&quot;">​</a></h4><p>经典的静态代理模式，其类图如下所示：</p>`,8),F=p(`<p>代理模式类图</p><p>从该类图中，你可以看到与代理模式相关的三个核心角色。</p><ul><li><p><strong>Subject</strong>：程序中的业务接口，定义了相关的业务方法。</p></li><li><p><strong>RealSubject</strong>：实现了 Subject 接口的业务实现类，其实现中完成了真正的业务逻辑。</p></li><li><p><strong>Proxy</strong>：代理类，实现了 Subject 接口，其中会持有一个 Subject 类型的字段，指向一个 RealSubject 对象。</p></li></ul><p>在使用的时候，会将 RealSubject 对象封装到 Proxy 对象中，然后访问 Proxy 的相关方法，而不是直接访问 RealSubject 对象。在 Proxy 的方法实现中，不仅会调用 RealSubject 对象的相应方法完成业务逻辑，还会在 RealSubject 方法执行前后进行预处理和后置处理。</p><p>通过对代理模式的描述可知，<strong>Proxy 能够控制使用方对 RealSubject 对象的访问，或是在执行业务逻辑之前执行统一的预处理逻辑，在执行业务逻辑之后执行统一的后置处理逻辑</strong>。</p><p><strong>代理模式除了实现访问控制以外，还能用于实现延迟加载</strong>。例如，查询数据库涉及网络 I/O 和磁盘 I/O，会是一个比较耗时的操作，有些时候从数据库加载到内存的数据，也并非系统真正会使用到的数据，所以就有了延迟加载这种优化操作。</p><p>延迟加载可以有效地避免数据库资源的浪费，其主要原理是：用户在访问数据库时，会立刻拿到一个代理对象，此时并没有执行任何 SQL 到数据库中查询数据，代理对象中自然也不会包含任何真正的有效数据；当用户真正需要使用数据时，会访问代理对象，此时会由代理对象去执行 SQL，完成数据库的查询。MyBatis 也提供了延迟加载功能，原理大同小异，具体的实现方式也是通过代理实现的。</p><p>针对每个 RealSubject 类，都需要创建一个 Proxy 代理类，当 RealSubject 这种需要被代理的类变得很多的时候，相应地就需要定义大量的 Proxy 类，这也是经典代理模式面临的一个问题。JDK 动态代理可以有效地解决这个问题，所以接下来我们就来一起分析 JDK 动态代理的核心原理。</p><h4 id="_2-jdk-动态代理" tabindex="-1">2. JDK 动态代理 <a class="header-anchor" href="#_2-jdk-动态代理" aria-label="Permalink to &quot;2. JDK 动态代理&quot;">​</a></h4><p><strong>JDK 动态代理的核心是 InvocationHandler 接口</strong>。这里我先给出了一个 InvocationHandler 的示例实现，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoInvokerHandler</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">InvocationHandler</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Object target; </span><span style="color:#6A737D;">// 真正的业务对象，也就是RealSubject对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// DemoInvokerHandler构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoInvokerHandler</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.target </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> target;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object </span><span style="color:#FFAB70;">proxy</span><span style="color:#E1E4E8;">, Method </span><span style="color:#FFAB70;">method</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">             </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ... </span><span style="color:#6A737D;">// 在执行业务逻辑之前的预处理逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        Object result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(target, args);</span></span>
<span class="line"><span style="color:#E1E4E8;">        ... </span><span style="color:#6A737D;">// 在执行业务逻辑之后的后置处理逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 创建代理对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Proxy.</span><span style="color:#B392F0;">newProxyInstance</span><span style="color:#E1E4E8;">(Thread.</span><span style="color:#B392F0;">currentThread</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">getContextClassLoader</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">                target.</span><span style="color:#B392F0;">getClass</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getInterfaces</span><span style="color:#E1E4E8;">(), </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoInvokerHandler</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">InvocationHandler</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Object target; </span><span style="color:#6A737D;">// 真正的业务对象，也就是RealSubject对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// DemoInvokerHandler构造方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoInvokerHandler</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">target</span><span style="color:#24292E;">) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.target </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> target;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Object </span><span style="color:#E36209;">proxy</span><span style="color:#24292E;">, Method </span><span style="color:#E36209;">method</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">             </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> Throwable {</span></span>
<span class="line"><span style="color:#24292E;">        ... </span><span style="color:#6A737D;">// 在执行业务逻辑之前的预处理逻辑</span></span>
<span class="line"><span style="color:#24292E;">        Object result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(target, args);</span></span>
<span class="line"><span style="color:#24292E;">        ... </span><span style="color:#6A737D;">// 在执行业务逻辑之后的后置处理逻辑</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">getProxy</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 创建代理对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Proxy.</span><span style="color:#6F42C1;">newProxyInstance</span><span style="color:#24292E;">(Thread.</span><span style="color:#6F42C1;">currentThread</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">getContextClassLoader</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">                target.</span><span style="color:#6F42C1;">getClass</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getInterfaces</span><span style="color:#24292E;">(), </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>接下来，我们可以创建一个 main() 方法来模拟使用方创建并使用 DemoInvokerHandler 动态生成代理对象，示例代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Main</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">main</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">[] </span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        Subject subject </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">RealSubject</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        DemoInvokerHandler invokerHandler </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">DemoInvokerHandler</span><span style="color:#E1E4E8;">(subject);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 获取代理对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        Subject proxy </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Subject) invokerHandler.</span><span style="color:#B392F0;">getProxy</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 调用代理对象的方法，它会调用DemoInvokerHandler.invoke()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        proxy.</span><span style="color:#B392F0;">operation</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Main</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">main</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">[] </span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        Subject subject </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">RealSubject</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        DemoInvokerHandler invokerHandler </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">DemoInvokerHandler</span><span style="color:#24292E;">(subject);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 获取代理对象</span></span>
<span class="line"><span style="color:#24292E;">        Subject proxy </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (Subject) invokerHandler.</span><span style="color:#6F42C1;">getProxy</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 调用代理对象的方法，它会调用DemoInvokerHandler.invoke()方法</span></span>
<span class="line"><span style="color:#24292E;">        proxy.</span><span style="color:#6F42C1;">operation</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>现在假设有多个业务逻辑类，需要相同的预处理逻辑和后置处理逻辑，那么只需要提供一个 InvocationHandler 接口实现类即可。<strong>在程序运行过程中，JDK 动态代理会为每个业务类动态生成相应的代理类实现</strong>，并加载到 JVM 中，然后创建对应的代理实例对象。</p><p>下面我们就接着来深入分析一下 JDK 动态代理底层动态创建代理类的原理。不同 JDK 版本 Proxy 类的实现会有些许差异，但总体的核心思路基本一致，这里我们就以 JDK 1.8.0 版本为例进行说明。</p><p>首先，从前面的示例代码中可以看出，JDK 动态代理的入口方法是 Proxy.newProxyInstance()，这个静态方法有以下三个参数。</p><ul><li><p>loader（ClassLoader 类型）：加载动态生成的代理类的类加载器。</p></li><li><p>interfaces（Class[] 类型）：业务类实现的接口。</p></li><li><p>h（InvocationHandler 类型）：自定义的 InvocationHandler 对象。</p></li></ul><p>下面进入 Proxy.newProxyInstance() 方法，查看其具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">newProxyInstance</span><span style="color:#E1E4E8;">(ClassLoader loader,</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">Class</span><span style="color:#E1E4E8;">[] interfaces, InvocationHandler h) </span></span>
<span class="line"><span style="color:#E1E4E8;">         throws IllegalArgumentException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Class&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt;[] intfs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> interfaces.</span><span style="color:#B392F0;">clone</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span><span style="color:#6A737D;">// 省略权限检查等代码</span></span>
<span class="line"><span style="color:#E1E4E8;">    Class&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; cl </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getProxyClass0</span><span style="color:#E1E4E8;">(loader, intfs);  </span><span style="color:#6A737D;">// 获取代理类</span></span>
<span class="line"><span style="color:#E1E4E8;">    ... </span><span style="color:#6A737D;">// 省略try/catch代码块和相关异常处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取代理类的构造方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Constructor&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; cons </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> cl.</span><span style="color:#B392F0;">getConstructor</span><span style="color:#E1E4E8;">(constructorParams);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> InvocationHandler ih </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> h;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> cons.</span><span style="color:#B392F0;">newInstance</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[]{h});  </span><span style="color:#6A737D;">// 创建代理对象</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">newProxyInstance</span><span style="color:#24292E;">(ClassLoader loader,</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">Class</span><span style="color:#24292E;">[] interfaces, InvocationHandler h) </span></span>
<span class="line"><span style="color:#24292E;">         throws IllegalArgumentException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Class&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt;[] intfs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> interfaces.</span><span style="color:#6F42C1;">clone</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    ... </span><span style="color:#6A737D;">// 省略权限检查等代码</span></span>
<span class="line"><span style="color:#24292E;">    Class&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; cl </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getProxyClass0</span><span style="color:#24292E;">(loader, intfs);  </span><span style="color:#6A737D;">// 获取代理类</span></span>
<span class="line"><span style="color:#24292E;">    ... </span><span style="color:#6A737D;">// 省略try/catch代码块和相关异常处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取代理类的构造方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Constructor&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; cons </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> cl.</span><span style="color:#6F42C1;">getConstructor</span><span style="color:#24292E;">(constructorParams);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> InvocationHandler ih </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> h;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> cons.</span><span style="color:#6F42C1;">newInstance</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[]{h});  </span><span style="color:#6A737D;">// 创建代理对象</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>从 newProxyInstance() 方法的具体实现代码中我们可以看到，JDK 动态代理是在 getProxyClass0() 方法中完成代理类的生成和加载。getProxyClass0() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Class </span><span style="color:#B392F0;">getProxyClass0</span><span style="color:#E1E4E8;"> (ClassLoader loader, </span></span>
<span class="line"><span style="color:#E1E4E8;">        Class... interfaces) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 边界检查，限制接口数量（略）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果指定的类加载器中已经创建了实现指定接口的代理类，则查找缓存；</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 否则通过ProxyClassFactory创建实现指定接口的代理类</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> proxyClassCache.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(loader, interfaces);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Class </span><span style="color:#6F42C1;">getProxyClass0</span><span style="color:#24292E;"> (ClassLoader loader, </span></span>
<span class="line"><span style="color:#24292E;">        Class... interfaces) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 边界检查，限制接口数量（略）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果指定的类加载器中已经创建了实现指定接口的代理类，则查找缓存；</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 否则通过ProxyClassFactory创建实现指定接口的代理类</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> proxyClassCache.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(loader, interfaces);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>proxyClassCache 是定义在 Proxy 类中一个静态字段，它是 WeakCache 类型的集合，用于缓存已经创建过的代理类，具体定义如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> WeakCache</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ClassLoader, Class</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;">[], Class</span><span style="color:#F97583;">&lt;?&gt;&gt;</span><span style="color:#E1E4E8;"> proxyClassCache</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> WeakCache&lt;&gt;(</span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">KeyFactory</span><span style="color:#E1E4E8;">(), </span></span>
<span class="line"><span style="color:#E1E4E8;">           </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ProxyClassFactory</span><span style="color:#E1E4E8;">());</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> WeakCache</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ClassLoader, Class</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;">[], Class</span><span style="color:#D73A49;">&lt;?&gt;&gt;</span><span style="color:#24292E;"> proxyClassCache</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> WeakCache&lt;&gt;(</span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">KeyFactory</span><span style="color:#24292E;">(), </span></span>
<span class="line"><span style="color:#24292E;">           </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ProxyClassFactory</span><span style="color:#24292E;">());</span></span></code></pre></div><p>WeakCache.get() 方法会首先尝试从缓存中查找代理类，如果查找失败，则会创建相应的 Factory 对象并调用其 get() 方法获取代理类。Factory 是 WeakCache 中的内部类，在 Factory.get() 方法中会通过 ProxyClassFactory.apply() 方法创建并加载代理类。</p><p>在 ProxyClassFactory.apply() 方法中，首先会检测代理类需要实现的接口集合，然后确定代理类的名称，之后创建代理类并将其写入文件中，最后加载代理类，返回对应的 Class 对象用于后续的实例化代理类对象。该方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Class </span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(ClassLoader loader, </span><span style="color:#F97583;">Class</span><span style="color:#E1E4E8;">[] interfaces) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ... 对interfaces集合进行一系列检测（略）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ... 选择定义代理类的包名（略）</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 代理类的名称是通过包名、代理类名称前缀以及编号这三项组成的</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">long</span><span style="color:#E1E4E8;"> num </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> nextUniqueNumber.</span><span style="color:#B392F0;">getAndIncrement</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    String proxyName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> proxyPkg </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> proxyClassNamePrefix </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> num;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 生成代理类，并写入文件</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] proxyClassFile </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ProxyGenerator.</span><span style="color:#B392F0;">generateProxyClass</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">            proxyName, interfaces, accessFlags);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 加载代理类，并返回Class对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">defineClass0</span><span style="color:#E1E4E8;">(loader, proxyName, proxyClassFile, </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">, </span></span>
<span class="line"><span style="color:#E1E4E8;">      proxyClassFile.length);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Class </span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(ClassLoader loader, </span><span style="color:#D73A49;">Class</span><span style="color:#24292E;">[] interfaces) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ... 对interfaces集合进行一系列检测（略）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ... 选择定义代理类的包名（略）</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 代理类的名称是通过包名、代理类名称前缀以及编号这三项组成的</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">long</span><span style="color:#24292E;"> num </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> nextUniqueNumber.</span><span style="color:#6F42C1;">getAndIncrement</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    String proxyName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> proxyPkg </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> proxyClassNamePrefix </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> num;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 生成代理类，并写入文件</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] proxyClassFile </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ProxyGenerator.</span><span style="color:#6F42C1;">generateProxyClass</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">            proxyName, interfaces, accessFlags);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 加载代理类，并返回Class对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">defineClass0</span><span style="color:#24292E;">(loader, proxyName, proxyClassFile, </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">, </span></span>
<span class="line"><span style="color:#24292E;">      proxyClassFile.length);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ProxyGenerator.generateProxyClass() 方法会按照指定的名称和接口集合生成代理类的字节码，并根据条件决定是否保存到磁盘上。该方法的具体代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">generateProxyClass</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> String name,</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#F97583;">Class</span><span style="color:#E1E4E8;">[] interfaces) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ProxyGenerator gen </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ProxyGenerator</span><span style="color:#E1E4E8;">(name, interfaces);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 动态生成代理类的字节码，具体生成过程不再详细介绍</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;">[] classFile </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> gen.</span><span style="color:#B392F0;">generateClassFile</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果saveGeneratedFiles值为true，会将生成的代理类的字节码保存到文件中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (saveGeneratedFiles) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        java.security.AccessController.</span><span style="color:#B392F0;">doPrivileged</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> java.security.</span><span style="color:#B392F0;">PrivilegedAction</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Void </span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 省略try/catch代码块</span></span>
<span class="line"><span style="color:#E1E4E8;">                    FileOutputStream file </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FileOutputStream</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#B392F0;">dotToSlash</span><span style="color:#E1E4E8;">(name) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;.class&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    file.</span><span style="color:#B392F0;">write</span><span style="color:#E1E4E8;">(classFile);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    file.</span><span style="color:#B392F0;">close</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        );</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> classFile; </span><span style="color:#6A737D;">// 返回上面生成的代理类的字节码</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">generateProxyClass</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> String name,</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#D73A49;">Class</span><span style="color:#24292E;">[] interfaces) {</span></span>
<span class="line"><span style="color:#24292E;">    ProxyGenerator gen </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ProxyGenerator</span><span style="color:#24292E;">(name, interfaces);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 动态生成代理类的字节码，具体生成过程不再详细介绍</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;">[] classFile </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> gen.</span><span style="color:#6F42C1;">generateClassFile</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果saveGeneratedFiles值为true，会将生成的代理类的字节码保存到文件中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (saveGeneratedFiles) { </span></span>
<span class="line"><span style="color:#24292E;">        java.security.AccessController.</span><span style="color:#6F42C1;">doPrivileged</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> java.security.</span><span style="color:#6F42C1;">PrivilegedAction</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Void </span><span style="color:#6F42C1;">run</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 省略try/catch代码块</span></span>
<span class="line"><span style="color:#24292E;">                    FileOutputStream file </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FileOutputStream</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6F42C1;">dotToSlash</span><span style="color:#24292E;">(name) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;.class&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                    file.</span><span style="color:#6F42C1;">write</span><span style="color:#24292E;">(classFile);</span></span>
<span class="line"><span style="color:#24292E;">                    file.</span><span style="color:#6F42C1;">close</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        );</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> classFile; </span><span style="color:#6A737D;">// 返回上面生成的代理类的字节码</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>最后，为了清晰地看到 JDK 动态生成的代理类的真正代码，我们需要将上述生成的代理类的字节码进行反编译。上述示例为 RealSubject 生成的代理类，反编译后得到的代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">$Proxy143</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">extends</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Proxy</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Subject</span><span style="color:#E1E4E8;"> {  </span><span style="color:#6A737D;">// 实现了Subject接口</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里省略了从Object类继承下来的相关方法和属性</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> Method m3;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 省略了try/catch代码块</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 记录了operation()方法对应的Method对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        m3 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> Class.</span><span style="color:#B392F0;">forName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;design.proxy.Subject&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">          .</span><span style="color:#B392F0;">getMethod</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;operation&quot;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">Class</span><span style="color:#E1E4E8;">[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 构造方法的参数就是我们在示例中使用的DemoInvokerHandler对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> $</span><span style="color:#B392F0;">Proxy11</span><span style="color:#E1E4E8;">(InvocationHandler </span><span style="color:#FFAB70;">var1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">(var1); </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">operation</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 省略了try/catch代码块</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 调用DemoInvokerHandler对象的invoke()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 最终调用RealSubject对象的对应方法</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">.h.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, m3, (</span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[]) </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">$Proxy143</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">extends</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Proxy</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Subject</span><span style="color:#24292E;"> {  </span><span style="color:#6A737D;">// 实现了Subject接口</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里省略了从Object类继承下来的相关方法和属性</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> Method m3;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 省略了try/catch代码块</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 记录了operation()方法对应的Method对象</span></span>
<span class="line"><span style="color:#24292E;">        m3 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> Class.</span><span style="color:#6F42C1;">forName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;design.proxy.Subject&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">          .</span><span style="color:#6F42C1;">getMethod</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;operation&quot;</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">Class</span><span style="color:#24292E;">[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 构造方法的参数就是我们在示例中使用的DemoInvokerHandler对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> $</span><span style="color:#6F42C1;">Proxy11</span><span style="color:#24292E;">(InvocationHandler </span><span style="color:#E36209;">var1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">(var1); </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">operation</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 省略了try/catch代码块</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 调用DemoInvokerHandler对象的invoke()方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 最终调用RealSubject对象的对应方法</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">.h.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, m3, (</span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[]) </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>到此为止，JDK 动态代理的基本使用以及核心原理就分析完了。这里我做一个简单的总结，JDK 动态代理的实现原理是：<strong>动态创建代理类，然后通过指定类加载器进行加载</strong>。在创建代理对象时，需要将 InvocationHandler 对象作为构造参数传入；当调用代理对象时，会调用 InvocationHandler.invoke() 方法，从而执行代理逻辑，最终调用真正业务对象的相应方法。</p><h3 id="jdbc-logger" tabindex="-1">JDBC Logger <a class="header-anchor" href="#jdbc-logger" aria-label="Permalink to &quot;JDBC Logger&quot;">​</a></h3><p>了解了代理模式以及 JDK 动态代理的基础知识之后，下面我们开始分析 org.apache.ibatis.logging.jdbc 包中的内容。</p><p>首先来看其中<strong>最基础的抽象类------ BaseJdbcLogger，它是 jdbc 包下其他 Logger 类的父类</strong>，继承关系如下图所示：</p>`,34),d=p(`<p>BaseJdbcLogger 继承关系图</p><p>在 BaseJdbcLogger 这个抽象类中，定义了 SET_METHODS 和 EXECUTE_METHODS 两个 Set 类型的集合。其中，SET_METHODS 用于记录绑定 SQL 参数涉及的全部 set*() 方法名称，例如 setString() 方法、setInt() 方法等。EXECUTE_METHODS 用于记录执行 SQL 语句涉及的所有方法名称，例如 execute() 方法、executeUpdate() 方法、executeQuery() 方法、addBatch() 方法等。这两个集合都是在 BaseJdbcLogger 的静态代码块中被填充的。</p><p>从上面的 BaseJdbcLogger 继承关系图中可以看到，BaseJdbcLogger 的子类同时会实现 InvocationHandler 接口。</p><p>我们先来看其中的 ConnectionLogger 实现，其底层维护了一个 Connection 对象的引用，在<a href="https://github.com/xxxlxy2008/mybatis/blob/master/src/main/java/org/apache/ibatis/logging/jdbc/ConnectionLogger.java#L84-L90" target="_blank" rel="noreferrer">ConnectionLogger.newInstance() 方法</a>中会使用 JDK 动态代理的方式为这个 Connection 对象创建相应的代理对象。</p><p>invoke() 方法是代理对象的核心方法，在该方法中，ConnectionLogger 会为 prepareStatement()、prepareCall()、createStatement() 三个方法添加代理逻辑。下面来看 invoke() 方法的具体实现，具体代码以及注释如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object proxy, Method method, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] params)</span></span>
<span class="line"><span style="color:#E1E4E8;">        throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Object.class.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(method.</span><span style="color:#B392F0;">getDeclaringClass</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果调用的是从Object继承的方法，则直接调用，不做任何拦截</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, params);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 调用prepareStatement()方法、prepareCall()方法的时候，</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 会在创建PreparedStatement对象之后，用PreparedStatementLogger为其创建代理对象</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&quot;prepareStatement&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(method.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">()) </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;prepareCall&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(method.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isDebugEnabled</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 通过statementLog这个Log输出日志</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#B392F0;">debug</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot; Preparing: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">removeExtraWhitespace</span><span style="color:#E1E4E8;">((String) params[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">]), </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">            PreparedStatement stmt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (PreparedStatement) method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(connection, params);</span></span>
<span class="line"><span style="color:#E1E4E8;">            stmt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> PreparedStatementLogger.</span><span style="color:#B392F0;">newInstance</span><span style="color:#E1E4E8;">(stmt, statementLog, queryStack);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> stmt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&quot;createStatement&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(method.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 调用createStatement()方法的时候，</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 会在创建Statement对象之后，用StatementLogger为其创建代理对象</span></span>
<span class="line"><span style="color:#E1E4E8;">            Statement stmt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (Statement) method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(connection, params);</span></span>
<span class="line"><span style="color:#E1E4E8;">            stmt </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> StatementLogger.</span><span style="color:#B392F0;">newInstance</span><span style="color:#E1E4E8;">(stmt, statementLog, queryStack);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> stmt;</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 除了上述三个方法之外，其他方法的调用将直接传递给底层Connection对象的相应方法处理</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(connection, params);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> ExceptionUtil.</span><span style="color:#B392F0;">unwrapThrowable</span><span style="color:#E1E4E8;">(t);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Object proxy, Method method, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] params)</span></span>
<span class="line"><span style="color:#24292E;">        throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Object.class.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(method.</span><span style="color:#6F42C1;">getDeclaringClass</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果调用的是从Object继承的方法，则直接调用，不做任何拦截</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, params);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 调用prepareStatement()方法、prepareCall()方法的时候，</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 会在创建PreparedStatement对象之后，用PreparedStatementLogger为其创建代理对象</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">&quot;prepareStatement&quot;</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(method.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">()) </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;prepareCall&quot;</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(method.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isDebugEnabled</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 通过statementLog这个Log输出日志</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6F42C1;">debug</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot; Preparing: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">removeExtraWhitespace</span><span style="color:#24292E;">((String) params[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">]), </span><span style="color:#005CC5;">true</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">            PreparedStatement stmt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (PreparedStatement) method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(connection, params);</span></span>
<span class="line"><span style="color:#24292E;">            stmt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> PreparedStatementLogger.</span><span style="color:#6F42C1;">newInstance</span><span style="color:#24292E;">(stmt, statementLog, queryStack);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> stmt;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">&quot;createStatement&quot;</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(method.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 调用createStatement()方法的时候，</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 会在创建Statement对象之后，用StatementLogger为其创建代理对象</span></span>
<span class="line"><span style="color:#24292E;">            Statement stmt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (Statement) method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(connection, params);</span></span>
<span class="line"><span style="color:#24292E;">            stmt </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> StatementLogger.</span><span style="color:#6F42C1;">newInstance</span><span style="color:#24292E;">(stmt, statementLog, queryStack);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> stmt;</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 除了上述三个方法之外，其他方法的调用将直接传递给底层Connection对象的相应方法处理</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(connection, params);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> ExceptionUtil.</span><span style="color:#6F42C1;">unwrapThrowable</span><span style="color:#24292E;">(t);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>下面我们来看 PreparedStatementLogger，在其 invoke() 方法中调用了 SET_METHODS 集合中的方法、EXECUTE_METHODS 集合中的方法或 getResultSet() 方法时，会添加相应的代理逻辑。StatementLogger 中的 Invoke() 方法实现与之类似，这里就不再赘述。</p><p>最后我们再看下 ResultSetLogger 对 InvocationHandler 接口的实现，其中会针对 ResultSet.next() 方法进行后置处理，主要是打印结果集中每一行数据以及统计结果集总行数等信息，具体实现和注释如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Object proxy, Method method, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">[] params) throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (Object.class.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(method.</span><span style="color:#B392F0;">getDeclaringClass</span><span style="color:#E1E4E8;">())) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#6A737D;">// 如果调用Object的方法，则直接调用，不做任何其他处理</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, params);</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      Object o </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> method.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(rs, params);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">// 针对ResultSet.next()方法进行后置处理</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#9ECBFF;">&quot;next&quot;</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">equals</span><span style="color:#E1E4E8;">(method.</span><span style="color:#B392F0;">getName</span><span style="color:#E1E4E8;">())) { </span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((Boolean) o) { </span><span style="color:#6A737D;">// 检测next()方法的返回值，确定是否还存在下一行数据</span></span>
<span class="line"><span style="color:#E1E4E8;">              rows</span><span style="color:#F97583;">++</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 记录ResultSet中的行数</span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">isTraceEnabled</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#6A737D;">// 获取数据集的列元数据</span></span>
<span class="line"><span style="color:#E1E4E8;">                  ResultSetMetaData rsmd </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> rs.</span><span style="color:#B392F0;">getMetaData</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#6A737D;">// 获取数据集的列数</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> columnCount </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> rsmd.</span><span style="color:#B392F0;">getColumnCount</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (first) { </span><span style="color:#6A737D;">// 如果是数据集的第一行数据，会输出表头信息</span></span>
<span class="line"><span style="color:#E1E4E8;">                      first </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">                      </span><span style="color:#6A737D;">// 这里除了输出表头，还会记录BLOB等超大类型的列名</span></span>
<span class="line"><span style="color:#E1E4E8;">                      </span><span style="color:#B392F0;">printColumnHeaders</span><span style="color:#E1E4E8;">(rsmd, columnCount);</span></span>
<span class="line"><span style="color:#E1E4E8;">                  }</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#6A737D;">// 输出当前遍历的这行记录，这里会过滤掉超大类型列的数据，不进行输出</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#B392F0;">printColumnValues</span><span style="color:#E1E4E8;">(columnCount);</span></span>
<span class="line"><span style="color:#E1E4E8;">              }</span></span>
<span class="line"><span style="color:#E1E4E8;">          } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> { </span><span style="color:#6A737D;">// 完成结果集的遍历之后，这里会在日志中输出总行数</span></span>
<span class="line"><span style="color:#E1E4E8;">              </span><span style="color:#B392F0;">debug</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;     Total: &quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> rows, </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">          }</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">clearColumnInfo</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 清空column*集合</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> o;</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> ExceptionUtil.</span><span style="color:#B392F0;">unwrapThrowable</span><span style="color:#E1E4E8;">(t);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Object proxy, Method method, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">[] params) throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (Object.class.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(method.</span><span style="color:#6F42C1;">getDeclaringClass</span><span style="color:#24292E;">())) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#6A737D;">// 如果调用Object的方法，则直接调用，不做任何其他处理</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, params);</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      Object o </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> method.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(rs, params);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">// 针对ResultSet.next()方法进行后置处理</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#032F62;">&quot;next&quot;</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">equals</span><span style="color:#24292E;">(method.</span><span style="color:#6F42C1;">getName</span><span style="color:#24292E;">())) { </span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((Boolean) o) { </span><span style="color:#6A737D;">// 检测next()方法的返回值，确定是否还存在下一行数据</span></span>
<span class="line"><span style="color:#24292E;">              rows</span><span style="color:#D73A49;">++</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 记录ResultSet中的行数</span></span>
<span class="line"><span style="color:#24292E;">              </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">isTraceEnabled</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#6A737D;">// 获取数据集的列元数据</span></span>
<span class="line"><span style="color:#24292E;">                  ResultSetMetaData rsmd </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> rs.</span><span style="color:#6F42C1;">getMetaData</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#6A737D;">// 获取数据集的列数</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> columnCount </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> rsmd.</span><span style="color:#6F42C1;">getColumnCount</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (first) { </span><span style="color:#6A737D;">// 如果是数据集的第一行数据，会输出表头信息</span></span>
<span class="line"><span style="color:#24292E;">                      first </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">                      </span><span style="color:#6A737D;">// 这里除了输出表头，还会记录BLOB等超大类型的列名</span></span>
<span class="line"><span style="color:#24292E;">                      </span><span style="color:#6F42C1;">printColumnHeaders</span><span style="color:#24292E;">(rsmd, columnCount);</span></span>
<span class="line"><span style="color:#24292E;">                  }</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#6A737D;">// 输出当前遍历的这行记录，这里会过滤掉超大类型列的数据，不进行输出</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#6F42C1;">printColumnValues</span><span style="color:#24292E;">(columnCount);</span></span>
<span class="line"><span style="color:#24292E;">              }</span></span>
<span class="line"><span style="color:#24292E;">          } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> { </span><span style="color:#6A737D;">// 完成结果集的遍历之后，这里会在日志中输出总行数</span></span>
<span class="line"><span style="color:#24292E;">              </span><span style="color:#6F42C1;">debug</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;     Total: &quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> rows, </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">          }</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">clearColumnInfo</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 清空column*集合</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> o;</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> ExceptionUtil.</span><span style="color:#6F42C1;">unwrapThrowable</span><span style="color:#24292E;">(t);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>在这一讲中，我们主要介绍的是 MyBatis 基础模块中的日志模块。</p><ul><li><p>首先，介绍了适配器模式的核心知识点，这也是日志模块底层的设计思想。</p></li><li><p>然后，说明了日志模块是如何基于适配器模式集成多种三方日志框架的。</p></li><li><p>接下来，详细讲解了静态代理模式以及 JDK 动态代理的实现原理。</p></li><li><p>最后，深入分析了 JDBC Logger 是如何基于 JDK 动态代理实现日志功能的。</p></li></ul><p>关于 MyBatis 的日志模块，若你有什么经验或问题，期待在留言区与我分享和交流。</p><p>在下一讲，我会介绍 MyBatis 数据源和事务相关的内容，记得按时来听课。</p><hr>`,15),u={href:"https://shenceyun.lagou.com/t/Mka",target:"_blank",rel:"noreferrer"},A=l("p",null,[l("strong",null,"《Java 工程师高薪训练营》")],-1),D=l("p",null,[s("实战训练+面试模拟+大厂内推，想要提升技术能力，进大厂拿高薪，"),l("a",{href:"https://shenceyun.lagou.com/t/Mka",target:"_blank",rel:"noreferrer"},"点击链接，提升自己"),s("！")],-1);function C(h,m,b,v,B,k){const n=e("Image");return t(),c("div",null,[E,a(n,{alt:"2.png",src:"https://s0.lgstatic.com/i/image6/M00/03/97/Cgp9HWAfYoOAKO6lAAEyIgsMVKA161.png"}),s(),y,a(n,{alt:"3.png",src:"https://s0.lgstatic.com/i/image6/M00/03/95/CioPOWAfYo6AbKZWAAKqpRwXpuA169.png"}),s(),i,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image6/M00/02/E4/CioPOWAeM0WAMQPTAABNRPFy7R0954.png"}),s(),g,a(n,{alt:"4.png",src:"https://s0.lgstatic.com/i/image6/M00/03/97/Cgp9HWAfYrOAWv7JAAD2hkpzuWw664.png"}),s(),F,a(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image6/M00/03/95/CioPOWAfYsuAc9WjAAFm7izVaMI477.png"}),s(),d,l("p",null,[l("a",u,[a(n,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/6D/3E/CgqCHl-s60-AC0B_AAhXSgFweBY762.png"})])]),A,D])}const S=o(r,[["render",C]]);export{x as __pageData,S as default};
