import{_ as e,j as o,o as t,h as c,k as a,f as s,Q as l,s as p}from"./chunks/framework.d3daa342.js";const k=JSON.parse('{"title":"22自渲染模式：从Flutter的渲染原理，进一步掌握性能优化策略","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/101-Flutter快学快用24讲文档/(3539) 22  自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略.md","filePath":"posts/frontEnd/101-Flutter快学快用24讲文档/(3539) 22  自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略.md","lastUpdated":1696682708000}'),r={name:"posts/frontEnd/101-Flutter快学快用24讲文档/(3539) 22  自渲染模式：从 Flutter 的渲染原理，进一步掌握性能优化策略.md"},E=l("",6),i=l("",6),y=p("p",null,"图 2 Element 树结构",-1),d=p("p",null,"你有没有发现就一个非常简单的 Widget ，在 Flutter 中实际生成的 Element 树结构图是如此的复杂。你有没有发现在树的最底层才是我们使用的组件 FirstRoute->Center->Text->RichText（如图 2 中红色的部分）。了解完三棵树结构后，我们再来看下三棵树是如何进行转化的。",-1),u=p("h3",{id:"三棵树对应关系",tabindex:"-1"},[s("三棵树对应关系 "),p("a",{class:"header-anchor",href:"#三棵树对应关系","aria-label":'Permalink to "三棵树对应关系"'},"​")],-1),h=p("p",null,"在 Flutter 中，Widget 和 Element 树是一一对应的，但是与 RenderObject 不是一一对应的。因为有些 Widget 是不需要渲染的，比如我们上面测试代码中的 FirstRoute 就是不需要渲染的 Widget。最终只有 RenderObjectWidget 相关的 Widget 才会转化为 RenderObject，也只有这种类型才需要进行渲染。可以看下表格 1 所展示的三棵树部分类型的对应关系。",-1),F=l("",8),g=l("",17),C=l("",7),m=l("",27);function b(_,A,W,w,D,B){const n=o("Image");return t(),c("div",null,[E,a(n,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_i_CAfmbFAAJQmkbVhaU299.png"}),s(),i,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_i_uAHvbgAAFqAXyCe9s498.png"}),s(),y,d,u,h,a(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jAWASaH5AABxjuioTcw001.png"}),s(),F,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jBaAPZtCAADE5IavI9E126.png"}),s(),g,a(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jEiAbM-GAAFJbtV_XLo642.png"}),s(),C,a(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/44/E0/Ciqc1F8_jJGATAlDAAFF3eMI6D8595.png"}),s(),m])}const f=e(r,[["render",b]]);export{k as __pageData,f as default};
