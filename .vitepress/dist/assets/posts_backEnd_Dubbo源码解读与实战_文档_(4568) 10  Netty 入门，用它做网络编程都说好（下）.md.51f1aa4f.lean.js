import{_ as t,j as s,o as p,h as r,k as a,f as e,Q as l,s as n}from"./chunks/framework.d3daa342.js";const Z=JSON.parse('{"title":"10Netty入门，用它做网络编程都说好（下）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4568) 10  Netty 入门，用它做网络编程都说好（下）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4568) 10  Netty 入门，用它做网络编程都说好（下）.md","lastUpdated":1696682708000}'),i={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4568) 10  Netty 入门，用它做网络编程都说好（下）.md"},c=l("",14),h=l("",9),u=n("p",null,"Netty 提供的 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 主要是帮助完成事件流转功能的，即自动调用传递事件的相应方法。这样，我们在自定义 ChannelHandler 实现类的时候，就可以直接继承相应的 Adapter 类，并覆盖需要的事件处理方法，其他不关心的事件方法直接使用默认实现即可，从而提高开发效率。",-1),d=n("p",null,[e("ChannelHandler 中的很多方法都需要一个 ChannelHandlerContext 类型的参数，ChannelHandlerContext 抽象的是 ChannleHandler 之间的关系以及 ChannelHandler 与ChannelPipeline 之间的关系。"),n("strong",null,"ChannelPipeline 中的事件传播主要依赖于ChannelHandlerContext 实现"),e("，在 ChannelHandlerContext 中维护了 ChannelHandler 之间的关系，所以我们可以从 ChannelHandlerContext 中得到当前 ChannelHandler 的后继节点，从而将事件传播到后续的 ChannelHandler。")],-1),y=n("p",null,"ChannelHandlerContext 继承了 AttributeMap，所以提供了 attr() 方法设置和删除一些状态属性信息，我们可将业务逻辑中所需使用的状态属性值存入到 ChannelHandlerContext 中，然后这些属性就可以随它传播了。Channel 中也维护了一个 AttributeMap，与 ChannelHandlerContext 中的 AttributeMap，从 Netty 4.1 开始，都是作用于整个 ChannelPipeline。",-1),C=n("p",null,[e("通过上述分析，我们可以了解到，"),n("strong",null,"一个 Channel 对应一个 ChannelPipeline，一个 ChannelHandlerContext 对应一个ChannelHandler。"),e(" 如下图所示：")],-1),E=n("p",null,"最后，需要注意的是，如果要在 ChannelHandler 中执行耗时较长的逻辑，例如，操作 DB 、进行网络或磁盘 I/O 等操作，一般会在注册到 ChannelPipeline 的同时，指定一个线程池异步执行 ChannelHandler 中的操作。",-1),_=n("h3",{id:"nioeventloop",tabindex:"-1"},[e("NioEventLoop "),n("a",{class:"header-anchor",href:"#nioeventloop","aria-label":'Permalink to "NioEventLoop"'},"​")],-1),g=n("p",null,"在前文介绍 Netty 线程模型的时候，我们简单提到了 NioEventLoop 这个组件，当时为了便于理解，只是简单将其描述成了一个线程。",-1),P=n("p",null,"一个 EventLoop 对象由一个永远都不会改变的线程驱动，同时一个 NioEventLoop 包含了一个 Selector 对象，可以支持多个 Channel 注册在其上，该 NioEventLoop 可以同时服务多个 Channel，每个 Channel 只能与一个 NioEventLoop 绑定，这样就实现了线程与 Channel 之间的关联。",-1),N=n("p",null,"我们知道，Channel 中的 I/O 操作是由 ChannelPipeline 中注册的 ChannelHandler 进行处理的，而 ChannelHandler 的逻辑都是由相应 NioEventLoop 关联的那个线程执行的。",-1),A=n("p",null,"除了与一个线程绑定之外，NioEvenLoop 中还维护了两个任务队列：",-1),B=n("ul",null,[n("li",null,[n("strong",null,"普通任务队列"),e("。用户产生的普通任务可以提交到该队列中暂存，NioEventLoop 发现该队列中的任务后会立即执行。这是一个多生产者、单消费者的队列，Netty 使用该队列将外部用户线程产生的任务收集到一起，并在 Reactor 线程内部用单线程的方式串行执行队列中的任务。例如，外部非 I/O 线程调用了 Channel 的 write() 方法，Netty 会将其封装成一个任务放入 TaskQueue 队列中，这样，所有的 I/O 操作都会在 I/O 线程中串行执行。")])],-1),b=l("",5),I=n("p",null,"前面我们提到过，在 Netty 服务器端中，会有 BossEventLoopGroup 和 WorkerEventLoopGroup 两个 NioEventLoopGroup。通常一个服务端口只需要一个ServerSocketChannel，对应一个 Selector 和一个 NioEventLoop 线程。",-1),k=n("p",null,"BossEventLoop 负责接收客户端的连接事件，即 OP_ACCEPT 事件，然后将创建的 NioSocketChannel 交给 WorkerEventLoopGroup； WorkerEventLoopGroup 会由 next() 方法选择其中一个 NioEventLoopGroup，并将这个 NioSocketChannel 注册到其维护的 Selector 并对其后续的I/O事件进行处理。",-1),v=l("",6),L=l("",9),f=n("h4",{id:"_1-内存分配-释放",tabindex:"-1"},[e("1. 内存分配&释放 "),n("a",{class:"header-anchor",href:"#_1-内存分配-释放","aria-label":'Permalink to "1. 内存分配\\&释放"'},"​")],-1),m=n("p",null,"当服务向内存池请求内存时，Netty 会将请求分配的内存数向上取整到最接近的分组大小，然后在该分组的相应层级中从左至右寻找空闲分组。例如，服务请求分配 3 * PageSize 的内存，向上取整得到的分组大小为 4 * PageSize，在该层分组中找到完全空闲的一组内存进行分配即可，如下图：",-1),F=n("p",null,"当分组大小 4 * PageSize 的内存分配出去后，为了方便下次内存分配，分组被标记为全部已使用（图中红色标记），向上更粗粒度的内存分组被标记为部分已使用（图中黄色标记）。",-1),S=n("p",null,[e("Netty 使用"),n("strong",null,"完全平衡树的结构"),e("实现了上述算法，这个完全平衡树底层是基于一个 byte 数组构建的，如下图所示：")],-1),H=n("p",null,"具体的实现逻辑这里就不再展开讲述了，你若感兴趣的话，可以参考 Netty 代码。",-1),q=n("h4",{id:"_2-大对象-小对象的处理",tabindex:"-1"},[e("2. 大对象&小对象的处理 "),n("a",{class:"header-anchor",href:"#_2-大对象-小对象的处理","aria-label":'Permalink to "2. 大对象\\&小对象的处理"'},"​")],-1),O=n("p",null,"当申请分配的对象是超过 Chunk 容量的大型对象，Netty 就不再使用池化管理方式了，在每次请求分配内存时单独创建特殊的非池化 PoolChunk 对象进行管理，当对象内存释放时整个PoolChunk 内存释放。",-1),T=n("p",null,"如果需要一定数量空间远小于 PageSize 的 ByteBuf 对象，例如，创建 256 Byte 的 ByteBuf，按照上述算法，就需要为每个小 ByteBuf 对象分配一个 Page，这就出现了很多内存碎片。Netty 通过再将 Page 细分的方式，解决这个问题。Netty 将请求的空间大小向上取最近的 16 的倍数（或 2 的幂），规整后小于 PageSize 的小 Buffer 可分为两类。",-1),D=n("ul",null,[n("li",null,[n("p",null,"微型对象：规整后的大小为 16 的整倍数，如 16、32、48、......、496，一共 31 种大小。")]),n("li",null,[n("p",null,"小型对象：规整后的大小为 2 的幂，如 512、1024、2048、4096，一共 4 种大小。")])],-1),x=n("p",null,"Netty 的实现会先从 PoolChunk 中申请空闲 Page，同一个 Page 分为相同大小的小 Buffer 进行存储；这些 Page 用 PoolSubpage 对象进行封装，PoolSubpage 内部会记录它自己能分配的小 Buffer 的规格大小、可用内存数量，并通过 bitmap 的方式记录各个小内存的使用情况（如下图所示）。虽然这种方案不能完美消灭内存碎片，但是很大程度上还是减少了内存浪费。",-1),w=n("p",null,"为了解决单个 PoolChunk 容量有限的问题，Netty 将多个 PoolChunk 组成链表一起管理，然后用 PoolChunkList 对象持有链表的 head。",-1),M=n("p",null,[n("strong",null,"Netty 通过 PoolArena 管理 PoolChunkList 以及 PoolSubpage"),e("。")],-1),V=n("p",null,"PoolArena 内部持有 6 个 PoolChunkList，各个 PoolChunkList 持有的 PoolChunk 的使用率区间有所不同，如下图所示：",-1),G=n("p",null,"6 个 PoolChunkList 对象组成双向链表，当 PoolChunk 内存分配、释放，导致使用率变化，需要判断 PoolChunk 是否超过所在 PoolChunkList 的限定使用率范围，如果超出了，需要沿着 6 个 PoolChunkList 的双向链表找到新的合适的 PoolChunkList ，成为新的 head。同样，当新建 PoolChunk 分配内存或释放空间时，PoolChunk 也需要按照上面逻辑放入合适的PoolChunkList 中。",-1),R=n("p",null,"从上图可以看出，这 6 个 PoolChunkList 额定使用率区间存在交叉，这样设计的原因是：如果使用单个临界值的话，当一个 PoolChunk 被来回申请和释放，内存使用率会在临界值上下徘徊，这就会导致它在两个 PoolChunkList 链表中来回移动。",-1),U=n("p",null,"PoolArena 内部持有 2 个 PoolSubpage 数组，分别存储微型 Buffer 和小型 Buffer 的PoolSubpage。相同大小的 PoolSubpage 组成链表，不同大小的 PoolSubpage 链表的 head 节点保存在 tinySubpagePools 或者 smallSubpagePools 数组中，如下图：",-1),z=l("",7);function W(J,j,Q,Y,K,X){const o=s("Image");return p(),r("div",null,[c,a(o,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/47/96/Ciqc1F9Ill2AMrCEAAFZL4VXrW8624.png"}),e(),h,a(o,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/47/96/Ciqc1F9IlmmABbbRAADcN9APiZs099.png"}),e(),u,d,y,C,a(o,{alt:"1.png",src:"https://s0.lgstatic.com/i/image/M00/47/BE/CgqCHl9Ixi-APR5UAADY4pM97IU060.png"}),e(),E,_,g,P,N,A,B,a(o,{alt:"2.png",src:"https://s0.lgstatic.com/i/image/M00/47/B2/Ciqc1F9IxjqAJwMsAAFsUFuiU6A398.png"}),e(),b,a(o,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/47/A1/CgqCHl9IloyAHiBiAALeke8Ln5c195.png"}),e(),I,k,a(o,{alt:"image (24).png",src:"https://s0.lgstatic.com/i/image/M00/4A/6F/CgqCHl9RrYCAVrHFAAF5lFo-Hgc219.png"}),e(),v,a(o,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/47/A1/CgqCHl9IlsaAJYcYAAA31kf6i_g696.png"}),e(),L,a(o,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/47/A1/CgqCHl9IlteANQ8lAADm9qN5mgE993.png"}),e(),f,m,a(o,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/47/96/Ciqc1F9IluuAFgouAADoPKhjuW4842.png"}),e(),F,S,a(o,{alt:"Drawing 9.png",src:"https://s0.lgstatic.com/i/image/M00/47/96/Ciqc1F9IlvKACdYpAAF2w22m4sQ981.png"}),e(),H,q,O,T,D,x,a(o,{alt:"Drawing 10.png",src:"https://s0.lgstatic.com/i/image/M00/47/A1/CgqCHl9Ilv-ABhKnAAFcBHa9_3E953.png"}),e(),w,M,V,a(o,{alt:"Drawing 11.png",src:"https://s0.lgstatic.com/i/image/M00/47/A1/CgqCHl9IlwaAMIzVAACq5iIjcZk639.png"}),e(),G,a(o,{alt:"Drawing 12.png",src:"https://s0.lgstatic.com/i/image/M00/47/A1/CgqCHl9Ilw2ATgO0AACWza-dQV4641.png"}),e(),R,U,a(o,{alt:"Drawing 13.png",src:"https://s0.lgstatic.com/i/image/M00/47/96/Ciqc1F9IlxSAWAuXAADUtE1ddhw421.png"}),e(),z])}const nn=t(i,[["render",W]]);export{Z as __pageData,nn as default};
