import{_ as p,j as o,o as e,g as t,k as a,Q as l,s}from"./chunks/framework.e0c66c3f.js";const m=JSON.parse('{"title":"什么是单例模式 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md","lastUpdated":1696338709000}'),c={name:"posts/backEnd/096-Java 并发编程文档/(301) 第63讲：单例模式的双重检查锁模式为什么必须加 volatile？.md"},r=l("",11),i=l("",12),E=s("ul",null,[s("li",null,[s("p",null,"第一步是给 singleton 分配内存空间；")]),s("li",null,[s("p",null,"然后第二步开始调用 Singleton 的构造函数等，来初始化 singleton；")]),s("li",null,[s("p",null,"最后第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。")])],-1),y=s("p",null,"这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。",-1),g=s("p",null,"如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错，详细流程如下图所示：",-1),h=l("",7);function _(u,d,v,A,f,b){const n=o("Image");return e(),t("div",null,[r,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/05/B6/Ciqah16BpV-AG9iPAAAf42nvy5s798.png"}),i,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7E/CC/Cgq2xl6BpWCAMBaVAACFIdffjfM852.png"}),E,y,g,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/7E/CC/Cgq2xl6BpWCAB6QQAAEKacFd0CE542.png"}),h])}const C=p(c,[["render",_]]);export{m as __pageData,C as default};
