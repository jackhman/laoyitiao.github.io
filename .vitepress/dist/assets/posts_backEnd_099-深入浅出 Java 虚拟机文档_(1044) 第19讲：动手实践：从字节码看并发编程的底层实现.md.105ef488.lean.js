import{_ as e,j as o,o as t,g as c,k as l,h as a,s,Q as p}from"./chunks/framework.4e7d56ce.js";const F=JSON.parse('{"title":"第19讲：动手实践：从字节码看并发编程的底层实现","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1044) 第19讲：动手实践：从字节码看并发编程的底层实现.md","filePath":"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1044) 第19讲：动手实践：从字节码看并发编程的底层实现.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/099-深入浅出 Java 虚拟机文档/(1044) 第19讲：动手实践：从字节码看并发编程的底层实现.md"},i=s("h1",{id:"第19讲-动手实践-从字节码看并发编程的底层实现",tabindex:"-1"},[a("第19讲：动手实践：从字节码看并发编程的底层实现 "),s("a",{class:"header-anchor",href:"#第19讲-动手实践-从字节码看并发编程的底层实现","aria-label":'Permalink to "第19讲：动手实践：从字节码看并发编程的底层实现"'},"​")],-1),E=s("p",null,"本课时我们主要分享一个实践案例：从字节码看并发编程的底层实现。",-1),d=s("br",null,null,-1),y=s("p",null,[a("我们在上一课时中简单学习了 JMM 的概念，知道了 Java 语言中一些默认的 "),s("strong",null,"happens-before"),a(" 规则，是靠内存屏障完成的。其中的 lock 和 unlock 两个 Action，就属于粒度最大的两个操作。")],-1),h=s("br",null,null,-1),u=s("p",null,"如下图所示，Java 中的多线程，第一类是 Thread 类。它有三种实现方式：第 1 种是通过继承 Thread 覆盖它的 run 方法；第 2 种是通过 Runnable 接口，实现它的 run 方法；而第 3 种是通过创建线程，就是通过线程池的方法去创建。",-1),_=s("br",null,null,-1),g=s("p",null,"多线程除了增加任务的执行速度，同样也有共享变量的同步问题。传统的线程同步方式，是使用 synchronized 关键字，或者 wait、notify 方法等，比如我们在第 15 课时中所介绍的，使用 jstack 命令可以观测到各种线程的状态。在目前的并发编程中，使用 concurrent 包里的工具更多一些。",-1),m=s("h1",{id:"线程模型",tabindex:"-1"},[a("线程模型 "),s("a",{class:"header-anchor",href:"#线程模型","aria-label":'Permalink to "线程模型"'},"​")],-1),b=s("p",null,"我们首先来看一下 JVM 的线程模型，以及它和操作系统进程之间的关系。",-1),v=s("br",null,null,-1),A=s("p",null,"如下图所示，对于 Hotspot 来说，每一个 Java 线程，都会映射到一条轻量级进程中（LWP，Light Weight Process）。轻量级进程是用户进程调用系统内核所提供的一套接口，实际上它还需要调用更加底层的内核线程（KLT，Kernel-Level Thread）。而具体的功能，比如创建、同步等，则需要进行系统调用。",-1),k=s("br",null,null,-1),C=s("br",null,null,-1),q=s("p",null,"这些系统调用的操作，代价都比较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换，也就是我们常说的线程上下文切换（ CS，Context Switch）。",-1),S=s("br",null,null,-1),T=s("p",null,"使用 vmstat 命令能够方便地观测到这个数值。",-1),x=s("br",null,null,-1),f=p("",33),V=p("",20),P=p("",19),z=p("",25),I=s("h1",{id:"小结",tabindex:"-1"},[a("小结 "),s("a",{class:"header-anchor",href:"#小结","aria-label":'Permalink to "小结"'},"​")],-1),J=s("p",null,'在本课时中，我们首先介绍了多线程的一些特点，然后熟悉了 Java 中的线程和它在操作系统中的一些表现形式；还了解了，线程上下文切换会严重影响系统的性能，所以 Java 的锁有基于硬件 CAS 自旋，也有基于比较轻量级的"轻量级锁"和"偏向锁"。',-1),M=s("p",null,"它们的目标是，在不改变编程模型的基础上，尽量提高系统的性能，进行更加高效的并发。",-1);function D(L,j,U,B,N,O){const n=o("Image");return t(),c("div",null,[i,E,d,y,h,u,_,g,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/CgpOIF5rUqGAMw7CAAJBHmU3oAY993.png"}),a(),m,b,v,A,k,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/CgpOIF5rUqGAJD0XAAJAeRaqnSA136.png"}),a(),C,q,S,T,x,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/Cgq2xl5rUqGADk6pAACEUa3DGeg786.jpg"}),a(),f,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/Cgq2xl5rUqKAJFTnAAI9mtaTDHU336.png"}),a(),V,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/Cgq2xl5rUqKAcN6XAAE1DZEldew335.png"}),a(),P,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/Cgq2xl5rUqKAIU9yAADdhmjBFTA260.png"}),a(),z,l(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/74/1A/Cgq2xl5rUqOAEUCoAAF0aEOpX50905.png"}),a(),I,J,M])}const w=e(r,[["render",D]]);export{F as __pageData,w as default};
