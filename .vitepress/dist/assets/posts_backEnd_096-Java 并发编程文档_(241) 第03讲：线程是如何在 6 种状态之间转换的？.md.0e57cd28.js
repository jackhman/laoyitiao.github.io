import{_ as l,j as o,o as s,g as c,k as a,Q as e,s as t,h as n}from"./chunks/framework.e0c66c3f.js";const H=JSON.parse('{"title":"线程的 6 种状态 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(241) 第03讲：线程是如何在 6 种状态之间转换的？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(241) 第03讲：线程是如何在 6 种状态之间转换的？.md","lastUpdated":1696338709000}'),_={name:"posts/backEnd/096-Java 并发编程文档/(241) 第03讲：线程是如何在 6 种状态之间转换的？.md"},d=e('<p>本课时我们主要学习线程是如何在 6 种状态之间转换的。</p><h6 id="线程的-6-种状态" tabindex="-1">线程的 6 种状态 <a class="header-anchor" href="#线程的-6-种状态" aria-label="Permalink to &quot;线程的 6 种状态&quot;">​</a></h6><p>就像生物从出生到长大、最终死亡的过程一样，线程也有自己的生命周期，在 Java 中线程的生命周期中一共有 6 种状态。</p><ol><li>New（新创建）</li><li>Runnable（可运行）</li><li>Blocked（被阻塞）</li><li>Waiting（等待）</li><li>Timed Waiting（计时等待）</li><li>Terminated（被终止）</li></ol><p>如果想要确定线程当前的状态，可以通过 getState() 方法，并且线程在任何时刻只可能处于 1 种状态。</p><h6 id="new-新创建" tabindex="-1">New 新创建 <a class="header-anchor" href="#new-新创建" aria-label="Permalink to &quot;New 新创建&quot;">​</a></h6><p>下面我们逐个介绍线程的 6 种状态，如图所示，首先来看下左上角的 New 状态。</p>',7),r=t("p",null,"New 表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable，也就是状态转换图中中间的这个大方框里的内容。",-1),h=t("h6",{id:"runnable-可运行",tabindex:"-1"},[n("Runnable 可运行 "),t("a",{class:"header-anchor",href:"#runnable-可运行","aria-label":'Permalink to "Runnable 可运行"'},"​")],-1),p=t("p",null,"Java 中的 Runable 状态对应操作系统线程状态中的两种状态，分别是 Running 和 Ready，也就是说，Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。",-1),g=t("p",null,"所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。",-1),u=t("h6",{id:"阻塞状态",tabindex:"-1"},[n("阻塞状态 "),t("a",{class:"header-anchor",href:"#阻塞状态","aria-label":'Permalink to "阻塞状态"'},"​")],-1),m=t("p",null,"接下来，我们来看下 Runnable 下面的三个方框，它们统称为阻塞状态，在 Java 中阻塞状态通常不仅仅是 Blocked，实际上它包括三种状态，分别是 Blocked(被阻塞）、Waiting(等待）、Timed Waiting(计时等待），这三 种状态统称为阻塞状态，下面我们来看看这三种状态具体是什么含义。",-1),k=t("h6",{id:"blocked-被阻塞",tabindex:"-1"},[n("Blocked 被阻塞 "),t("a",{class:"header-anchor",href:"#blocked-被阻塞","aria-label":'Permalink to "Blocked 被阻塞"'},"​")],-1),b=t("p",null,"首先来看最简单的 Blocked，从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。",-1),A=t("p",null,"我们再往右看，当处于 Blocked 的线程抢到 monitor 锁，就会从 Blocked 状态回到Runnable 状态。",-1),f=t("h6",{id:"waiting-等待",tabindex:"-1"},[n("Waiting 等待 "),t("a",{class:"header-anchor",href:"#waiting-等待","aria-label":'Permalink to "Waiting 等待"'},"​")],-1),T=t("p",null,"我们再看看 Waiting 状态，线程进入 Waiting 状态有三种可能性。",-1),R=t("ol",null,[t("li",null,"没有设置 Timeout 参数的 Object.wait() 方法。"),t("li",null,"没有设置 Timeout 参数的 Thread.join() 方法。"),t("li",null,"LockSupport.park() 方法。")],-1),W=t("p",null,"刚才强调过，Blocked 仅仅针对 synchronized monitor 锁，可是在 Java 中还有很多其他的锁，比如 ReentrantLock，如果线程在获取这种锁时没有抢到该锁就会进入 Waiting 状态，因为本质上它执行了 LockSupport.park() 方法，所以会进入 Waiting 状态。同样，Object.wait() 和 Thread.join() 也会让线程进入 Waiting 状态。",-1),B=t("p",null,"Blocked 与 Waiting 的区别是 Blocked 在等待其他线程释放 monitor 锁，而 Waiting 则是在等待某个条件，比如 join 的线程执行完毕，或者是 notify()/notifyAll() 。",-1),C=t("h6",{id:"timed-waiting-限期等待",tabindex:"-1"},[n("Timed Waiting 限期等待 "),t("a",{class:"header-anchor",href:"#timed-waiting-限期等待","aria-label":'Permalink to "Timed Waiting 限期等待"'},"​")],-1),w=t("p",null,"在 Waiting 上面是 Timed Waiting 状态，这两个状态是非常相似的，区别仅在于有没有时间限制，Timed Waiting 会等待超时，由系统自动唤醒，或者在超时前被唤醒信号唤醒。",-1),q=t("br",null,null,-1),N=t("br",null,null,-1),y=t("p",null,"以下情况会让线程进入 Timed Waiting 状态。",-1),P=t("ol",null,[t("li",null,"设置了时间参数的 Thread.sleep(long millis) 方法；"),t("li",null,"设置了时间参数的 Object.wait(long timeout) 方法；"),t("li",null,"设置了时间参数的 Thread.join(long millis) 方法；"),t("li",null,"设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。")],-1),D=t("p",null,"讲完如何进入这三种状态，我们再来看下如何从这三种状态流转到下一个状态。",-1),S=t("p",null,"想要从 Blocked 状态进入 Runnable 状态，要求线程获取 monitor 锁，而从 Waiting 状态流转到其他状态则比较特殊，因为首先 Waiting 是不限时的，也就是说无论过了多长时间它都不会主动恢复。",-1),x=t("p",null,"只有当执行了 LockSupport.unpark()，或者 join 的线程运行结束，或者被中断时才可以进入 Runnable 状态。",-1),Q=t("p",null,"如果其他线程调用 notify() 或 notifyAll()来唤醒它，它会直接进入 Blocked 状态，这是为什么呢？因为唤醒 Waiting 线程的线程如果调用 notify() 或 notifyAll()，要求必须首先持有该 monitor 锁，所以处于 Waiting 状态的线程被唤醒时拿不到该锁，就会进入 Blocked 状态，直到执行了 notify()/notifyAll() 的唤醒它的线程执行完毕并释放 monitor 锁，才可能轮到它去抢夺这把锁，如果它能抢到，就会从 Blocked 状态回到 Runnable 状态。",-1),M=t("p",null,"同样在 Timed Waiting 中执行 notify() 和 notifyAll() 也是一样的道理，它们会先进入 Blocked 状态，然后抢夺锁成功后，再回到 Runnable 状态。",-1),F=t("p",null,"当然对于 Timed Waiting 而言，如果它的超时时间到了且能直接获取到锁/join的线程运行结束/被中断/调用了LockSupport.unpark()，会直接恢复到 Runnable 状态，而无需经历 Blocked 状态。",-1),j=t("h6",{id:"terminated-终止",tabindex:"-1"},[n("Terminated 终止 "),t("a",{class:"header-anchor",href:"#terminated-终止","aria-label":'Permalink to "Terminated 终止"'},"​")],-1),v=e('<p>再来看看最后一种状态，Terminated 终止状态，要想进入这个状态有两种可能。</p><ul><li>run() 方法执行完毕，线程正常退出。</li><li>出现一个没有捕获的异常，终止了 run() 方法，最终导致意外终止。</li></ul><h6 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h6><p>最后我们再看线程转换的两个注意点。</p><ol><li>线程的状态是需要按照箭头方向来走的，比如线程从 New 状态是不可以直接进入 Blocked 状态的，它需要先经历 Runnable 状态。</li><li>线程生命周期不可逆：一旦进入 Runnable 状态就不能回到 New 状态；一旦被终止就不可能再有任何状态的变化。所以一个线程只能有一次 New 和 Terminated 状态，只有处于中间状态才可以相互转换。</li></ol><p>好了，本课时的内容就全部讲完了，下一课时我将讲解&quot;wait()/notify()/notifyAll() 的使用注意事项&quot;记得按时来听课啊，下一课时见。</p>',6);function J(L,E,V,z,I,O){const i=o("Image");return s(),c("div",null,[d,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_QfyaAFXAQAAD1xkYN7RE683.png"}),r,h,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png"}),p,g,u,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_QfzOAYoshAAD34kLRebs212.png"}),m,k,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/2F/CgqCHl_QfzmAT3mBAAD1O9cjB1Q393.png"}),b,A,f,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qfz6AROaIAAD0oNZDdx0700.png"}),T,R,W,B,C,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/2F/CgqCHl_Qf0aASbDHAAD1VJbPv8c632.png"}),w,q,N,y,P,D,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qf02ALx3yAAD1Zwrli6c436.png"}),S,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qf1SABGoMAAD08byRpJo570.png"}),x,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qf1qAWZ18AAD0WYzP5nY511.png"}),Q,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/2F/CgqCHl_Qf1-AWhOjAAD1EwUX7NE880.png"}),M,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qf2SAdJKAAAD1noNKR4M217.png"}),F,j,a(i,{alt:"",src:"https://s0.lgstatic.com/i/image/M00/80/2F/CgqCHl_Qf2qAPdCTAAD1YUKiI1s598.png"}),v])}const Y=l(_,[["render",J]]);export{H as __pageData,Y as default};
