import{_ as p,j as e,o,h as t,k as n,f as a,Q as l,s as r}from"./chunks/framework.d3daa342.js";const A=JSON.parse('{"title":"21PeritenceContext所表达的核心概念是什么？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Spring Data JPA 原理与实战_文档/(4721) 21  Peritence Context 所表达的核心概念是什么？.md","filePath":"posts/backEnd/Spring Data JPA 原理与实战_文档/(4721) 21  Peritence Context 所表达的核心概念是什么？.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/Spring Data JPA 原理与实战_文档/(4721) 21  Peritence Context 所表达的核心概念是什么？.md"},y=l(`<h1 id="_21peritencecontext所表达的核心概念是什么" tabindex="-1">21PeritenceContext所表达的核心概念是什么？ <a class="header-anchor" href="#_21peritencecontext所表达的核心概念是什么" aria-label="Permalink to &quot;21PeritenceContext所表达的核心概念是什么？&quot;">​</a></h1><p>你好，欢迎学习第 21 讲。上一讲我们介绍了 Hibernate 和 JPA 在 Spring Boot 里面的配置项相关内容，那么这一讲其实是对前一讲内容的延续，我们再介绍一下 Hibernate 和 JPA 的一个核心概念 Persistence Context。</p><p>这个概念是 JPA 入门者，或者初中级开发人员最容易用错的一部分内容，今天我们就来弄清楚它的来龙去脉，分析原理及用法，帮你更好地掌握，以便熟练运用。我们先从了解核心概念入手。</p><h3 id="persistence-context-相关的核心概念有哪些" tabindex="-1">Persistence Context 相关的核心概念有哪些？ <a class="header-anchor" href="#persistence-context-相关的核心概念有哪些" aria-label="Permalink to &quot;Persistence Context 相关的核心概念有哪些？&quot;">​</a></h3><h4 id="entitymanagerfactory-和-persistence-unit-是什么" tabindex="-1">EntityManagerFactory 和 Persistence Unit 是什么？ <a class="header-anchor" href="#entitymanagerfactory-和-persistence-unit-是什么" aria-label="Permalink to &quot;EntityManagerFactory 和 Persistence Unit 是什么？&quot;">​</a></h4><p>按照 JPA 协议里面的定义：persistence unit 是一些持久化配置的集合，里面包含了数据源的配置、EntityManagerFactory 的配置，spring 3.1 之前主要是通过 persistence.xml 的方式来配置一个 persistence unit。</p><p>而 spring 3.1 之后已经不再推荐这种方式了，但是还保留了 persistence unit 的概念，我们只需要在配置 LocalContainerEntityManagerFactory 的时候，指定 persistence unit 的名字即可，正如我在&quot;<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=490#/detail/pc?id=4718" target="_blank" rel="noreferrer">18 | 生产环境多数据源的处理方法有哪些？</a>&quot;中讲解多数据的时候一样。</p><p>请看下面代码，我们直接指定 persistenceUnit 的 name 即可。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Bean</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;db2EntityManagerFactory&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> LocalContainerEntityManagerFactoryBean </span><span style="color:#B392F0;">entityManagerFactory</span><span style="color:#E1E4E8;">(EntityManagerFactoryBuilder builder, @</span><span style="color:#F97583;">Qualifier</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;db2DataSource&quot;</span><span style="color:#E1E4E8;">) DataSource db2DataSource) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> builder.</span><span style="color:#B392F0;">dataSource</span><span style="color:#E1E4E8;">(db2DataSource)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">packages</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;com.example.jpa.example1.db2&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//数据2的实体所在的路径</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">persistenceUnit</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;db2&quot;</span><span style="color:#E1E4E8;">)</span><span style="color:#6A737D;">// persistenceUnit的名字采用db2</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Bean</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;db2EntityManagerFactory&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> LocalContainerEntityManagerFactoryBean </span><span style="color:#6F42C1;">entityManagerFactory</span><span style="color:#24292E;">(EntityManagerFactoryBuilder builder, @</span><span style="color:#D73A49;">Qualifier</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;db2DataSource&quot;</span><span style="color:#24292E;">) DataSource db2DataSource) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> builder.</span><span style="color:#6F42C1;">dataSource</span><span style="color:#24292E;">(db2DataSource)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">packages</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;com.example.jpa.example1.db2&quot;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//数据2的实体所在的路径</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">persistenceUnit</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;db2&quot;</span><span style="color:#24292E;">)</span><span style="color:#6A737D;">// persistenceUnit的名字采用db2</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div><p>EntityManagerFactory 的用途就比较明显了，即根据不同的数据源，来管理 Entity 和创建 EntityManger，在整个 application 的生命周期中是单例状态。所以在 spring 的 application 里面获得 EntityManagerFactory 有两种方式。</p><p><strong>第一种：通过 Spring 的 Bean 的方式注入。</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Autowired</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Qualifier</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;db2EntityManagerFactory&quot;</span><span style="color:#E1E4E8;">) </span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> EntityManagerFactory entityManagerFactory;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Autowired</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Qualifier</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">value</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;db2EntityManagerFactory&quot;</span><span style="color:#24292E;">) </span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> EntityManagerFactory entityManagerFactory;</span></span></code></pre></div><p>这种方式是我比较推荐的，它利用了 Spring 自身的 Bean 的管理机制。</p><p><strong>第二种：利用 java.persistence.PersistenceUnit 注解的方式获取。</strong></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">PersistenceUnit</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;db2&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> EntityManagerFactory entityManagerFactory;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">PersistenceUnit</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;db2&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> EntityManagerFactory entityManagerFactory;</span></span></code></pre></div><h4 id="entitymanager-和-persistencecontext-是什么" tabindex="-1">EntityManager 和 PersistenceContext 是什么？ <a class="header-anchor" href="#entitymanager-和-persistencecontext-是什么" aria-label="Permalink to &quot;EntityManager 和 PersistenceContext 是什么？&quot;">​</a></h4><p>按照 JPA 协议的规范，我们先理解一下 PersistenceContext，它是用来管理会话里面的 Entity 状态的一个上下文环境，使 Entity 的实例有了不同的状态，也就是我们所说的实体实例的生命周期。</p><p>而这些实体在 PersistenceContext 中的不同状态都是通过 EntityManager 提供的一些方法进行管理的，也就是说：</p><ol><li><p>PersistenceContext 是持久化上下文，是 JPA 协议定义的，而 Hibernate 的实现是通过 Session 创建和销毁的，也就是说一个 Session 有且仅有一个 PersistenceContext；</p></li><li><p>PersistenceContext 既然是持久化上下文，里面管理的是 Entity 的状态；</p></li><li><p>EntityManager 是通过 PersistenceContext 创建的，用来管理 PersistenceContext 中 Entity 状态的方法，离开 PersistenceContext 持久化上下文，EntityManager 没有意义；</p></li><li><p>EntityManger 是操作对象的唯一入口，一个请求里面可能会有多个 EntityManger 对象。</p></li></ol><p>下面我们看一下 PersistenceContext 是怎么创建的。直接打开 SessionImpl 的构造方法，就可以知道 PersistenceContext 是和 Session 的生命周期绑定的，关键代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//session实例初始化的入口</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">SessionImpl</span><span style="color:#E1E4E8;">(SessionFactoryImpl factory, SessionCreationOptions options) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">super</span><span style="color:#E1E4E8;">( factory, options );</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#6A737D;">//Session里面创建了persistenceContext，每次session都是新对象</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.persistenceContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createPersistenceContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">......省略一些不重要的代码   </span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> StatefulPersistenceContext </span><span style="color:#B392F0;">createPersistenceContext</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">StatefulPersistenceContext</span><span style="color:#E1E4E8;">( </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;"> );</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#6A737D;">//StatefulPersistenceContext就是PersistenceContext的实现类</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">class</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">StatefulPersistenceContext</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">implements</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">PersistenceContext</span><span style="color:#E1E4E8;"> {......}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//session实例初始化的入口</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">SessionImpl</span><span style="color:#24292E;">(SessionFactoryImpl factory, SessionCreationOptions options) {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#005CC5;">super</span><span style="color:#24292E;">( factory, options );</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6A737D;">//Session里面创建了persistenceContext，每次session都是新对象</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.persistenceContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createPersistenceContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">......省略一些不重要的代码   </span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> StatefulPersistenceContext </span><span style="color:#6F42C1;">createPersistenceContext</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">StatefulPersistenceContext</span><span style="color:#24292E;">( </span><span style="color:#005CC5;">this</span><span style="color:#24292E;"> );</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#6A737D;">//StatefulPersistenceContext就是PersistenceContext的实现类</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">class</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">StatefulPersistenceContext</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">implements</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">PersistenceContext</span><span style="color:#24292E;"> {......}</span></span></code></pre></div><p>我们通过上面的讲述，知道了 PersistenceContext 的创建和销毁机制，那么 EntityManger 如何获得呢？需要通过 @PersistenceContext 的方式进行获取，代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">PersistenceContext</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> EntityManager em;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">PersistenceContext</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> EntityManager em;</span></span></code></pre></div><p>而其中 @PersistenceContext 的属性配置有如下这些。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> @</span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">PersistenceContext</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">name</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//PersistenceContextUnit的名字，多数据源的时候有用</span></span>
<span class="line"><span style="color:#E1E4E8;">    String </span><span style="color:#B392F0;">unitName</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//是指创建的EntityManager的生命周期是存在事务内还是可以跨事务，默认为生命周期和事务一样；</span></span>
<span class="line"><span style="color:#E1E4E8;">    PersistenceContextType </span><span style="color:#B392F0;">type</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> PersistenceContextType.TRANSACTION;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//同步的类型：只有SYNCHRONIZED和UNSYNCHRONIZED两个值用来表示，但开启事务的时候是否自动加入已开启的事务里面，默认SYNCHRONIZED表示自动加入，不创建新的事务。而UNSYNCHRONIZED表示，不自动加入上下文已经有的事务，自动开启新的事务；这里你使用的时候需要注意看一下事务的日志；</span></span>
<span class="line"><span style="color:#E1E4E8;">    SynchronizationType </span><span style="color:#B392F0;">synchronization</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> SynchronizationType.SYNCHRONIZED;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//持久化的配置属性，这里指我们上一课时讲过的hibernate中AvailableSettings里面的值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">PersistenceProperty</span><span style="color:#E1E4E8;">[] </span><span style="color:#B392F0;">properties</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> {};</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> @</span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">PersistenceContext</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">name</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//PersistenceContextUnit的名字，多数据源的时候有用</span></span>
<span class="line"><span style="color:#24292E;">    String </span><span style="color:#6F42C1;">unitName</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//是指创建的EntityManager的生命周期是存在事务内还是可以跨事务，默认为生命周期和事务一样；</span></span>
<span class="line"><span style="color:#24292E;">    PersistenceContextType </span><span style="color:#6F42C1;">type</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> PersistenceContextType.TRANSACTION;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//同步的类型：只有SYNCHRONIZED和UNSYNCHRONIZED两个值用来表示，但开启事务的时候是否自动加入已开启的事务里面，默认SYNCHRONIZED表示自动加入，不创建新的事务。而UNSYNCHRONIZED表示，不自动加入上下文已经有的事务，自动开启新的事务；这里你使用的时候需要注意看一下事务的日志；</span></span>
<span class="line"><span style="color:#24292E;">    SynchronizationType </span><span style="color:#6F42C1;">synchronization</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> SynchronizationType.SYNCHRONIZED;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//持久化的配置属性，这里指我们上一课时讲过的hibernate中AvailableSettings里面的值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">PersistenceProperty</span><span style="color:#24292E;">[] </span><span style="color:#6F42C1;">properties</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> {};</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>一般情况下保持默认即可，你也可以根据实际情况自由组合，我再举个复杂点的例子。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">PersistenceContext</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#79B8FF;">unitName</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;db2&quot;</span><span style="color:#E1E4E8;">,</span><span style="color:#6A737D;">//采用数据源2的</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#6A737D;">//可以跨事务的EntityManager</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#79B8FF;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> PersistenceContextType.EXTENDED,</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#79B8FF;">properties</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">//通过properties改变一下自动flush的机制</span></span>
<span class="line"><span style="color:#E1E4E8;">            @</span><span style="color:#F97583;">PersistenceProperty</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#79B8FF;">name</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;org.hibernate.flushMode&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">                  </span><span style="color:#79B8FF;">value</span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MANUAL&quot;</span><span style="color:#6A737D;">//改成手动刷新方式</span></span>
<span class="line"><span style="color:#E1E4E8;">            )</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> EntityManager entityManager;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">PersistenceContext</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">unitName</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;db2&quot;</span><span style="color:#24292E;">,</span><span style="color:#6A737D;">//采用数据源2的</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6A737D;">//可以跨事务的EntityManager</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">type</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> PersistenceContextType.EXTENDED,</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#005CC5;">properties</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">//通过properties改变一下自动flush的机制</span></span>
<span class="line"><span style="color:#24292E;">            @</span><span style="color:#D73A49;">PersistenceProperty</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#005CC5;">name</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;org.hibernate.flushMode&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">                  </span><span style="color:#005CC5;">value</span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MANUAL&quot;</span><span style="color:#6A737D;">//改成手动刷新方式</span></span>
<span class="line"><span style="color:#24292E;">            )</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> EntityManager entityManager;</span></span></code></pre></div><p>以上就是 Persistence Context 的相关基础概念。其中，实体的生命周期指的是什么呢？我们来了解一下。</p><h3 id="实体对象的生命周期" tabindex="-1">实体对象的生命周期 <a class="header-anchor" href="#实体对象的生命周期" aria-label="Permalink to &quot;实体对象的生命周期&quot;">​</a></h3><p>既然 PersistenceContext 是存储 Entity 的，那么 Entity 在 PersistenceContext 里面肯定有不同的状态。对此，JPA 协议定义了四种状态：new、manager、detached、removed。我们通过一个图来整体认识一下。</p>`,30),E=l(`<p>注：图片来自网络</p><h4 id="第一种-new-状态的对象" tabindex="-1">第一种：New 状态的对象 <a class="header-anchor" href="#第一种-new-状态的对象" aria-label="Permalink to &quot;第一种：New 状态的对象&quot;">​</a></h4><p>当我们使用关键字 new 的时候创建的实体对象，称为 new 状态的 Entity 对象。它需要同时满足两个条件：new 状态的实体 Id 和 Version 字段都是 null；new 状态的实体没有在 PersistenceContext 中出现过。</p><p>那么如果我们要把 new 状态的 Entity 放到 PersistenceContext 里面，有两种方法：执行 entityManager.persist(entity) 方法；通过关联关系的实体关系配置 cascade=PERSIST or cascade=ALL 这种类型，并且关联关系的一方，也执行了 entityManager.persist(entity) 方法。</p><p>我们使用一个案例来说明一下。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testPersist</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserInfo.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时不在</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertFalse</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//通过persist方法把对象放到PersistenceContext里面</span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时在</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertTrue</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertNotNull</span><span style="color:#E1E4E8;">(userInfo.</span><span style="color:#B392F0;">getId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testPersist</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserInfo.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时不在</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertFalse</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通过persist方法把对象放到PersistenceContext里面</span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时在</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertTrue</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertNotNull</span><span style="color:#24292E;">(userInfo.</span><span style="color:#6F42C1;">getId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这就是 new 状态的实体对象，我们再来看一下和它类似的 Deteched 状态的对象。</p><h4 id="第二种-detached-游离-的实体对象" tabindex="-1">第二种：Detached（游离）的实体对象 <a class="header-anchor" href="#第二种-detached-游离-的实体对象" aria-label="Permalink to &quot;第二种：Detached（游离）的实体对象&quot;">​</a></h4><p>Detached 状态的对象表示和 PersistenceContext 脱离关系的 Entity 对象。它和 new 状态的对象的不同点在于：</p><ul><li><p>Detached 是 new 状态的实体对象没有持久化 ID（即没有 ID 和 version）；</p></li><li><p>变成持久化对象需要进行 merger 操作，merger 操作会 copy 一个新的实体对象，然后把新的实体对象变成 Manager 状态。</p></li></ul><p>而 Detached 和 new 状态的对象相同点也有两个方面：</p><ul><li><p>都和 PersistenceContext 脱离了关系；</p></li><li><p>当执行 flush 操作或者 commit 操作的时候，不会进行数据库同步。</p></li></ul><p>如果想让 Manager(persist) 状态的对象从 PersistenceContext 里面游离出来变成 Detached 的状态，可以通过 EntityManager 的 Detach 方法实现，如下面这行代码。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">entityManager.</span><span style="color:#B392F0;">detach</span><span style="color:#E1E4E8;">(entity);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">entityManager.</span><span style="color:#6F42C1;">detach</span><span style="color:#24292E;">(entity);</span></span></code></pre></div><p>当执行完 entityManager.clear()、entityManager.close()，或者事务 commit()、事务 rollback() 之后，所有曾经在 PersistenceContext 里面的实体都会变成 Detached 状态。</p><p>而游离状态的对象想回到 PersistenceContext 里面变成 manager 状态的话，只能执行 entityManager 的 merge 方法，也就是下面这行代码。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">entityManager.</span><span style="color:#B392F0;">merge</span><span style="color:#E1E4E8;">(entity);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">entityManager.</span><span style="color:#6F42C1;">merge</span><span style="color:#24292E;">(entity);</span></span></code></pre></div><p>游离状态的实体执行 EntityManager 中 persist 方法的时候就会报异常，我们举个例子：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testMergeException</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//通过new的方式构建一个游离状态的对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserInfo.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">id</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1L</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">lastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">version</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//验证是否存在于persistence context 里面，new的肯定不存在</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertFalse</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//当执行persist方法的时候就会报异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertThrows</span><span style="color:#E1E4E8;">(PersistentObjectException.class,()</span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;">entityManager.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//detached状态的实体通过merge的方式保存在了persistence context里面</span></span>
<span class="line"><span style="color:#E1E4E8;">   UserInfo user2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> entityManager.</span><span style="color:#B392F0;">merge</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//验证一下存在于持久化上下文里面</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertTrue</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(user2));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testMergeException</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//通过new的方式构建一个游离状态的对象</span></span>
<span class="line"><span style="color:#24292E;">    UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserInfo.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">id</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1L</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">lastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">version</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//验证是否存在于persistence context 里面，new的肯定不存在</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertFalse</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//当执行persist方法的时候就会报异常</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertThrows</span><span style="color:#24292E;">(PersistentObjectException.class,()</span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;">entityManager.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//detached状态的实体通过merge的方式保存在了persistence context里面</span></span>
<span class="line"><span style="color:#24292E;">   UserInfo user2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> entityManager.</span><span style="color:#6F42C1;">merge</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//验证一下存在于持久化上下文里面</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertTrue</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(user2));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>以上就是 new 和 Detached 状态的实体对象，我们再来看第三种------Manager 状态的实体又是什么样的呢？</p><h4 id="第三种-manager-persist-状态的实体" tabindex="-1">第三种：Manager（persist） 状态的实体 <a class="header-anchor" href="#第三种-manager-persist-状态的实体" aria-label="Permalink to &quot;第三种：Manager（persist） 状态的实体&quot;">​</a></h4><p>Manager 状态的实体，顾名思义，是指在 PersistenceContext 里面管理的实体，而此种状态的实体当我们执行事务的 commit()，或者 entityManager 的 flush 方法的时候，就会进行数据库的同步操作。可以说是和数据库的数据有映射关系。</p><p>New 状态如果要变成 Manager 的状态，需要执行 persist 方法；而 Detached 状态的实体如果想变成 Manager 的状态，则需要执行 merge 方法。在 session 的生命周期中，任何从数据库里面查询到的 Entity 都会自动成为 Manager 的状态，如 entityManager.findById(id)、entityManager.getReference 等方法。</p><p>而 Manager 状态的 Entity 要同步到数据库里面，必须执行 EntityManager 里面的 flush 方法。也就是说我们对 Entity 对象做的任何增删改查，必须通过 entityManager.flush() 执行之后才会变成 SQL 同步到 DB 里面。什么意思呢？我们看个例子。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Rollback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testManagerException</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserInfo.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;没有执行 flush()方法，产生insert sql&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;执行了flush()方法，产生了insert sql&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    Assertions.</span><span style="color:#B392F0;">assertTrue</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Rollback</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testManagerException</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserInfo.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;没有执行 flush()方法，产生insert sql&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;执行了flush()方法，产生了insert sql&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    Assertions.</span><span style="color:#6F42C1;">assertTrue</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>执行完之后，我们可以看到如下输出：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">没有执行 </span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生insert sql</span></span>
<span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> insert into </span><span style="color:#B392F0;">user_info</span><span style="color:#E1E4E8;"> (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) </span><span style="color:#B392F0;">values</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">执行了</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生了insert sql</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">没有执行 </span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生insert sql</span></span>
<span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> insert into </span><span style="color:#6F42C1;">user_info</span><span style="color:#24292E;"> (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) </span><span style="color:#6F42C1;">values</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">执行了</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生了insert sql</span></span></code></pre></div><p>那么这个时候你可能会问了，并没有看到我们在之前写的 Repository 例子里面手动执行过任何 flush() 操作呀，那么请你带着这个问题继续往下看。了解下实体的第四个状态：Removed。</p><h4 id="第四种-removed-的实体状态" tabindex="-1">第四种：Removed 的实体状态 <a class="header-anchor" href="#第四种-removed-的实体状态" aria-label="Permalink to &quot;第四种：Removed 的实体状态&quot;">​</a></h4><p>Removed 的状态，顾名思义就是指删除了的实体，但是此实体还在 PersistenceContext 里面，只是在其中表示为 Removed 的状态，它和 Detached 状态的实体最主要的区别就是不在 PersistenceContext 里面，但都有 ID 属性。</p><p>而 Removed 状态的实体，当我们执行 entityManager.flush() 方法的时候，就会生成一条 delete 语句到数据库里面。Removed 状态的实体，在执行 flush() 方法之前，执行 entityManger.persist(removedEntity) 方法时候，就会去掉删除的表示，变成 Managed 的状态实例。我们还是看个例子。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testDelete</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserInfo.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;执行了flush()方法，产生了insert sql&quot;</span><span style="color:#E1E4E8;">);           </span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">    entityManager.</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;执行了flush()方法之后，又产生了delete sql&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testDelete</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserInfo.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;执行了flush()方法，产生了insert sql&quot;</span><span style="color:#24292E;">);           </span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">    entityManager.</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;执行了flush()方法之后，又产生了delete sql&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>执行完之后可以看到如下日志：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> insert into </span><span style="color:#B392F0;">user_info</span><span style="color:#E1E4E8;"> (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) </span><span style="color:#B392F0;">values</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">执行了</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生了insert sql</span></span>
<span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> delete from user_info where id</span><span style="color:#F97583;">=?</span><span style="color:#E1E4E8;"> and version</span><span style="color:#F97583;">=?</span></span>
<span class="line"><span style="color:#E1E4E8;">执行了</span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法之后，又产生了delete sql</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> insert into </span><span style="color:#6F42C1;">user_info</span><span style="color:#24292E;"> (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) </span><span style="color:#6F42C1;">values</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">执行了</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生了insert sql</span></span>
<span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> delete from user_info where id</span><span style="color:#D73A49;">=?</span><span style="color:#24292E;"> and version</span><span style="color:#D73A49;">=?</span></span>
<span class="line"><span style="color:#24292E;">执行了</span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法之后，又产生了delete sql</span></span></code></pre></div><p>到这里四种实体对象的状态就介绍完了，通过上面的详细解释，你知道了 Entity 的不同状态的时机是什么样的、不同状态直接的转化方式是什么样的，并且知道实体状态的任何变化都是在 Persistence Context 中进行的，和数据一点关系没有。</p><p>这仅仅是 JPA 和 Hibernate 为了提高方法执行的性能而设计的缓存实体机制，也是 JPA 和 MyBatis 的主要区别之处。</p><p>MyBatis 是对数据库的操作所见即所得的模式；而使用 JPA，你的任何操作都不会产生 DB 的sql。那么什么时间才能进行 DB 的 sql 操作呢？我们看一下 flush 的实现机制。</p><h3 id="解密-entitymanager-的-flush-方法" tabindex="-1">解密 EntityManager 的 flush() 方法 <a class="header-anchor" href="#解密-entitymanager-的-flush-方法" aria-label="Permalink to &quot;解密 EntityManager 的 flush() 方法&quot;">​</a></h3><p>flush 方法的用法很简单，就是我们在需要 DB 同步 sql 执行的时候，执行 entityManager.flush() 即可，它的作用如下所示。</p><h4 id="flush-的作用" tabindex="-1">Flush 的作用 <a class="header-anchor" href="#flush-的作用" aria-label="Permalink to &quot;Flush 的作用&quot;">​</a></h4><p>flush 重要的、唯一的作用，就是将 Persistence Context 中变化的实体转化成 sql 语句，同步执行到数据库里面。换句话来说，如果我们不执行 flush() 方法的话，通过 EntityManager 操作的任何 Entity 过程都不会同步到数据库里面。</p><p>而 flush() 方法很多时候不需要我们手动操作，这里我直接通过 entityManager 操作 flush() 方法，仅仅是为了向你演示执行过程。实际工作中很少会这样操作，而是会直接利用 JPA 和 Hibernate 底层框架帮我们实现的自动 flush 的机制。</p><h4 id="flush-的机制是什么" tabindex="-1">Flush 的机制是什么？ <a class="header-anchor" href="#flush-的机制是什么" aria-label="Permalink to &quot;Flush 的机制是什么？&quot;">​</a></h4><p>JPA 协议规定了 EntityManager 可以通过如下方法修改 FlushMode。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//entity manager 里面提供的修改FlushMode的方法</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">setFlushMode</span><span style="color:#E1E4E8;">(FlushModeType flushMode);</span></span>
<span class="line"><span style="color:#6A737D;">//FlushModeType只有两个值，自动和事务提交之前</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">enum</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FlushModeType</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//事务commit之前</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">COMMIT</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">//自动规则，默认</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#79B8FF;">AUTO</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//entity manager 里面提供的修改FlushMode的方法</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">setFlushMode</span><span style="color:#24292E;">(FlushModeType flushMode);</span></span>
<span class="line"><span style="color:#6A737D;">//FlushModeType只有两个值，自动和事务提交之前</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">enum</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FlushModeType</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//事务commit之前</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#005CC5;">COMMIT</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">//自动规则，默认</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#005CC5;">AUTO</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>而 Hiberbernate 还提供了一种手动触发的机制，可以通过如下代码的方式进行修改。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">PersistenceContext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">properties</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {@</span><span style="color:#F97583;">PersistenceProperty</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">name</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;org.hibernate.flushMode&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#79B8FF;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;MANUAL&quot;</span><span style="color:#6A737D;">//手动flush</span></span>
<span class="line"><span style="color:#E1E4E8;">)})</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> EntityManager entityManager;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">PersistenceContext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">properties</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {@</span><span style="color:#D73A49;">PersistenceProperty</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">name</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;org.hibernate.flushMode&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#005CC5;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;MANUAL&quot;</span><span style="color:#6A737D;">//手动flush</span></span>
<span class="line"><span style="color:#24292E;">)})</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> EntityManager entityManager;</span></span></code></pre></div><p>手动和 commit 的时候很好理解，就是手动执行 flush 方法，像我们案例中的写法一样；事务就是代码在执行事务 commit 的时候，必须要执行 flush() 方法，否则怎么将 PersistenceContext 中变化了的对象同步到数据库里面呢？下面我重点说一下 flush 的自动机制。</p><p><strong>Flush 的自动机制</strong></p><p>默认情况下，JPA 和 Hibernate 都是采用的 AUTO 的 Flush 机制，自动触发的规则如下：</p><ol><li><p>事务 commit 之前，即指执行 transactionManager.commit() 之前都会触发，这个很好理解；</p></li><li><p>执行任何的 JPQL 或者 native SQL（代替直接操作 Entity 的方法）都会触发 flush。这句话怎么理解呢？我们举个例子。</p></li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testPersist</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserInfo.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时不在</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assertions.</span><span style="color:#B392F0;">assertFalse</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//通过persist方法把对象放到PersistenceContext里面</span></span>
<span class="line"><span style="color:#E1E4E8;">        entityManager.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(userInfo);</span><span style="color:#6A737D;">//是直接操作Entity的，不会触发flush操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//entityManager.remove(userInfo);//是直接操作Entity的，不会触发flush操作</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;没有执行 flush()方法，产生insert sql&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        UserInfo userInfo2 </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> entityManager.</span><span style="color:#B392F0;">find</span><span style="color:#E1E4E8;">(UserInfo.class,</span><span style="color:#79B8FF;">2L</span><span style="color:#E1E4E8;">);</span><span style="color:#6A737D;">//是直接操作Entity的，这个就不会触发flush操作</span></span>
<span class="line"><span style="color:#6A737D;">//        userInfoRepository.queryByFlushTest();//是操作JPQL的，这个就会先触发flush操作；</span></span>
<span class="line"><span style="color:#E1E4E8;">        System.out.</span><span style="color:#B392F0;">println</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;flush()方法，产生insert sql&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时在</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assertions.</span><span style="color:#B392F0;">assertTrue</span><span style="color:#E1E4E8;">(entityManager.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(userInfo));</span></span>
<span class="line"><span style="color:#E1E4E8;">        Assertions.</span><span style="color:#B392F0;">assertNotNull</span><span style="color:#E1E4E8;">(userInfo.</span><span style="color:#B392F0;">getId</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testPersist</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserInfo.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时不在</span></span>
<span class="line"><span style="color:#24292E;">        Assertions.</span><span style="color:#6F42C1;">assertFalse</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//通过persist方法把对象放到PersistenceContext里面</span></span>
<span class="line"><span style="color:#24292E;">        entityManager.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(userInfo);</span><span style="color:#6A737D;">//是直接操作Entity的，不会触发flush操作</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//entityManager.remove(userInfo);//是直接操作Entity的，不会触发flush操作</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;没有执行 flush()方法，产生insert sql&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        UserInfo userInfo2 </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> entityManager.</span><span style="color:#6F42C1;">find</span><span style="color:#24292E;">(UserInfo.class,</span><span style="color:#005CC5;">2L</span><span style="color:#24292E;">);</span><span style="color:#6A737D;">//是直接操作Entity的，这个就不会触发flush操作</span></span>
<span class="line"><span style="color:#6A737D;">//        userInfoRepository.queryByFlushTest();//是操作JPQL的，这个就会先触发flush操作；</span></span>
<span class="line"><span style="color:#24292E;">        System.out.</span><span style="color:#6F42C1;">println</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;flush()方法，产生insert sql&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">//通过contains方法可以验证对象是否在PersistenceContext里面，此时在</span></span>
<span class="line"><span style="color:#24292E;">        Assertions.</span><span style="color:#6F42C1;">assertTrue</span><span style="color:#24292E;">(entityManager.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(userInfo));</span></span>
<span class="line"><span style="color:#24292E;">        Assertions.</span><span style="color:#6F42C1;">assertNotNull</span><span style="color:#24292E;">(userInfo.</span><span style="color:#6F42C1;">getId</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div><p>而只有执行类似 .queryByFlushTest() 这个方法的时候，才会触发 flush，因为它是用的 JPQL 的机制执行的。</p><p>上面的方法触发了 flush 的日志，会输出如下格式，你可以看到这里多了一个 insert 语句。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">没有执行 </span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生insert sql</span></span>
<span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> insert into </span><span style="color:#B392F0;">user_info</span><span style="color:#E1E4E8;"> (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) </span><span style="color:#B392F0;">values</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> select userinfo0_.id as id1_0_, userinfo0_.create_time as create_t2_0_, userinfo0_.create_user_id as create_u3_0_, userinfo0_.last_modified_time as last_mod4_0_, userinfo0_.last_modified_user_id as last_mod5_0_, userinfo0_.version as version6_0_, userinfo0_.ages as ages7_0_, userinfo0_.email_address as email_ad8_0_, userinfo0_.last_name as last_nam9_0_, userinfo0_.telephone as telepho10_0_ from user_info userinfo0_ where userinfo0_.id</span><span style="color:#F97583;">=</span><span style="color:#79B8FF;">2</span></span>
<span class="line"><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生insert sql</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">没有执行 </span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生insert sql</span></span>
<span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> insert into </span><span style="color:#6F42C1;">user_info</span><span style="color:#24292E;"> (create_time, create_user_id, last_modified_time, last_modified_user_id, version, ages, email_address, last_name, telephone, id) </span><span style="color:#6F42C1;">values</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">?</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> select userinfo0_.id as id1_0_, userinfo0_.create_time as create_t2_0_, userinfo0_.create_user_id as create_u3_0_, userinfo0_.last_modified_time as last_mod4_0_, userinfo0_.last_modified_user_id as last_mod5_0_, userinfo0_.version as version6_0_, userinfo0_.ages as ages7_0_, userinfo0_.email_address as email_ad8_0_, userinfo0_.last_name as last_nam9_0_, userinfo0_.telephone as telepho10_0_ from user_info userinfo0_ where userinfo0_.id</span><span style="color:#D73A49;">=</span><span style="color:#005CC5;">2</span></span>
<span class="line"><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生insert sql</span></span></code></pre></div><p>没有触发 flush 的日志输出的是如下格式，其中没有 insert 语句。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">没有执行 </span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生insert sql</span></span>
<span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> select userinfo0_.id as id1_0_0_, userinfo0_.create_time as create_t2_0_0_, userinfo0_.create_user_id as create_u3_0_0_, userinfo0_.last_modified_time as last_mod4_0_0_, userinfo0_.last_modified_user_id as last_mod5_0_0_, userinfo0_.version as version6_0_0_, userinfo0_.ages as ages7_0_0_, userinfo0_.email_address as email_ad8_0_0_, userinfo0_.last_name as last_nam9_0_0_, userinfo0_.telephone as telepho10_0_0_ from user_info userinfo0_ where userinfo0_.id</span><span style="color:#F97583;">=?</span></span>
<span class="line"><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">()方法，产生insert sql</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">没有执行 </span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生insert sql</span></span>
<span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> select userinfo0_.id as id1_0_0_, userinfo0_.create_time as create_t2_0_0_, userinfo0_.create_user_id as create_u3_0_0_, userinfo0_.last_modified_time as last_mod4_0_0_, userinfo0_.last_modified_user_id as last_mod5_0_0_, userinfo0_.version as version6_0_0_, userinfo0_.ages as ages7_0_0_, userinfo0_.email_address as email_ad8_0_0_, userinfo0_.last_name as last_nam9_0_0_, userinfo0_.telephone as telepho10_0_0_ from user_info userinfo0_ where userinfo0_.id</span><span style="color:#D73A49;">=?</span></span>
<span class="line"><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">()方法，产生insert sql</span></span></code></pre></div><p>我们了解完了 flush 的自动触发机制还不够，因为 flush 的自动刷新机制还会改变 update、insert、delete 的执行顺序。</p><h4 id="flush-的时候会改变-sql-的执行顺序" tabindex="-1">Flush 的时候会改变 SQL 的执行顺序 <a class="header-anchor" href="#flush-的时候会改变-sql-的执行顺序" aria-label="Permalink to &quot;Flush 的时候会改变 SQL 的执行顺序&quot;">​</a></h4><p>flush() 方法调用之后，同一个事务内，sql 的执行顺序会变成如下模式：insert 的先执行、delete 的第二个执行、update 的第三个执行。我们举个例子，方法如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">entityManager.</span><span style="color:#B392F0;">remove</span><span style="color:#E1E4E8;">(u3);</span></span>
<span class="line"><span style="color:#E1E4E8;">UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> UserInfo.</span><span style="color:#B392F0;">builder</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">lastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack&quot;</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">build</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">entityManager.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(userInfo);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">entityManager.</span><span style="color:#6F42C1;">remove</span><span style="color:#24292E;">(u3);</span></span>
<span class="line"><span style="color:#24292E;">UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> UserInfo.</span><span style="color:#6F42C1;">builder</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">lastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack&quot;</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">build</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">entityManager.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(userInfo);</span></span></code></pre></div><p>看一下执行的 sql 会变成如下模样，即先 insert 后 delete。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> insert into user_info 。。。。。。</span></span>
<span class="line"><span style="color:#E1E4E8;">Hibernate</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> delete from user_info where id</span><span style="color:#F97583;">=?</span><span style="color:#E1E4E8;"> and version</span><span style="color:#F97583;">=?</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> insert into user_info 。。。。。。</span></span>
<span class="line"><span style="color:#24292E;">Hibernate</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> delete from user_info where id</span><span style="color:#D73A49;">=?</span><span style="color:#24292E;"> and version</span><span style="color:#D73A49;">=?</span></span></code></pre></div><p>这种会改变顺序的现象，主要是由 persistence context 的实体状态机制导致的，所以在 Hibernate 的环境中，顺序会变成如下的 ActionQueue 的模式：</p><ol><li><p><code>OrphanRemovalAction</code></p></li><li><p><code>EntityInsertAction</code>or<code>EntityIdentityInsertAction</code></p></li><li><p><code>EntityUpdateAction</code></p></li><li><p><code>CollectionRemoveAction</code></p></li><li><p><code>CollectionUpdateAction</code></p></li><li><p><code>CollectionRecreateAction</code></p></li><li><p><code>EntityDeleteAction</code></p></li></ol><p>flush 的作用你已经知道了，它会把 sql 同步执行到数据库里面。但是需要注意的是，虽然 sql 到数据库里面执行了，那么最终数据是不是持久化，是不是被其他事务看到还会受到控制呢？Flush 与事务 Commit 的关系如何？</p><h4 id="flush-与事务-commit-的关系" tabindex="-1">Flush 与事务 Commit 的关系 <a class="header-anchor" href="#flush-与事务-commit-的关系" aria-label="Permalink to &quot;Flush 与事务 Commit 的关系&quot;">​</a></h4><p>大概有以下几点：</p><ol><li><p>在当前的事务执行 commit 的时候，会触发 flush 方法；</p></li><li><p>在当前的事务执行完 commit 的时候，如果隔离级别是可重复读的话，flush 之后执行的 update、insert、delete 的操作，会被其他的新事务看到最新结果；</p></li><li><p>假设当前的事务是可重复读的，当我们手动执行 flush 方法之后，没有执行事务 commit 方法，那么其他事务是看不到最新值变化的，但是最新值变化对当前没有 commit 的事务是有效的；</p></li><li><p>如果执行了 flush 之后，当前事务发生了 rollback 操作，那么数据将会被回滚（数据库的机制）。</p></li></ol><p>以上介绍的都是 flush 的机制，那么 **Repository 里面的 saveAndFlush 有什么作用呢？</p><h4 id="saveandflush-和-save-的区别" tabindex="-1">saveAndFlush 和 save 的区别 <a class="header-anchor" href="#saveandflush-和-save-的区别" aria-label="Permalink to &quot;saveAndFlush 和 save 的区别&quot;">​</a></h4><p>细心的同学会发现 **Repository 里面有一个 saveAndFlush(entity); 的方法，我们通过查看可以发现如下内容：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">S extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> S </span><span style="color:#B392F0;">saveAndFlush</span><span style="color:#E1E4E8;">(S entity) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//执行了save方法之后，调用了flush()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">   S result </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(entity);</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#B392F0;">flush</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">S extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> S </span><span style="color:#6F42C1;">saveAndFlush</span><span style="color:#24292E;">(S entity) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">//执行了save方法之后，调用了flush()方法</span></span>
<span class="line"><span style="color:#24292E;">   S result </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(entity);</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#6F42C1;">flush</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>而另一个 **Repository 里面的 save 的方法，我们查看其源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//没有做flush操作，只是，执行了persist或者merge的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">S extends T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> S </span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(S entity) {</span></span>
<span class="line"><span style="color:#E1E4E8;">   </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (entityInformation.</span><span style="color:#B392F0;">isNew</span><span style="color:#E1E4E8;">(entity)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">      em.</span><span style="color:#B392F0;">persist</span><span style="color:#E1E4E8;">(entity);</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> entity;</span></span>
<span class="line"><span style="color:#E1E4E8;">   } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> em.</span><span style="color:#B392F0;">merge</span><span style="color:#E1E4E8;">(entity);</span></span>
<span class="line"><span style="color:#E1E4E8;">   }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//没有做flush操作，只是，执行了persist或者merge的操作</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">S extends T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> S </span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(S entity) {</span></span>
<span class="line"><span style="color:#24292E;">   </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (entityInformation.</span><span style="color:#6F42C1;">isNew</span><span style="color:#24292E;">(entity)) {</span></span>
<span class="line"><span style="color:#24292E;">      em.</span><span style="color:#6F42C1;">persist</span><span style="color:#24292E;">(entity);</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> entity;</span></span>
<span class="line"><span style="color:#24292E;">   } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> em.</span><span style="color:#6F42C1;">merge</span><span style="color:#24292E;">(entity);</span></span>
<span class="line"><span style="color:#24292E;">   }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>所以这个时候我们应该很清楚 Repository 里面提供的 saveAndFlush 和 save 的区别，有如下几点：</p><ol><li><p>saveAndFlush 执行完，再执行 flush，会刷新整个 PersistenceContext 里面的实体并进入到数据库里面，那么当我们频繁调用 saveAndFlush 就失去了 cache 的意义，这个时候就和执行 mybatis 的 saveOrUpdate 是一样的效果；</p></li><li><p>当多次调用相同的 save 方法的时候，最终 flush 执行只会产生一条 sql，在性能上会比 saveAndFlush 高一点；</p></li><li><p>不管是 saveAndFlush 还是 save，都受当前事务控制，事务在没有 commit 之前，都只会影响当前事务的操作；</p></li></ol><p>综上，两种本质的区别就是 flush 执行的时机不一样而已，对数据库中数据的事务一致性没有任何影响。然而有的时候，即使我们调用了 flush 的方法也是一条 sql 都没有，为什么呢？我们再来了解一个概念：Dirty。</p><h3 id="entity-的-dirty-判断逻辑及其作用" tabindex="-1">Entity 的 Dirty 判断逻辑及其作用 <a class="header-anchor" href="#entity-的-dirty-判断逻辑及其作用" aria-label="Permalink to &quot;Entity 的 Dirty 判断逻辑及其作用&quot;">​</a></h3><p>在 PersistenceContext 里面还有一个重要概念，就是当实体不是 Dirty 状态，也就是没有任何变化的时候，是不会进行任何 db 操作的。所以即使我们执行 flush 和 commit，实体没有变化，就没有必要执行，这也能大大减少数据库的压力。</p><p>下面通过一个例子，认识一下 Dirty 的效果。</p><h4 id="dirty-的效果的例子" tabindex="-1">Dirty 的效果的例子 <a class="header-anchor" href="#dirty-的效果的例子" aria-label="Permalink to &quot;Dirty 的效果的例子&quot;">​</a></h4><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">//我们假设数据库里面存在一条id=1的数据，我们不做任何改变执行save或者saveAndFlush，除了select之外，不会产生任何sql语句；</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Rollback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testDirty</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> userInfoRepository.</span><span style="color:#B392F0;">findById</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1L</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    userInfoRepository.</span><span style="color:#B392F0;">saveAndFlush</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">    userInfoRepository.</span><span style="color:#B392F0;">save</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">//我们假设数据库里面存在一条id=1的数据，我们不做任何改变执行save或者saveAndFlush，除了select之外，不会产生任何sql语句；</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Rollback</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testDirty</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> userInfoRepository.</span><span style="color:#6F42C1;">findById</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1L</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    userInfoRepository.</span><span style="color:#6F42C1;">saveAndFlush</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">    userInfoRepository.</span><span style="color:#6F42C1;">save</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>那么当我们尝试改变一下 userInfo 里面的值，当执行如下方法的时候就会产生 update 的 sql。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Test</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Transactional</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Rollback</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">value</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">testDirty</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    UserInfo userInfo </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> userInfoRepository.</span><span style="color:#B392F0;">findById</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1L</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    userInfo.</span><span style="color:#B392F0;">setLastName</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;jack_test_dirty&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    userInfoRepository.</span><span style="color:#B392F0;">saveAndFlush</span><span style="color:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Test</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Transactional</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Rollback</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">value</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">false</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">testDirty</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">    UserInfo userInfo </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> userInfoRepository.</span><span style="color:#6F42C1;">findById</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">1L</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    userInfo.</span><span style="color:#6F42C1;">setLastName</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;jack_test_dirty&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    userInfoRepository.</span><span style="color:#6F42C1;">saveAndFlush</span><span style="color:#24292E;">(userInfo);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>那么实体的 Dirty 判断过程是什么样的呢？我们通过源码来看一下。</p><h4 id="entity-判断-dirty-的过程" tabindex="-1">Entity 判断 Dirty 的过程 <a class="header-anchor" href="#entity-判断-dirty-的过程" aria-label="Permalink to &quot;Entity 判断 Dirty 的过程&quot;">​</a></h4><p>如果我们通过 debug 一步一步分析的话可以找到，DefaultFlushEntityEventListener 的源码里面 isUpdateNecessary 的关键方法如下所示：</p>`,88),i=r("p",null,"我们进一步 debug 看 dirtyCheck 的实现，可以看发现如下关键点，从而找出发生变化的 proerties。",-1),u=l('<p>我们再仔细看 persister.findDirty（values, loadedState, entity, session），可以看出来源码里面是通过一个字段一个字段比较的，所以可以知道 PsersistenceContext 中的前后两个 Entity 的哪些字段发生了变化。因此当我们执行完 save 之后，没有产生任何 sql（因为没有变化）。你知道了这个原理之后，就不用再为此&quot;大惊小怪&quot;了。</p><p>总结起来就是，在 flush 的时候，Hibernate 会一个个判断实体的前后对象中哪个属性发生变化了，如果没有发生变化，则不产生 update 的 sql 语句；只有变化才会才生 update sql，并且可以做到同一个事务里面的多次 update 合并，从而在一定程度上可以减轻 DB 的压力。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>这一讲我为你介绍了 PersistenceContext 的概念、EntityManager 的作用，以及 flush 操作是什么时机进行的，它和事务的关系如何。其中也夹杂了我多年来的经验分享，希望你可以从头到尾学下来。</p><p>如果你能完全理解这一讲的内容，那么对于 JPA 和 Hibernate 的核心原理你算是掌握一大半了，没掌握的同学的也不要紧，跟着我的操作，每一篇都仔细探究，你也会逐渐掌握这门技术的，加油吧！</p><p>下一课时我会为你介绍 PersistenceContext 的容器 Session 相关的概念，到时见。</p><blockquote><p>点击下方链接查看源码（不定时更新）<br><a href="https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa" target="_blank" rel="noreferrer">https://github.com/zhangzhenhuajack/spring-boot-guide/tree/master/spring-data/spring-data-jpa</a></p></blockquote>',7);function d(F,h,g,f,C,_){const s=e("Image");return o(),t("div",null,[y,n(s,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/70/03/CgqCHl-3m3OAPiQmAAB8FdvAFnE298.png"}),a(),E,n(s,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/70/03/CgqCHl-3m6uAEoT1AAEkZaYyxn8305.png"}),a(),i,n(s,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/6F/F8/Ciqc1F-3m7GAUkFiAAEtQI1J900876.png"}),a(),u])}const m=p(c,[["render",d]]);export{A as __pageData,m as default};
