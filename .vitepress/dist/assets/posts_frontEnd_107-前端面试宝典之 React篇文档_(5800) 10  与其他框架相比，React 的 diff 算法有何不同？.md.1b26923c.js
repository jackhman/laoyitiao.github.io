import{_ as o,D as p,o as e,g as r,J as l,h as a,Q as t,m as s}from"./chunks/framework.f67d7268.js";const M=JSON.parse('{"title":"10与其他框架相比，React的diff算法有何不同？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/frontEnd/107-前端面试宝典之 React篇文档/(5800) 10  与其他框架相比，React 的 diff 算法有何不同？.md","filePath":"posts/frontEnd/107-前端面试宝典之 React篇文档/(5800) 10  与其他框架相比，React 的 diff 算法有何不同？.md","lastUpdated":1696682708000}'),c={name:"posts/frontEnd/107-前端面试宝典之 React篇文档/(5800) 10  与其他框架相比，React 的 diff 算法有何不同？.md"},i=t('<h1 id="_10与其他框架相比-react的diff算法有何不同" tabindex="-1">10与其他框架相比，React的diff算法有何不同？ <a class="header-anchor" href="#_10与其他框架相比-react的diff算法有何不同" aria-label="Permalink to &quot;10与其他框架相比，React的diff算法有何不同？&quot;">​</a></h1><p>diff 算法通常被认为 React 的核心点，在面试中很受重视。之前，关于 diff 算法的问法仅仅停留在&quot;React 的 diff 算法的流程是什么&quot;。但近几年有所变化，问题开始变得多样了，一个比较常见的场景是对比其他框架进行阐述。这一讲我们来一起探讨下这个问题应该如何回答。</p><h3 id="破题" tabindex="-1">破题 <a class="header-anchor" href="#破题" aria-label="Permalink to &quot;破题&quot;">​</a></h3><p>这个题目虽然有对比，但本质上仍然是一道原理题。根据我们之前学习的方法论，原理题需要按照&quot;<strong>讲概念</strong> ，<strong>说用途</strong> ，<strong>理思路</strong> ，<strong>优缺点</strong> ，<strong>列一遍</strong>&quot;的思路来答题。</p><p>针对 React 而言，diff 算法是对<strong>知识深度的考核</strong> 。面试官考察的不仅仅是你会用就可以，更重要的是你在使用中有没有思考，对 diff 算法有没有透彻的理解，这是本题的第一道关卡。对于前端工程师而言，<strong>这是一道能够快速划分</strong> &quot;<strong>内功</strong> &quot;<strong>等级的常见题目。</strong></p><p>而题目中的&quot;其他框架&quot;，则是在考核你知识面的广度。所以你在回答的时候，务必采取&quot;先分类，后讲述&quot;的方式。切忌语无伦次，没有条理、没有区分度、一股脑地表达。而且，你的分类方式还向面试官透露了对知识点的理解度。</p><p>那讲到 React，不得不说的其他框架有两个。</p><ul><li><p>Vue，因为 React 与 Vue 是国内前端中的主流框架。</p></li><li><p>类 React 框架，又被称为 React-like 框架，通常是指 Preact、 inferno 等兼容 React API 的框架，它们与 React 设计相似、 使用相似。</p></li></ul><p>所以该讲我们就拿 Vue 和 Preact 与 React 的 diff 算法进行比较。</p><h3 id="承题" tabindex="-1">承题 <a class="header-anchor" href="#承题" aria-label="Permalink to &quot;承题&quot;">​</a></h3><p>到这里，我们就清楚了本讲考察的两个重点，可以梳理出这样的一个答题框架：</p><ol><li><p>就 React diff 算法完成&quot;讲概念，说用途，理思路，优缺点，列一遍&quot;的组合拳；</p></li><li><p>横向对比 React、React-like 框架及 Vue 的 diff 算法。</p></li></ol>',12),y=s("h3",{id:"入手",tabindex:"-1"},[a("入手 "),s("a",{class:"header-anchor",href:"#入手","aria-label":'Permalink to "入手"'},"​")],-1),d=s("h4",{id:"diff-算法",tabindex:"-1"},[a("Diff 算法 "),s("a",{class:"header-anchor",href:"#diff-算法","aria-label":'Permalink to "Diff 算法"'},"​")],-1),E=s("p",null,'首先主角当然是"diff 算法"，但讨论 diff 算法一定是建立在虚拟 DOM 的基础上的。第 09 讲"Virtual DOM 的工作原理是什么？"讲过，使用虚拟 DOM 而非直接操作真实 DOM 是现代前端框架的一个基本认知。',-1),g=s("p",null,"而 diff 算法探讨的就是虚拟 DOM 树发生变化后，生成 DOM 树更新补丁的方式。它通过对比新旧两株虚拟 DOM 树的变更差异，将更新补丁作用于真实 DOM，以最小成本完成视图更新。",-1),f=s("p",null,"具体的流程是这样的：",-1),u=s("ul",null,[s("li",null,[s("p",null,"真实 DOM 与虚拟 DOM 之间存在一个映射关系。这个映射关系依靠初始化时的 JSX 建立完成；")]),s("li",null,[s("p",null,"当虚拟 DOM 发生变化后，就会根据差距计算生成 patch，这个 patch 是一个结构化的数据，内容包含了增加、更新、移除等；")]),s("li",null,[s("p",null,"最后再根据 patch 去更新真实的 DOM，反馈到用户的界面上。")])],-1),_=t(`<p>举一个简单易懂的例子：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> React from &#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">export </span><span style="color:#FDAEB7;font-style:italic;">default</span><span style="color:#E1E4E8;"> </span><span style="color:#FDAEB7;font-style:italic;">class</span><span style="color:#E1E4E8;"> ExampleComponent </span><span style="color:#FDAEB7;font-style:italic;">extends</span><span style="color:#E1E4E8;"> React.Component {</span></span>
<span class="line"><span style="color:#E1E4E8;">  render() {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#FDAEB7;font-style:italic;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#FDAEB7;font-style:italic;">this</span><span style="color:#E1E4E8;">.props.isVisible) {</span></span>
<span class="line"><span style="color:#E1E4E8;">       </span><span style="color:#FDAEB7;font-style:italic;">return</span><span style="color:#E1E4E8;"> &lt;div className=&quot;visible&quot;&gt;visbile&lt;/div&gt;;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">     </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">div className</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;hidden&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">hidden</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">div</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">import</span><span style="color:#24292E;"> React from &#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">export </span><span style="color:#B31D28;font-style:italic;">default</span><span style="color:#24292E;"> </span><span style="color:#B31D28;font-style:italic;">class</span><span style="color:#24292E;"> ExampleComponent </span><span style="color:#B31D28;font-style:italic;">extends</span><span style="color:#24292E;"> React.Component {</span></span>
<span class="line"><span style="color:#24292E;">  render() {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#B31D28;font-style:italic;">if</span><span style="color:#24292E;">(</span><span style="color:#B31D28;font-style:italic;">this</span><span style="color:#24292E;">.props.isVisible) {</span></span>
<span class="line"><span style="color:#24292E;">       </span><span style="color:#B31D28;font-style:italic;">return</span><span style="color:#24292E;"> &lt;div className=&quot;visible&quot;&gt;visbile&lt;/div&gt;;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">     </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">div className</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;hidden&quot;</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">hidden</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">div</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里，首先我们假定 ExampleComponent 可见，然后再改变它的状态，让它不可见 。映射为真实的 DOM 操作是这样的，React 会创建一个 div 节点。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">div class</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;visible&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">visbile</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">div</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">div class</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;visible&quot;</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">visbile</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">div</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><p>当把 visbile 的值变为 false 时，就会替换 class 属性为 hidden，并重写内部的 innerText 为 hidden。这样一个<strong>生成补丁</strong> 、<strong>更新差异</strong>的过程统称为 diff 算法。</p><p>在整个过程中你需要注意 3 点：<strong>更新时机、遍历算法、优化策略</strong>，这些也是面试官最爱考察的。</p><p><strong>更新时机</strong></p><p>更新时机就是触发更新、进行差异对比的时机。根据前面的章节内容可以知道，更新发生在setState、Hooks 调用等操作以后。此时，树的结点发生变化，开始进行比对。那这里涉及一个问题，即两株树如何对比差异?</p><p>这里就需要使用遍历算法。</p><p><strong>遍历算法</strong></p><p>遍历算法是指沿着某条搜索路线，依次对树的每个节点做访问。通常分为两种：深度优先遍历和广度优先遍历。</p><ul><li><p>深度优先遍历，是从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点。</p></li><li><p>广度优先遍历，则是从根节点出发，在横向遍历二叉树层段节点的基础上，纵向遍历二叉树的层次。</p></li></ul><p>React 选择了哪一种遍历方式呢？它的 diff 算法采用了深度优先遍历算法。因为广度优先遍历可能会导致组件的生命周期时序错乱，而深度优先遍历算法就可以解决这个问题。</p><p><strong>优化策略</strong></p><p>优化策略是指 React 对 diff 算法做的优化手段。</p><p>虽然深度优先遍历保证了组件的生命周期时序不错乱，但传统的 diff 算法也带来了一个严重的性能瓶颈，复杂程度为 O(n^3)(后期备注上角标)，其中 n 表示树的节点总数。正如计算机科学中常见的优化方案一样，React 用了一个非常经典的手法将复杂度降低为 O(n)，也就是<a href="https://leetcode-cn.com/tag/divide-and-conquer/" target="_blank" rel="noreferrer">分治</a>，即通过&quot;分而治之&quot;这一巧妙的思想分解问题。</p><p>具体而言， React 分别从<strong>树</strong> 、<strong>组件</strong> 及<strong>元素</strong>三个层面进行复杂度的优化，并诞生了与之对应的策略。</p><p><strong>策略一</strong> ：<strong>忽略节点跨层级操作场景，提升比对效率</strong>。</p><p>这一策略需要进行<strong>树比对</strong>，即对树进行分层比较。树比对的处理手法是非常&quot;暴力&quot;的，即两棵树只对同一层次的节点进行比较，如果发现节点已经不存在了，则该节点及其子节点会被完全删除掉，不会用于进一步的比较，这就提升了比对效率。</p><p><strong>策略二</strong> ：<strong>如果组件的 class 一致</strong> ，<strong>则默认为相似的树结构</strong> ，<strong>否则默认为不同的树结构</strong>。</p><p>在组件比对的过程中：</p><ul><li><p>如果组件是同一类型则进行树比对；</p></li><li><p>如果不是则直接放入补丁中。</p></li></ul><p>只要父组件类型不同，就会被重新渲染。这也就是为什么</p><p>shouldComponentUpdate、PureComponent 及 React.memo 可以提高性能的原因。</p><p><strong>策略三：同一层级的子节点</strong> ，<strong>可以通过标记 key 的方式进行列表对比</strong>。</p><p>元素比对主要发生在同层级中，通过<strong>标记节点操作</strong>生成补丁。节点操作包含了插入、移动、删除等。其中节点重新排序同时涉及插入、移动、删除三个操作，所以效率消耗最大，此时策略三起到了至关重要的作用。</p><p>通过标记 key 的方式，React 可以直接移动 DOM 节点，降低内耗。操作代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ul</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">li key</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">a</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">li</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">li key</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">b</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">li</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">li key</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;c&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">c</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">li</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">li key</span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;">&quot;d&quot;</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;">d</span><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">li</span><span style="color:#F97583;">&gt;</span></span>
<span class="line"><span style="color:#F97583;">&lt;/</span><span style="color:#E1E4E8;">ui</span><span style="color:#F97583;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ul</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">li key</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">a</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">li</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">li key</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;b&quot;</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">b</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">li</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">li key</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;c&quot;</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">c</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">li</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">li key</span><span style="color:#D73A49;">=</span><span style="color:#032F62;">&quot;d&quot;</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;">d</span><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">li</span><span style="color:#D73A49;">&gt;</span></span>
<span class="line"><span style="color:#D73A49;">&lt;/</span><span style="color:#24292E;">ui</span><span style="color:#D73A49;">&gt;</span></span></code></pre></div><p>以上是 React Diff 算法最基本的内容，除此以外，由于 React 16 引入<strong>Fiber 设计</strong>，所以我们还需要了解 Fiber 给 diff 算法带来的影响。</p><p>Fiber 机制下节点与树分别采用 FiberNode 与 FiberTree 进行重构。FiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点，使得整个更新过程可以随时暂停恢复。FiberTree 则是通过 FiberNode 构成的树。</p><p>Fiber 机制下，整个更新过程由 current 与 workInProgress 两株树双缓冲完成。当 workInProgress 更新完成后，通过修改 current 相关指针指向的节点，直接抛弃老树，虽然非常简单粗暴，却非常合理。</p><p>这些就是 React 中 diff 算法的回答要点，我们再来看看其他框架需要掌握什么。</p><h4 id="其他框架" tabindex="-1">其他框架 <a class="header-anchor" href="#其他框架" aria-label="Permalink to &quot;其他框架&quot;">​</a></h4><p><strong>Preact</strong></p><p>在众多的 React-like 框架中，<strong>Preact 适用范围最广，生命力最强</strong>。它以仅 3kb 的小巧特点应用于对体积追求非常极致的场景。也正因为体积受限，Preact 在 diff 算法上做了裁剪。</p><p>以下 Preact 的 diff 算法的图示，可以看到它将 diff 分为了三个类型：Fragment、Component 及 DOM Node。</p>`,36),h=t('<ul><li><p>Fragment 对应 React 的树比较；</p></li><li><p>Component 对应组件比较，它们在原理上是相通的，所以这里我们不再赘述；</p></li><li><p>最大的不同在于 DOM Node 这一层，Preact 并没有 Patch 的过程，而是直接更新 DOM 节点属性。</p></li></ul><p><strong>Vue</strong></p><p>Vue 2.0 因为使用了 <a href="https://github.com/snabbdom/snabbdom/tree/8079ba78685b0f0e0e67891782c3e8fb9d54d5b8" target="_blank" rel="noreferrer">snabbdom</a>，所以整体思路与 React 相同。但在元素对比时，如果新旧两个元素是同一个元素，且没有设置 key 时，snabbdom 在 diff 子元素中会一次性对比<strong>旧节点</strong> 、<strong>新节点</strong> 及它们的<strong>首尾元素</strong> 四个节点，以及<strong>验证列表</strong>是否有变化。Vue 3.0 整体变化不大，依然没有引入 Fiber 等设计，也没有时间切片等功能。</p><h3 id="答题" tabindex="-1">答题 <a class="header-anchor" href="#答题" aria-label="Permalink to &quot;答题&quot;">​</a></h3><blockquote><p>在回答有何不同之前，首先需要说明下什么是 diff 算法。</p><p>diff 算法是指生成更新补丁的方式，主要应用于虚拟 DOM 树变化后，更新真实 DOM。所以 diff 算法一定存在这样一个过程：触发更新 → 生成补丁 → 应用补丁。</p><p>React 的 diff 算法，触发更新的时机主要在 state 变化与 hooks 调用之后。此时触发虚拟 DOM 树变更遍历，采用了深度优先遍历算法。但传统的遍历方式，效率较低。为了优化效率，使用了分治的方式。将单一节点比对转化为了 3 种类型节点的比对，分别是树、组件及元素，以此提升效率。</p><p>树比对：由于网页视图中较少有跨层级节点移动，两株虚拟 DOM 树只对同一层次的节点进行比较。</p><p>组件比对：如果组件是同一类型，则进行树比对，如果不是，则直接放入到补丁中。</p><p>元素比对：主要发生在同层级中，通过标记节点操作生成补丁，节点操作对应真实的 DOM 剪裁操作。</p><p>以上是经典的 React diff 算法内容。自 React 16 起，引入了 Fiber 架构。为了使整个更新过程可随时暂停恢复，节点与树分别采用了 FiberNode 与 FiberTree 进行重构。fiberNode 使用了双链表的结构，可以直接找到兄弟节点与子节点。</p><p>整个更新过程由 current 与 workInProgress 两株树双缓冲完成。workInProgress 更新完成后，再通过修改 current 相关指针指向新节点。</p><p>然后拿 Vue 和 Preact 与 React 的 diff 算法进行对比。</p><p>Preact 的 Diff 算法相较于 React，整体设计思路相似，但最底层的元素采用了真实 DOM 对比操作，也没有采用 Fiber 设计。Vue 的 Diff 算法整体也与 React 相似，同样未实现 Fiber 设计。</p><p>然后进行横向比较，React 拥有完整的 Diff 算法策略，且拥有随时中断更新的时间切片能力，在大批量节点更新的极端情况下，拥有更友好的交互体验。</p><p>Preact 可以在一些对性能要求不高，仅需要渲染框架的简单场景下应用。</p><p>Vue 的整体 diff 策略与 React 对齐，虽然缺乏时间切片能力，但这并不意味着 Vue 的性能更差，因为在 Vue 3 初期引入过，后期因为收益不高移除掉了。除了高帧率动画，在 Vue 中其他的场景几乎都可以使用防抖和节流去提高响应性能。</p></blockquote>',5),D=t('<p>这里需要注意的是：对比过程中切忌踩一捧一，容易引发面试官反感。</p><h3 id="进阶" tabindex="-1">进阶 <a class="header-anchor" href="#进阶" aria-label="Permalink to &quot;进阶&quot;">​</a></h3><p><strong>学习原理的目的就是应用。那如何根据 React diff 算法原理优化代码呢？</strong> 这个问题其实按优化方式逆向回答即可。</p><blockquote><p>根据 diff 算法的设计原则，应尽量避免跨层级节点移动。</p><p>通过设置唯一 key 进行优化，尽量减少组件层级深度。因为过深的层级会加深遍历深度，带来性能问题。</p><p>设置 shouldComponentUpdate 或者 React.pureComponet 减少 diff 次数。</p></blockquote><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>diff 算法一直在 React 中处于核心的位置，所以本讲讲到的内容，你一定要掌握。如果你有什么问题或者想法，欢迎留言与我互动。</p><p>在下一讲，我会为你讲述 React 的渲染流程，下节课见！</p><hr><p>[</p>',9),b=s("p",null,[a("]("),s("a",{href:"https://shenceyun.lagou.com/t/mka",target:"_blank",rel:"noreferrer"},"https://shenceyun.lagou.com/t/mka"),a(")")],-1),F=s("p",null,"《大前端高薪训练营》",-1),m=s("p",null,[a("对标阿里 P7 技术需求 + 每月大厂内推，6 个月助你斩获名企高薪 Offer。"),s("a",{href:"https://shenceyun.lagou.com/t/mka",target:"_blank",rel:"noreferrer"},"点击链接"),a("，快来领取！")],-1);function A(q,k,R,v,C,P){const n=p("Image");return e(),r("div",null,[i,l(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/8C/55/CgqCHl_qyoCARaC-AABHz3sJYwo329.png"}),a(),y,d,E,g,l(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/8C/55/CgqCHl_qyouAAkb9AAB_cmWuZhc920.png"}),a(),f,u,l(n,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/8C/55/CgqCHl_qypGAZPuGAADYrK9nkJY878.png"}),a(),_,l(n,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/8C/4A/Ciqc1F_qyqeAWvpYAAEVYxYrQis686.png"}),a(),h,l(n,{alt:"Diff 算法1.png",src:"https://s0.lgstatic.com/i/image2/M01/04/31/CgpVE1_q2zGAe9UzAACKAZViwbM237.png"}),a(),D,l(n,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/72/94/Ciqc1F_EZ0eANc6tAASyC72ZqWw643.png"}),a(),b,F,m])}const T=o(c,[["render",A]]);export{M as __pageData,T as default};
