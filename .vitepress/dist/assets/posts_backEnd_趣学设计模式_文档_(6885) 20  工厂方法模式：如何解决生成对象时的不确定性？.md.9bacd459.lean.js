import{_ as o,j as t,o as e,h as c,k as l,f as n,Q as p,s}from"./chunks/framework.d3daa342.js";const f=JSON.parse('{"title":"20工厂方法模式：如何解决生成对象时的不确定性？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/趣学设计模式_文档/(6885) 20  工厂方法模式：如何解决生成对象时的不确定性？.md","filePath":"posts/backEnd/趣学设计模式_文档/(6885) 20  工厂方法模式：如何解决生成对象时的不确定性？.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/趣学设计模式_文档/(6885) 20  工厂方法模式：如何解决生成对象时的不确定性？.md"},i=p("",9),E=p("",37),g=s("p",null,[n("这里尤其要注意的是，工厂方法模式和抽象工厂模式虽然都用于创建对象，但是两者的侧重点是完全不同的。"),s("strong",null,"工厂方法模式侧重于继承的连续性，而抽象工厂模式侧重于组合的扩展性"),n("，这就导致了工厂方法模式会更多去关注是否满足里氏替换原则，而抽象工厂模式很多时候是要寻找到更好的抽象产品，这期间很有可能是会违反里氏替换原则的。")],-1),y=s("h3",{id:"课后思考",tabindex:"-1"},[n("课后思考 "),s("a",{class:"header-anchor",href:"#课后思考","aria-label":'Permalink to "课后思考"'},"​")],-1),u=s("p",null,"在文中 LogFactory 的代码实现里，如果不使用静态加载来实现具体产品的初始化的话，要想实现接入更多日志组件的话，该如何实现呢？",-1),d=s("p",null,"欢迎留言分享，我会第一时间给你回复。",-1),m=s("p",null,'在下一讲，我会接着与你分享"原型模式：什么场景下需要用到对象拷贝？"这个话题，记得按时来听课！',-1);function h(_,b,L,v,I,q){const a=t("Image");return e(),c("div",null,[i,l(a,{alt:"image (4).png",src:"https://s0.lgstatic.com/i/image6/M00/40/38/CioPOWCjk6qAJLeiAADWU3qiKQg267.png"}),n(),E,l(a,{alt:"设计模式20--金句.png",src:"https://s0.lgstatic.com/i/image6/M00/40/2F/Cgp9HWCjk9yAAngzAAYesuPxHzg864.png"}),n(),g,y,u,d,m])}const C=o(r,[["render",h]]);export{f as __pageData,C as default};
