import{_ as s,o as n,g as a,Q as l}from"./chunks/framework.f949202b.js";const u=JSON.parse('{"title":"Cluster 接口与容错机制 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(5834) 37  集群容错：一个好汉三个帮（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(5834) 37  集群容错：一个好汉三个帮（上）.md","lastUpdated":null}'),p={name:"posts/backEnd/Dubbo源码解读与实战_文档/(5834) 37  集群容错：一个好汉三个帮（上）.md"},o=l(`<p>你好，我是杨四正，今天我和你分享的主题是集群容错：一个好汉三个帮（上篇）。</p><p>在前面的课时中，我们已经对 Directory、Router、LoadBalance 等概念进行了深入的剖析，本课时将重点分析 Cluster 接口的相关内容。</p><p><strong>Cluster 接口提供了我们常说的集群容错功能。</strong></p><p>集群中的单个节点有一定概率出现一些问题，例如，磁盘损坏、系统崩溃等，导致节点无法对外提供服务，因此在分布式 RPC 框架中，必须要重视这种情况。为了避免单点故障，我们的 Provider 通常至少会部署在两台服务器上，以集群的形式对外提供服务，对于一些负载比较高的服务，则需要部署更多 Provider 来抗住流量。</p><p>在 Dubbo 中，通过 Cluster 这个接口把一组可供调用的 Provider 信息组合成为一个统一的 Invoker 供调用方进行调用。经过 Router 过滤、LoadBalance 选址之后，选中一个具体 Provider 进行调用，<strong>如果调用失败，则会按照集群的容错策略进行容错处理</strong>。</p><p>Dubbo 默认内置了若干容错策略，并且每种容错策略都有自己独特的应用场景，我们可以<strong>通过配置选择不同的容错策略</strong> 。如果这些内置容错策略不能满足需求，我们还可以<strong>通过自定义容错策略进行配置</strong>。</p><p>了解了上述背景知识之后，下面我们就正式开始介绍 Cluster 接口。</p><h3 id="cluster-接口与容错机制" tabindex="-1">Cluster 接口与容错机制 <a class="header-anchor" href="#cluster-接口与容错机制" aria-label="Permalink to &quot;Cluster 接口与容错机制&quot;">​</a></h3><p>Cluster 的工作流程大致可以分为两步（如下图所示）：①<strong>创建 Cluster Invoker 实例</strong> （在 Consumer 初始化时，Cluster 实现类会创建一个 Cluster Invoker 实例，即下图中的 merge 操作）；②<strong>使用 Cluster Invoker 实例</strong>（在 Consumer 服务消费者发起远程调用请求的时候，Cluster Invoker 会依赖前面课时介绍的 Directory、Router、LoadBalance 等组件得到最终要调用的 Invoker 对象）。</p><p><img src="https://s0.lgstatic.com/i/image/M00/73/73/Ciqc1F_GAzqAFfi0AAEr0jR4WUk707.png" alt="Lark20201201-164714.png"><br> Cluster 核心流程图</p><p>Cluster Invoker 获取 Invoker 的流程大致可描述为如下：</p><ol><li><p>通过 Directory 获取 Invoker 列表，以 RegistryDirectory 为例，会感知注册中心的动态变化，实时获取当前 Provider 对应的 Invoker 集合；</p></li><li><p>调用 Router 的 route() 方法进行路由，过滤掉不符合路由规则的 Invoker 对象；</p></li><li><p>通过 LoadBalance 从 Invoker 列表中选择一个 Invoker；</p></li><li><p>ClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。</p></li></ol><p>这个过程是一个正常流程，没有涉及容错处理。Dubbo 中常见的容错方式有如下几个。</p><ul><li><p>Failover Cluster：失败自动切换。<strong>它是 Dubbo 的默认容错机制</strong>，在请求一个 Provider 节点失败的时候，自动切换其他 Provider 节点，默认执行 3 次，适合幂等操作。当然，重试次数越多，在故障容错的时候带给 Provider 的压力就越大，在极端情况下甚至可能造成雪崩式的问题。</p></li><li><p>Failback Cluster：失败自动恢复。失败后记录到队列中，通过定时器重试。</p></li><li><p>Failfast Cluster：快速失败。请求失败后返回异常，不进行任何重试。</p></li><li><p>Failsafe Cluster：失败安全。请求失败后忽略异常，不进行任何重试。</p></li><li><p>Forking Cluster：并行调用多个 Provider 节点，只要有一个成功就返回。</p></li><li><p>Broadcast Cluster：广播多个 Provider 节点，只要有一个节点失败就失败。</p></li><li><p>Available Cluster：遍历所有的 Provider 节点，找到每一个可用的节点，就直接调用。如果没有可用的 Provider 节点，则直接抛出异常。</p></li><li><p>Mergeable Cluster：请求多个 Provider 节点并将得到的结果进行合并。</p></li></ul><p>下面我们再来看 Cluster 接口。Cluster 接口是一个扩展接口，通过 @SPI 注解的参数我们知道其使用的默认实现是 FailoverCluster，它只定义了一个 join() 方法，在其上添加了 @Adaptive 注解，会动态生成适配器类，其中会优先根据 Directory.getUrl() 方法返回的 URL 中的 cluster 参数值选择扩展实现，若无 cluster 参数则使用默认的 FailoverCluster 实现。Cluster 接口的具体定义如下所示：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span><span style="color:#E1E4E8;">(FailoverCluster.NAME)</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Cluster</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    @</span><span style="color:#F97583;">Adaptive</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">(Directory&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">directory</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span><span style="color:#24292E;">(FailoverCluster.NAME)</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Cluster</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    @</span><span style="color:#D73A49;">Adaptive</span></span>
<span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">(Directory&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">directory</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Cluster 接口的实现类如下图所示，分别对应前面提到的多种容错策略：</p><p><img src="https://s0.lgstatic.com/i/image/M00/73/73/Ciqc1F_GA0WADFvhAAFaDfyWGXU780.png" alt="Lark20201201-164718.png"><br> Cluster 接口继承关系</p><p><strong>在每个 Cluster 接口实现中，都会创建对应的 Invoker 对象，这些都继承自 AbstractClusterInvoker 抽象类</strong>，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/73/7E/CgqCHl_GA0-AcVvrAAGLJ3YaO2Q177.png" alt="Lark20201201-164728.png"><br> AbstractClusterInvoker 继承关系图</p><p>通过上面两张继承关系图我们可以看出，Cluster 接口和 Invoker 接口都会有相应的抽象实现类，这些抽象实现类都实现了一些公共能力。下面我们就来深入介绍 AbstractClusterInvoker 和 AbstractCluster 这两个抽象类。</p><h3 id="abstractclusterinvoker" tabindex="-1">AbstractClusterInvoker <a class="header-anchor" href="#abstractclusterinvoker" aria-label="Permalink to &quot;AbstractClusterInvoker&quot;">​</a></h3><p>了解了 Cluster Invoker 的继承关系之后，我们首先来看 AbstractClusterInvoker，它有两点核心功能：一个是实现的 Invoker 接口，对 Invoker.invoke() 方法进行通用的抽象实现；另一个是实现通用的负载均衡算法。</p><p>在 AbstractClusterInvoker.invoke() 方法中，会通过 Directory 获取 Invoker 列表，然后通过 SPI 初始化 LoadBalance，最后调用 doInvoke() 方法执行子类的逻辑。在 Directory.list() 方法返回 Invoker 集合之前，已经使用 Router 进行了一次筛选，你可以回顾前面<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=393#/detail/pc?id=4277" target="_blank" rel="noreferrer">第 31 课时</a>对 RegistryDirectory 的分析。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测当前Invoker是否已销毁</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">checkWhetherDestroyed</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将RpcContext中的attachment添加到Invocation中</span></span>
<span class="line"><span style="color:#E1E4E8;">    Map&lt;</span><span style="color:#F97583;">String</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Object</span><span style="color:#E1E4E8;">&gt; contextAttachments </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getObjectAttachments</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (contextAttachments </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> contextAttachments.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ((RpcInvocation) invocation).</span><span style="color:#B392F0;">addObjectAttachments</span><span style="color:#E1E4E8;">(contextAttachments);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过Directory获取Invoker对象列表，通过对RegistryDirectory的介绍我们知道，其中已经调用了Router进行过滤</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;&gt; invokers </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">list</span><span style="color:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过SPI加载LoadBalance</span></span>
<span class="line"><span style="color:#E1E4E8;">    LoadBalance loadbalance </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">initLoadBalance</span><span style="color:#E1E4E8;">(invokers, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcUtils.</span><span style="color:#B392F0;">attachInvocationIdIfAsync</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用doInvoke()方法，该方法是个抽象方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doInvoke</span><span style="color:#E1E4E8;">(invocation, invokers, loadbalance);</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">list</span><span style="color:#E1E4E8;">(Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> directory.</span><span style="color:#B392F0;">list</span><span style="color:#E1E4E8;">(invocation); </span><span style="color:#6A737D;">// 调用Directory.list()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测当前Invoker是否已销毁</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">checkWhetherDestroyed</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将RpcContext中的attachment添加到Invocation中</span></span>
<span class="line"><span style="color:#24292E;">    Map&lt;</span><span style="color:#D73A49;">String</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Object</span><span style="color:#24292E;">&gt; contextAttachments </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getObjectAttachments</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (contextAttachments </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> contextAttachments.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        ((RpcInvocation) invocation).</span><span style="color:#6F42C1;">addObjectAttachments</span><span style="color:#24292E;">(contextAttachments);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过Directory获取Invoker对象列表，通过对RegistryDirectory的介绍我们知道，其中已经调用了Router进行过滤</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;&gt; invokers </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">list</span><span style="color:#24292E;">(invocation);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过SPI加载LoadBalance</span></span>
<span class="line"><span style="color:#24292E;">    LoadBalance loadbalance </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">initLoadBalance</span><span style="color:#24292E;">(invokers, invocation);</span></span>
<span class="line"><span style="color:#24292E;">    RpcUtils.</span><span style="color:#6F42C1;">attachInvocationIdIfAsync</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), invocation);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用doInvoke()方法，该方法是个抽象方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doInvoke</span><span style="color:#24292E;">(invocation, invokers, loadbalance);</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">list</span><span style="color:#24292E;">(Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> directory.</span><span style="color:#6F42C1;">list</span><span style="color:#24292E;">(invocation); </span><span style="color:#6A737D;">// 调用Directory.list()方法</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>下面我们来看一下 AbstractClusterInvoker 是如何按照不同的 LoadBalance 算法从 Invoker 集合中选取最终 Invoker 对象的。</p><p>AbstractClusterInvoker 并没有简单粗暴地使用 LoadBalance.select() 方法完成负载均衡，而是做了进一步的封装，具体实现在 select() 方法中。在 select() 方法中会根据配置决定是否开启粘滞连接特性，如果开启了，则需要将上次使用的 Invoker 缓存起来，只要 Provider 节点可用就直接调用，不会再进行负载均衡。如果调用失败，才会重新进行负载均衡，并且排除已经重试过的 Provider 节点。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 第一个参数是此次使用的LoadBalance实现，第二个参数Invocation是此次服务调用的上下文信息，</span></span>
<span class="line"><span style="color:#6A737D;">// 第三个参数是待选择的Invoker集合，第四个参数用来记录负载均衡已经选出来、尝试过的Invoker集合</span></span>
<span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(LoadBalance loadbalance, Invocation invocation, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> selected) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CollectionUtils.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(invokers)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取调用方法名</span></span>
<span class="line"><span style="color:#E1E4E8;">    String methodName </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invocation </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> StringUtils.EMPTY_STRING </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> invocation.</span><span style="color:#B392F0;">getMethodName</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取sticky配置，sticky表示粘滞连接，所谓粘滞连接是指Consumer会尽可能地</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用同一个Provider节点，除非这个Provider无法提供服务</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> sticky </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">).</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">getMethodParameter</span><span style="color:#E1E4E8;">(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测invokers列表是否包含sticky Invoker，如果不包含，</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 说明stickyInvoker代表的服务提供者挂了，此时需要将其置空</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (stickyInvoker </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">invokers.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(stickyInvoker)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        stickyInvoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果开启了粘滞连接特性，需要先判断这个Provider节点是否已经重试过了</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sticky </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> stickyInvoker </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// 表示粘滞连接</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> (selected </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">selected.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(stickyInvoker)) </span><span style="color:#6A737D;">// 表示stickyInvoker未重试过</span></span>
<span class="line"><span style="color:#E1E4E8;">    ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 检测当前stickyInvoker是否可用，如果可用，直接返回stickyInvoker</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (availablecheck </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> stickyInvoker.</span><span style="color:#B392F0;">isAvailable</span><span style="color:#E1E4E8;">()) { </span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> stickyInvoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 执行到这里，说明前面的stickyInvoker为空，或者不可用</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里会继续调用doSelect选择新的Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSelect</span><span style="color:#E1E4E8;">(loadbalance, invocation, invokers, selected);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (sticky) { </span><span style="color:#6A737D;">// 是否开启粘滞，更新stickyInvoker字段</span></span>
<span class="line"><span style="color:#E1E4E8;">        stickyInvoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 第一个参数是此次使用的LoadBalance实现，第二个参数Invocation是此次服务调用的上下文信息，</span></span>
<span class="line"><span style="color:#6A737D;">// 第三个参数是待选择的Invoker集合，第四个参数用来记录负载均衡已经选出来、尝试过的Invoker集合</span></span>
<span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(LoadBalance loadbalance, Invocation invocation, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> selected) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CollectionUtils.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(invokers)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取调用方法名</span></span>
<span class="line"><span style="color:#24292E;">    String methodName </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invocation </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> StringUtils.EMPTY_STRING </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> invocation.</span><span style="color:#6F42C1;">getMethodName</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取sticky配置，sticky表示粘滞连接，所谓粘滞连接是指Consumer会尽可能地</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用同一个Provider节点，除非这个Provider无法提供服务</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> sticky </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">).</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">getMethodParameter</span><span style="color:#24292E;">(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测invokers列表是否包含sticky Invoker，如果不包含，</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 说明stickyInvoker代表的服务提供者挂了，此时需要将其置空</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (stickyInvoker </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">invokers.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(stickyInvoker)) {</span></span>
<span class="line"><span style="color:#24292E;">        stickyInvoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果开启了粘滞连接特性，需要先判断这个Provider节点是否已经重试过了</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sticky </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> stickyInvoker </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// 表示粘滞连接</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> (selected </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">selected.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(stickyInvoker)) </span><span style="color:#6A737D;">// 表示stickyInvoker未重试过</span></span>
<span class="line"><span style="color:#24292E;">    ) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 检测当前stickyInvoker是否可用，如果可用，直接返回stickyInvoker</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (availablecheck </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> stickyInvoker.</span><span style="color:#6F42C1;">isAvailable</span><span style="color:#24292E;">()) { </span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> stickyInvoker;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 执行到这里，说明前面的stickyInvoker为空，或者不可用</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里会继续调用doSelect选择新的Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSelect</span><span style="color:#24292E;">(loadbalance, invocation, invokers, selected);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (sticky) { </span><span style="color:#6A737D;">// 是否开启粘滞，更新stickyInvoker字段</span></span>
<span class="line"><span style="color:#24292E;">        stickyInvoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invoker;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>doSelect() 方法主要做了两件事：</p><ul><li><p>一是通过 LoadBalance 选择 Invoker 对象；</p></li><li><p>二是如果选出来的 Invoker 不稳定或不可用，会调用 reselect() 方法进行重选。</p></li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">doSelect</span><span style="color:#E1E4E8;">(LoadBalance loadbalance, Invocation invocation,</span></span>
<span class="line"><span style="color:#E1E4E8;">                            List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> selected) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 判断是否需要进行负载均衡，Invoker集合为空，直接返回null</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CollectionUtils.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(invokers)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 只有一个Invoker对象，直接返回即可</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过LoadBalance实现选择Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> loadbalance.</span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(invokers, </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 如果LoadBalance选出的Invoker对象，已经尝试过请求了或不可用，则需要调用reselect()方法重选</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((selected </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> selected.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(invoker)) </span><span style="color:#6A737D;">// Invoker已经尝试调用过了，但是失败了</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">invoker.</span><span style="color:#B392F0;">isAvailable</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> availablecheck) </span><span style="color:#6A737D;">// Invoker不可用</span></span>
<span class="line"><span style="color:#E1E4E8;">    ) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 调用reselect()方法重选</span></span>
<span class="line"><span style="color:#E1E4E8;">            Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; rInvoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reselect</span><span style="color:#E1E4E8;">(loadbalance, invocation, invokers, selected, availablecheck);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 如果重选的Invoker对象不为空，则直接返回这个 rInvoker</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (rInvoker </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> rInvoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> index </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">indexOf</span><span style="color:#E1E4E8;">(invoker);</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#6A737D;">// 如果重选的Invoker对象为空，则返回该Invoker的下一个Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">                    invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">((index </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">%</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">                } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Exception </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    logger.</span><span style="color:#B392F0;">warn</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;...&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            logger.</span><span style="color:#B392F0;">error</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;...&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> invoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">doSelect</span><span style="color:#24292E;">(LoadBalance loadbalance, Invocation invocation,</span></span>
<span class="line"><span style="color:#24292E;">                            List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> selected) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 判断是否需要进行负载均衡，Invoker集合为空，直接返回null</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CollectionUtils.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(invokers)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 只有一个Invoker对象，直接返回即可</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过LoadBalance实现选择Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> loadbalance.</span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(invokers, </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), invocation);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 如果LoadBalance选出的Invoker对象，已经尝试过请求了或不可用，则需要调用reselect()方法重选</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((selected </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> selected.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(invoker)) </span><span style="color:#6A737D;">// Invoker已经尝试调用过了，但是失败了</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">invoker.</span><span style="color:#6F42C1;">isAvailable</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> availablecheck) </span><span style="color:#6A737D;">// Invoker不可用</span></span>
<span class="line"><span style="color:#24292E;">    ) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 调用reselect()方法重选</span></span>
<span class="line"><span style="color:#24292E;">            Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; rInvoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reselect</span><span style="color:#24292E;">(loadbalance, invocation, invokers, selected, availablecheck);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 如果重选的Invoker对象不为空，则直接返回这个 rInvoker</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (rInvoker </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> rInvoker;</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> index </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">indexOf</span><span style="color:#24292E;">(invoker);</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#6A737D;">// 如果重选的Invoker对象为空，则返回该Invoker的下一个Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">                    invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">((index </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">%</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">                } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Exception </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                    logger.</span><span style="color:#6F42C1;">warn</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;...&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            logger.</span><span style="color:#6F42C1;">error</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;...&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> invoker;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p><strong>reselect() 方法会重新进行一次负载均衡</strong>，首先对未尝试过的可用 Invokers 进行负载均衡，如果已经全部重试过了，则将尝试过的 Provider 节点过滤掉，然后在可用的 Provider 节点中重新进行负载均衡。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">reselect</span><span style="color:#E1E4E8;">(LoadBalance loadbalance, Invocation invocation,</span></span>
<span class="line"><span style="color:#E1E4E8;">                            List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> invokers, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> selected, </span><span style="color:#F97583;">boolean</span><span style="color:#E1E4E8;"> availablecheck) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 用于记录要重新进行负载均衡的Invoker集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;&gt; reselectInvokers </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> ArrayList&lt;&gt;(</span></span>
<span class="line"><span style="color:#E1E4E8;">            invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> (invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> invokers.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将不在selected集合中的Invoker过滤出来进行负载均衡</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; invoker </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> invokers) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (availablecheck </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">invoker.</span><span style="color:#B392F0;">isAvailable</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (selected </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">selected.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(invoker)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            reselectInvokers.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(invoker);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// reselectInvokers不为空时，才需要通过负载均衡组件进行选择</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">reselectInvokers.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> loadbalance.</span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(reselectInvokers, </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 只能对selected集合中可用的Invoker再次进行负载均衡</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (selected </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; invoker </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> selected) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> ((invoker.</span><span style="color:#B392F0;">isAvailable</span><span style="color:#E1E4E8;">()) </span><span style="color:#6A737D;">// available first</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">reselectInvokers.</span><span style="color:#B392F0;">contains</span><span style="color:#E1E4E8;">(invoker)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                reselectInvokers.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(invoker);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">reselectInvokers.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> loadbalance.</span><span style="color:#B392F0;">select</span><span style="color:#E1E4E8;">(reselectInvokers, </span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">reselect</span><span style="color:#24292E;">(LoadBalance loadbalance, Invocation invocation,</span></span>
<span class="line"><span style="color:#24292E;">                            List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> invokers, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> selected, </span><span style="color:#D73A49;">boolean</span><span style="color:#24292E;"> availablecheck) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 用于记录要重新进行负载均衡的Invoker集合</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;&gt; reselectInvokers </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> ArrayList&lt;&gt;(</span></span>
<span class="line"><span style="color:#24292E;">            invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> (invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> invokers.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将不在selected集合中的Invoker过滤出来进行负载均衡</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; invoker </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> invokers) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (availablecheck </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">invoker.</span><span style="color:#6F42C1;">isAvailable</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (selected </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">selected.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(invoker)) {</span></span>
<span class="line"><span style="color:#24292E;">            reselectInvokers.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(invoker);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// reselectInvokers不为空时，才需要通过负载均衡组件进行选择</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">reselectInvokers.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> loadbalance.</span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(reselectInvokers, </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), invocation);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 只能对selected集合中可用的Invoker再次进行负载均衡</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (selected </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; invoker </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> selected) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> ((invoker.</span><span style="color:#6F42C1;">isAvailable</span><span style="color:#24292E;">()) </span><span style="color:#6A737D;">// available first</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">!</span><span style="color:#24292E;">reselectInvokers.</span><span style="color:#6F42C1;">contains</span><span style="color:#24292E;">(invoker)) {</span></span>
<span class="line"><span style="color:#24292E;">                reselectInvokers.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(invoker);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">reselectInvokers.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> loadbalance.</span><span style="color:#6F42C1;">select</span><span style="color:#24292E;">(reselectInvokers, </span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), invocation);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="abstractcluster" tabindex="-1">AbstractCluster <a class="header-anchor" href="#abstractcluster" aria-label="Permalink to &quot;AbstractCluster&quot;">​</a></h3><p>常用的 ClusterInvoker 实现都继承了 AbstractClusterInvoker 类型，对应的 Cluster 扩展实现都继承了 AbstractCluster 抽象类。<strong>AbstractCluster 抽象类的核心逻辑是在 ClusterInvoker 外层包装一层 ClusterInterceptor，从而实现类似切面的效果</strong>。</p><p>下面是 ClusterInterceptor 接口的定义：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">SPI</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ClusterInterceptor</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 前置拦截方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">before</span><span style="color:#E1E4E8;">(AbstractClusterInvoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clusterInvoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 后置拦截方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">after</span><span style="color:#E1E4E8;">(AbstractClusterInvoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clusterInvoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用ClusterInvoker的invoke()方法完成请求</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">default</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">intercept</span><span style="color:#E1E4E8;">(AbstractClusterInvoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clusterInvoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> clusterInvoker.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这个Listener用来监听请求的正常结果以及异常</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">interface</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Listener</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onMessage</span><span style="color:#E1E4E8;">(Result </span><span style="color:#FFAB70;">appResponse</span><span style="color:#E1E4E8;">, AbstractClusterInvoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clusterInvoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(Throwable </span><span style="color:#FFAB70;">t</span><span style="color:#E1E4E8;">, AbstractClusterInvoker&lt;</span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#FFAB70;">clusterInvoker</span><span style="color:#E1E4E8;">, Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">SPI</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ClusterInterceptor</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 前置拦截方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">before</span><span style="color:#24292E;">(AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clusterInvoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 后置拦截方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">after</span><span style="color:#24292E;">(AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clusterInvoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用ClusterInvoker的invoke()方法完成请求</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">default</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">intercept</span><span style="color:#24292E;">(AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clusterInvoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> clusterInvoker.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(invocation);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这个Listener用来监听请求的正常结果以及异常</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">interface</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Listener</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onMessage</span><span style="color:#24292E;">(Result </span><span style="color:#E36209;">appResponse</span><span style="color:#24292E;">, AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clusterInvoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(Throwable </span><span style="color:#E36209;">t</span><span style="color:#24292E;">, AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">?</span><span style="color:#24292E;">&gt; </span><span style="color:#E36209;">clusterInvoker</span><span style="color:#24292E;">, Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>在 AbstractCluster 抽象类的 join() 方法中，首先会调用 doJoin() 方法获取最终要调用的 Invoker 对象，doJoin() 是个抽象方法，由 AbstractCluster 子类根据具体的策略进行实现。之后，AbstractCluster.join() 方法会调用 buildClusterInterceptors() 方法加载 ClusterInterceptor 扩展实现类，对 Invoker 对象进行包装。具体实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buildClusterInterceptors</span><span style="color:#E1E4E8;">(AbstractClusterInvoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> clusterInvoker, String key) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    AbstractClusterInvoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> clusterInvoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 通过SPI方式加载ClusterInterceptor扩展实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">ClusterInterceptor</span><span style="color:#E1E4E8;">&gt; interceptors </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ExtensionLoader.</span><span style="color:#B392F0;">getExtensionLoader</span><span style="color:#E1E4E8;">(ClusterInterceptor.class).</span><span style="color:#B392F0;">getActivateExtension</span><span style="color:#E1E4E8;">(clusterInvoker.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), key);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">interceptors.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> interceptors.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 将InterceptorInvokerNode收尾连接到一起，形成调用链</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> ClusterInterceptor interceptor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> interceptors.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> AbstractClusterInvoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> last;</span></span>
<span class="line"><span style="color:#E1E4E8;">            last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> InterceptorInvokerNode&lt;&gt;(clusterInvoker, interceptor, next);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> last;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">@</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">join</span><span style="color:#E1E4E8;">(Directory</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> directory) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 扩展名称由reference.interceptor参数确定</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buildClusterInterceptors</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">doJoin</span><span style="color:#E1E4E8;">(directory), directory.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getParameter</span><span style="color:#E1E4E8;">(REFERENCE_INTERCEPTOR_KEY));</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buildClusterInterceptors</span><span style="color:#24292E;">(AbstractClusterInvoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> clusterInvoker, String key) {</span></span>
<span class="line"><span style="color:#24292E;">    AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> clusterInvoker;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 通过SPI方式加载ClusterInterceptor扩展实现</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">ClusterInterceptor</span><span style="color:#24292E;">&gt; interceptors </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ExtensionLoader.</span><span style="color:#6F42C1;">getExtensionLoader</span><span style="color:#24292E;">(ClusterInterceptor.class).</span><span style="color:#6F42C1;">getActivateExtension</span><span style="color:#24292E;">(clusterInvoker.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), key);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">interceptors.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> interceptors.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 将InterceptorInvokerNode收尾连接到一起，形成调用链</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> ClusterInterceptor interceptor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> interceptors.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> AbstractClusterInvoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> last;</span></span>
<span class="line"><span style="color:#24292E;">            last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> InterceptorInvokerNode&lt;&gt;(clusterInvoker, interceptor, next);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> last;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#24292E;">@</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">join</span><span style="color:#24292E;">(Directory</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> directory) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 扩展名称由reference.interceptor参数确定</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buildClusterInterceptors</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">doJoin</span><span style="color:#24292E;">(directory), directory.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getParameter</span><span style="color:#24292E;">(REFERENCE_INTERCEPTOR_KEY));</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p><strong>InterceptorInvokerNode 会将底层的 AbstractClusterInvoker 对象以及关联的 ClusterInterceptor 对象封装到一起，还会维护一个 next 引用，指向下一个 InterceptorInvokerNode 对象</strong>。</p><p>在 InterceptorInvokerNode.invoke() 方法中，会先调用 ClusterInterceptor 的前置逻辑，然后执行 intercept() 方法调用 AbstractClusterInvoker 的 invoke() 方法完成远程调用，最后执行 ClusterInterceptor 的后置逻辑。具体实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result asyncResult;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        interceptor.</span><span style="color:#B392F0;">before</span><span style="color:#E1E4E8;">(next, invocation); </span><span style="color:#6A737D;">// 前置逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 执行invoke()方法完成远程调用</span></span>
<span class="line"><span style="color:#E1E4E8;">        asyncResult </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> interceptor.</span><span style="color:#B392F0;">intercept</span><span style="color:#E1E4E8;">(next, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Exception </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (interceptor </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> ClusterInterceptor.Listener) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 出现异常时，会触发监听器的onError()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">            ClusterInterceptor.Listener listener </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ClusterInterceptor.Listener) interceptor;</span></span>
<span class="line"><span style="color:#E1E4E8;">            listener.</span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(e, clusterInvoker, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> e;</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 执行后置逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        interceptor.</span><span style="color:#B392F0;">after</span><span style="color:#E1E4E8;">(next, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> asyncResult.</span><span style="color:#B392F0;">whenCompleteWithContext</span><span style="color:#E1E4E8;">((r, t) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (interceptor </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> ClusterInterceptor.Listener) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            ClusterInterceptor.Listener listener </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ClusterInterceptor.Listener) interceptor;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (t </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#6A737D;">// 正常返回时，会调用onMessage()方法触发监听器</span></span>
<span class="line"><span style="color:#E1E4E8;">                listener.</span><span style="color:#B392F0;">onMessage</span><span style="color:#E1E4E8;">(r, clusterInvoker, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">            } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                listener.</span><span style="color:#B392F0;">onError</span><span style="color:#E1E4E8;">(t, clusterInvoker, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    Result asyncResult;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        interceptor.</span><span style="color:#6F42C1;">before</span><span style="color:#24292E;">(next, invocation); </span><span style="color:#6A737D;">// 前置逻辑</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 执行invoke()方法完成远程调用</span></span>
<span class="line"><span style="color:#24292E;">        asyncResult </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> interceptor.</span><span style="color:#6F42C1;">intercept</span><span style="color:#24292E;">(next, invocation);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Exception </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (interceptor </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> ClusterInterceptor.Listener) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 出现异常时，会触发监听器的onError()方法</span></span>
<span class="line"><span style="color:#24292E;">            ClusterInterceptor.Listener listener </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (ClusterInterceptor.Listener) interceptor;</span></span>
<span class="line"><span style="color:#24292E;">            listener.</span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(e, clusterInvoker, invocation);</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> e;</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 执行后置逻辑</span></span>
<span class="line"><span style="color:#24292E;">        interceptor.</span><span style="color:#6F42C1;">after</span><span style="color:#24292E;">(next, invocation);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> asyncResult.</span><span style="color:#6F42C1;">whenCompleteWithContext</span><span style="color:#24292E;">((r, t) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (interceptor </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> ClusterInterceptor.Listener) {</span></span>
<span class="line"><span style="color:#24292E;">            ClusterInterceptor.Listener listener </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (ClusterInterceptor.Listener) interceptor;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (t </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#6A737D;">// 正常返回时，会调用onMessage()方法触发监听器</span></span>
<span class="line"><span style="color:#24292E;">                listener.</span><span style="color:#6F42C1;">onMessage</span><span style="color:#24292E;">(r, clusterInvoker, invocation);</span></span>
<span class="line"><span style="color:#24292E;">            } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                listener.</span><span style="color:#6F42C1;">onError</span><span style="color:#24292E;">(t, clusterInvoker, invocation);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>Dubbo 提供了两个 ClusterInterceptor 实现类，分别是 ConsumerContextClusterInterceptor 和 ZoneAwareClusterInterceptor，如下图所示：</p><p><img src="https://s0.lgstatic.com/i/image/M00/73/7F/CgqCHl_GA2GAYY4rAAGXJIXwK1k980.png" alt="Lark20201201-164721.png"><br> ClusterInterceptor 继承关系图</p><p>在 ConsumerContextClusterInterceptor 的 before() 方法中，会在 RpcContext 中设置当前 Consumer 地址、此次调用的 Invoker 等信息，同时还会删除之前与当前线程绑定的 Server Context。在 after() 方法中，会删除本地 RpcContext 的信息。ConsumerContextClusterInterceptor 的具体实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">before</span><span style="color:#E1E4E8;">(AbstractClusterInvoker</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> invoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 获取当前线程绑定的RpcContext</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext context </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 设置Invoker、Consumer地址等信息 context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (invocation </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> RpcInvocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ((RpcInvocation) invocation).</span><span style="color:#B392F0;">setInvoker</span><span style="color:#E1E4E8;">(invoker);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext.</span><span style="color:#B392F0;">removeServerContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">after</span><span style="color:#E1E4E8;">(AbstractClusterInvoker</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> clusterInvoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext.</span><span style="color:#B392F0;">removeContext</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">// 删除本地RpcContext的信息</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">before</span><span style="color:#24292E;">(AbstractClusterInvoker</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> invoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 获取当前线程绑定的RpcContext</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext context </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 设置Invoker、Consumer地址等信息 context.setInvocation(invocation).setLocalAddress(NetUtils.getLocalHost(), 0);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (invocation </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> RpcInvocation) {</span></span>
<span class="line"><span style="color:#24292E;">        ((RpcInvocation) invocation).</span><span style="color:#6F42C1;">setInvoker</span><span style="color:#24292E;">(invoker);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext.</span><span style="color:#6F42C1;">removeServerContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">after</span><span style="color:#24292E;">(AbstractClusterInvoker</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> clusterInvoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext.</span><span style="color:#6F42C1;">removeContext</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">true</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">// 删除本地RpcContext的信息</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>ConsumerContextClusterInterceptor 同时继承了 ClusterInterceptor.Listener 接口，在其 onMessage() 方法中，会获取响应中的 attachments 并设置到 RpcContext 中的 SERVER_LOCAL 之中，具体实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">onMessage</span><span style="color:#E1E4E8;">(Result appResponse, AbstractClusterInvoker</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> invoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#6A737D;">// 从AppResponse中获取attachment，并设置到SERVER_LOCAL这个RpcContext中    RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">onMessage</span><span style="color:#24292E;">(Result appResponse, AbstractClusterInvoker</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> invoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#6A737D;">// 从AppResponse中获取attachment，并设置到SERVER_LOCAL这个RpcContext中    RpcContext.getServerContext().setObjectAttachments(appResponse.getObjectAttachments());</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>介绍完 ConsumerContextClusterInterceptor，我们再来看 ZoneAwareClusterInterceptor。</p><p>在 ZoneAwareClusterInterceptor 的 before() 方法中，会从 RpcContext 中获取多注册中心相关的参数并设置到 Invocation 中（主要是 registry_zone 参数和 registry_zone_force 参数，这两个参数的具体含义，在后面分析 ZoneAwareClusterInvoker 时详细介绍），ZoneAwareClusterInterceptor 的 after() 方法为空实现。ZoneAwareClusterInterceptor 的具体实现如下：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">before</span><span style="color:#E1E4E8;">(AbstractClusterInvoker</span><span style="color:#F97583;">&lt;?&gt;</span><span style="color:#E1E4E8;"> clusterInvoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext rpcContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 从RpcContext中获取registry_zone参数和registry_zone_force参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    String zone </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (String) rpcContext.</span><span style="color:#B392F0;">getAttachment</span><span style="color:#E1E4E8;">(REGISTRY_ZONE);</span></span>
<span class="line"><span style="color:#E1E4E8;">    String force </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (String) rpcContext.</span><span style="color:#B392F0;">getAttachment</span><span style="color:#E1E4E8;">(REGISTRY_ZONE_FORCE);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 检测用户是否提供了ZoneDetector接口的扩展实现</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExtensionLoader&lt;</span><span style="color:#F97583;">ZoneDetector</span><span style="color:#E1E4E8;">&gt; loader </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ExtensionLoader.</span><span style="color:#B392F0;">getExtensionLoader</span><span style="color:#E1E4E8;">(ZoneDetector.class);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (StringUtils.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">(zone) </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> loader.</span><span style="color:#B392F0;">hasExtension</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;default&quot;</span><span style="color:#E1E4E8;">)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ZoneDetector detector </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> loader.</span><span style="color:#B392F0;">getExtension</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;default&quot;</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">        zone </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> detector.</span><span style="color:#B392F0;">getZoneOfCurrentRequest</span><span style="color:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">        force </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> detector.</span><span style="color:#B392F0;">isZoneForcingEnabled</span><span style="color:#E1E4E8;">(invocation, zone);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将registry_zone参数和registry_zone_force参数设置到Invocation中</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (StringUtils.</span><span style="color:#B392F0;">isNotEmpty</span><span style="color:#E1E4E8;">(zone)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        invocation.</span><span style="color:#B392F0;">setAttachment</span><span style="color:#E1E4E8;">(REGISTRY_ZONE, zone);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (StringUtils.</span><span style="color:#B392F0;">isNotEmpty</span><span style="color:#E1E4E8;">(force)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        invocation.</span><span style="color:#B392F0;">setAttachment</span><span style="color:#E1E4E8;">(REGISTRY_ZONE_FORCE, force);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">before</span><span style="color:#24292E;">(AbstractClusterInvoker</span><span style="color:#D73A49;">&lt;?&gt;</span><span style="color:#24292E;"> clusterInvoker, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext rpcContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 从RpcContext中获取registry_zone参数和registry_zone_force参数</span></span>
<span class="line"><span style="color:#24292E;">    String zone </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (String) rpcContext.</span><span style="color:#6F42C1;">getAttachment</span><span style="color:#24292E;">(REGISTRY_ZONE);</span></span>
<span class="line"><span style="color:#24292E;">    String force </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (String) rpcContext.</span><span style="color:#6F42C1;">getAttachment</span><span style="color:#24292E;">(REGISTRY_ZONE_FORCE);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 检测用户是否提供了ZoneDetector接口的扩展实现</span></span>
<span class="line"><span style="color:#24292E;">    ExtensionLoader&lt;</span><span style="color:#D73A49;">ZoneDetector</span><span style="color:#24292E;">&gt; loader </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ExtensionLoader.</span><span style="color:#6F42C1;">getExtensionLoader</span><span style="color:#24292E;">(ZoneDetector.class);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (StringUtils.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">(zone) </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> loader.</span><span style="color:#6F42C1;">hasExtension</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;default&quot;</span><span style="color:#24292E;">)) {</span></span>
<span class="line"><span style="color:#24292E;">        ZoneDetector detector </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> loader.</span><span style="color:#6F42C1;">getExtension</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;default&quot;</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">        zone </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> detector.</span><span style="color:#6F42C1;">getZoneOfCurrentRequest</span><span style="color:#24292E;">(invocation);</span></span>
<span class="line"><span style="color:#24292E;">        force </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> detector.</span><span style="color:#6F42C1;">isZoneForcingEnabled</span><span style="color:#24292E;">(invocation, zone);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将registry_zone参数和registry_zone_force参数设置到Invocation中</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (StringUtils.</span><span style="color:#6F42C1;">isNotEmpty</span><span style="color:#24292E;">(zone)) {</span></span>
<span class="line"><span style="color:#24292E;">        invocation.</span><span style="color:#6F42C1;">setAttachment</span><span style="color:#24292E;">(REGISTRY_ZONE, zone);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (StringUtils.</span><span style="color:#6F42C1;">isNotEmpty</span><span style="color:#24292E;">(force)) {</span></span>
<span class="line"><span style="color:#24292E;">        invocation.</span><span style="color:#6F42C1;">setAttachment</span><span style="color:#24292E;">(REGISTRY_ZONE_FORCE, force);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p><strong>需要注意的是，ZoneAwareClusterInterceptor 没有实现 ClusterInterceptor.Listener 接口，也就是不提供监听响应的功能。</strong></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时我们主要介绍的是 Dubbo Cluster 层中容错机制相关的内容。首先，我们了解了集群容错机制的作用。然后，我们介绍了 Cluster 接口的定义以及其各个实现类的核心功能。之后，我们深入讲解了 AbstractClusterInvoker 的实现，其<strong>核心是实现了一套通用的负载均衡算法</strong>。最后，我们还分析了 AbstractCluster 抽象实现类以及其中涉及的 ClusterInterceptor 接口的内容。</p><p>下一课时，我们将继续介绍 Cluster 接口以及 Cluster Invoker 的相关实现类，记得按时来听课。</p>`,55),e=[o];function r(t,c,E,y,i,b){return n(),a("div",null,e)}const F=s(p,[["render",r]]);export{u as __pageData,F as default};
