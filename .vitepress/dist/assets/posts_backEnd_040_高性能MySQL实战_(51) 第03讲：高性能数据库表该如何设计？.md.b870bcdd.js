import{_ as e,j as o,o as n,g as r,k as a,h as i,Q as t,s as l}from"./chunks/framework.cfb14fe0.js";const Q=JSON.parse('{"title":"第03讲：高性能数据库表该如何设计？","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/040_高性能MySQL实战/(51) 第03讲：高性能数据库表该如何设计？.md","filePath":"posts/backEnd/040_高性能MySQL实战/(51) 第03讲：高性能数据库表该如何设计？.md","lastUpdated":1696682708000}'),s={name:"posts/backEnd/040_高性能MySQL实战/(51) 第03讲：高性能数据库表该如何设计？.md"},_=t('<h1 id="第03讲-高性能数据库表该如何设计" tabindex="-1">第03讲：高性能数据库表该如何设计？ <a class="header-anchor" href="#第03讲-高性能数据库表该如何设计" aria-label="Permalink to &quot;第03讲：高性能数据库表该如何设计？&quot;">​</a></h1><p>本课时讲解的主要内容是：&quot;高性能库表设计&quot;。</p><h1 id="范式与反范式" tabindex="-1">范式与反范式 <a class="header-anchor" href="#范式与反范式" aria-label="Permalink to &quot;范式与反范式&quot;">​</a></h1><p>优秀的库表设计是高性能数据库的基础。如何才能设计出高性能的库表结构呢？这里必须要提到数据库范式。范式是基础规范，反范式是针对性设计。</p><h2 id="范式" tabindex="-1">范式 <a class="header-anchor" href="#范式" aria-label="Permalink to &quot;范式&quot;">​</a></h2><p>范式是关系数据库理论的基础，也是我们在设计数据库结构过程中所要遵循的规则和指导方法。数据库的设计范式是数据库设计所需要满足的规范。只有理解数据库的设计范式，才能设计出高效率、优雅的数据库，否则可能会设计出低效的库表结构。</p><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）和第五范式（5NF，还又称完美范式）。</p><p>满足最低要求的叫第一范式，简称 1NF。在第一范式基础上进一步满足一些要求的为第二范式，简称 2NF。其余依此类推。各种范式呈递次规范，越高的范式数据库冗余越小。通常所用到的只是前三个范式，即：第一范式（1NF），第二范式（2NF），第三范式（3NF）。</p><h3 id="第一范式" tabindex="-1">第一范式 <a class="header-anchor" href="#第一范式" aria-label="Permalink to &quot;第一范式&quot;">​</a></h3><p>第一范式无重复的列，表中的每一列都是拆分的基本数据项，即列不能够再拆分成其他几列，强调的是列的原子性.。</p><p>如果在实际场景中，一个联系人有家庭电话和公司电话，那么以&quot;姓名、性别、电话&quot;为表头的表结构就没有达到 1NF。要符合 1NF 我们只需把电话列拆分，让表头变为姓名、性别、家庭电话、公司电话即可。</p><h3 id="第二范式" tabindex="-1">第二范式 <a class="header-anchor" href="#第二范式" aria-label="Permalink to &quot;第二范式&quot;">​</a></h3><p>第二范式属性完全依赖于主键，首先要满足它符合 1NF，另外还需要包含两部分内容：</p><ul><li><p>表必须有一个主键；</p></li><li><p>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。即要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。</p></li></ul><h3 id="第三范式" tabindex="-1">第三范式 <a class="header-anchor" href="#第三范式" aria-label="Permalink to &quot;第三范式&quot;">​</a></h3><p>第三范式属性不传递依赖于其他非主属性，首先需要满足 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><h3 id="第二范式和第三范式的区别" tabindex="-1">第二范式和第三范式的区别 <a class="header-anchor" href="#第二范式和第三范式的区别" aria-label="Permalink to &quot;第二范式和第三范式的区别&quot;">​</a></h3><ul><li><p>第二范式：非主键列是否依赖主键（包括一列通过某一列间接依赖主键），要是有依赖关系就是第二范式；</p></li><li><p>第三范式：非主键列是否直接依赖主键，不能是那种通过传递关系的依赖。要是符合这种依赖关系就是第三范式。</p></li></ul><p>通过对前三个范式的了解，我们知道 3NF 是 2NF 的子集，2NF 是 1NF 的子集。</p><h3 id="设计符合-2nf-的表" tabindex="-1">设计符合 2NF 的表 <a class="header-anchor" href="#设计符合-2nf-的表" aria-label="Permalink to &quot;设计符合 2NF 的表&quot;">​</a></h3><p>接下来以订单信息表为例，讲述如何设计一个符合 2NF 的表，首先，我们看原始的订单信息表，如下图所示。</p>',21),u=t('<p>图中，以订单编号和商品编号作为联合主键，商品名称、单位、价格等信息不与主键相关，只与编号相关，违反了第二范式。 应该对订单信息表进行拆分，商品信息单独一张表，订单项目一张表，如下所示，拆分分成 3 张表。</p><ul><li><p>包含客户信息的订单信息表；</p></li><li><p>包含商品详情的商品信息表；</p></li><li><p>包含订单详情的订单详情表。</p></li></ul><h3 id="范式优缺点" tabindex="-1">范式优缺点 <a class="header-anchor" href="#范式优缺点" aria-label="Permalink to &quot;范式优缺点&quot;">​</a></h3><p>经过前面的讲解和案例分析可知范式具备以下优点：</p><ul><li><p>避免数据冗余，减少维护数据完整性的麻烦；</p></li><li><p>减少数据库的空间；</p></li><li><p>数据变更速度快。</p></li></ul><p>同时，也有如下缺点：</p><ul><li><p>按照范式的规范设计的表，等级越高的范式设计出来的表数量越多。</p></li><li><p>获取数据时，表关联过多，性能较差。</p></li></ul><p>表的数量越多，查询所需要的时间越多。也就是说所用的范式越高，对数据操作的性能越低。</p><h2 id="反范式" tabindex="-1">反范式 <a class="header-anchor" href="#反范式" aria-label="Permalink to &quot;反范式&quot;">​</a></h2><p>范式是普适的规则，满足大多数的业务场景的需求。对于一些特殊的业务场景，范式设计的表，无法满足性能的需求。此时，就需要根据业务场景，在范式的基础之上进行灵活设计，也就是反范式设计。</p><br><p>反范式设计主要从三方面考虑：</p><ul><li><p>业务场景；</p></li><li><p>相应时间；</p></li><li><p>字段冗余。</p></li></ul><p>反范式设计就是用空间来换取时间，提高业务场景的响应时间，减少多表关联。主要的优点如下。</p><ul><li><p>允许适当的数据冗余，业务场景中需要的数据几乎都可以在一张表上显示，避免关联；</p></li><li><p>可以设计有效的索引。</p></li></ul><h3 id="范式与反范式异同" tabindex="-1">范式与反范式异同 <a class="header-anchor" href="#范式与反范式异同" aria-label="Permalink to &quot;范式与反范式异同&quot;">​</a></h3><p>范式化模型：</p><ul><li><p>数据没有冗余，更新容易；</p></li><li><p>当表的数量比较多，查询数据需要多表关联时，会导致查询性能低下。</p></li></ul><p>反范式化模型：</p><ul><li><p>冗余将带来很好的读取性能，因为不需要 join 很多表；</p></li><li><p>虽然需要维护冗余数据，但是对磁盘空间的消耗是可以接受的。</p></li></ul><h1 id="mysql-使用原则和设计规范" tabindex="-1">MySQL 使用原则和设计规范 <a class="header-anchor" href="#mysql-使用原则和设计规范" aria-label="Permalink to &quot;MySQL 使用原则和设计规范&quot;">​</a></h1><p>讲完范式，接下来我们看看 MySQL 使用中的一些使用原则和设计规范。</p><p>MySQL 虽然具有很多特性并提供了很多功能，但是有些特性会严重影响它的性能，比如，在数据库里进行计算，写大事务、大 SQL、存储大字段等。</p><p>想要发挥 MySQL 的最佳性能，需要遵循 3 个基本使用原则。</p><ol><li><p>首先是需要让 MySQL 回归存储的基本职能：MySQL 数据库只用于数据的存储，不进行数据的复杂计算，不承载业务逻辑，确保存储和计算分离；</p></li><li><p>其次是查询数据时，尽量单表查询，减少跨库查询和多表关联；</p></li><li><p>还有就是要杜绝大事务、大 SQL、大批量、大字段等一系列性能杀手**。**</p></li></ol><ul><li><p>大事务，运行步骤较多，涉及的表和字段较多，容易造成资源的争抢，甚至形成死锁。一旦事务回滚，会导致资源占用时间过长。</p></li><li><p>大 SQL，复杂的 SQL 意味着过多的表的关联，MySQL 数据库处理关联超过 3 张表以上的 SQL 时，占用资源多，性能低下。</p></li><li><p>大批量，意味着多条 SQL 一次性执行完成，必须确保进行充分的测试，并且在业务低峰时段或者非业务时段执行。</p></li><li><p>大字段，blob、text 等大字段，尽量少用。必须要用时，尽量与主业务表分离，减少对这类字段的检索和更新。</p></li></ul><p>下面具体讲解数据库的基本设置规则：</p><ol><li><p>必须指定默认存储引擎为 InnoDB，并且禁用 MyISAM 存储引擎，随着 MySQL 8.0 版本的发布，所有的数据字典表都已经转换成了 InnoDB，MyISAM 存储引擎已成为了历史。</p></li><li><p>默认字符集 UTF8mb4，以前版本的 UTF8 是 UTF8mb3，未包含个别特殊字符，新版本的 UTF8mb4 包含所有字符，官方强烈建议使用此字符集。</p></li><li><p>关闭区分大小写功能。设置 lower_case_tables_name=1，即可关闭区分大小写功能，即大写字母 T 和小写字母 t 一样。</p></li></ol><p>这里在实践中有个小问题，如何让系统中区分大小写的库表转换为不区分大小写的库表呢？因为要修改底层数据，还是比较麻烦的，操作步骤如下。</p><ol><li><p>MySQL dump 导出数据库。</p></li><li><p>修改参数 lower_case_tables_name=1。</p></li><li><p>导入备份数据时，必须停止数据库，停止业务，影响非常大。</p></li><li><p>开启 per-table 表空间，开启后，每张业务表会单独创建一个独立于系统表空间的表空间，便于空间的回收，数据的迁移。</p></li></ol><p>MySQL 数据库提供的功能很全面，但并不是所有的功能性能都高效。</p><ol><li><p>存储过程、触发器、视图、event。为了存储计算分离，这类功能尽量在程序中实现。这些功能非常不完整，调试、排错、监控都非常困难，相关数据字典也不完善，存在潜在的风险。一般在生产数据库中，禁止使用。</p></li><li><p>lob、text、enum、set。这些字段类型，在 MySQL 数据库的检索性能不高，很难使用索引进行优化。如果必须使用这些功能，一般采取特殊的结构设计，或者与程序结合使用其他的字段类型替代。比如：set 可以使用整型（0，1，2，3）、注释功能和程序的检查功能集合替代。</p></li></ol><p>以上是基础规范的内容，但并不是全部，只是以点带面，进行粗略的介绍。下面我们开始讲解命名规范，统一的规范命名，可以增加可读性，减少隐式转换。</p><h1 id="规范命名" tabindex="-1">规范命名 <a class="header-anchor" href="#规范命名" aria-label="Permalink to &quot;规范命名&quot;">​</a></h1><p>命名规范如下，命名时的字符取值范围为：a~z，0~9 和 _（下画线）。</p><ol><li><p>所有表名小写，不允许驼峰式命名；</p></li><li><p>允许使用 -（横线）和 （空格）；如下图所示，当使用 -（横线），后台默认会转化成 @002d；</p></li><li><p>不允许使用其他特殊字符作为名称，减少潜在风险。</p></li></ol>',36),h=t('<p>数据库库名的命名规则必须遵循&quot;见名知意&quot;的原则，即库名规则为&quot;数据库类型代码 + 项目简称 + 识别代码 + 序号&quot;。</p><p>这样包含了更多的业务信息，比如：</p><ul><li><p>出入系统业务生产库：AOCT、AOCT1、AOCT2；</p></li><li><p>出入系统业务开发库：AOCTDEV、AOCTDEV1、AOCTDEV2；</p></li><li><p>出入系统业务测试库：AOCTTEST、AOCTTEST1、AOCTTEST2；</p></li><li><p>只有一个数据库，则不加序号，否则末尾增加序号；</p></li><li><p>生产库不加识别代码，否则需要增加识别代码 DEV 或 TEST；</p></li><li><p>如果只作历史库，则只需要项目简称 +H+ 序号；</p></li><li><p>图例为常用的识别代码。</p></li></ul><p>表名的命名规则分为：</p><ol><li><p>单表仅使用 a~z、_；</p></li><li><p>分表名称为&quot;表名_编号&quot;；</p></li><li><p>业务表名代表用途、内容：子系统简称_业务含义_后缀。</p></li></ol><p>常见业务表类型有：</p><ul><li><p>临时表，tmp；</p></li><li><p>备份表，bak；</p></li><li><p>字典表，dic；</p></li><li><p>日志表，log。</p></li></ul><p>字段名精确，遵循&quot;见名知意&quot;的原则，格式：名称_后缀。</p><ul><li>避免普遍简单、有歧义的名称。</li></ul><p>用户表中，用户名的字段为 UserName 比 Name 更好。</p><ul><li>布尔型的字段，以助动词（has/is）开头。</li></ul><p>用户是否有留言 hasmessage，用户是否通过检查 ischecked 等。</p><p>常见后缀如下：</p><ul><li><p>流水号/无意义主键，后缀为 id，比如 task_id；</p></li><li><p>时间，后缀为 time，insert_time。</p></li></ul><p>程序账号与数据库名称保持一致。如果所有的程序账号都是 root@&#39;%&#39;，密码也一样，很容易错连到其他的数据库，造成误操作。</p><p>索引命名格式，主要为了区分哪些对象是索引：</p><ul><li><p>前缀_表名（或缩写）_字段名（或缩写）；</p></li><li><p>主键必须使用前缀&quot;pk_&quot;；</p></li><li><p>UNIQUE 约束必须使用前缀&quot;uk_&quot;；</p></li><li><p>普通索引必须使用前缀&quot;idx_&quot;。</p></li></ul><p>数据库规范库表字段的命名，能够提高数据库的易读性，为数据库表设计打下基础。下面我们具体看看表设计的一些规则。</p><ul><li>显式指定需要的属性；</li></ul><p>创建表时显示指定字符集、存储引擎、注释信息等。</p><ul><li>不同系统之间，统一规范；</li></ul><p>不同表之间的相同字段或者关联字段，字段类型/命名要保持一致；库表字符集和前端程序、中间件必须保持一致的 UTF8mb4。</p><h2 id="innodb-表的注意事项" tabindex="-1">InnoDB 表的注意事项 <a class="header-anchor" href="#innodb-表的注意事项" aria-label="Permalink to &quot;InnoDB 表的注意事项&quot;">​</a></h2><ol><li><p>主键列，UNSIGNED 整数，使用 auto_increment；禁止手动更新 auto_increment，可以删除。</p></li><li><p>必须添加 comment 注释。</p></li><li><p>必须显示指定的 engine。</p></li><li><p>表必备三字段：id、 xxx_create、 xxx_modified。</p></li></ol><ul><li><p>id 为主键，类型为 unsigned bigint 等数字类型；</p></li><li><p>xxx_create、xxx_modified 的类型均为 datetime 类型，分别记录该条数据的创建时间、修改时间。</p></li></ul><h2 id="备份表-临时表等常见表的设计规范" tabindex="-1">备份表/临时表等常见表的设计规范 <a class="header-anchor" href="#备份表-临时表等常见表的设计规范" aria-label="Permalink to &quot;备份表/临时表等常见表的设计规范&quot;">​</a></h2><p>备份表/临时表等常见表的设计规范如下。</p><ol><li><p>备份表，表名必须添加 bak 和日期，主要用于系统版本上线时，存储原始数据，上线完成后，必须及时删除。</p></li><li><p>临时表，用于存储中间业务数据，定期优化，及时降低表碎片。</p></li><li><p>日志类表，首先考虑不入库，保存成文件，其次如果入库，明确其生命周期，保留业务需求的数据，定期清理。</p></li><li><p>大字段表，把主键字段和大字段，单独拆分成表，并且保持与主表主键同步，尽量减少大字段的检索和更新。</p></li><li><p>大表，根据业务需求，从垂直和水平两个维度进行拆分。</p></li></ol><p>垂直拆分：按列关联度。</p><br><p>水平拆分：</p><ul><li><p>按照时间、地域、范围等；</p></li><li><p>冷热数据（历史数据归档）。</p></li></ul><h2 id="字段设计要求" tabindex="-1">字段设计要求 <a class="header-anchor" href="#字段设计要求" aria-label="Permalink to &quot;字段设计要求&quot;">​</a></h2><ol><li><p>根据业务场景需求，选择合适的类型，最短的长度；确保字段的宽度足够用，但也不要过宽。所有字段必须为 NOT NULL，空值则指定 default 值，空值难以优化，查询效率低。比如：人的年龄用 unsigned tinyint（范围 0~255，人的寿命不会超过 255 岁）；海龟就必须是 smallint，但如果是太阳的年龄，就必须是 int；如果是所有恒星的年龄都加起来，那么就必须使用 bigint。</p></li><li><p>表字段数少而精，尽量不加冗余列。</p></li><li><p>单实例表个数必须控制在 2000 个以内。</p></li><li><p>单表分表个数必须控制在 1024 个以内。</p></li><li><p>单表字段数上限控制在 20~50 个。</p></li></ol><p>禁用 ENUM、SET 类型。</p><ul><li>兼容性不好，性能差。</li></ul><p>解决方案：使用 TINYINT，在 COMMENT 信息中标明被枚举的含义。`is_disable` TINYINT UNSIGNED DEFAULT &#39;0&#39; COMMENT &#39;0:启用 1:禁用 2:异常&#39;。</p><p>禁用列为 NULL。</p><ul><li><p>MySQL 难以优化 NULL 列；</p></li><li><p>NULL 列加索引，需要额外空间；</p></li><li><p>含 NULL 复合索引无效。</p></li></ul><p>解决方案：在列上添加 NOT NULL DEFAULT 缺省值。</p><p>禁止 VARBINARY、BLOB 存储图片、文件等。</p><ul><li>禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统中，数据库中存储路径。</li></ul><p>不建议使用 TEXT/BLOB：</p><ul><li><p>处理性能差；</p></li><li><p>行长度变长；</p></li><li><p>全表扫描代价大。</p></li></ul><p>解决方案：拆分成单独的表。</p><p>存储字节越小，占用空间越小。尽量选择合适的整型，如下图所示。</p>',46),c=l("ol",null,[l("li",null,[l("p",null,"主键列，无负数，建议使用 INT UNSIGNED 或者 BIGINT UNSIGNED；预估字段数字取值会超过 42 亿，使用 BIGINT 类型。")]),l("li",null,[l("p",null,"短数据使用 TINYINT 或 SMALLINT，比如：人类年龄，城市代码。")]),l("li",null,[l("p",null,"使用 UNSIGNED 存储非负数值，扩大正数的范围。")])],-1),d=l("h2",{id:"int-3-int-5-区别",tabindex:"-1"},[i("int(3)/int(5) 区别 "),l("a",{class:"header-anchor",href:"#int-3-int-5-区别","aria-label":'Permalink to "int(3)/int(5) 区别"'},"​")],-1),T=l("p",null,"int(3)/int(5) 的区别，如下图所示。",-1),m=l("ul",null,[l("li",null,[l("p",null,"正常显示没有区别。")]),l("li",null,[l("p",null,"3 和 5 仅是最小显示宽度而已。")]),l("li",null,[l("p",null,"有 zerofill 等扩展属性时则显示有区别。")])],-1),A=l("h2",{id:"浮点数与定点数区别",tabindex:"-1"},[i("浮点数与定点数区别 "),l("a",{class:"header-anchor",href:"#浮点数与定点数区别","aria-label":'Permalink to "浮点数与定点数区别"'},"​")],-1),N=l("p",null,"浮点数与定点数区别，如下图所示。",-1),b=t('<ol><li><p>浮点数：float、double（或 real）。</p></li><li><p>定点数：decimal（或 numberic）。</p></li></ol><br><p>从上图中可以观察到：</p><ul><li><p>浮点数存在误差问题；</p></li><li><p>尽量避免进行浮点数比较；</p></li><li><p>对货币等对精度敏感的数据，应该使用定点数。</p></li></ul><h2 id="n-解释" tabindex="-1">N 解释 <a class="header-anchor" href="#n-解释" aria-label="Permalink to &quot;N 解释&quot;">​</a></h2><p>字符集都为 UTF8mb4，中文存储占三个字节，而数据或字母，则只占一个字节。</p><br><p>下面看一下字符类型中 N 的解释。</p><ul><li><p>CHAR(N) 和 VARCHAR(N) 的长度 N，不是字节数，是字符数。</p></li><li><p>username 列可以存多少个汉字，占用多少个字节</p></li><li><p>username 最多能存储 40 个字符，占用 120 个字节。</p></li></ul><br><p><strong>Char 与 Varchar 类型</strong></p><p>存储字符串长度相同的全部使用 Char 类型；字符长度不相同的使用 Varchar 类型，不预先分配存储空间，长度不要超过 255。</p><p>Char 和 Varchar 占用空间的对比，如下图所示。</p>',13),q=t('<p>Varchar 值存储为 1 字节或 2 字节长度前缀加数据。如果值不超过 255 个字节，则列使用一个字节长度；如果值可能需要超过 255 个字节，则列使用两个字节长度。</p><p>为什么超过 255 个字节时，必须使用两个字节长度。</p><ul><li><p>2^8^=256，1 个字节是 8 位；</p></li><li><p>2^16^=65535，2 个字节是 16 位。</p></li></ul><h1 id="案例" tabindex="-1">案例 <a class="header-anchor" href="#案例" aria-label="Permalink to &quot;案例&quot;">​</a></h1><p>我们学习了范式和反范式、命名规则、表设计规范，下面通过几个具体的案例，进一步巩固这些知识。</p><h2 id="ip-处理" tabindex="-1">IP 处理 <a class="header-anchor" href="#ip-处理" aria-label="Permalink to &quot;IP 处理&quot;">​</a></h2><ol><li><p>一般使用 Char(15) 进行存储，但是当进行查找和统计时，字符类型不是很高效。</p></li><li><p>MySQL 数据库内置了两个 IP 相关的函数 INET_ATON()、INET_NTOA()，可以实现 IP 地址和整数的项目转换。</p></li></ol><p>因此，我们使用 INT UNSIGNED（占用 4 个字节）存储 IP，非 Char(15)。占 15 个字节。</p><p>下图所示，IP：192.168.0.1 与整数之间的转换。</p>',9),S=l("p",null,"将 IP 的存储从字符型转换成整形，转化后数字是连续的，提高了查询性能，使查询更快，占用空间更小。",-1),I=l("h2",{id:"timestamp-处理",tabindex:"-1"},[i("TIMESTAMP 处理 "),l("a",{class:"header-anchor",href:"#timestamp-处理","aria-label":'Permalink to "TIMESTAMP 处理"'},"​")],-1),g=l("p",null,"同样的方法，我们使用 MySQL 内置的函数(FROM_UNIXTIME()，UNIX_TIMESTAMP())，可以将日期转化为数字，用 INT UNSIGNED 存储日期和时间。",-1),P=l("br",null,null,-1),M=l("p",null,"下图示所示，时间 2007-11-30 10:30:19 与整数之间的转换，转化后数字是连续的，占用空间更小，并且可以使用索引提升查询性能。",-1),E=l("p",null,"本案例展示的是，不当的数字类型，导致表无法插入新数据，如下图所示。",-1),C=t('<br><p>当我们使用 load data 进行批量加载数据时，会导致 1467 错误。根据分析，导致 1467 错误是由于 auto_increment 的值，超过了 int 类型的取值范围。</p><br><p>原因分析部分显示，max(seq_id) 为 2147477751，而 int 的范围为 -2147483648~ 2147483647，还剩余空间 5896，而程序需要导入 1 万行，所以报错。</p><h3 id="解决办法" tabindex="-1">解决办法 <a class="header-anchor" href="#解决办法" aria-label="Permalink to &quot;解决办法&quot;">​</a></h3><p>将 int 改为 bigint 或者将数据分表。</p><h2 id="表大小及使用频率" tabindex="-1">表大小及使用频率 <a class="header-anchor" href="#表大小及使用频率" aria-label="Permalink to &quot;表大小及使用频率&quot;">​</a></h2><p>设计表时，必须考虑表的大小和使用频率，避免由于取值范围过小，导致程序运行失败。</p><br><p>对于 InnoDB 表，要求创建一个与业务无关的主键，比如：每张表以 id 列为主键。但是 id 列非常常见，完全无法表达更深层次的意思，特别是在做两张表的联合查询时，它们都有相同的 id 主键的情况下。</p><br><p>如果你的程序用的是列名，该如何区分 Accounts 表的 id 和 Bugs 的 id 呢？如下图所示，列名 id 并不会使查询变得更加清晰。但如果列名叫作 bug_id 或者 account_id，事情就会变得更加简单。</p>',12),x=l("p",null,"我们使用主键来定位唯一一条记录，因此主键的列名就应该更加便于理解，如下图所示。",-1),L=t('<ol><li><p>在缺陷跟踪数据库中，我们使用 Products 表中的 product_id 主键列来关联产品和对应的联系人。每个账号可能对应很多产品，每个产品又引用了一个联系人，因此产品和帐号之间是多对一的关系</p></li><li><p>随着项目日趋成熟，一个产品可能会有多个联系人，除了多对一的关系外，还需要支持产品到账号的一对多的关系。Products 表中的一行数据必须要存储多个联系人。</p></li><li><p>为了把数据库表结构的改动控制在最小范围内，我们决定将 account_id 的类型修改为 Varchar，这样可以在该列中存储多个账号 id，每个账号 id 之间用逗号分隔。</p></li><li><p>这样的设计似乎是可行的，没有创建额外的表和列，仅仅改变了一个字段的数据类型。然而，我们来看看这样的设计所必须承受的性能和数据完整性问题。所有外键都合并在一个单元格内，查询会变成异常困难。只能通过正则表达式进行模糊匹配，不但可能会返回错误的结果，而且无法使用索引提高性能。例如：查询指定产品的账号时，联合两张表将不能使用任何索引。这样的查询必然会对两张表进行全表扫描，并创建一个交叉结果集，然后使用正则表达式遍历每一行联合后的数据进行匹配。</p></li><li><p>出于性能优化方面的考虑，可能在数据库的结果中需要使用反范式的设计。上述 Products 表中将列表存储为以逗号分隔的字符串，就是反范式的一个实例。这个设计只是简化了存储，但是性能低下。因此你需要谨慎使用反范式的数据库设计。尽可能地使用规范化的数据库设计。</p></li><li><p>根据业务需求，我们如何设计合理的反范式，解决方案是：创建一个交叉表。将 account_id 存储在一张单独的表中，而不是存储在 Products 表中，从而确保每个独立的 account 值都可以占据一行。</p></li></ol><p>这张新表 Contacts，实现了 Products 和 Accounts 的多对多关系。当一张表有指向两张表的外键时，称这种表为交叉表，它实现了两张表之间的多对多关系。这意味着每个产品都可以通过交叉表和多个账号关联；同样地，一个账号也可以通过交叉表和多个产品关联。当我们&quot;查询指定产品的账号&quot;时，就可以直接使用下面的联合查询语句高效实现。</p><h1 id="总结回顾" tabindex="-1">总结回顾 <a class="header-anchor" href="#总结回顾" aria-label="Permalink to &quot;总结回顾&quot;">​</a></h1><p>本节课主要讲解一些高性能表设计的规则和案例。</p><ol><li><p>以高性能为目标，库表设计以范式为主，根据特殊业务场景使用反范式，允许必要的空间换时间。</p></li><li><p>规范数据库的使用原则，统一规范命名，减少性能隐患，减少隐式转换。</p></li><li><p>高性能表设计的原则：合适的字段、合适的长度、NOT NULL。</p></li><li><p>从不同角度思考 IP、timestamp 的转换，拓宽设计思路。</p></li><li><p>规范的命名可提高可读性，反范式设计可提高查询性能。</p></li></ol><p>本课时到这里就结束了，主要讲了范式和反范式、基础规范、命名规范、表设计规范、高性能数据库表实践，下一课时将分享&quot;高性能索引如何设计&quot;。</p>',6);function f(k,U,O,D,V,F){const p=o("Image");return n(),r("div",null,[_,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/C0/CgoB5l14nkOAGCKWAAFmA3Z6YKY830.png"}),i(),u,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/0D/CgotOV13OUyAEEFVAAD5jwl3kR0869.png"}),i(),h,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgoB5l13OUyATsQnAAA4g1UgnXs652.png"}),i(),c,d,T,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/0D/CgotOV13OUyAHP8wAAGqIw0bt-Q508.png"}),i(),m,A,N,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgoB5l13OUyAeWc1AAOJ7yjHSvE323.png"}),i(),b,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/0D/CgotOV13OUyAXwFVAAA0nOrMqC4728.png"}),i(),q,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgoB5l13OUyAaa7WAAMXMykWJTQ418.png"}),i(),S,I,g,P,M,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/0D/CgotOV13OU2AUqvlAAMhnvLoP8c575.png"}),i(),E,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgoB5l13OU2AOxkSAABmRJMVIEE248.png"}),i(),C,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/8A/0D/CgotOV13OU2ATwrqAAXfmFaSYKY123.png"}),i(),x,a(p,{alt:"",src:"http://s0.lgstatic.com/i/image2/M01/89/ED/CgoB5l13OU2AP4Z8AALWmJYqBBY555.png"}),i(),L])}const B=e(s,[["render",f]]);export{Q as __pageData,B as default};
