import{_ as o,j as e,o as t,h as r,k as l,f as n,s,Q as p}from"./chunks/framework.d3daa342.js";const j=JSON.parse('{"title":"24从Protocol起手，看服务暴露和服务引用的全流程（上）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4274) 24  从 Protocol 起手，看服务暴露和服务引用的全流程（上）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4274) 24  从 Protocol 起手，看服务暴露和服务引用的全流程（上）.md","lastUpdated":1696682708000}'),c={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4274) 24  从 Protocol 起手，看服务暴露和服务引用的全流程（上）.md"},E=s("h1",{id:"_24从protocol起手-看服务暴露和服务引用的全流程-上",tabindex:"-1"},[n("24从Protocol起手，看服务暴露和服务引用的全流程（上） "),s("a",{class:"header-anchor",href:"#_24从protocol起手-看服务暴露和服务引用的全流程-上","aria-label":'Permalink to "24从Protocol起手，看服务暴露和服务引用的全流程（上）"'},"​")],-1),y=s("p",null,"在上一课时我们讲解了 Protocol 的核心接口，那本课时我们就以 Protocol 接口为核心，详细介绍整个 Protocol 的核心实现。下图展示了 Protocol 接口的继承关系：",-1),i=s("p",null,"Protocol 接口继承关系图",-1),d=s("p",null,[n("其中，"),s("strong",null,"AbstractProtocol"),n("提供了一些 Protocol 实现需要的公共能力以及公共字段，它的核心字段有如下三个。")],-1),D=s("ul",null,[s("li",null,"exporterMap（Map<String, Exporter<?>>类型）：用于存储出去的服务集合，其中的 Key 通过 ProtocolUtils.serviceKey() 方法创建的服务标识，在 ProtocolUtils 中维护了多层的 Map 结构（如下图所示）。首先按照 group 分组，在实践中我们可以根据需求设置 group，例如，按照机房、地域等进行 group 划分，做到就近调用；在 GroupServiceKeyCache 中，依次按照 serviceName、serviceVersion、port 进行分类，最终缓存的 serviceKey 是前面三者拼接而成的。")],-1),F=p("",9),u=s("p",null,"DubboExporter 继承关系图",-1),A=s("p",null,"AbstractExporter 中维护了一个 Invoker 对象，以及一个 unexported 字段（boolean 类型），在 unexport() 方法中会设置 unexported 字段为 true，并调用 Invoker 对象的 destory() 方法进行销毁。",-1),v=s("p",null,"DubboExporter 也比较简单，其中会维护底层 Invoker 对应的 ServiceKey 以及 DubboProtocol 中的 exportMap 集合，在其 unexport() 方法中除了会调用父类 AbstractExporter 的 unexport() 方法之外，还会清理该 DubboExporter 实例在 exportMap 中相应的元素。",-1),g=s("h4",{id:"_2-服务端初始化",tabindex:"-1"},[n("2. 服务端初始化 "),s("a",{class:"header-anchor",href:"#_2-服务端初始化","aria-label":'Permalink to "2. 服务端初始化"'},"​")],-1),b=s("p",null,"了解了 Exporter 实现之后，我们继续看 DubboProtocol 中服务发布的流程。从下面这张调用关系图中可以看出，openServer() 方法会一路调用前面介绍的 Exchange 层、Transport 层，并最终创建 NettyServer 来接收客户端的请求。",-1),C=p("",9),h=p("",4),_=p("",5),S=p("",4),m=p("",19),x=s("p",null,"getRegisteredClasses() 方法的调用位置",-1),I=s("p",null,"按照 Dubbo 官方文档的说法，即使不注册任何类进行优化，Kryo 和 FST 的性能依然普遍优于Hessian2 和 Dubbo 序列化。",-1),R=s("h3",{id:"总结",tabindex:"-1"},[n("总结 "),s("a",{class:"header-anchor",href:"#总结","aria-label":'Permalink to "总结"'},"​")],-1),T=s("p",null,"本课时我们重点介绍了 DubboProtocol 发布一个 Dubbo 服务的核心流程。首先，我们介绍了 AbstractProtocol 这个抽象类为 Protocol 实现类提供的公共能力和字段，然后我们结合 Dubbo 协议对应的 DubboProtocol 实现，讲解了发布一个 Dubbo 服务的核心流程，其中涉及整个服务端核心启动流程、RpcInvocation 实现、DubboProtocol.requestHandler 字段调用 Invoker 对象以及序列化相关的优化处理等内容。",-1),k=s("p",null,"下一课时，我们将继续介绍 DubboProtocol 引用服务的相关实现。",-1);function B(P,O,N,f,M,z){const a=e("Image");return t(),r("div",null,[E,y,l(a,{alt:"Drawing 0.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTHGAOVGKAAJe5PD5u9A015.png"}),n(),i,d,D,l(a,{alt:"Lark20201016-164613.png",src:"https://s0.lgstatic.com/i/image/M00/5F/74/Ciqc1F-JXfmAJK8RAAHUliqXmBc629.png"}),n(),F,l(a,{alt:"Drawing 2.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTJSAd9oTAAAm0DgOmVo715.png"}),n(),u,A,v,g,b,l(a,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTKGAJNO8AAElldtvsRM104.png"}),n(),C,l(a,{alt:"Drawing 4.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTK-AUlLCAADTWhhySe8432.png"}),n(),h,l(a,{alt:"Drawing 5.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTLuAZ-AoAACeZ02hpEg723.png"}),n(),_,l(a,{alt:"Drawing 6.png",src:"https://s0.lgstatic.com/i/image/M00/5D/D0/CgqCHl-FTMSAYeP7AAA_pzU2CPA016.png"}),n(),S,l(a,{alt:"Drawing 7.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTM2Ae73pAAC0_daI0N4088.png"}),n(),m,l(a,{alt:"Drawing 8.png",src:"https://s0.lgstatic.com/i/image/M00/5D/C5/Ciqc1F-FTOGAEWu7AADOU3xBmjA069.png"}),n(),x,I,R,T,k])}const U=o(c,[["render",B]]);export{j as __pageData,U as default};
