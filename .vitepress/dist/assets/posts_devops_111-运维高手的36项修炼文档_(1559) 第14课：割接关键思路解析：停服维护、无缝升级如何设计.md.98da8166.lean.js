import{_ as o,j as e,o as p,g as i,k as a,h as l,s,Q as t}from"./chunks/framework.e0c66c3f.js";const U=JSON.parse('{"title":"割接与迁移 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/devops/111-运维高手的36项修炼文档/(1559) 第14课：割接关键思路解析：停服维护、无缝升级如何设计.md","filePath":"posts/devops/111-运维高手的36项修炼文档/(1559) 第14课：割接关键思路解析：停服维护、无缝升级如何设计.md","lastUpdated":1696338709000}'),r={name:"posts/devops/111-运维高手的36项修炼文档/(1559) 第14课：割接关键思路解析：停服维护、无缝升级如何设计.md"},c=s("br",null,null,-1),_=s("p",null,"在上一课时中我们讲解了割接的相关检查项及命令，本课时我们继续讲解割接的关键思路：停服维护和无缝升级时应该如何进行设计。",-1),d=s("h2",{id:"割接与迁移",tabindex:"-1"},[l("割接与迁移 "),s("a",{class:"header-anchor",href:"#割接与迁移","aria-label":'Permalink to "割接与迁移"'},"​")],-1),g=s("p",null,"通过上一课时的学习，想必你已经对网站割接的定义都有一定的了解。在此基础上再讲一讲割接和迁移存在的区别。",-1),h=s("br",null,null,-1),u=t("",15),b=t("",22),m=s("br",null,null,-1),x=s("p",null,"我们先来看一下这样的一张图，在这张图里我仍然把企业通架构分为入口层、逻辑层和数据层。",-1),y=s("br",null,null,-1),E=s("p",null,"如果我们要做更详细的划分，就可以把逻辑层剥离成业务逻辑层和服务逻辑层。服务逻辑层就是我们现在通常所说的中台，有了服务逻辑层，就可以把公共服务交给中台处理。在数据层如果涉及修改数据库的配置，如：后端需要升级数据库的版本，或者要对数据库进行迁移等，我们都只需要去修改中台和数据库的关联关系配置，而不会干扰到业务层的正常访问。所以这种架构的剥离（采用服务层和数据层直接对接），会更加的合理和方便。",-1),A=s("br",null,null,-1),N=s("p",null,"一个中型企业，通常会把传统的逻辑层进行拆分，分别拆成业务层和服务层，在这种模式的基础上，我们通过这张图来了解 MySQL 的停服割接是如何做到的？",-1),M=s("br",null,null,-1),T=t("",23),k=s("br",null,null,-1),S=s("p",null,"还是在这张图里面，我们先要重点解决几个问题，一个是老库和新库的数据如何在不一致的情况下进行恢复和填补，这时我们需要在逻辑层对你的数据开启一个 CIDR 日志，也就是说，我们要在某一个时间，在服务逻辑层上把业务上的 CIDR 日志完整地保留一份。这里的 CIDR就是对数据的增 加、删除和更新。",-1),C=s("p",null,"同时我们还需要开发一个非常重要的工具，我把它命名为 Migration Tools，这个工具通常是企业根据自身业务情况和数据库的表结构情况来进行开发。在不停服割接时，由于服务逻辑层切换了数据库的连接地址，我们可以用 Mgration Tools 通过日志重放的方式重新填平数据上的差异。",-1),q=s("br",null,null,-1),v=s("p",null,"图中有两套数据库，我们知道 MySQL 通常采用主从的方式，老库同步数据给从库，新库我们可以做成一个主从的方式，同时把新库的主做成老库的从库，这样的话就可以把老库的数据通过 binlog 的方式实时同步。在切换完老库和新库以后，数据不一致，我们需要通过 Mgration_tools 基于逻辑层已经写好的日志文件来进行数据的填平。",-1),I=s("br",null,null,-1),D=s("p",null,"刚刚讲到的不停服割接方式是通过 Mgration_tools，直接以同步的数据把老库和新库的数据填平，接下来介绍第 2 种方式，就是做服务层作数据双写。所谓双写就是在服务层同时写两份数据，既写给老库也写给新库。",-1),P=s("br",null,null,-1),Q=s("br",null,null,-1),w=s("p",null,"我们来看一下这种方式是如何实现的，首先在时间点 T1 进行代码版本的升级。这个代码的升级的作用是同时开启双写，既写老库也写新库，这样的话我们会看到在 T1 的时间点之后，所有的数据也会在新库里有一份。在 T2 这个时间点开始割接，老库完全停写，所有的流量都到新库里去，这个时候我们可能会有一个问题，在时间点 T1 之前的数据怎么办呢？这个时候我们也需要去开发一套 Mgration_tools，也就是数据同步的工具，去把老库在 T1 时间点之前的数据同步到新库上。",-1),B=s("br",null,null,-1),L=s("p",null,"以上就是企业在做 MySQL 不停服割接时，对 MySQL 迁移架构设计一些思路上的要求。",-1);function V(f,F,R,K,$,J){const n=e("Image");return p(),i("div",null,[c,_,d,g,h,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/81/4D/Cgq2xl6FmKmAO_CMAAU2syJogr0306.png"}),l(),u,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/81/4D/Cgq2xl6FmKqAJXLOAAIMFmFy9LU520.png"}),b,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/08/37/Ciqah16FmKqAMZZeAAKlVRgND70352.png"}),l(),m,x,y,E,A,N,M,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/08/37/Ciqah16FmKqAQVr8AASygXQDB2I188.png"}),l(),T,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/08/37/Ciqah16FmKuAaVH0AAaOEBkiat0291.png"}),l(),k,S,C,q,v,I,D,P,a(n,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/08/37/Ciqah16FmKuADHD8AAT1Jp-tn5U841.png"}),l(),Q,w,B,L])}const j=o(r,[["render",V]]);export{U as __pageData,j as default};
