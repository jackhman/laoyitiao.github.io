import{_ as n,j as e,o as _,g as a,k as o,Q as s,s as l}from"./chunks/framework.e0c66c3f.js";const ll=JSON.parse('{"title":"案例 说明 volatile 和原子类的异同 ","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/096-Java 并发编程文档/(279) 第41讲：原子类和 volatile 有什么异同？.md","filePath":"posts/backEnd/096-Java 并发编程文档/(279) 第41讲：原子类和 volatile 有什么异同？.md","lastUpdated":1696338709000}'),i={name:"posts/backEnd/096-Java 并发编程文档/(279) 第41讲：原子类和 volatile 有什么异同？.md"},c=s("",4),r=l("br",null,null,-1),u=l("p",null,"在图中左上角可以看出，有一个公共的 boolean flag 标记位，最开始赋值为 true，然后线程 2 会进入一个 while 循环，并且根据这个 flag 也就是标记位的值来决定是否继续执行或着退出。",-1),p=l("br",null,null,-1),h=l("p",null,"最开始由于 flag 的值是 true，所以首先会在这里执行一定时期的循环。然后假设在某一时刻，线程 1 把这个 flag 的值改为 false 了，它所希望的是，线程 2 看到这个变化后停止运行。",-1),d=l("br",null,null,-1),g=l("p",null,"但是这样做其实是有风险的，线程 2 可能并不能立刻停下来，也有可能过一段时间才会停止，甚至在最极端的情况下可能永远都不会停止。",-1),A=l("br",null,null,-1),b=l("p",null,"为了理解发生这种情况的原因，我们首先来看一下 CPU 的内存结构，这里是一个双核的 CPU 的简单示意图：",-1),v=l("br",null,null,-1),m=l("br",null,null,-1),C=l("p",null,"可以看出，线程 1 和线程 2 分别在不同的 CPU 核心上运行，每一个核心都有自己的本地内存，并且在下方也有它们共享的内存。",-1),f=l("br",null,null,-1),I=l("p",null,"最开始它们都可以读取到 flag 为 true ，不过当线程 1 这个值改为 false 之后，线程 2 并不能及时看到这次修改，因为线程 2 不能直接访问线程 1 的本地内存，这样的问题就是一个非常典型的可见性问题。",-1),T=l("br",null,null,-1),q=l("br",null,null,-1),P=l("p",null,"要想解决这个问题，我们只需要在变量的前面加上 volatile 关键字修饰，只要我们加上这个关键字，那么每一次变量被修改的时候，其他线程对此都可见，这样一旦线程 1 改变了这个值，那么线程 2 就可以立刻看到，因此就可以退出 while 循环了。",-1),B=l("br",null,null,-1),F=l("br",null,null,-1),M=l("p",null,"之所以加了关键字之后就就可以让它拥有可见性，原因在于有了这个关键字之后，线程 1 的更改会被 flush 到共享内存中，然后又会被 refresh 到线程 2 的本地内存中，这样线程 2 就能感受到这个变化了，所以 volatile 这个关键字最主要是用来解决可见性问题的，可以一定程度上保证线程安全。",-1),k=l("br",null,null,-1),x=l("p",null,"现在让我们回顾一下很熟悉的多线程同时进行 value++ 的场景，如图所示：",-1),S=l("br",null,null,-1),J=l("br",null,null,-1),N=l("p",null,"如果它被初始化为每个线程都加 1000 次，最终的结果很可能不是 2000。由于 value++ 不是原子的，所以在多线程的情况下，会出现线程安全问题。但是如果我们在这里使用 volatile 关键字，能不能解决问题呢？",-1),V=l("br",null,null,-1),E=l("br",null,null,-1),O=l("p",null,"很遗憾，答案是即便使用了 volatile 也是不能保证线程安全的，因为这里的问题不单单是可见性问题，还包含原子性问题。",-1),Q=l("br",null,null,-1),U=l("p",null,"我们有多种办法可以解决这里的问题，第 1 种是使用 synchronized 关键字，如图所示：",-1),z=l("br",null,null,-1),D=l("br",null,null,-1),G=l("p",null,"这样一来，两个线程就不能同时去更改 value 的数值，保证了 value++ 语句的原子性，并且 synchronized 同样保证了可见性，也就是说，当第 1 个线程修改了 value 值之后，第 2 个线程可以立刻看见本次修改的结果。",-1),R=l("br",null,null,-1),$=l("p",null,"解决这个问题的第 2 个方法，就是使用我们的原子类，如图所示：",-1),w=l("br",null,null,-1),H=s("",12);function W(j,y,L,Z,K,X){const t=e("Image");return _(),a("div",null,[c,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/9F/CgpOIF49B7qAIJThAAB6qxJtvhs898.png"}),r,u,p,h,d,g,A,b,v,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/A0/Cgq2xl49B9GAHIQWAABs3zG_-08605.png"}),m,C,f,I,T,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/A0/Cgq2xl49B-mAArdMAACJefFgK2k906.png"}),q,P,B,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/A0/Cgq2xl49CACANaAbAACTXNZMnjQ802.png"}),F,M,k,x,S,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/9F/CgpOIF49CBeAUzqHAABbWQsq8Q8832.png"}),J,N,V,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/9F/CgpOIF49CCqALcWIAABfoeCHiaA363.png"}),E,O,Q,U,z,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/9F/CgpOIF49CD6AQpviAACRYw_n1i4430.png"}),D,G,R,$,w,o(t,{alt:"",src:"https://s0.lgstatic.com/i/image3/M01/64/A0/CgpOIF49Ca2AL79uAACSZRAVJcg684.png"}),H])}const tl=n(i,[["render",W]]);export{ll as __pageData,tl as default};
