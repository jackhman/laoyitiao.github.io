import{_ as l,D as o,o as e,g as t,J as a,h as p,Q as s}from"./chunks/framework.f67d7268.js";const g=JSON.parse('{"title":"27加餐：直击Dubbo“心脏”，带你一起探秘Invoker（下）","description":"","frontmatter":{},"headers":[],"relativePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4972) 27  加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（下）.md","filePath":"posts/backEnd/Dubbo源码解读与实战_文档/(4972) 27  加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（下）.md","lastUpdated":1696682708000}'),r={name:"posts/backEnd/Dubbo源码解读与实战_文档/(4972) 27  加餐：直击 Dubbo “心脏”，带你一起探秘 Invoker（下）.md"},c=s(`<h1 id="_27加餐-直击dubbo-心脏-带你一起探秘invoker-下" tabindex="-1">27加餐：直击Dubbo“心脏”，带你一起探秘Invoker（下） <a class="header-anchor" href="#_27加餐-直击dubbo-心脏-带你一起探秘invoker-下" aria-label="Permalink to &quot;27加餐：直击Dubbo“心脏”，带你一起探秘Invoker（下）&quot;">​</a></h1><p>关于 DubboInvoker，在发送完<strong>oneway 请求</strong>之后，会立即创建一个已完成状态的 AsyncRpcResult 对象（主要是其中的 responseFuture 是已完成状态）。这在上一课时我们已经讲解过了。</p><p>本课时我们将继续介绍 DubboInvoker 处理 twoway 请求和响应的相关实现，其中会涉及响应解码、同步/异步响应等相关内容；完成对 DubboInvoker 的分析之后，我们还会介绍 Dubbo 中与 Listener、Filter 相关的 Invoker 装饰器。</p><h3 id="再探-dubboinvoker" tabindex="-1">再探 DubboInvoker <a class="header-anchor" href="#再探-dubboinvoker" aria-label="Permalink to &quot;再探 DubboInvoker&quot;">​</a></h3><p>那 DubboInvoker 对<strong>twoway 请求</strong>的处理又是怎样的呢？接下来我们就来重点介绍下。首先，DubboInvoker 会调用 getCallbackExecutor() 方法，根据不同的 InvokeMode 返回不同的线程池实现，代码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">protected</span><span style="color:#E1E4E8;"> ExecutorService </span><span style="color:#B392F0;">getCallbackExecutor</span><span style="color:#E1E4E8;">(URL url, Invocation inv) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    ExecutorService sharedExecutor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ExtensionLoader.</span><span style="color:#B392F0;">getExtensionLoader</span><span style="color:#E1E4E8;">(ExecutorRepository.class).</span><span style="color:#B392F0;">getDefaultExtension</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getExecutor</span><span style="color:#E1E4E8;">(url);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (InvokeMode.SYNC </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> RpcUtils.</span><span style="color:#B392F0;">getInvokeMode</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), inv)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ThreadlessExecutor</span><span style="color:#E1E4E8;">(sharedExecutor);</span></span>
<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> sharedExecutor;</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">protected</span><span style="color:#24292E;"> ExecutorService </span><span style="color:#6F42C1;">getCallbackExecutor</span><span style="color:#24292E;">(URL url, Invocation inv) {</span></span>
<span class="line"><span style="color:#24292E;">    ExecutorService sharedExecutor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ExtensionLoader.</span><span style="color:#6F42C1;">getExtensionLoader</span><span style="color:#24292E;">(ExecutorRepository.class).</span><span style="color:#6F42C1;">getDefaultExtension</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getExecutor</span><span style="color:#24292E;">(url);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (InvokeMode.SYNC </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> RpcUtils.</span><span style="color:#6F42C1;">getInvokeMode</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), inv)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ThreadlessExecutor</span><span style="color:#24292E;">(sharedExecutor);</span></span>
<span class="line"><span style="color:#24292E;">    } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> sharedExecutor;</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>InvokeMode 有三个可选值，分别是 SYNC、ASYNC 和 FUTURE。这里对于 SYNC 模式返回的线程池是 ThreadlessExecutor，至于其他两种异步模式，会根据 URL 选择对应的共享线程池。</p><p><strong>SYNC 表示同步模式</strong>，是 Dubbo 的默认调用模式，具体含义如下图所示，客户端发送请求之后，客户端线程会阻塞等待服务端返回响应。</p>`,8),E=s(`<p>SYNC 调用模式图</p><p>在拿到线程池之后，DubboInvoker 就会调用 ExchangeClient.request() 方法，将 Invocation 包装成 Request 请求发送出去，同时会创建相应的 DefaultFuture 返回。注意，这里还加了一个回调，取出其中的 AppResponse 对象。AppResponse 表示的是服务端返回的具体响应，其中有三个字段。</p><ul><li><p>result（Object 类型）：响应结果，也就是服务端返回的结果值，注意，这是一个业务上的结果值。例如，在我们前面第 01 课时的 Demo 示例（即 dubbo-demo 模块中的 Demo）中，Provider 端 DemoServiceImpl 返回的 &quot;Hello Dubbo xxx&quot; 这一串字符串。</p></li><li><p>exception（Throwable 类型）：服务端返回的异常信息。</p></li><li><p>attachments（Map&lt;String, Object&gt; 类型）：服务端返回的附加信息。</p></li></ul><p>这里请求返回的 AppResponse 你可能不太熟悉，但是其子类 DecodeableRpcResult 你可能就有点眼熟了，DecodeableRpcResult 表示的是一个响应，与其对应的是 DecodeableRpcInvocation（它表示的是请求）。在第 24 课时介绍 DubboCodec 对 Dubbo 请求体的编码流程中，我们已经详细介绍过 DecodeableRpcInvocation 了，你可以回顾一下 DubboCodec 的 decodeBody() 方法，就会发现 DecodeableRpcResult 的&quot;身影&quot;。</p><h4 id="_1-decodeablerpcresult" tabindex="-1">1. DecodeableRpcResult <a class="header-anchor" href="#_1-decodeablerpcresult" aria-label="Permalink to &quot;1. DecodeableRpcResult&quot;">​</a></h4><p>DecodeableRpcResult 解码核心流程大致如下：</p><ul><li><p>首先，确定当前使用的序列化方式，并对字节流进行解码。</p></li><li><p>然后，读取一个 byte 的标志位，其可选值有六种枚举，下面我们就以其中的 RESPONSE_VALUE_WITH_ATTACHMENTS 为例进行分析。</p></li><li><p>标志位为 RESPONSE_VALUE_WITH_ATTACHMENTS 时，会先通过 handleValue() 方法处理返回值，其中会根据 RpcInvocation 中记录的返回值类型读取返回值，并设置到 result 字段。</p></li><li><p>最后，再通过 handleAttachment() 方法读取返回的附加信息，并设置到 DecodeableRpcResult 的 attachments 字段中。</p></li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">decode</span><span style="color:#E1E4E8;">(Channel channel, InputStream input) throws IOException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 反序列化</span></span>
<span class="line"><span style="color:#E1E4E8;">    ObjectInput in </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> CodecSupport.</span><span style="color:#B392F0;">getSerialization</span><span style="color:#E1E4E8;">(channel.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), serializationType)</span></span>
<span class="line"><span style="color:#E1E4E8;">            .</span><span style="color:#B392F0;">deserialize</span><span style="color:#E1E4E8;">(channel.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), input);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">byte</span><span style="color:#E1E4E8;"> flag </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> in.</span><span style="color:#B392F0;">readByte</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 读取一个byte的标志位</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据标志位判断当前结果中包含的信息，并调用不同的方法进行处理</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">switch</span><span style="color:#E1E4E8;"> (flag) { </span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DubboCodec.RESPONSE_NULL_VALUE</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DubboCodec.RESPONSE_VALUE</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">handleValue</span><span style="color:#E1E4E8;">(in);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DubboCodec.RESPONSE_WITH_EXCEPTION</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">handleException</span><span style="color:#E1E4E8;">(in);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">handleAttachment</span><span style="color:#E1E4E8;">(in);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">handleValue</span><span style="color:#E1E4E8;">(in);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#B392F0;">handleAttachment</span><span style="color:#E1E4E8;">(in);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">break</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">case</span><span style="color:#E1E4E8;"> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS</span><span style="color:#F97583;">:</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">default:</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">IOException</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;...&quot;</span><span style="color:#E1E4E8;"> );</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (in </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> Cleanable) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        ((Cleanable) in).</span><span style="color:#B392F0;">cleanup</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">decode</span><span style="color:#24292E;">(Channel channel, InputStream input) throws IOException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 反序列化</span></span>
<span class="line"><span style="color:#24292E;">    ObjectInput in </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> CodecSupport.</span><span style="color:#6F42C1;">getSerialization</span><span style="color:#24292E;">(channel.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), serializationType)</span></span>
<span class="line"><span style="color:#24292E;">            .</span><span style="color:#6F42C1;">deserialize</span><span style="color:#24292E;">(channel.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), input);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">byte</span><span style="color:#24292E;"> flag </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> in.</span><span style="color:#6F42C1;">readByte</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 读取一个byte的标志位</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据标志位判断当前结果中包含的信息，并调用不同的方法进行处理</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">switch</span><span style="color:#24292E;"> (flag) { </span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DubboCodec.RESPONSE_NULL_VALUE</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DubboCodec.RESPONSE_VALUE</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">handleValue</span><span style="color:#24292E;">(in);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DubboCodec.RESPONSE_WITH_EXCEPTION</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">handleException</span><span style="color:#24292E;">(in);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">handleAttachment</span><span style="color:#24292E;">(in);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">handleValue</span><span style="color:#24292E;">(in);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6F42C1;">handleAttachment</span><span style="color:#24292E;">(in);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">break</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">case</span><span style="color:#24292E;"> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS</span><span style="color:#D73A49;">:</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">default:</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">IOException</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;...&quot;</span><span style="color:#24292E;"> );</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (in </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> Cleanable) {</span></span>
<span class="line"><span style="color:#24292E;">        ((Cleanable) in).</span><span style="color:#6F42C1;">cleanup</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>decode() 方法中其他分支的代码这里就不再展示了，你若感兴趣的话可以参考 DecodeableRpcResult 源码进行分析。</p><h4 id="_2-asyncrpcresult" tabindex="-1">2. AsyncRpcResult <a class="header-anchor" href="#_2-asyncrpcresult" aria-label="Permalink to &quot;2. AsyncRpcResult&quot;">​</a></h4><p>在 DubboInvoker 中还有一个 <strong>AsyncRpcResult 类，它表示的是一个异步的、未完成的 RPC 调用，其中会记录对应 RPC 调用的信息</strong>（例如，关联的 RpcContext 和 Invocation 对象），包括以下几个核心字段。</p><ul><li><p>responseFuture（CompletableFuture<code>&lt;AppResponse&gt;</code> 类型）：这个 responseFuture 字段与前文提到的 DefaultFuture 有紧密的联系，是 DefaultFuture 回调链上的一个 Future。后面 AsyncRpcResult 之上添加的回调，实际上都是添加到这个 Future 之上。</p></li><li><p>storedContext、storedServerContext（RpcContext 类型）：用于存储相关的 RpcContext 对象。我们知道 RpcContext 是与线程绑定的，而真正执行 AsyncRpcResult 上添加的回调方法的线程可能先后处理过多个不同的 AsyncRpcResult，所以我们需要传递并保存当前的 RpcContext。</p></li><li><p>executor（Executor 类型）：此次 RPC 调用关联的线程池。</p></li><li><p>invocation（Invocation 类型）：此次 RPC 调用关联的 Invocation 对象。</p></li></ul><p>在 AsyncRpcResult 构造方法中，除了接收发送请求返回的 CompletableFuture<code>&lt;AppResponse&gt;</code> 对象，还会将当前的 RpcContext 保存到 storedContext 和 storedServerContext 中，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">AsyncRpcResult</span><span style="color:#E1E4E8;">(CompletableFuture</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">AppResponse</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> future, Invocation invocation) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.responseFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> future;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.invocation </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invocation;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.storedContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.storedServerContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getServerContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">AsyncRpcResult</span><span style="color:#24292E;">(CompletableFuture</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">AppResponse</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> future, Invocation invocation) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.responseFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> future;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.invocation </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invocation;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.storedContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.storedServerContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getServerContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>通过 whenCompleteWithContext() 方法，我们可以为 AsyncRpcResult 添加回调方法，而这个回调方法会被包装一层并注册到 responseFuture 上，具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">whenCompleteWithContext</span><span style="color:#E1E4E8;">(BiConsumer</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">Result, Throwable</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> fn) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 在responseFuture之上注册回调</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.responseFuture </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.responseFuture.</span><span style="color:#B392F0;">whenComplete</span><span style="color:#E1E4E8;">((v, t) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">        beforeContext.</span><span style="color:#B392F0;">accept</span><span style="color:#E1E4E8;">(v, t);</span></span>
<span class="line"><span style="color:#E1E4E8;">        fn.</span><span style="color:#B392F0;">accept</span><span style="color:#E1E4E8;">(v, t);</span></span>
<span class="line"><span style="color:#E1E4E8;">        afterContext.</span><span style="color:#B392F0;">accept</span><span style="color:#E1E4E8;">(v, t);</span></span>
<span class="line"><span style="color:#E1E4E8;">    });</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">whenCompleteWithContext</span><span style="color:#24292E;">(BiConsumer</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">Result, Throwable</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> fn) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 在responseFuture之上注册回调</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.responseFuture </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.responseFuture.</span><span style="color:#6F42C1;">whenComplete</span><span style="color:#24292E;">((v, t) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">        beforeContext.</span><span style="color:#6F42C1;">accept</span><span style="color:#24292E;">(v, t);</span></span>
<span class="line"><span style="color:#24292E;">        fn.</span><span style="color:#6F42C1;">accept</span><span style="color:#24292E;">(v, t);</span></span>
<span class="line"><span style="color:#24292E;">        afterContext.</span><span style="color:#6F42C1;">accept</span><span style="color:#24292E;">(v, t);</span></span>
<span class="line"><span style="color:#24292E;">    });</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里的 beforeContext 首先会将当前线程的 RpcContext 记录到 tmpContext 中，然后将构造函数中存储的 RpcContext 设置到当前线程中，为后面的回调执行做准备；而 afterContext 则会恢复线程原有的 RpcContext。具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> RpcContext tmpContext;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> RpcContext tmpServerContext;</span></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> BiConsumer&lt;</span><span style="color:#F97583;">Result</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">&gt; beforeContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (appResponse, t) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将当前线程的 RpcContext 记录到 tmpContext 中</span></span>
<span class="line"><span style="color:#E1E4E8;">    tmpContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    tmpServerContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getServerContext</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将构造函数中存储的 RpcContext 设置到当前线程中</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext.</span><span style="color:#B392F0;">restoreContext</span><span style="color:#E1E4E8;">(storedContext);</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext.</span><span style="color:#B392F0;">restoreServerContext</span><span style="color:#E1E4E8;">(storedServerContext);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> BiConsumer&lt;</span><span style="color:#F97583;">Result</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">Throwable</span><span style="color:#E1E4E8;">&gt; afterContext </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (appResponse, t) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 将tmpContext中存储的RpcContext恢复到当前线程绑定的RpcContext</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext.</span><span style="color:#B392F0;">restoreContext</span><span style="color:#E1E4E8;">(tmpContext);</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcContext.</span><span style="color:#B392F0;">restoreServerContext</span><span style="color:#E1E4E8;">(tmpServerContext);</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> RpcContext tmpContext;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> RpcContext tmpServerContext;</span></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> BiConsumer&lt;</span><span style="color:#D73A49;">Result</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">&gt; beforeContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (appResponse, t) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将当前线程的 RpcContext 记录到 tmpContext 中</span></span>
<span class="line"><span style="color:#24292E;">    tmpContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    tmpServerContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getServerContext</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将构造函数中存储的 RpcContext 设置到当前线程中</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext.</span><span style="color:#6F42C1;">restoreContext</span><span style="color:#24292E;">(storedContext);</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext.</span><span style="color:#6F42C1;">restoreServerContext</span><span style="color:#24292E;">(storedServerContext);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> BiConsumer&lt;</span><span style="color:#D73A49;">Result</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">Throwable</span><span style="color:#24292E;">&gt; afterContext </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (appResponse, t) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 将tmpContext中存储的RpcContext恢复到当前线程绑定的RpcContext</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext.</span><span style="color:#6F42C1;">restoreContext</span><span style="color:#24292E;">(tmpContext);</span></span>
<span class="line"><span style="color:#24292E;">    RpcContext.</span><span style="color:#6F42C1;">restoreServerContext</span><span style="color:#24292E;">(tmpServerContext);</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>这样，AsyncRpcResult 就可以处于不断地添加回调而不丢失 RpcContext 的状态。总之，AsyncRpcResult 整个就是为异步请求设计的。</p><p>在前面的分析中我们看到，RpcInvocation.InvokeMode 字段中可以指定调用为 SYNC 模式，也就是同步调用模式，那 AsyncRpcResult 这种异步设计是如何支持同步调用的呢？ 在 AbstractProtocol.refer() 方法中，Dubbo 会将 DubboProtocol.protocolBindingRefer() 方法返回的 Invoker 对象（即 DubboInvoker 对象）用 AsyncToSyncInvoker 封装一层。</p><p><strong>AsyncToSyncInvoker 是 Invoker 的装饰器，负责将异步调用转换成同步调用</strong>，其 invoke() 方法的核心实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Result asyncResult </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (InvokeMode.SYNC </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> ((RpcInvocation) invocation).</span><span style="color:#B392F0;">getInvokeMode</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 调用get()方法，阻塞等待响应返回</span></span>
<span class="line"><span style="color:#E1E4E8;">        asyncResult.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> asyncResult;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Invocation invocation) throws RpcException {</span></span>
<span class="line"><span style="color:#24292E;">    Result asyncResult </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(invocation);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (InvokeMode.SYNC </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> ((RpcInvocation) invocation).</span><span style="color:#6F42C1;">getInvokeMode</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 调用get()方法，阻塞等待响应返回</span></span>
<span class="line"><span style="color:#24292E;">        asyncResult.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> asyncResult;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>其实 AsyncRpcResult.get() 方法底层调用的就是 responseFuture 字段的 get() 方法，对于同步请求来说，会先调用 ThreadlessExecutor.waitAndDrain() 方法阻塞等待响应返回，具体实现如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">() throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (executor </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> executor </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> ThreadlessExecutor) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 针对ThreadlessExecutor的特殊处理，这里调用waitAndDrain()等待响应</span></span>
<span class="line"><span style="color:#E1E4E8;">        ThreadlessExecutor threadlessExecutor </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (ThreadlessExecutor) executor;</span></span>
<span class="line"><span style="color:#E1E4E8;">        threadlessExecutor.</span><span style="color:#B392F0;">waitAndDrain</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 非ThreadlessExecutor线程池的场景中，则直接调用Future(最底层是DefaultFuture)的get()方法阻塞</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> responseFuture.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">() throws InterruptedException, ExecutionException {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (executor </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> executor </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> ThreadlessExecutor) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 针对ThreadlessExecutor的特殊处理，这里调用waitAndDrain()等待响应</span></span>
<span class="line"><span style="color:#24292E;">        ThreadlessExecutor threadlessExecutor </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (ThreadlessExecutor) executor;</span></span>
<span class="line"><span style="color:#24292E;">        threadlessExecutor.</span><span style="color:#6F42C1;">waitAndDrain</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 非ThreadlessExecutor线程池的场景中，则直接调用Future(最底层是DefaultFuture)的get()方法阻塞</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> responseFuture.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ThreadlessExecutor 针对同步请求的优化，我们在前面的第 20 课时已经详细介绍过了，这里不再重复。</p><p>最后要说明的是，<strong>AsyncRpcResult 实现了 Result 接口</strong>，如下图所示：</p>`,26),y=s(`<p>AsyncRpcResult 继承关系图</p><p>AsyncRpcResult 对 Result 接口的实现，例如，getValue() 方法、recreate() 方法、getAttachments() 方法等，都会先调用 getAppResponse() 方法从 responseFuture 中拿到 AppResponse 对象，然后再调用其对应的方法。这里我们以 recreate() 方法为例，简单分析一下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">getAppResponse</span><span style="color:#E1E4E8;">() { </span><span style="color:#6A737D;">// 省略异常处理的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (responseFuture.</span><span style="color:#B392F0;">isDone</span><span style="color:#E1E4E8;">()) { </span><span style="color:#6A737D;">// 检测responseFuture是否已完成</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> responseFuture.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(); </span><span style="color:#6A737D;">// 获取AppResponse</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据调用方法的返回值，生成默认值</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createDefaultValue</span><span style="color:#E1E4E8;">(invocation); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">recreate</span><span style="color:#E1E4E8;">() throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    RpcInvocation rpcInvocation </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (RpcInvocation) invocation;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (InvokeMode.FUTURE </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> rpcInvocation.</span><span style="color:#B392F0;">getInvokeMode</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getFuture</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 调用AppResponse.recreate()方法</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">getAppResponse</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">recreate</span><span style="color:#E1E4E8;">(); </span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">getAppResponse</span><span style="color:#24292E;">() { </span><span style="color:#6A737D;">// 省略异常处理的逻辑</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (responseFuture.</span><span style="color:#6F42C1;">isDone</span><span style="color:#24292E;">()) { </span><span style="color:#6A737D;">// 检测responseFuture是否已完成</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> responseFuture.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(); </span><span style="color:#6A737D;">// 获取AppResponse</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据调用方法的返回值，生成默认值</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createDefaultValue</span><span style="color:#24292E;">(invocation); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">recreate</span><span style="color:#24292E;">() throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    RpcInvocation rpcInvocation </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (RpcInvocation) invocation;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (InvokeMode.FUTURE </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> rpcInvocation.</span><span style="color:#6F42C1;">getInvokeMode</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getFuture</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 调用AppResponse.recreate()方法</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">getAppResponse</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">recreate</span><span style="color:#24292E;">(); </span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>AppResponse.recreate() 方法实现比较简单，如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Object </span><span style="color:#B392F0;">recreate</span><span style="color:#E1E4E8;">() throws Throwable {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (exception </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 存在异常则直接抛出异常</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#6A737D;">// 省略处理堆栈信息的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">throw</span><span style="color:#E1E4E8;"> exception; </span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> result; </span><span style="color:#6A737D;">// 正常返回无异常时，直接返回result</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Object </span><span style="color:#6F42C1;">recreate</span><span style="color:#24292E;">() throws Throwable {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (exception </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) { </span><span style="color:#6A737D;">// 存在异常则直接抛出异常</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#6A737D;">// 省略处理堆栈信息的逻辑</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">throw</span><span style="color:#24292E;"> exception; </span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> result; </span><span style="color:#6A737D;">// 正常返回无异常时，直接返回result</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>这里我们注意到，在 recreate() 方法中，AsyncRpcResult 会对 FUTURE 特殊处理。如果服务接口定义的返回参数是 CompletableFuture，则属于 FUTURE 模式，<strong>FUTURE 模式也属于 Dubbo 提供的一种异步调用方式，只不过是服务端异步</strong>。FUTURE 模式下拿到的 CompletableFuture 对象其实是在 AbstractInvoker 中塞到 RpcContext 中的，在 AbstractInvoker.invoke() 方法中有这么一段代码：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">RpcContext.</span><span style="color:#B392F0;">getContext</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">setFuture</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">FutureAdapter</span><span style="color:#E1E4E8;">(asyncResult.</span><span style="color:#B392F0;">getResponseFuture</span><span style="color:#E1E4E8;">()));</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">RpcContext.</span><span style="color:#6F42C1;">getContext</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">setFuture</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">FutureAdapter</span><span style="color:#24292E;">(asyncResult.</span><span style="color:#6F42C1;">getResponseFuture</span><span style="color:#24292E;">()));</span></span></code></pre></div><p>这里拿到的其实就是 AsyncRpcResult 中 responseFuture，即前面介绍的 DefaultFuture。可见，<strong>无论是 SYNC 模式、ASYNC 模式还是 FUTURE 模式，都是围绕 DefaultFuture 展开的。</strong></p><p>其实，在 Dubbo 2.6.x 及之前的版本提供了一定的异步编程能力，但其异步方式存在如下一些问题：</p><ul><li><p>Future 获取方式不够直接，业务需要从 RpcContext 中手动获取。</p></li><li><p>Future 接口无法实现自动回调，而自定义 ResponseFuture（这是 Dubbo 2.6.x 中类）虽支持回调，但支持的异步场景有限，并且还不支持 Future 间的相互协调或组合等。</p></li><li><p>不支持 Provider 端异步。</p></li></ul><p>Dubbo 2.6.x 及之前版本中使用的 Future 是在 Java 5 中引入的，所以存在以上一些功能设计上的问题；而在 Java 8 中引入的 CompletableFuture 进一步丰富了 Future 接口，很好地解决了这些问题。<strong>Dubbo 在 2.7.0 版本已经升级了对 Java 8 的支持，同时基于 CompletableFuture 对当前的异步功能进行了增强，弥补了上述不足。</strong></p><p>因为 CompletableFuture 实现了 CompletionStage 和 Future 接口，所以它还是可以像以前一样通过 get() 阻塞或者 isDone() 方法轮询的方式获得结果，这就保证了同步调用依旧可用。当然，在实际工作中，不是很建议用 get() 这样阻塞的方式来获取结果，因为这样就丢失了异步操作带来的性能提升。</p><p>另外，CompletableFuture 提供了良好的回调方法，例如，whenComplete()、whenCompleteAsync() 等方法都可以在逻辑完成后，执行该方法中添加的 action 逻辑，实现回调的逻辑。同时，CompletableFuture 很好地支持了 Future 间的相互协调或组合，例如，thenApply()、thenApplyAsync() 等方法。</p><p>正是由于 CompletableFuture 的增强，我们可以更加流畅地使用回调，不必因为等待一个响应而阻塞着调用线程，而是通过前面介绍的方法告诉 CompletableFuture 完成当前逻辑之后，就去执行某个特定的函数。在 Demo 示例（即 dubbo-demo 模块中的 Demo ）中，返回 CompletableFuture 的 sayHelloAsync() 方法就是使用的 FUTURE 模式。</p><p>好了，DubboInvoker 涉及的同步调用、异步调用的原理和底层实现就介绍到这里了，我们可以通过一张流程图进行简单总结，如下所示：</p>`,15),i=s('<p>DubboInvoker 核心流程图</p><p>在 Client 端发送请求时，首先会创建对应的 DefaultFuture（其中记录了请求 ID 等信息），然后依赖 Netty 的异步发送特性将请求发送到 Server 端。需要说明的是，这整个发送过程是不会阻塞任何线程的。之后，将 DefaultFuture 返回给上层，在这个返回过程中，DefaultFuture 会被封装成 AsyncRpcResult，同时也可以添加回调函数。</p><p>当 Client 端接收到响应结果的时候，会交给关联的线程池（ExecutorService）或是业务线程（使用 ThreadlessExecutor 场景）进行处理，得到 Server 返回的真正结果。拿到真正的返回结果后，会将其设置到 DefaultFuture 中，并调用 complete() 方法将其设置为完成状态。此时，就会触发前面注册在 DefaulFuture 上的回调函数，执行回调逻辑。</p><h3 id="invoker-装饰器" tabindex="-1">Invoker 装饰器 <a class="header-anchor" href="#invoker-装饰器" aria-label="Permalink to &quot;Invoker 装饰器&quot;">​</a></h3><p>除了上面介绍的 DubboInvoker 实现之外，Invoker 接口还有很多装饰器实现，这里重点介绍 Listener、Filter 相关的 Invoker 实现。</p><h4 id="_1-listenerinvokerwrapper" tabindex="-1">1. ListenerInvokerWrapper <a class="header-anchor" href="#_1-listenerinvokerwrapper" aria-label="Permalink to &quot;1. ListenerInvokerWrapper&quot;">​</a></h4><p>在前面的第 23 课时中简单提到过 InvokerListener 接口，我们可以提供其实现来监听 refer 事件以及 destroy 事件，相应地要实现 referred() 方法以及 destroyed() 方法。</p><p>ProtocolListenerWrapper 是 Protocol 接口的实现之一，如下图所示：</p>',8),u=s(`<p>ProtocolListenerWrapper 继承关系图</p><p>ProtocolListenerWrapper 本身是 Protocol 接口的装饰器，在其 export() 方法和 refer() 方法中，会分别在原有 Invoker 基础上封装一层 ListenerExporterWrapper 和 ListenerInvokerWrapper。</p><p><strong>ListenerInvokerWrapper 是 Invoker 的装饰器</strong>，其构造方法参数列表中除了被修饰的 Invoker 外，还有 InvokerListener 列表，在构造方法内部会遍历整个 InvokerListener 列表，并调用每个 InvokerListener 的 referred() 方法，通知它们 Invoker 被引用的事件。核心逻辑如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListenerInvokerWrapper</span><span style="color:#E1E4E8;">(Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> invoker, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">InvokerListener</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> listeners) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.invoker </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker; </span><span style="color:#6A737D;">// 底层被修饰的Invoker对象</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.listeners </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> listeners; </span><span style="color:#6A737D;">// 监听器集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CollectionUtils.</span><span style="color:#B392F0;">isNotEmpty</span><span style="color:#E1E4E8;">(listeners)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (InvokerListener listener </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> listeners) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (listener </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span><span style="color:#6A737D;">// 在服务引用过程中触发全部InvokerListener监听器</span></span>
<span class="line"><span style="color:#E1E4E8;">                listener.</span><span style="color:#B392F0;">referred</span><span style="color:#E1E4E8;">(invoker); </span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListenerInvokerWrapper</span><span style="color:#24292E;">(Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> invoker, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">InvokerListener</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> listeners) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.invoker </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker; </span><span style="color:#6A737D;">// 底层被修饰的Invoker对象</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.listeners </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> listeners; </span><span style="color:#6A737D;">// 监听器集合</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CollectionUtils.</span><span style="color:#6F42C1;">isNotEmpty</span><span style="color:#24292E;">(listeners)) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (InvokerListener listener </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> listeners) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (listener </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span><span style="color:#6A737D;">// 在服务引用过程中触发全部InvokerListener监听器</span></span>
<span class="line"><span style="color:#24292E;">                listener.</span><span style="color:#6F42C1;">referred</span><span style="color:#24292E;">(invoker); </span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 ListenerInvokerWrapper.destroy() 方法中，首先会调用被修饰 Invoker 对象的 destroy() 方法，之后循环调用全部 InvokerListener 的 destroyed() 方法，通知它们该 Invoker 被销毁的事件，具体实现比较简单，这里就不再展示，你若感兴趣的话可以<a href="https://github.com/apache/dubbo/tree/dubbo-2.7.7" target="_blank" rel="noreferrer">参考源码</a>进行学习。</p><p>与 InvokerListener 对应的是 ExporterListener 监听器，其实现类可以通过实现 exported() 方法和 unexported() 方法监听服务暴露事件以及取消暴露事件。</p><p>相应地，在 ProtocolListenerWrapper 的 export() 方法中也会在原有 Invoker 之上用 ListenerExporterWrapper 进行一层封装，ListenerExporterWrapper 的构造方法中会循环调用全部 ExporterListener 的 exported() 方法，通知其服务暴露的事件，核心逻辑如下所示：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">ListenerExporterWrapper</span><span style="color:#E1E4E8;">(Exporter</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> exporter, List</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">ExporterListener</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> listeners) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.exporter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> exporter;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.listeners </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> listeners;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (CollectionUtils.</span><span style="color:#B392F0;">isNotEmpty</span><span style="color:#E1E4E8;">(listeners)) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        RuntimeException exception </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (ExporterListener listener </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> listeners) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (listener </span><span style="color:#F97583;">!=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                listener.</span><span style="color:#B392F0;">exported</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">);</span></span>
<span class="line"><span style="color:#E1E4E8;">            }</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">public</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">ListenerExporterWrapper</span><span style="color:#24292E;">(Exporter</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> exporter, List</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">ExporterListener</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> listeners) {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.exporter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> exporter;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.listeners </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> listeners;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (CollectionUtils.</span><span style="color:#6F42C1;">isNotEmpty</span><span style="color:#24292E;">(listeners)) {</span></span>
<span class="line"><span style="color:#24292E;">        RuntimeException exception </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (ExporterListener listener </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> listeners) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (listener </span><span style="color:#D73A49;">!=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                listener.</span><span style="color:#6F42C1;">exported</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">);</span></span>
<span class="line"><span style="color:#24292E;">            }</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>ListenerExporterWrapper.unexported() 方法的逻辑与上述 exported() 方法的实现基本类似，这里不再赘述。</p><p>这里介绍的 ListenerInvokerWrapper 和 ListenerExporterWrapper 都是被 @SPI 注解修饰的，我们可以提供相应的扩展实现，然后配置 SPI 文件监听这些事件。</p><h4 id="_2-filter-相关的-invoker-装饰器" tabindex="-1">2. Filter 相关的 Invoker 装饰器 <a class="header-anchor" href="#_2-filter-相关的-invoker-装饰器" aria-label="Permalink to &quot;2. Filter 相关的 Invoker 装饰器&quot;">​</a></h4><p>Filter 接口是 Dubbo 为用户提供的一个非常重要的扩展接口，将各个 Filter 串联成 Filter 链并与 Invoker 实例相关。构造 Filter 链的核心逻辑位于 ProtocolFilterWrapper.buildInvokerChain() 方法中，ProtocolFilterWrapper 的 refer() 方法和 export() 方法都会调用该方法。</p><p>buildInvokerChain() 方法的核心逻辑如下：</p><ul><li><p>首先会根据 URL 中携带的配置信息，确定当前激活的 Filter 扩展实现有哪些，形成 Filter 集合。</p></li><li><p>遍历 Filter 集合，将每个 Filter 实现封装成一个匿名 Invoker，在这个匿名 Invoker 中，会调用 Filter 的 invoke() 方法执行 Filter 的逻辑，然后由 Filter 内部的逻辑决定是否将调用传递到下一个 Filter 执行。</p></li></ul><p>buildInvokerChain() 方法的具体实现如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">private</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">static</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">buildInvokerChain</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Invoker</span><span style="color:#F97583;">&lt;</span><span style="color:#E1E4E8;">T</span><span style="color:#F97583;">&gt;</span><span style="color:#E1E4E8;"> invoker, String key, String group) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> invoker;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 根据 URL 中携带的配置信息，确定当前激活的 Filter 扩展实现有哪些，形成 Filter 集合</span></span>
<span class="line"><span style="color:#E1E4E8;">    List&lt;</span><span style="color:#F97583;">Filter</span><span style="color:#E1E4E8;">&gt; filters </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> ExtensionLoader.</span><span style="color:#B392F0;">getExtensionLoader</span><span style="color:#E1E4E8;">(Filter.class).</span><span style="color:#B392F0;">getActivateExtension</span><span style="color:#E1E4E8;">(invoker.</span><span style="color:#B392F0;">getUrl</span><span style="color:#E1E4E8;">(), key, group);</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">!</span><span style="color:#E1E4E8;">filters.</span><span style="color:#B392F0;">isEmpty</span><span style="color:#E1E4E8;">()) {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> i </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> filters.</span><span style="color:#B392F0;">size</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; i </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">; i</span><span style="color:#F97583;">--</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Filter filter </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> filters.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(i);</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#F97583;">final</span><span style="color:#E1E4E8;"> Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt; next </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> last;</span></span>
<span class="line"><span style="color:#E1E4E8;">            </span><span style="color:#6A737D;">// 遍历 Filter 集合，将每个 Filter 实现封装成一个匿名 Invoker</span></span>
<span class="line"><span style="color:#E1E4E8;">            last </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> Invoker&lt;</span><span style="color:#F97583;">T</span><span style="color:#E1E4E8;">&gt;() {</span></span>
<span class="line"><span style="color:#E1E4E8;">                @</span><span style="color:#F97583;">Override</span></span>
<span class="line"><span style="color:#E1E4E8;">                </span><span style="color:#F97583;">public</span><span style="color:#E1E4E8;"> Result </span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(Invocation </span><span style="color:#FFAB70;">invocation</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">throws</span><span style="color:#E1E4E8;"> RpcException {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    Result asyncResult;</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">try</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        </span><span style="color:#6A737D;">// 调用 Filter 的 invoke() 方法执行 Filter 的逻辑，然后由 Filter 内部的逻辑决定是否将调用传递到下一个 Filter 执行</span></span>
<span class="line"><span style="color:#E1E4E8;">                        asyncResult </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> filter.</span><span style="color:#B392F0;">invoke</span><span style="color:#E1E4E8;">(next, invocation);</span></span>
<span class="line"><span style="color:#E1E4E8;">                    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (Exception </span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        ... </span><span style="color:#6A737D;">// 省略异常时监听器的逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">                    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                    }</span></span>
<span class="line"><span style="color:#E1E4E8;">                    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> asyncResult.</span><span style="color:#B392F0;">whenCompleteWithContext</span><span style="color:#E1E4E8;">((r, t) </span><span style="color:#F97583;">-&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">                        ... </span><span style="color:#6A737D;">// 省略监听器的处理逻辑</span></span>
<span class="line"><span style="color:#E1E4E8;">                    });</span></span>
<span class="line"><span style="color:#E1E4E8;">                }</span></span>
<span class="line"><span style="color:#E1E4E8;">            };</span></span>
<span class="line"><span style="color:#E1E4E8;">        }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> last;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">private</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">static</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">buildInvokerChain</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Invoker</span><span style="color:#D73A49;">&lt;</span><span style="color:#24292E;">T</span><span style="color:#D73A49;">&gt;</span><span style="color:#24292E;"> invoker, String key, String group) {</span></span>
<span class="line"><span style="color:#24292E;">    Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> invoker;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 根据 URL 中携带的配置信息，确定当前激活的 Filter 扩展实现有哪些，形成 Filter 集合</span></span>
<span class="line"><span style="color:#24292E;">    List&lt;</span><span style="color:#D73A49;">Filter</span><span style="color:#24292E;">&gt; filters </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> ExtensionLoader.</span><span style="color:#6F42C1;">getExtensionLoader</span><span style="color:#24292E;">(Filter.class).</span><span style="color:#6F42C1;">getActivateExtension</span><span style="color:#24292E;">(invoker.</span><span style="color:#6F42C1;">getUrl</span><span style="color:#24292E;">(), key, group);</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">!</span><span style="color:#24292E;">filters.</span><span style="color:#6F42C1;">isEmpty</span><span style="color:#24292E;">()) {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> i </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> filters.</span><span style="color:#6F42C1;">size</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">-</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; i </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">0</span><span style="color:#24292E;">; i</span><span style="color:#D73A49;">--</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Filter filter </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> filters.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(i);</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#D73A49;">final</span><span style="color:#24292E;"> Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt; next </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> last;</span></span>
<span class="line"><span style="color:#24292E;">            </span><span style="color:#6A737D;">// 遍历 Filter 集合，将每个 Filter 实现封装成一个匿名 Invoker</span></span>
<span class="line"><span style="color:#24292E;">            last </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> Invoker&lt;</span><span style="color:#D73A49;">T</span><span style="color:#24292E;">&gt;() {</span></span>
<span class="line"><span style="color:#24292E;">                @</span><span style="color:#D73A49;">Override</span></span>
<span class="line"><span style="color:#24292E;">                </span><span style="color:#D73A49;">public</span><span style="color:#24292E;"> Result </span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(Invocation </span><span style="color:#E36209;">invocation</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">throws</span><span style="color:#24292E;"> RpcException {</span></span>
<span class="line"><span style="color:#24292E;">                    Result asyncResult;</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">try</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                        </span><span style="color:#6A737D;">// 调用 Filter 的 invoke() 方法执行 Filter 的逻辑，然后由 Filter 内部的逻辑决定是否将调用传递到下一个 Filter 执行</span></span>
<span class="line"><span style="color:#24292E;">                        asyncResult </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> filter.</span><span style="color:#6F42C1;">invoke</span><span style="color:#24292E;">(next, invocation);</span></span>
<span class="line"><span style="color:#24292E;">                    } </span><span style="color:#D73A49;">catch</span><span style="color:#24292E;"> (Exception </span><span style="color:#E36209;">e</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">                        ... </span><span style="color:#6A737D;">// 省略异常时监听器的逻辑</span></span>
<span class="line"><span style="color:#24292E;">                    } </span><span style="color:#D73A49;">finally</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                    }</span></span>
<span class="line"><span style="color:#24292E;">                    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> asyncResult.</span><span style="color:#6F42C1;">whenCompleteWithContext</span><span style="color:#24292E;">((r, t) </span><span style="color:#D73A49;">-&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">                        ... </span><span style="color:#6A737D;">// 省略监听器的处理逻辑</span></span>
<span class="line"><span style="color:#24292E;">                    });</span></span>
<span class="line"><span style="color:#24292E;">                }</span></span>
<span class="line"><span style="color:#24292E;">            };</span></span>
<span class="line"><span style="color:#24292E;">        }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> last;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>在 Filter 接口内部还定义了一个 Listener 接口，有一些 Filter 实现会同时实现这个内部 Listener 接口，当 invoke() 方法执行正常结束时，会调用该 Listener 的 onResponse() 方法进行通知；当 invoke() 方法执行出现异常时，会调用该 Listener 的 onError() 方法进行通知。</p><p>另外，还有一个 ListenableFilter 抽象类，它继承了 Filter 接口，在原有 Filter 的基础上添加了一个 listeners 集合（ConcurrentMap&lt;Invocation, Filter.Listener&gt; 集合）用来记录一次请求需要触发的监听器。需要注意的是，在执行 invoke() 调用之前，我们可以调用 addListener() 方法添加 Filter.Listener 实例进行监听，完成一次 invoke() 方法之后，这些添加的 Filter.Listener 实例就会立即从 listeners 集合中删除，也就是说，这些 Filter.Listener 实例不会在调用之间共享。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>本课时主要介绍的是 Dubbo 中 Invoker 接口的核心实现，这也是 Dubbo 最核心的实现之一。</p><p>紧接上一课时，我们分析了 DubboInvoker 对 twoway 请求的处理逻辑，其中展开介绍了涉及的 DecodeableRpcResult 以及 AsyncRpcResult 等核心类，深入讲解了 Dubbo 的同步、异步调用实现原理，说明了 Dubbo 在 2.7.x 版本之后的相关改进。最后，我们还介绍了 Invoker 接口的几个装饰器，其中涉及用于注册监听器的 ListenerInvokerWrapper 以及 Filter 相关的 Invoker 装饰器。</p><p>下一课时，我们将深入介绍 Dubbo RPC 层中代理的相关实现。</p>`,22);function F(d,C,v,A,D,b){const n=o("Image");return e(),t("div",null,[c,a(n,{alt:"Lark20201027-180625.png",src:"https://s0.lgstatic.com/i/image/M00/64/4B/CgqCHl-X8UOAOTRbAACy-uBf52M689.png"}),p(),E,a(n,{alt:"Drawing 1.png",src:"https://s0.lgstatic.com/i/image/M00/63/A9/Ciqc1F-WqdmAbppOAABOGWzVljY775.png"}),p(),y,a(n,{alt:"Lark20201027-180621.png",src:"https://s0.lgstatic.com/i/image/M00/64/40/Ciqc1F-X8WuACaAKAAEb-X6qf4Y710.png"}),p(),i,a(n,{alt:"Drawing 3.png",src:"https://s0.lgstatic.com/i/image/M00/63/B4/CgqCHl-WqfyAZ0TzAAAbeTUMLT0465.png"}),p(),u])}const x=l(r,[["render",F]]);export{g as __pageData,x as default};
